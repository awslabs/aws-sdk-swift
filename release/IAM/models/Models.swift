// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AccessAdvisorUsageGranularityType {
    case actionLevel
    case serviceLevel
    case sdkUnknown(String)
}

extension AccessAdvisorUsageGranularityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessAdvisorUsageGranularityType] {
        return [
            .actionLevel,
            .serviceLevel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .actionLevel: return "ACTION_LEVEL"
        case .serviceLevel: return "SERVICE_LEVEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessAdvisorUsageGranularityType(rawValue: rawValue) ?? AccessAdvisorUsageGranularityType.sdkUnknown(rawValue)
    }
}

extension AccessDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityPath = "EntityPath"
        case lastAuthenticatedTime = "LastAuthenticatedTime"
        case region = "Region"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: Key("EntityPath"))
        }
        if let lastAuthenticatedTime = lastAuthenticatedTime {
            try container.encode(TimestampWrapper(lastAuthenticatedTime, format: .dateTime), forKey: Key("lastAuthenticatedTime"))
        }
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: Key("TotalAuthenticatedEntities"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let entityPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityPath)
        entityPath = entityPathDecoded
        let lastAuthenticatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAuthenticatedTime)
        var lastAuthenticatedTimeBuffer:Date? = nil
        if let lastAuthenticatedTimeDecoded = lastAuthenticatedTimeDecoded {
            lastAuthenticatedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastAuthenticatedTimeDecoded, format: .dateTime)
        }
        lastAuthenticatedTime = lastAuthenticatedTimeBuffer
        let totalAuthenticatedEntitiesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalAuthenticatedEntities)
        totalAuthenticatedEntities = totalAuthenticatedEntitiesDecoded
    }
}

extension AccessDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDetail(entityPath: \(String(describing: entityPath)), lastAuthenticatedTime: \(String(describing: lastAuthenticatedTime)), region: \(String(describing: region)), serviceName: \(String(describing: serviceName)), serviceNamespace: \(String(describing: serviceNamespace)), totalAuthenticatedEntities: \(String(describing: totalAuthenticatedEntities)))"}
}

/// <p>An object that contains details about when a principal in the reported AWS Organizations entity
///          last attempted to access an AWS service. A principal can be an IAM user, an IAM role,
///          or the AWS account root user within the reported Organizations entity.</p>
///          <p>This data type is a response element in the <a>GetOrganizationsAccessReport</a> operation.</p>
public struct AccessDetail: Equatable {
    /// <p>The path of the Organizations entity (root, organizational unit, or account) from which an
    ///          authenticated principal last attempted to access the service. AWS does not report
    ///          unauthenticated requests.</p>
    ///          <p>This field is null if no principals (IAM users, IAM roles, or root users) in the
    ///          reported Organizations entity attempted to access the service within the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let entityPath: String?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when an authenticated principal most recently attempted to access the
    ///          service. AWS does not report unauthenticated requests.</p>
    ///          <p>This field is null if no principals in the reported Organizations entity attempted to access the
    ///          service within the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let lastAuthenticatedTime: Date?
    /// <p>The Region where the last service access attempt occurred.</p>
    ///          <p>This field is null if no principals in the reported Organizations entity attempted to access the
    ///          service within the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let region: String?
    /// <p>The name of the service in which access was attempted.</p>
    public let serviceName: String?
    /// <p>The namespace of the service in which access was attempted.</p>
    ///          <p>To learn the service namespace of a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
    ///             <i>Service Authorization Reference</i>. Choose the name of the service to
    ///          view details for that service. In the first paragraph, find the service prefix. For
    ///          example, <code>(service prefix: a4b)</code>. For more information about service namespaces,
    ///          see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
    ///             service namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let serviceNamespace: String?
    /// <p>The number of accounts with authenticated principals (root users, IAM users, and IAM
    ///          roles) that attempted to access the service in the reporting period.</p>
    public let totalAuthenticatedEntities: Int?

    public init (
        entityPath: String? = nil,
        lastAuthenticatedTime: Date? = nil,
        region: String? = nil,
        serviceName: String? = nil,
        serviceNamespace: String? = nil,
        totalAuthenticatedEntities: Int? = nil
    )
    {
        self.entityPath = entityPath
        self.lastAuthenticatedTime = lastAuthenticatedTime
        self.region = region
        self.serviceName = serviceName
        self.serviceNamespace = serviceNamespace
        self.totalAuthenticatedEntities = totalAuthenticatedEntities
    }
}

extension AccessKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case secretAccessKey = "SecretAccessKey"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let secretAccessKey = secretAccessKey {
            try container.encode(secretAccessKey, forKey: Key("SecretAccessKey"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
    }
}

extension AccessKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessKey(accessKeyId: \(String(describing: accessKeyId)), createDate: \(String(describing: createDate)), secretAccessKey: \(String(describing: secretAccessKey)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about an AWS access key.</p>
///          <p> This data type is used as a response element in the <a>CreateAccessKey</a>
///          and <a>ListAccessKeys</a> operations. </p>
///          <note>
///             <p>The <code>SecretAccessKey</code> value is returned only in response to <a>CreateAccessKey</a>. You can get a secret access key only when you first
///             create an access key; you cannot recover the secret access key later. If you lose a
///             secret access key, you must create a new access key.</p>
///          </note>
public struct AccessKey: Equatable {
    /// <p>The ID for this access key.</p>
    public let accessKeyId: String?
    /// <p>The date when the access key was created.</p>
    public let createDate: Date?
    /// <p>The secret key used to sign requests.</p>
    public let secretAccessKey: String?
    /// <p>The status of the access key. <code>Active</code> means that the key is valid for API
    ///          calls, while <code>Inactive</code> means it is not. </p>
    public let status: StatusType?
    /// <p>The name of the IAM user that the access key is associated with.</p>
    public let userName: String?

    public init (
        accessKeyId: String? = nil,
        createDate: Date? = nil,
        secretAccessKey: String? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.createDate = createDate
        self.secretAccessKey = secretAccessKey
        self.status = status
        self.userName = userName
    }
}

extension AccessKeyLastUsed: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encode(TimestampWrapper(lastUsedDate, format: .dateTime), forKey: Key("lastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUsedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUsedDate)
        var lastUsedDateBuffer:Date? = nil
        if let lastUsedDateDecoded = lastUsedDateDecoded {
            lastUsedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUsedDateDecoded, format: .dateTime)
        }
        lastUsedDate = lastUsedDateBuffer
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension AccessKeyLastUsed: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessKeyLastUsed(lastUsedDate: \(String(describing: lastUsedDate)), region: \(String(describing: region)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>Contains information about the last time an AWS access key was used since IAM began
///          tracking this information on April 22, 2015.</p>
///          <p>This data type is used as a response element in the <a>GetAccessKeyLastUsed</a> operation.</p>
public struct AccessKeyLastUsed: Equatable {
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the access key was most recently used. This field is null in the
    ///          following situations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The user does not have an access key.</p>
    ///             </li>
    ///             <li>
    ///                <p>An access key exists but has not been used since IAM began tracking this
    ///                information.</p>
    ///             </li>
    ///             <li>
    ///                <p>There is no sign-in data associated with the user.</p>
    ///             </li>
    ///          </ul>
    public let lastUsedDate: Date?
    /// <p>The AWS Region where this access key was most recently used. The value for this field is
    ///          "N/A" in the following situations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The user does not have an access key.</p>
    ///             </li>
    ///             <li>
    ///                <p>An access key exists but has not been used since IAM began tracking this
    ///                information.</p>
    ///             </li>
    ///             <li>
    ///                <p>There is no sign-in data associated with the user.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about AWS Regions, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and endpoints</a> in the Amazon Web Services
    ///          General Reference.</p>
    public let region: String?
    /// <p>The name of the AWS service with which this access key was most recently used. The value
    ///          of this field is "N/A" in the following situations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The user does not have an access key.</p>
    ///             </li>
    ///             <li>
    ///                <p>An access key exists but has not been used since IAM started tracking this
    ///                information.</p>
    ///             </li>
    ///             <li>
    ///                <p>There is no sign-in data associated with the user.</p>
    ///             </li>
    ///          </ul>
    public let serviceName: String?

    public init (
        lastUsedDate: Date? = nil,
        region: String? = nil,
        serviceName: String? = nil
    )
    {
        self.lastUsedDate = lastUsedDate
        self.region = region
        self.serviceName = serviceName
    }
}

extension AccessKeyMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
    }
}

extension AccessKeyMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessKeyMetadata(accessKeyId: \(String(describing: accessKeyId)), createDate: \(String(describing: createDate)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about an AWS access key, without its secret key.</p>
///          <p>This data type is used as a response element in the <a>ListAccessKeys</a>
///          operation.</p>
public struct AccessKeyMetadata: Equatable {
    /// <p>The ID for this access key.</p>
    public let accessKeyId: String?
    /// <p>The date when the access key was created.</p>
    public let createDate: Date?
    /// <p>The status of the access key. <code>Active</code> means that the key is valid for API
    ///          calls; <code>Inactive</code> means it is not.</p>
    public let status: StatusType?
    /// <p>The name of the IAM user that the key is associated with.</p>
    public let userName: String?

    public init (
        accessKeyId: String? = nil,
        createDate: Date? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.createDate = createDate
        self.status = status
        self.userName = userName
    }
}

public struct AddClientIDToOpenIDConnectProviderInputBodyMiddleware: Middleware {
    public let id: String = "AddClientIDToOpenIDConnectProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddClientIDToOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<AddClientIDToOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddClientIDToOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<AddClientIDToOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddClientIDToOpenIDConnectProviderOutputError>
}

extension AddClientIDToOpenIDConnectProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddClientIDToOpenIDConnectProviderInput(clientID: \(String(describing: clientID)), openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)))"}
}

extension AddClientIDToOpenIDConnectProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        try container.encode("AddClientIDToOpenIDConnectProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct AddClientIDToOpenIDConnectProviderInputHeadersMiddleware: Middleware {
    public let id: String = "AddClientIDToOpenIDConnectProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddClientIDToOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<AddClientIDToOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddClientIDToOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<AddClientIDToOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddClientIDToOpenIDConnectProviderOutputError>
}

public struct AddClientIDToOpenIDConnectProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "AddClientIDToOpenIDConnectProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddClientIDToOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<AddClientIDToOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddClientIDToOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<AddClientIDToOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddClientIDToOpenIDConnectProviderOutputError>
}

public struct AddClientIDToOpenIDConnectProviderInput: Equatable {
    /// <p>The client ID (also known as audience) to add to the IAM OpenID Connect provider
    ///             resource.</p>
    public let clientID: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to
    ///             add the client ID to. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    public let openIDConnectProviderArn: String?

    public init (
        clientID: String? = nil,
        openIDConnectProviderArn: String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension AddClientIDToOpenIDConnectProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddClientIDToOpenIDConnectProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddClientIDToOpenIDConnectProviderOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddClientIDToOpenIDConnectProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddClientIDToOpenIDConnectProviderOutputResponse()"}
}

extension AddClientIDToOpenIDConnectProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddClientIDToOpenIDConnectProviderOutputResponse: Equatable {

    public init() {}
}

struct AddClientIDToOpenIDConnectProviderOutputResponseBody: Equatable {
}

extension AddClientIDToOpenIDConnectProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddRoleToInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "AddRoleToInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToInstanceProfileInput>
    public typealias MOutput = OperationOutput<AddRoleToInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToInstanceProfileOutputError>
}

extension AddRoleToInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToInstanceProfileInput(instanceProfileName: \(String(describing: instanceProfileName)), roleName: \(String(describing: roleName)))"}
}

extension AddRoleToInstanceProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("AddRoleToInstanceProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct AddRoleToInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "AddRoleToInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToInstanceProfileInput>
    public typealias MOutput = OperationOutput<AddRoleToInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToInstanceProfileOutputError>
}

public struct AddRoleToInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "AddRoleToInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToInstanceProfileInput>
    public typealias MOutput = OperationOutput<AddRoleToInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToInstanceProfileOutputError>
}

public struct AddRoleToInstanceProfileInput: Equatable {
    /// <p>The name of the instance profile to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let instanceProfileName: String?
    /// <p>The name of the role to add.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        instanceProfileName: String? = nil,
        roleName: String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

extension AddRoleToInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToInstanceProfileOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToInstanceProfileOutputResponse()"}
}

extension AddRoleToInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToInstanceProfileOutputResponse: Equatable {

    public init() {}
}

struct AddRoleToInstanceProfileOutputResponseBody: Equatable {
}

extension AddRoleToInstanceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddUserToGroupInputBodyMiddleware: Middleware {
    public let id: String = "AddUserToGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddUserToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddUserToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddUserToGroupInput>
    public typealias MOutput = OperationOutput<AddUserToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddUserToGroupOutputError>
}

extension AddUserToGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddUserToGroupInput(groupName: \(String(describing: groupName)), userName: \(String(describing: userName)))"}
}

extension AddUserToGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("AddUserToGroup", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct AddUserToGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AddUserToGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddUserToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddUserToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddUserToGroupInput>
    public typealias MOutput = OperationOutput<AddUserToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddUserToGroupOutputError>
}

public struct AddUserToGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AddUserToGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddUserToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddUserToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddUserToGroupInput>
    public typealias MOutput = OperationOutput<AddUserToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddUserToGroupOutputError>
}

public struct AddUserToGroupInput: Equatable {
    /// <p>The name of the group to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>The name of the user to add.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        groupName: String? = nil,
        userName: String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

extension AddUserToGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddUserToGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddUserToGroupOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddUserToGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddUserToGroupOutputResponse()"}
}

extension AddUserToGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddUserToGroupOutputResponse: Equatable {

    public init() {}
}

struct AddUserToGroupOutputResponseBody: Equatable {
}

extension AddUserToGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum AssignmentStatusType {
    case any
    case assigned
    case unassigned
    case sdkUnknown(String)
}

extension AssignmentStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssignmentStatusType] {
        return [
            .any,
            .assigned,
            .unassigned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .any: return "Any"
        case .assigned: return "Assigned"
        case .unassigned: return "Unassigned"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssignmentStatusType(rawValue: rawValue) ?? AssignmentStatusType.sdkUnknown(rawValue)
    }
}

public struct AttachGroupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "AttachGroupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachGroupPolicyInput>
    public typealias MOutput = OperationOutput<AttachGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachGroupPolicyOutputError>
}

extension AttachGroupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachGroupPolicyInput(groupName: \(String(describing: groupName)), policyArn: \(String(describing: policyArn)))"}
}

extension AttachGroupPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        try container.encode("AttachGroupPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct AttachGroupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "AttachGroupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachGroupPolicyInput>
    public typealias MOutput = OperationOutput<AttachGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachGroupPolicyOutputError>
}

public struct AttachGroupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachGroupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachGroupPolicyInput>
    public typealias MOutput = OperationOutput<AttachGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachGroupPolicyOutputError>
}

public struct AttachGroupPolicyInput: Equatable {
    /// <p>The name (friendly name, not ARN) of the group to attach the policy to.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?

    public init (
        groupName: String? = nil,
        policyArn: String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

extension AttachGroupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachGroupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachableException" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachGroupPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachGroupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachGroupPolicyOutputResponse()"}
}

extension AttachGroupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachGroupPolicyOutputResponse: Equatable {

    public init() {}
}

struct AttachGroupPolicyOutputResponseBody: Equatable {
}

extension AttachGroupPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AttachRolePolicyInputBodyMiddleware: Middleware {
    public let id: String = "AttachRolePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachRolePolicyInput>
    public typealias MOutput = OperationOutput<AttachRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachRolePolicyOutputError>
}

extension AttachRolePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachRolePolicyInput(policyArn: \(String(describing: policyArn)), roleName: \(String(describing: roleName)))"}
}

extension AttachRolePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("AttachRolePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct AttachRolePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "AttachRolePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachRolePolicyInput>
    public typealias MOutput = OperationOutput<AttachRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachRolePolicyOutputError>
}

public struct AttachRolePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachRolePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachRolePolicyInput>
    public typealias MOutput = OperationOutput<AttachRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachRolePolicyOutputError>
}

public struct AttachRolePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The name (friendly name, not ARN) of the role to attach the policy to.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        policyArn: String? = nil,
        roleName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

extension AttachRolePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachRolePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachableException" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachRolePolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachRolePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachRolePolicyOutputResponse()"}
}

extension AttachRolePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachRolePolicyOutputResponse: Equatable {

    public init() {}
}

struct AttachRolePolicyOutputResponseBody: Equatable {
}

extension AttachRolePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AttachUserPolicyInputBodyMiddleware: Middleware {
    public let id: String = "AttachUserPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachUserPolicyInput>
    public typealias MOutput = OperationOutput<AttachUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachUserPolicyOutputError>
}

extension AttachUserPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachUserPolicyInput(policyArn: \(String(describing: policyArn)), userName: \(String(describing: userName)))"}
}

extension AttachUserPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("AttachUserPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct AttachUserPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "AttachUserPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachUserPolicyInput>
    public typealias MOutput = OperationOutput<AttachUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachUserPolicyOutputError>
}

public struct AttachUserPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachUserPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachUserPolicyInput>
    public typealias MOutput = OperationOutput<AttachUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachUserPolicyOutputError>
}

public struct AttachUserPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The name (friendly name, not ARN) of the IAM user to attach the policy to.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        policyArn: String? = nil,
        userName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

extension AttachUserPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachUserPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachableException" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachUserPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachUserPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachUserPolicyOutputResponse()"}
}

extension AttachUserPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachUserPolicyOutputResponse: Equatable {

    public init() {}
}

struct AttachUserPolicyOutputResponseBody: Equatable {
}

extension AttachUserPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachedPermissionsBoundary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionsBoundaryArn = "PermissionsBoundaryArn"
        case permissionsBoundaryType = "PermissionsBoundaryType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let permissionsBoundaryArn = permissionsBoundaryArn {
            try container.encode(permissionsBoundaryArn, forKey: Key("PermissionsBoundaryArn"))
        }
        if let permissionsBoundaryType = permissionsBoundaryType {
            try container.encode(permissionsBoundaryType, forKey: Key("PermissionsBoundaryType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsBoundaryTypeDecoded = try containerValues.decodeIfPresent(PermissionsBoundaryAttachmentType.self, forKey: .permissionsBoundaryType)
        permissionsBoundaryType = permissionsBoundaryTypeDecoded
        let permissionsBoundaryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionsBoundaryArn)
        permissionsBoundaryArn = permissionsBoundaryArnDecoded
    }
}

extension AttachedPermissionsBoundary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachedPermissionsBoundary(permissionsBoundaryArn: \(String(describing: permissionsBoundaryArn)), permissionsBoundaryType: \(String(describing: permissionsBoundaryType)))"}
}

/// <p>Contains information about an attached permissions boundary.</p>
///          <p>An attached permissions boundary is a managed policy that has been attached to a user or
///          role to set the permissions boundary.</p>
///          <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
///             identities </a> in the <i>IAM User Guide</i>.</p>
public struct AttachedPermissionsBoundary: Equatable {
    /// <p> The ARN of the policy used to set the permissions boundary for the user or role.</p>
    public let permissionsBoundaryArn: String?
    /// <p> The permissions boundary usage type that indicates what type of IAM resource is used
    ///          as the permissions boundary for an entity. This data type can only have a value of
    ///             <code>Policy</code>.</p>
    public let permissionsBoundaryType: PermissionsBoundaryAttachmentType?

    public init (
        permissionsBoundaryArn: String? = nil,
        permissionsBoundaryType: PermissionsBoundaryAttachmentType? = nil
    )
    {
        self.permissionsBoundaryArn = permissionsBoundaryArn
        self.permissionsBoundaryType = permissionsBoundaryType
    }
}

extension AttachedPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AttachedPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachedPolicy(policyArn: \(String(describing: policyArn)), policyName: \(String(describing: policyName)))"}
}

/// <p>Contains information about an attached policy.</p>
///          <p>An attached policy is a managed policy that has been attached to a user, group, or role.
///          This data type is used as a response element in the <a>ListAttachedGroupPolicies</a>, <a>ListAttachedRolePolicies</a>, <a>ListAttachedUserPolicies</a>, and <a>GetAccountAuthorizationDetails</a> operations. </p>
///          <p>For more information about managed policies, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html">Managed policies and inline
///             policies</a> in the <i>IAM User Guide</i>. </p>
public struct AttachedPolicy: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let policyArn: String?
    /// <p>The friendly name of the attached policy.</p>
    public let policyName: String?

    public init (
        policyArn: String? = nil,
        policyName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.policyName = policyName
    }
}

public struct ChangePasswordInputBodyMiddleware: Middleware {
    public let id: String = "ChangePasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangePasswordInput>
    public typealias MOutput = OperationOutput<ChangePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangePasswordOutputError>
}

extension ChangePasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangePasswordInput(newPassword: \(String(describing: newPassword)), oldPassword: \(String(describing: oldPassword)))"}
}

extension ChangePasswordInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let newPassword = newPassword {
            try container.encode(newPassword, forKey: Key("NewPassword"))
        }
        if let oldPassword = oldPassword {
            try container.encode(oldPassword, forKey: Key("OldPassword"))
        }
        try container.encode("ChangePassword", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ChangePasswordInputHeadersMiddleware: Middleware {
    public let id: String = "ChangePasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangePasswordInput>
    public typealias MOutput = OperationOutput<ChangePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangePasswordOutputError>
}

public struct ChangePasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "ChangePasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangePasswordInput>
    public typealias MOutput = OperationOutput<ChangePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangePasswordOutputError>
}

public struct ChangePasswordInput: Equatable {
    /// <p>The new password. The new password must conform to the AWS account's password
    ///             policy, if one exists.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     that is used to validate this parameter is a string of characters. That string can include almost any printable
    ///     ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
    ///     You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
    ///     characters. Any of these characters are valid in a password. However, many tools, such
    ///     as the AWS Management Console, might restrict the ability to type certain characters because they have
    ///     special meaning within that tool.</p>
    public let newPassword: String?
    /// <p>The IAM user's current password.</p>
    public let oldPassword: String?

    public init (
        newPassword: String? = nil,
        oldPassword: String? = nil
    )
    {
        self.newPassword = newPassword
        self.oldPassword = oldPassword
    }
}

extension ChangePasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ChangePasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiableException" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserTypeException" : self = .invalidUserTypeException(try InvalidUserTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordPolicyViolationException" : self = .passwordPolicyViolationException(try PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ChangePasswordOutputError: Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case invalidUserTypeException(InvalidUserTypeException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case passwordPolicyViolationException(PasswordPolicyViolationException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChangePasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangePasswordOutputResponse()"}
}

extension ChangePasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ChangePasswordOutputResponse: Equatable {

    public init() {}
}

struct ChangePasswordOutputResponseBody: Equatable {
}

extension ChangePasswordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ConcurrentModificationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because multiple requests to change this object were submitted
///       simultaneously. Wait a few minutes and submit your request again.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ContextEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contextKeyName = "ContextKeyName"
        case contextKeyType = "ContextKeyType"
        case contextKeyValues = "ContextKeyValues"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let contextKeyName = contextKeyName {
            try container.encode(contextKeyName, forKey: Key("ContextKeyName"))
        }
        if let contextKeyType = contextKeyType {
            try container.encode(contextKeyType, forKey: Key("ContextKeyType"))
        }
        if let contextKeyValues = contextKeyValues {
            var contextKeyValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ContextKeyValues"))
            for (index0, contextkeyvaluetype0) in contextKeyValues.enumerated() {
                try contextKeyValuesContainer.encode(contextkeyvaluetype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contextKeyName)
        contextKeyName = contextKeyNameDecoded
        if containerValues.contains(.contextKeyValues) {
            struct KeyVal0{struct member{}}
            let contextKeyValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyValues)
            if let contextKeyValuesWrappedContainer = contextKeyValuesWrappedContainer {
                let contextKeyValuesContainer = try contextKeyValuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var contextKeyValuesBuffer:[String]? = nil
                if let contextKeyValuesContainer = contextKeyValuesContainer {
                    contextKeyValuesBuffer = [String]()
                    for stringContainer0 in contextKeyValuesContainer {
                        contextKeyValuesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyValues = contextKeyValuesBuffer
            } else {
                contextKeyValues = []
            }
        } else {
            contextKeyValues = nil
        }
        let contextKeyTypeDecoded = try containerValues.decodeIfPresent(ContextKeyTypeEnum.self, forKey: .contextKeyType)
        contextKeyType = contextKeyTypeDecoded
    }
}

extension ContextEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContextEntry(contextKeyName: \(String(describing: contextKeyName)), contextKeyType: \(String(describing: contextKeyType)), contextKeyValues: \(String(describing: contextKeyValues)))"}
}

/// <p>Contains information about a condition context key. It includes the name of the key and
///          specifies the value (or values, if the context key supports multiple values) to use in the
///          simulation. This information is used when evaluating the <code>Condition</code> elements of
///          the input policies.</p>
///          <p>This data type is used as an input parameter to <a>SimulateCustomPolicy</a> and <a>SimulatePrincipalPolicy</a>.</p>
public struct ContextEntry: Equatable {
    /// <p>The full name of a condition context key, including the service prefix. For example,
    ///             <code>aws:SourceIp</code> or <code>s3:VersionId</code>.</p>
    public let contextKeyName: String?
    /// <p>The data type of the value (or values) specified in the <code>ContextKeyValues</code>
    ///          parameter.</p>
    public let contextKeyType: ContextKeyTypeEnum?
    /// <p>The value (or values, if the condition context key supports multiple values) to provide
    ///          to the simulation when the key is referenced by a <code>Condition</code> element in an
    ///          input policy.</p>
    public let contextKeyValues: [String]?

    public init (
        contextKeyName: String? = nil,
        contextKeyType: ContextKeyTypeEnum? = nil,
        contextKeyValues: [String]? = nil
    )
    {
        self.contextKeyName = contextKeyName
        self.contextKeyType = contextKeyType
        self.contextKeyValues = contextKeyValues
    }
}

public enum ContextKeyTypeEnum {
    case binary
    case binaryList
    case boolean
    case booleanList
    case date
    case dateList
    case ip
    case ipList
    case numeric
    case numericList
    case string
    case stringList
    case sdkUnknown(String)
}

extension ContextKeyTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContextKeyTypeEnum] {
        return [
            .binary,
            .binaryList,
            .boolean,
            .booleanList,
            .date,
            .dateList,
            .ip,
            .ipList,
            .numeric,
            .numericList,
            .string,
            .stringList,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .binary: return "binary"
        case .binaryList: return "binaryList"
        case .boolean: return "boolean"
        case .booleanList: return "booleanList"
        case .date: return "date"
        case .dateList: return "dateList"
        case .ip: return "ip"
        case .ipList: return "ipList"
        case .numeric: return "numeric"
        case .numericList: return "numericList"
        case .string: return "string"
        case .stringList: return "stringList"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContextKeyTypeEnum(rawValue: rawValue) ?? ContextKeyTypeEnum.sdkUnknown(rawValue)
    }
}

public struct CreateAccessKeyInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccessKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessKeyInput>
    public typealias MOutput = OperationOutput<CreateAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessKeyOutputError>
}

extension CreateAccessKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessKeyInput(userName: \(String(describing: userName)))"}
}

extension CreateAccessKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("CreateAccessKey", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateAccessKeyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccessKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessKeyInput>
    public typealias MOutput = OperationOutput<CreateAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessKeyOutputError>
}

public struct CreateAccessKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccessKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessKeyInput>
    public typealias MOutput = OperationOutput<CreateAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessKeyOutputError>
}

public struct CreateAccessKeyInput: Equatable {
    /// <p>The name of the IAM user that the new key will belong to.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        userName: String? = nil
    )
    {
        self.userName = userName
    }
}

extension CreateAccessKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAccessKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessKeyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessKeyOutputResponse(accessKey: \(String(describing: accessKey)))"}
}

extension CreateAccessKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccessKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessKey = output.accessKey
        } else {
            self.accessKey = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateAccessKey</a> request.
///     </p>
public struct CreateAccessKeyOutputResponse: Equatable {
    /// <p>A structure with details about the access key.</p>
    public let accessKey: AccessKey?

    public init (
        accessKey: AccessKey? = nil
    )
    {
        self.accessKey = accessKey
    }
}

struct CreateAccessKeyOutputResponseBody: Equatable {
    public let accessKey: AccessKey?
}

extension CreateAccessKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessKey = "AccessKey"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateAccessKeyResult"))
        let accessKeyDecoded = try containerValues.decodeIfPresent(AccessKey.self, forKey: .accessKey)
        accessKey = accessKeyDecoded
    }
}

public struct CreateAccountAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccountAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountAliasInput>
    public typealias MOutput = OperationOutput<CreateAccountAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountAliasOutputError>
}

extension CreateAccountAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccountAliasInput(accountAlias: \(String(describing: accountAlias)))"}
}

extension CreateAccountAliasInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: Key("AccountAlias"))
        }
        try container.encode("CreateAccountAlias", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateAccountAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccountAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountAliasInput>
    public typealias MOutput = OperationOutput<CreateAccountAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountAliasOutputError>
}

public struct CreateAccountAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccountAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountAliasInput>
    public typealias MOutput = OperationOutput<CreateAccountAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountAliasOutputError>
}

public struct CreateAccountAliasInput: Equatable {
    /// <p>The account alias to create.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
    ///     lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
    ///     two dashes in a row.</p>
    public let accountAlias: String?

    public init (
        accountAlias: String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

extension CreateAccountAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAccountAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccountAliasOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccountAliasOutputResponse()"}
}

extension CreateAccountAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateAccountAliasOutputResponse: Equatable {

    public init() {}
}

struct CreateAccountAliasOutputResponseBody: Equatable {
}

extension CreateAccountAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupInput(groupName: \(String(describing: groupName)), path: \(String(describing: path)))"}
}

extension CreateGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        try container.encode("CreateGroup", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInput: Equatable {
    /// <p>The name of the group to create. Do not include the path in this value.</p>
    ///         <p>IAM user, group, role, and policy names must be unique within the account. Names are
    ///             not distinguished by case. For example, you cannot create resources named both
    ///             "MyResource" and "myresource".</p>
    public let groupName: String?
    /// <p> The path to the group. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///                 identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let path: String?

    public init (
        groupName: String? = nil,
        path: String? = nil
    )
    {
        self.groupName = groupName
        self.path = path
    }
}

extension CreateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupOutputResponse(group: \(String(describing: group)))"}
}

extension CreateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateGroup</a> request. </p>
public struct CreateGroupOutputResponse: Equatable {
    /// <p>A structure containing details about the new group.</p>
    public let group: Group?

    public init (
        group: Group? = nil
    )
    {
        self.group = group
    }
}

struct CreateGroupOutputResponseBody: Equatable {
    public let group: Group?
}

extension CreateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateGroupResult"))
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
    }
}

public struct CreateInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceProfileOutputError>
}

extension CreateInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceProfileInput(instanceProfileName: \(String(describing: instanceProfileName)), path: \(String(describing: path)), tags: \(String(describing: tags)))"}
}

extension CreateInstanceProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateInstanceProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInput: Equatable {
    /// <p>The name of the instance profile to create.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let instanceProfileName: String?
    /// <p> The path to the instance profile. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///                 Identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let path: String?
    /// <p>A list of tags that you want to attach to the newly created IAM instance profile.
    ///       Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        instanceProfileName: String? = nil,
        path: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.path = path
        self.tags = tags
    }
}

extension CreateInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceProfileOutputResponse(instanceProfile: \(String(describing: instanceProfile)))"}
}

extension CreateInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateInstanceProfile</a> request.
///     </p>
public struct CreateInstanceProfileOutputResponse: Equatable {
    /// <p>A structure containing details about the new instance profile.</p>
    public let instanceProfile: InstanceProfile?

    public init (
        instanceProfile: InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct CreateInstanceProfileOutputResponseBody: Equatable {
    public let instanceProfile: InstanceProfile?
}

extension CreateInstanceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateInstanceProfileResult"))
        let instanceProfileDecoded = try containerValues.decodeIfPresent(InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct CreateLoginProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateLoginProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoginProfileInput>
    public typealias MOutput = OperationOutput<CreateLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoginProfileOutputError>
}

extension CreateLoginProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoginProfileInput(password: \(String(describing: password)), passwordResetRequired: \(String(describing: passwordResetRequired)), userName: \(String(describing: userName)))"}
}

extension CreateLoginProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let password = password {
            try container.encode(password, forKey: Key("Password"))
        }
        if passwordResetRequired != false {
            try container.encode(passwordResetRequired, forKey: Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("CreateLoginProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateLoginProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLoginProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoginProfileInput>
    public typealias MOutput = OperationOutput<CreateLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoginProfileOutputError>
}

public struct CreateLoginProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLoginProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoginProfileInput>
    public typealias MOutput = OperationOutput<CreateLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoginProfileOutputError>
}

public struct CreateLoginProfileInput: Equatable {
    /// <p>The new password for the user.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     that is used to validate this parameter is a string of characters. That string can include almost any printable
    ///     ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
    ///     You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
    ///     characters. Any of these characters are valid in a password. However, many tools, such
    ///     as the AWS Management Console, might restrict the ability to type certain characters because they have
    ///     special meaning within that tool.</p>
    public let password: String?
    /// <p>Specifies whether the user is required to set a new password on next sign-in.</p>
    public let passwordResetRequired: Bool
    /// <p>The name of the IAM user to create a password for. The user must already
    ///             exist.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        password: String? = nil,
        passwordResetRequired: Bool = false,
        userName: String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

extension CreateLoginProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoginProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordPolicyViolationException" : self = .passwordPolicyViolationException(try PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoginProfileOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case passwordPolicyViolationException(PasswordPolicyViolationException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoginProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoginProfileOutputResponse(loginProfile: \(String(describing: loginProfile)))"}
}

extension CreateLoginProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLoginProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loginProfile = output.loginProfile
        } else {
            self.loginProfile = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateLoginProfile</a> request.
///     </p>
public struct CreateLoginProfileOutputResponse: Equatable {
    /// <p>A structure containing the user name and password create date.</p>
    public let loginProfile: LoginProfile?

    public init (
        loginProfile: LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

struct CreateLoginProfileOutputResponseBody: Equatable {
    public let loginProfile: LoginProfile?
}

extension CreateLoginProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loginProfile = "LoginProfile"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateLoginProfileResult"))
        let loginProfileDecoded = try containerValues.decodeIfPresent(LoginProfile.self, forKey: .loginProfile)
        loginProfile = loginProfileDecoded
    }
}

public struct CreateOpenIDConnectProviderInputBodyMiddleware: Middleware {
    public let id: String = "CreateOpenIDConnectProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<CreateOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpenIDConnectProviderOutputError>
}

extension CreateOpenIDConnectProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOpenIDConnectProviderInput(clientIDList: \(String(describing: clientIDList)), tags: \(String(describing: tags)), thumbprintList: \(String(describing: thumbprintList)), url: \(String(describing: url)))"}
}

extension CreateOpenIDConnectProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientIDList = clientIDList {
            var clientIDListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClientIDList"))
            for (index0, clientidtype0) in clientIDList.enumerated() {
                try clientIDListContainer.encode(clientidtype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let thumbprintList = thumbprintList {
            var thumbprintListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ThumbprintList"))
            for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                try thumbprintListContainer.encode(thumbprinttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let url = url {
            try container.encode(url, forKey: Key("Url"))
        }
        try container.encode("CreateOpenIDConnectProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateOpenIDConnectProviderInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOpenIDConnectProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<CreateOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpenIDConnectProviderOutputError>
}

public struct CreateOpenIDConnectProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOpenIDConnectProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<CreateOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpenIDConnectProviderOutputError>
}

public struct CreateOpenIDConnectProviderInput: Equatable {
    /// <p>A list of client IDs (also known as audiences). When a mobile or web app registers
    ///             with an OpenID Connect provider, they establish a value that identifies the application.
    ///             (This is the value that's sent as the <code>client_id</code> parameter on OAuth
    ///             requests.)</p>
    ///         <p>You can register multiple client IDs with the same provider. For example, you might
    ///             have multiple applications that use the same OIDC provider. You cannot register more
    ///             than 100 client IDs with a single IAM OIDC provider.</p>
    ///         <p>There is no defined format for a client ID. The
    ///                 <code>CreateOpenIDConnectProviderRequest</code> operation accepts client IDs up to
    ///             255 characters long.</p>
    public let clientIDList: [String]?
    /// <p>A list of tags that you want to attach to the new IAM OpenID Connect (OIDC) provider.
    ///       Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>A list of server certificate thumbprints for the OpenID Connect (OIDC) identity
    ///             provider's server certificates. Typically this list includes only one entry. However,
    ///             IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain
    ///             multiple thumbprints if the identity provider is rotating certificates.</p>
    ///         <p>The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509
    ///             certificate used by the domain where the OpenID Connect provider makes its keys
    ///             available. It is always a 40-character string.</p>
    ///         <p>You must provide at least one thumbprint when creating an IAM OIDC provider. For
    ///             example, assume that the OIDC provider is <code>server.example.com</code> and the
    ///             provider stores its keys at https://keys.server.example.com/openid-connect. In that
    ///             case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate
    ///             used by https://keys.server.example.com.</p>
    ///         <p>For more information about obtaining the OIDC provider's thumbprint, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/identity-providers-oidc-obtain-thumbprint.html">Obtaining the
    ///                 thumbprint for an OpenID Connect provider</a> in the <i>IAM User
    ///                 Guide</i>.</p>
    public let thumbprintList: [String]?
    /// <p>The URL of the identity provider. The URL must begin with <code>https://</code> and
    ///             should correspond to the <code>iss</code> claim in the provider's OpenID Connect ID
    ///             tokens. Per the OIDC standard, path components are allowed but query parameters are not.
    ///             Typically the URL consists of only a hostname, like
    ///                 <code>https://server.example.org</code> or <code>https://example.com</code>.</p>
    ///         <p>You cannot register the same provider multiple times in a single AWS account. If you
    ///             try to submit a URL that has already been used for an OpenID Connect provider in the
    ///             AWS account, you will get an error.</p>
    public let url: String?

    public init (
        clientIDList: [String]? = nil,
        tags: [Tag]? = nil,
        thumbprintList: [String]? = nil,
        url: String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

extension CreateOpenIDConnectProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOpenIDConnectProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOpenIDConnectProviderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpenIDConnectProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOpenIDConnectProviderOutputResponse(openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)), tags: \(String(describing: tags)))"}
}

extension CreateOpenIDConnectProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateOpenIDConnectProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.openIDConnectProviderArn = output.openIDConnectProviderArn
            self.tags = output.tags
        } else {
            self.openIDConnectProviderArn = nil
            self.tags = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateOpenIDConnectProvider</a>
///       request. </p>
public struct CreateOpenIDConnectProviderOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the new IAM OpenID Connect provider that is
    ///             created. For more information, see <a>OpenIDConnectProviderListEntry</a>.
    ///         </p>
    public let openIDConnectProviderArn: String?
    /// <p>A list of tags that are attached to the new IAM OIDC provider. The returned list of
    ///       tags is sorted by tag key. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        openIDConnectProviderArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

struct CreateOpenIDConnectProviderOutputResponseBody: Equatable {
    public let openIDConnectProviderArn: String?
    public let tags: [Tag]?
}

extension CreateOpenIDConnectProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateOpenIDConnectProviderResult"))
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

public struct CreatePolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreatePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyInput>
    public typealias MOutput = OperationOutput<CreatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyOutputError>
}

extension CreatePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyInput(description: \(String(describing: description)), path: \(String(describing: path)), policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), tags: \(String(describing: tags)))"}
}

extension CreatePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreatePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreatePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyInput>
    public typealias MOutput = OperationOutput<CreatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyOutputError>
}

public struct CreatePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyInput>
    public typealias MOutput = OperationOutput<CreatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyOutputError>
}

public struct CreatePolicyInput: Equatable {
    /// <p>A friendly description of the policy.</p>
    ///         <p>Typically used to store information about the permissions defined in the policy. For
    ///             example, "Grants access to production DynamoDB tables."</p>
    ///         <p>The policy description is immutable. After a value is assigned, it cannot be
    ///             changed.</p>
    public let description: String?
    /// <p>The path for the policy.</p>
    ///         <p>For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///                 <i>IAM User Guide</i>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let path: String?
    /// <p>The JSON policy document that you want to use as the content for the new
    ///             policy.</p>
    ///         <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    ///             templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    ///             CloudFormation always converts a YAML policy to JSON format before submitting it to
    ///             IAM.</p>
    ///         <p>To learn more about JSON policy grammar, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html">Grammar of the IAM JSON policy language</a> in the
    ///             <i>IAM User Guide</i>. </p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyDocument: String?
    /// <p>The friendly name of the policy.</p>
    ///         <p>IAM user, group, role, and policy names must be unique within the account. Names are
    ///             not distinguished by case. For example, you cannot create resources named both
    ///             "MyResource" and "myresource".</p>
    public let policyName: String?
    /// <p>A list of tags that you want to attach to the new IAM customer managed policy.
    ///       Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        path: String? = nil,
        policyDocument: String? = nil,
        policyName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.path = path
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

extension CreatePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePolicyOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension CreatePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreatePolicy</a> request.
///     </p>
public struct CreatePolicyOutputResponse: Equatable {
    /// <p>A structure containing details about the new policy.</p>
    public let policy: Policy?

    public init (
        policy: Policy? = nil
    )
    {
        self.policy = policy
    }
}

struct CreatePolicyOutputResponseBody: Equatable {
    public let policy: Policy?
}

extension CreatePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreatePolicyResult"))
        let policyDecoded = try containerValues.decodeIfPresent(Policy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct CreatePolicyVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreatePolicyVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyVersionInput>
    public typealias MOutput = OperationOutput<CreatePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyVersionOutputError>
}

extension CreatePolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyVersionInput(policyArn: \(String(describing: policyArn)), policyDocument: \(String(describing: policyDocument)), setAsDefault: \(String(describing: setAsDefault)))"}
}

extension CreatePolicyVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: Key("PolicyDocument"))
        }
        if setAsDefault != false {
            try container.encode(setAsDefault, forKey: Key("SetAsDefault"))
        }
        try container.encode("CreatePolicyVersion", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreatePolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyVersionInput>
    public typealias MOutput = OperationOutput<CreatePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyVersionOutputError>
}

public struct CreatePolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyVersionInput>
    public typealias MOutput = OperationOutput<CreatePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyVersionOutputError>
}

public struct CreatePolicyVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new
    ///             version.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The JSON policy document that you want to use as the content for this new version of
    ///             the policy.</p>
    ///         <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    ///             templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    ///             CloudFormation always converts a YAML policy to JSON format before submitting it to
    ///             IAM.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyDocument: String?
    /// <p>Specifies whether to set this version as the policy's default version.</p>
    ///         <p>When this parameter is <code>true</code>, the new policy version becomes the operative
    ///             version. That is, it becomes the version that is in effect for the IAM users, groups,
    ///             and roles that the policy is attached to.</p>
    ///         <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    ///                 policies</a> in the <i>IAM User Guide</i>.</p>
    public let setAsDefault: Bool

    public init (
        policyArn: String? = nil,
        policyDocument: String? = nil,
        setAsDefault: Bool = false
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.setAsDefault = setAsDefault
    }
}

extension CreatePolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePolicyVersionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyVersionOutputResponse(policyVersion: \(String(describing: policyVersion)))"}
}

extension CreatePolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyVersion = output.policyVersion
        } else {
            self.policyVersion = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreatePolicyVersion</a> request.
///     </p>
public struct CreatePolicyVersionOutputResponse: Equatable {
    /// <p>A structure containing details about the new policy version.</p>
    public let policyVersion: PolicyVersion?

    public init (
        policyVersion: PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

struct CreatePolicyVersionOutputResponseBody: Equatable {
    public let policyVersion: PolicyVersion?
}

extension CreatePolicyVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyVersion = "PolicyVersion"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreatePolicyVersionResult"))
        let policyVersionDecoded = try containerValues.decodeIfPresent(PolicyVersion.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
    }
}

public struct CreateRoleInputBodyMiddleware: Middleware {
    public let id: String = "CreateRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoleInput>
    public typealias MOutput = OperationOutput<CreateRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoleOutputError>
}

extension CreateRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoleInput(assumeRolePolicyDocument: \(String(describing: assumeRolePolicyDocument)), description: \(String(describing: description)), maxSessionDuration: \(String(describing: maxSessionDuration)), path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), roleName: \(String(describing: roleName)), tags: \(String(describing: tags)))"}
}

extension CreateRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: Key("AssumeRolePolicyDocument"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateRoleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoleInput>
    public typealias MOutput = OperationOutput<CreateRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoleOutputError>
}

public struct CreateRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoleInput>
    public typealias MOutput = OperationOutput<CreateRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoleOutputError>
}

public struct CreateRoleInput: Equatable {
    /// <p>The trust relationship policy document that grants an entity permission to assume the
    ///             role.</p>
    ///         <p>In IAM, you must provide a JSON policy that has been converted to a string. However,
    ///             for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON
    ///             or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before
    ///             submitting it to IAM.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    ///         <p> Upon success, the response includes the same trust policy in JSON format.</p>
    public let assumeRolePolicyDocument: String?
    /// <p>A description of the role.</p>
    public let description: String?
    /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
    ///             If you do not specify a value for this setting, the default maximum of one hour is
    ///             applied. This setting can have a value from 1 hour to 12 hours.</p>
    ///         <p>Anyone who assumes the role from the AWS CLI or API can use the
    ///                 <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
    ///             parameter to request a longer session. The <code>MaxSessionDuration</code> setting
    ///             determines the maximum duration that can be requested using the
    ///                 <code>DurationSeconds</code> parameter. If users don't specify a value for the
    ///                 <code>DurationSeconds</code> parameter, their security credentials are valid for one
    ///             hour by default. This applies when you use the <code>AssumeRole*</code> API operations
    ///             or the <code>assume-role*</code> CLI operations but does not apply when you use those
    ///             operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
    ///                 roles</a> in the <i>IAM User Guide</i>.</p>
    public let maxSessionDuration: Int?
    /// <p> The path to the role. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///                 Identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let path: String?
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    ///             role.</p>
    public let permissionsBoundary: String?
    /// <p>The name of the role to create.</p>
    ///         <p>IAM user, group, role, and policy names must be unique within the account. Names are
    ///             not distinguished by case. For example, you cannot create resources named both
    ///             "MyResource" and "myresource".</p>
    public let roleName: String?
    /// <p>A list of tags that you want to attach to the new role. Each tag consists of a key name and an associated value.
    ///       For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        assumeRolePolicyDocument: String? = nil,
        description: String? = nil,
        maxSessionDuration: Int? = nil,
        path: String? = nil,
        permissionsBoundary: String? = nil,
        roleName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
        self.tags = tags
    }
}

extension CreateRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoleOutputResponse(role: \(String(describing: role)))"}
}

extension CreateRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateRole</a> request. </p>
public struct CreateRoleOutputResponse: Equatable {
    /// <p>A structure containing details about the new role.</p>
    public let role: Role?

    public init (
        role: Role? = nil
    )
    {
        self.role = role
    }
}

struct CreateRoleOutputResponseBody: Equatable {
    public let role: Role?
}

extension CreateRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case role = "Role"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(Role.self, forKey: .role)
        role = roleDecoded
    }
}

public struct CreateSAMLProviderInputBodyMiddleware: Middleware {
    public let id: String = "CreateSAMLProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSAMLProviderInput>
    public typealias MOutput = OperationOutput<CreateSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSAMLProviderOutputError>
}

extension CreateSAMLProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSAMLProviderInput(name: \(String(describing: name)), sAMLMetadataDocument: \(String(describing: sAMLMetadataDocument)), tags: \(String(describing: tags)))"}
}

extension CreateSAMLProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let sAMLMetadataDocument = sAMLMetadataDocument {
            try container.encode(sAMLMetadataDocument, forKey: Key("SAMLMetadataDocument"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateSAMLProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateSAMLProviderInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSAMLProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSAMLProviderInput>
    public typealias MOutput = OperationOutput<CreateSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSAMLProviderOutputError>
}

public struct CreateSAMLProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSAMLProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSAMLProviderInput>
    public typealias MOutput = OperationOutput<CreateSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSAMLProviderOutputError>
}

public struct CreateSAMLProviderInput: Equatable {
    /// <p>The name of the provider to create.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let name: String?
    /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
    ///             document includes the issuer's name, expiration information, and keys that can be used
    ///             to validate the SAML authentication response (assertions) that are received from the
    ///             IdP. You must generate the metadata document using the identity management software that
    ///             is used as your organization's IdP.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html">About SAML 2.0-based
    ///                 federation</a> in the <i>IAM User Guide</i>
    ///         </p>
    public let sAMLMetadataDocument: String?
    /// <p>A list of tags that you want to attach to the new IAM SAML provider.
    ///       Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        name: String? = nil,
        sAMLMetadataDocument: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.name = name
        self.sAMLMetadataDocument = sAMLMetadataDocument
        self.tags = tags
    }
}

extension CreateSAMLProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSAMLProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSAMLProviderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSAMLProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSAMLProviderOutputResponse(sAMLProviderArn: \(String(describing: sAMLProviderArn)), tags: \(String(describing: tags)))"}
}

extension CreateSAMLProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSAMLProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sAMLProviderArn = output.sAMLProviderArn
            self.tags = output.tags
        } else {
            self.sAMLProviderArn = nil
            self.tags = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateSAMLProvider</a> request.
///     </p>
public struct CreateSAMLProviderOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the new SAML provider resource in IAM.</p>
    public let sAMLProviderArn: String?
    /// <p>A list of tags that are attached to the new IAM SAML provider. The returned list of tags is sorted by tag key.
    ///       For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        sAMLProviderArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.sAMLProviderArn = sAMLProviderArn
        self.tags = tags
    }
}

struct CreateSAMLProviderOutputResponseBody: Equatable {
    public let sAMLProviderArn: String?
    public let tags: [Tag]?
}

extension CreateSAMLProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sAMLProviderArn = "SAMLProviderArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateSAMLProviderResult"))
        let sAMLProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sAMLProviderArn)
        sAMLProviderArn = sAMLProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

public struct CreateServiceLinkedRoleInputBodyMiddleware: Middleware {
    public let id: String = "CreateServiceLinkedRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceLinkedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceLinkedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceLinkedRoleInput>
    public typealias MOutput = OperationOutput<CreateServiceLinkedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceLinkedRoleOutputError>
}

extension CreateServiceLinkedRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceLinkedRoleInput(aWSServiceName: \(String(describing: aWSServiceName)), customSuffix: \(String(describing: customSuffix)), description: \(String(describing: description)))"}
}

extension CreateServiceLinkedRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aWSServiceName = aWSServiceName {
            try container.encode(aWSServiceName, forKey: Key("AWSServiceName"))
        }
        if let customSuffix = customSuffix {
            try container.encode(customSuffix, forKey: Key("CustomSuffix"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        try container.encode("CreateServiceLinkedRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateServiceLinkedRoleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServiceLinkedRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceLinkedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceLinkedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceLinkedRoleInput>
    public typealias MOutput = OperationOutput<CreateServiceLinkedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceLinkedRoleOutputError>
}

public struct CreateServiceLinkedRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServiceLinkedRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceLinkedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceLinkedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceLinkedRoleInput>
    public typealias MOutput = OperationOutput<CreateServiceLinkedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceLinkedRoleOutputError>
}

public struct CreateServiceLinkedRoleInput: Equatable {
    /// <p>The service principal for the AWS service to which this role is attached. You use a
    ///             string similar to a URL but without the http:// in front. For example:
    ///                 <code>elasticbeanstalk.amazonaws.com</code>. </p>
    ///         <p>Service principals are unique and case-sensitive. To find the exact service principal
    ///             for your service-linked role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html">AWS services
    ///                 that work with IAM</a> in the <i>IAM User Guide</i>. Look for
    ///             the services that have <b>Yes </b>in the <b>Service-Linked Role</b> column. Choose the <b>Yes</b> link to view the service-linked role documentation for that
    ///             service.</p>
    public let aWSServiceName: String?
    /// <p></p>
    ///         <p>A string that you provide, which is combined with the service-provided prefix to form
    ///             the complete role name. If you make multiple requests for the same service, then you
    ///             must supply a different <code>CustomSuffix</code> for each request. Otherwise the
    ///             request fails with a duplicate role name error. For example, you could add
    ///                 <code>-1</code> or <code>-debug</code> to the suffix.</p>
    ///         <p>Some services do not support the <code>CustomSuffix</code> parameter. If you provide
    ///             an optional suffix and the operation fails, try the operation again without the
    ///             suffix.</p>
    public let customSuffix: String?
    /// <p>The description of the role.</p>
    public let description: String?

    public init (
        aWSServiceName: String? = nil,
        customSuffix: String? = nil,
        description: String? = nil
    )
    {
        self.aWSServiceName = aWSServiceName
        self.customSuffix = customSuffix
        self.description = description
    }
}

extension CreateServiceLinkedRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateServiceLinkedRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceLinkedRoleOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceLinkedRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceLinkedRoleOutputResponse(role: \(String(describing: role)))"}
}

extension CreateServiceLinkedRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServiceLinkedRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

public struct CreateServiceLinkedRoleOutputResponse: Equatable {
    /// <p>A <a>Role</a> object that contains details about the newly created
    ///             role.</p>
    public let role: Role?

    public init (
        role: Role? = nil
    )
    {
        self.role = role
    }
}

struct CreateServiceLinkedRoleOutputResponseBody: Equatable {
    public let role: Role?
}

extension CreateServiceLinkedRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case role = "Role"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateServiceLinkedRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(Role.self, forKey: .role)
        role = roleDecoded
    }
}

public struct CreateServiceSpecificCredentialInputBodyMiddleware: Middleware {
    public let id: String = "CreateServiceSpecificCredentialInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<CreateServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceSpecificCredentialOutputError>
}

extension CreateServiceSpecificCredentialInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceSpecificCredentialInput(serviceName: \(String(describing: serviceName)), userName: \(String(describing: userName)))"}
}

extension CreateServiceSpecificCredentialInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("CreateServiceSpecificCredential", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateServiceSpecificCredentialInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServiceSpecificCredentialInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<CreateServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceSpecificCredentialOutputError>
}

public struct CreateServiceSpecificCredentialInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServiceSpecificCredentialInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<CreateServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceSpecificCredentialOutputError>
}

public struct CreateServiceSpecificCredentialInput: Equatable {
    /// <p>The name of the AWS service that is to be associated with the credentials. The
    ///             service you specify here is the only service that can be accessed using these
    ///             credentials.</p>
    public let serviceName: String?
    /// <p>The name of the IAM user that is to be associated with the credentials. The new
    ///             service-specific credentials have the same permissions as the associated user except
    ///             that they can be used only to access the specified service.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        serviceName: String? = nil,
        userName: String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

extension CreateServiceSpecificCredentialOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateServiceSpecificCredentialOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotSupportedException" : self = .serviceNotSupportedException(try ServiceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceSpecificCredentialOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceNotSupportedException(ServiceNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceSpecificCredentialOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceSpecificCredentialOutputResponse(serviceSpecificCredential: \(String(describing: serviceSpecificCredential)))"}
}

extension CreateServiceSpecificCredentialOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServiceSpecificCredentialOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceSpecificCredential = output.serviceSpecificCredential
        } else {
            self.serviceSpecificCredential = nil
        }
    }
}

public struct CreateServiceSpecificCredentialOutputResponse: Equatable {
    /// <p>A structure that contains information about the newly created service-specific
    ///             credential.</p>
    ///         <important>
    ///             <p>This is the only time that the password for this credential set is available. It
    ///                 cannot be recovered later. Instead, you must reset the password with <a>ResetServiceSpecificCredential</a>.</p>
    ///         </important>
    public let serviceSpecificCredential: ServiceSpecificCredential?

    public init (
        serviceSpecificCredential: ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

struct CreateServiceSpecificCredentialOutputResponseBody: Equatable {
    public let serviceSpecificCredential: ServiceSpecificCredential?
}

extension CreateServiceSpecificCredentialOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceSpecificCredential = "ServiceSpecificCredential"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateServiceSpecificCredentialResult"))
        let serviceSpecificCredentialDecoded = try containerValues.decodeIfPresent(ServiceSpecificCredential.self, forKey: .serviceSpecificCredential)
        serviceSpecificCredential = serviceSpecificCredentialDecoded
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), tags: \(String(describing: tags)), userName: \(String(describing: userName)))"}
}

extension CreateUserInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("CreateUser", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Equatable {
    /// <p> The path for the user name. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///                 identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let path: String?
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    ///             user.</p>
    public let permissionsBoundary: String?
    /// <p>A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value.
    ///       For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The name of the user to create.</p>
    ///         <p>IAM user, group, role, and policy names must be unique within the account. Names are
    ///             not distinguished by case. For example, you cannot create resources named both
    ///             "MyResource" and "myresource".</p>
    public let userName: String?

    public init (
        path: String? = nil,
        permissionsBoundary: String? = nil,
        tags: [Tag]? = nil,
        userName: String? = nil
    )
    {
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.tags = tags
        self.userName = userName
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse(user: \(String(describing: user)))"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateUser</a> request. </p>
public struct CreateUserOutputResponse: Equatable {
    /// <p>A structure with details about the new IAM user.</p>
    public let user: User?

    public init (
        user: User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputResponseBody: Equatable {
    public let user: User?
}

extension CreateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateUserResult"))
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
    }
}

public struct CreateVirtualMFADeviceInputBodyMiddleware: Middleware {
    public let id: String = "CreateVirtualMFADeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualMFADeviceInput>
    public typealias MOutput = OperationOutput<CreateVirtualMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualMFADeviceOutputError>
}

extension CreateVirtualMFADeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualMFADeviceInput(path: \(String(describing: path)), tags: \(String(describing: tags)), virtualMFADeviceName: \(String(describing: virtualMFADeviceName)))"}
}

extension CreateVirtualMFADeviceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let virtualMFADeviceName = virtualMFADeviceName {
            try container.encode(virtualMFADeviceName, forKey: Key("VirtualMFADeviceName"))
        }
        try container.encode("CreateVirtualMFADevice", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct CreateVirtualMFADeviceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVirtualMFADeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualMFADeviceInput>
    public typealias MOutput = OperationOutput<CreateVirtualMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualMFADeviceOutputError>
}

public struct CreateVirtualMFADeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVirtualMFADeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualMFADeviceInput>
    public typealias MOutput = OperationOutput<CreateVirtualMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualMFADeviceOutputError>
}

public struct CreateVirtualMFADeviceInput: Equatable {
    /// <p> The path for the virtual MFA device. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///                 identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let path: String?
    /// <p>A list of tags that you want to attach to the new IAM virtual MFA device.
    ///       Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The name of the virtual MFA device. Use with path to uniquely identify a virtual MFA
    ///             device.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let virtualMFADeviceName: String?

    public init (
        path: String? = nil,
        tags: [Tag]? = nil,
        virtualMFADeviceName: String? = nil
    )
    {
        self.path = path
        self.tags = tags
        self.virtualMFADeviceName = virtualMFADeviceName
    }
}

extension CreateVirtualMFADeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateVirtualMFADeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualMFADeviceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualMFADeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualMFADeviceOutputResponse(virtualMFADevice: \(String(describing: virtualMFADevice)))"}
}

extension CreateVirtualMFADeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateVirtualMFADeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.virtualMFADevice = output.virtualMFADevice
        } else {
            self.virtualMFADevice = nil
        }
    }
}

/// <p>Contains the response to a successful <a>CreateVirtualMFADevice</a> request.
///     </p>
public struct CreateVirtualMFADeviceOutputResponse: Equatable {
    /// <p>A structure containing details about the new virtual MFA device.</p>
    public let virtualMFADevice: VirtualMFADevice?

    public init (
        virtualMFADevice: VirtualMFADevice? = nil
    )
    {
        self.virtualMFADevice = virtualMFADevice
    }
}

struct CreateVirtualMFADeviceOutputResponseBody: Equatable {
    public let virtualMFADevice: VirtualMFADevice?
}

extension CreateVirtualMFADeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualMFADevice = "VirtualMFADevice"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateVirtualMFADeviceResult"))
        let virtualMFADeviceDecoded = try containerValues.decodeIfPresent(VirtualMFADevice.self, forKey: .virtualMFADevice)
        virtualMFADevice = virtualMFADeviceDecoded
    }
}

extension CredentialReportExpiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CredentialReportExpiredException(message: \(String(describing: message)))"}
}

extension CredentialReportExpiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CredentialReportExpiredExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the most recent credential report has expired. To
///       generate a new credential report, use <a>GenerateCredentialReport</a>. For more
///       information about credential report expiration, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html">Getting credential reports</a> in the
///         <i>IAM User Guide</i>.</p>
public struct CredentialReportExpiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CredentialReportExpiredExceptionBody: Equatable {
    public let message: String?
}

extension CredentialReportExpiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CredentialReportNotPresentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CredentialReportNotPresentException(message: \(String(describing: message)))"}
}

extension CredentialReportNotPresentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CredentialReportNotPresentExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the credential report does not exist. To generate a
///       credential report, use <a>GenerateCredentialReport</a>.</p>
public struct CredentialReportNotPresentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CredentialReportNotPresentExceptionBody: Equatable {
    public let message: String?
}

extension CredentialReportNotPresentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CredentialReportNotReadyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CredentialReportNotReadyException(message: \(String(describing: message)))"}
}

extension CredentialReportNotReadyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CredentialReportNotReadyExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the credential report is still being generated.</p>
public struct CredentialReportNotReadyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CredentialReportNotReadyExceptionBody: Equatable {
    public let message: String?
}

extension CredentialReportNotReadyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeactivateMFADeviceInputBodyMiddleware: Middleware {
    public let id: String = "DeactivateMFADeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateMFADeviceInput>
    public typealias MOutput = OperationOutput<DeactivateMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateMFADeviceOutputError>
}

extension DeactivateMFADeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateMFADeviceInput(serialNumber: \(String(describing: serialNumber)), userName: \(String(describing: userName)))"}
}

extension DeactivateMFADeviceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeactivateMFADevice", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeactivateMFADeviceInputHeadersMiddleware: Middleware {
    public let id: String = "DeactivateMFADeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateMFADeviceInput>
    public typealias MOutput = OperationOutput<DeactivateMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateMFADeviceOutputError>
}

public struct DeactivateMFADeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeactivateMFADeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateMFADeviceInput>
    public typealias MOutput = OperationOutput<DeactivateMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateMFADeviceOutputError>
}

public struct DeactivateMFADeviceInput: Equatable {
    /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
    ///             the serial number is the device ARN.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
    ///     following characters: =,.@:/-</p>
    public let serialNumber: String?
    /// <p>The name of the user whose MFA device you want to deactivate.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        serialNumber: String? = nil,
        userName: String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension DeactivateMFADeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeactivateMFADeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiableException" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateMFADeviceOutputError: Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateMFADeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateMFADeviceOutputResponse()"}
}

extension DeactivateMFADeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateMFADeviceOutputResponse: Equatable {

    public init() {}
}

struct DeactivateMFADeviceOutputResponseBody: Equatable {
}

extension DeactivateMFADeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAccessKeyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAccessKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessKeyInput>
    public typealias MOutput = OperationOutput<DeleteAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessKeyOutputError>
}

extension DeleteAccessKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessKeyInput(accessKeyId: \(String(describing: accessKeyId)), userName: \(String(describing: userName)))"}
}

extension DeleteAccessKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: Key("AccessKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteAccessKey", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteAccessKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessKeyInput>
    public typealias MOutput = OperationOutput<DeleteAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessKeyOutputError>
}

public struct DeleteAccessKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessKeyInput>
    public typealias MOutput = OperationOutput<DeleteAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessKeyOutputError>
}

public struct DeleteAccessKeyInput: Equatable {
    /// <p>The access key ID for the access key ID and secret access key you want to
    ///             delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let accessKeyId: String?
    /// <p>The name of the user whose access key pair you want to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        accessKeyId: String? = nil,
        userName: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.userName = userName
    }
}

extension DeleteAccessKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccessKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessKeyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessKeyOutputResponse()"}
}

extension DeleteAccessKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessKeyOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessKeyOutputResponseBody: Equatable {
}

extension DeleteAccessKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAccountAliasInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAccountAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAliasInput>
    public typealias MOutput = OperationOutput<DeleteAccountAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAliasOutputError>
}

extension DeleteAccountAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountAliasInput(accountAlias: \(String(describing: accountAlias)))"}
}

extension DeleteAccountAliasInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: Key("AccountAlias"))
        }
        try container.encode("DeleteAccountAlias", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteAccountAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccountAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAliasInput>
    public typealias MOutput = OperationOutput<DeleteAccountAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAliasOutputError>
}

public struct DeleteAccountAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccountAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAliasInput>
    public typealias MOutput = OperationOutput<DeleteAccountAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAliasOutputError>
}

public struct DeleteAccountAliasInput: Equatable {
    /// <p>The name of the account alias to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
    ///     lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
    ///     two dashes in a row.</p>
    public let accountAlias: String?

    public init (
        accountAlias: String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

extension DeleteAccountAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccountAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountAliasOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountAliasOutputResponse()"}
}

extension DeleteAccountAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccountAliasOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccountAliasOutputResponseBody: Equatable {
}

extension DeleteAccountAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAccountPasswordPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAccountPasswordPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountPasswordPolicyOutputError>
}

extension DeleteAccountPasswordPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountPasswordPolicyInput()"}
}

extension DeleteAccountPasswordPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("DeleteAccountPasswordPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteAccountPasswordPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccountPasswordPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountPasswordPolicyOutputError>
}

public struct DeleteAccountPasswordPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccountPasswordPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountPasswordPolicyOutputError>
}

public struct DeleteAccountPasswordPolicyInput: Equatable {

    public init() {}
}

extension DeleteAccountPasswordPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccountPasswordPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountPasswordPolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountPasswordPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountPasswordPolicyOutputResponse()"}
}

extension DeleteAccountPasswordPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccountPasswordPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccountPasswordPolicyOutputResponseBody: Equatable {
}

extension DeleteAccountPasswordPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConflictException(message: \(String(describing: message)))"}
}

extension DeleteConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DeleteConflictExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to delete a resource that has attached
///       subordinate entities. The error message describes these entities.</p>
public struct DeleteConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteConflictExceptionBody: Equatable {
    public let message: String?
}

extension DeleteConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

extension DeleteGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupInput(groupName: \(String(describing: groupName)))"}
}

extension DeleteGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        try container.encode("DeleteGroup", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Equatable {
    /// <p>The name of the IAM group to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?

    public init (
        groupName: String? = nil
    )
    {
        self.groupName = groupName
    }
}

extension DeleteGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupOutputResponse()"}
}

extension DeleteGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteGroupOutputResponseBody: Equatable {
}

extension DeleteGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteGroupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGroupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupPolicyInput>
    public typealias MOutput = OperationOutput<DeleteGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupPolicyOutputError>
}

extension DeleteGroupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupPolicyInput(groupName: \(String(describing: groupName)), policyName: \(String(describing: policyName)))"}
}

extension DeleteGroupPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("DeleteGroupPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteGroupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupPolicyInput>
    public typealias MOutput = OperationOutput<DeleteGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupPolicyOutputError>
}

public struct DeleteGroupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupPolicyInput>
    public typealias MOutput = OperationOutput<DeleteGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupPolicyOutputError>
}

public struct DeleteGroupPolicyInput: Equatable {
    /// <p>The name (friendly name, not ARN) identifying the group that the policy is embedded
    ///             in.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>The name identifying the policy document to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?

    public init (
        groupName: String? = nil,
        policyName: String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

extension DeleteGroupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteGroupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupPolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupPolicyOutputResponse()"}
}

extension DeleteGroupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteGroupPolicyOutputResponseBody: Equatable {
}

extension DeleteGroupPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceProfileOutputError>
}

extension DeleteInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceProfileInput(instanceProfileName: \(String(describing: instanceProfileName)))"}
}

extension DeleteInstanceProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        try container.encode("DeleteInstanceProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInput: Equatable {
    /// <p>The name of the instance profile to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let instanceProfileName: String?

    public init (
        instanceProfileName: String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

extension DeleteInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceProfileOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceProfileOutputResponse()"}
}

extension DeleteInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteInstanceProfileOutputResponseBody: Equatable {
}

extension DeleteInstanceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLoginProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLoginProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoginProfileInput>
    public typealias MOutput = OperationOutput<DeleteLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoginProfileOutputError>
}

extension DeleteLoginProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoginProfileInput(userName: \(String(describing: userName)))"}
}

extension DeleteLoginProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteLoginProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteLoginProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoginProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoginProfileInput>
    public typealias MOutput = OperationOutput<DeleteLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoginProfileOutputError>
}

public struct DeleteLoginProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoginProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoginProfileInput>
    public typealias MOutput = OperationOutput<DeleteLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoginProfileOutputError>
}

public struct DeleteLoginProfileInput: Equatable {
    /// <p>The name of the user whose password you want to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        userName: String? = nil
    )
    {
        self.userName = userName
    }
}

extension DeleteLoginProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoginProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiableException" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoginProfileOutputError: Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoginProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoginProfileOutputResponse()"}
}

extension DeleteLoginProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoginProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoginProfileOutputResponseBody: Equatable {
}

extension DeleteLoginProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteOpenIDConnectProviderInputBodyMiddleware: Middleware {
    public let id: String = "DeleteOpenIDConnectProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<DeleteOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOpenIDConnectProviderOutputError>
}

extension DeleteOpenIDConnectProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOpenIDConnectProviderInput(openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)))"}
}

extension DeleteOpenIDConnectProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        try container.encode("DeleteOpenIDConnectProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteOpenIDConnectProviderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOpenIDConnectProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<DeleteOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOpenIDConnectProviderOutputError>
}

public struct DeleteOpenIDConnectProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOpenIDConnectProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<DeleteOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOpenIDConnectProviderOutputError>
}

public struct DeleteOpenIDConnectProviderInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to
    ///             delete. You can get a list of OpenID Connect provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    public let openIDConnectProviderArn: String?

    public init (
        openIDConnectProviderArn: String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension DeleteOpenIDConnectProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOpenIDConnectProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOpenIDConnectProviderOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOpenIDConnectProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOpenIDConnectProviderOutputResponse()"}
}

extension DeleteOpenIDConnectProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOpenIDConnectProviderOutputResponse: Equatable {

    public init() {}
}

struct DeleteOpenIDConnectProviderOutputResponseBody: Equatable {
}

extension DeleteOpenIDConnectProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeletePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

extension DeletePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyInput(policyArn: \(String(describing: policyArn)))"}
}

extension DeletePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        try container.encode("DeletePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeletePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to delete.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?

    public init (
        policyArn: String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

extension DeletePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyOutputResponse()"}
}

extension DeletePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeletePolicyOutputResponseBody: Equatable {
}

extension DeletePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePolicyVersionInputBodyMiddleware: Middleware {
    public let id: String = "DeletePolicyVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyVersionInput>
    public typealias MOutput = OperationOutput<DeletePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyVersionOutputError>
}

extension DeletePolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyVersionInput(policyArn: \(String(describing: policyArn)), versionId: \(String(describing: versionId)))"}
}

extension DeletePolicyVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
        try container.encode("DeletePolicyVersion", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeletePolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyVersionInput>
    public typealias MOutput = OperationOutput<DeletePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyVersionOutputError>
}

public struct DeletePolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyVersionInput>
    public typealias MOutput = OperationOutput<DeletePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyVersionOutputError>
}

public struct DeletePolicyVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a
    ///             version.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The policy version to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
    ///     consists of the lowercase letter 'v' followed by one or two digits, and optionally
    ///     followed by a period '.' and a string of letters and digits.</p>
    ///         <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    ///                 policies</a> in the <i>IAM User Guide</i>.</p>
    public let versionId: String?

    public init (
        policyArn: String? = nil,
        versionId: String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

extension DeletePolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyVersionOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyVersionOutputResponse()"}
}

extension DeletePolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyVersionOutputResponse: Equatable {

    public init() {}
}

struct DeletePolicyVersionOutputResponseBody: Equatable {
}

extension DeletePolicyVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRoleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoleInput>
    public typealias MOutput = OperationOutput<DeleteRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoleOutputError>
}

extension DeleteRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoleInput(roleName: \(String(describing: roleName)))"}
}

extension DeleteRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("DeleteRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteRoleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoleInput>
    public typealias MOutput = OperationOutput<DeleteRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoleOutputError>
}

public struct DeleteRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoleInput>
    public typealias MOutput = OperationOutput<DeleteRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoleOutputError>
}

public struct DeleteRoleInput: Equatable {
    /// <p>The name of the role to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        roleName: String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension DeleteRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoleOutputResponse()"}
}

extension DeleteRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoleOutputResponse: Equatable {

    public init() {}
}

struct DeleteRoleOutputResponseBody: Equatable {
}

extension DeleteRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRolePermissionsBoundaryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRolePermissionsBoundaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRolePermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRolePermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRolePermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<DeleteRolePermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRolePermissionsBoundaryOutputError>
}

extension DeleteRolePermissionsBoundaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRolePermissionsBoundaryInput(roleName: \(String(describing: roleName)))"}
}

extension DeleteRolePermissionsBoundaryInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("DeleteRolePermissionsBoundary", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteRolePermissionsBoundaryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRolePermissionsBoundaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRolePermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRolePermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRolePermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<DeleteRolePermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRolePermissionsBoundaryOutputError>
}

public struct DeleteRolePermissionsBoundaryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRolePermissionsBoundaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRolePermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRolePermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRolePermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<DeleteRolePermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRolePermissionsBoundaryOutputError>
}

public struct DeleteRolePermissionsBoundaryInput: Equatable {
    /// <p>The name (friendly name, not ARN) of the IAM role from which you want to remove the
    ///             permissions boundary.</p>
    public let roleName: String?

    public init (
        roleName: String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension DeleteRolePermissionsBoundaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRolePermissionsBoundaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRolePermissionsBoundaryOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRolePermissionsBoundaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRolePermissionsBoundaryOutputResponse()"}
}

extension DeleteRolePermissionsBoundaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRolePermissionsBoundaryOutputResponse: Equatable {

    public init() {}
}

struct DeleteRolePermissionsBoundaryOutputResponseBody: Equatable {
}

extension DeleteRolePermissionsBoundaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRolePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRolePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRolePolicyInput>
    public typealias MOutput = OperationOutput<DeleteRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRolePolicyOutputError>
}

extension DeleteRolePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRolePolicyInput(policyName: \(String(describing: policyName)), roleName: \(String(describing: roleName)))"}
}

extension DeleteRolePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("DeleteRolePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteRolePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRolePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRolePolicyInput>
    public typealias MOutput = OperationOutput<DeleteRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRolePolicyOutputError>
}

public struct DeleteRolePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRolePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRolePolicyInput>
    public typealias MOutput = OperationOutput<DeleteRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRolePolicyOutputError>
}

public struct DeleteRolePolicyInput: Equatable {
    /// <p>The name of the inline policy to delete from the specified IAM role.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?
    /// <p>The name (friendly name, not ARN) identifying the role that the policy is embedded
    ///             in.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        policyName: String? = nil,
        roleName: String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

extension DeleteRolePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRolePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRolePolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRolePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRolePolicyOutputResponse()"}
}

extension DeleteRolePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRolePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteRolePolicyOutputResponseBody: Equatable {
}

extension DeleteRolePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSAMLProviderInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSAMLProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSAMLProviderInput>
    public typealias MOutput = OperationOutput<DeleteSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSAMLProviderOutputError>
}

extension DeleteSAMLProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSAMLProviderInput(sAMLProviderArn: \(String(describing: sAMLProviderArn)))"}
}

extension DeleteSAMLProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sAMLProviderArn = sAMLProviderArn {
            try container.encode(sAMLProviderArn, forKey: Key("SAMLProviderArn"))
        }
        try container.encode("DeleteSAMLProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteSAMLProviderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSAMLProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSAMLProviderInput>
    public typealias MOutput = OperationOutput<DeleteSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSAMLProviderOutputError>
}

public struct DeleteSAMLProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSAMLProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSAMLProviderInput>
    public typealias MOutput = OperationOutput<DeleteSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSAMLProviderOutputError>
}

public struct DeleteSAMLProviderInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the SAML provider to delete.</p>
    public let sAMLProviderArn: String?

    public init (
        sAMLProviderArn: String? = nil
    )
    {
        self.sAMLProviderArn = sAMLProviderArn
    }
}

extension DeleteSAMLProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSAMLProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSAMLProviderOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSAMLProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSAMLProviderOutputResponse()"}
}

extension DeleteSAMLProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSAMLProviderOutputResponse: Equatable {

    public init() {}
}

struct DeleteSAMLProviderOutputResponseBody: Equatable {
}

extension DeleteSAMLProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSSHPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSSHPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<DeleteSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSSHPublicKeyOutputError>
}

extension DeleteSSHPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSSHPublicKeyInput(sSHPublicKeyId: \(String(describing: sSHPublicKeyId)), userName: \(String(describing: userName)))"}
}

extension DeleteSSHPublicKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sSHPublicKeyId = sSHPublicKeyId {
            try container.encode(sSHPublicKeyId, forKey: Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteSSHPublicKey", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteSSHPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSSHPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<DeleteSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSSHPublicKeyOutputError>
}

public struct DeleteSSHPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSSHPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<DeleteSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSSHPublicKeyOutputError>
}

public struct DeleteSSHPublicKeyInput: Equatable {
    /// <p>The unique identifier for the SSH public key.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let sSHPublicKeyId: String?
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        sSHPublicKeyId: String? = nil,
        userName: String? = nil
    )
    {
        self.sSHPublicKeyId = sSHPublicKeyId
        self.userName = userName
    }
}

extension DeleteSSHPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSSHPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSSHPublicKeyOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSSHPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSSHPublicKeyOutputResponse()"}
}

extension DeleteSSHPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSSHPublicKeyOutputResponse: Equatable {

    public init() {}
}

struct DeleteSSHPublicKeyOutputResponseBody: Equatable {
}

extension DeleteSSHPublicKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteServerCertificateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServerCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerCertificateInput>
    public typealias MOutput = OperationOutput<DeleteServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerCertificateOutputError>
}

extension DeleteServerCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerCertificateInput(serverCertificateName: \(String(describing: serverCertificateName)))"}
}

extension DeleteServerCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        try container.encode("DeleteServerCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteServerCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServerCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerCertificateInput>
    public typealias MOutput = OperationOutput<DeleteServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerCertificateOutputError>
}

public struct DeleteServerCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServerCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerCertificateInput>
    public typealias MOutput = OperationOutput<DeleteServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerCertificateOutputError>
}

public struct DeleteServerCertificateInput: Equatable {
    /// <p>The name of the server certificate you want to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let serverCertificateName: String?

    public init (
        serverCertificateName: String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

extension DeleteServerCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteServerCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServerCertificateOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerCertificateOutputResponse()"}
}

extension DeleteServerCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerCertificateOutputResponse: Equatable {

    public init() {}
}

struct DeleteServerCertificateOutputResponseBody: Equatable {
}

extension DeleteServerCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteServiceLinkedRoleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServiceLinkedRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceLinkedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceLinkedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceLinkedRoleInput>
    public typealias MOutput = OperationOutput<DeleteServiceLinkedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceLinkedRoleOutputError>
}

extension DeleteServiceLinkedRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceLinkedRoleInput(roleName: \(String(describing: roleName)))"}
}

extension DeleteServiceLinkedRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("DeleteServiceLinkedRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteServiceLinkedRoleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServiceLinkedRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceLinkedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceLinkedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceLinkedRoleInput>
    public typealias MOutput = OperationOutput<DeleteServiceLinkedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceLinkedRoleOutputError>
}

public struct DeleteServiceLinkedRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServiceLinkedRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceLinkedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceLinkedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceLinkedRoleInput>
    public typealias MOutput = OperationOutput<DeleteServiceLinkedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceLinkedRoleOutputError>
}

public struct DeleteServiceLinkedRoleInput: Equatable {
    /// <p>The name of the service-linked role to be deleted.</p>
    public let roleName: String?

    public init (
        roleName: String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension DeleteServiceLinkedRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteServiceLinkedRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceLinkedRoleOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceLinkedRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceLinkedRoleOutputResponse(deletionTaskId: \(String(describing: deletionTaskId)))"}
}

extension DeleteServiceLinkedRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteServiceLinkedRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletionTaskId = output.deletionTaskId
        } else {
            self.deletionTaskId = nil
        }
    }
}

public struct DeleteServiceLinkedRoleOutputResponse: Equatable {
    /// <p>The deletion task identifier that you can use to check the status of the deletion.
    ///             This identifier is returned in the format
    ///                 <code>task/aws-service-role/<service-principal-name>/<role-name>/<task-uuid></code>.</p>
    public let deletionTaskId: String?

    public init (
        deletionTaskId: String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

struct DeleteServiceLinkedRoleOutputResponseBody: Equatable {
    public let deletionTaskId: String?
}

extension DeleteServiceLinkedRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionTaskId = "DeletionTaskId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteServiceLinkedRoleResult"))
        let deletionTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionTaskId)
        deletionTaskId = deletionTaskIdDecoded
    }
}

public struct DeleteServiceSpecificCredentialInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServiceSpecificCredentialInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<DeleteServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceSpecificCredentialOutputError>
}

extension DeleteServiceSpecificCredentialInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceSpecificCredentialInput(serviceSpecificCredentialId: \(String(describing: serviceSpecificCredentialId)), userName: \(String(describing: userName)))"}
}

extension DeleteServiceSpecificCredentialInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteServiceSpecificCredential", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteServiceSpecificCredentialInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServiceSpecificCredentialInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<DeleteServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceSpecificCredentialOutputError>
}

public struct DeleteServiceSpecificCredentialInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServiceSpecificCredentialInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<DeleteServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceSpecificCredentialOutputError>
}

public struct DeleteServiceSpecificCredentialInput: Equatable {
    /// <p>The unique identifier of the service-specific credential. You can get this value by
    ///             calling <a>ListServiceSpecificCredentials</a>.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let serviceSpecificCredentialId: String?
    /// <p>The name of the IAM user associated with the service-specific credential. If this
    ///             value is not specified, then the operation assumes the user whose credentials are used
    ///             to call the operation.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        serviceSpecificCredentialId: String? = nil,
        userName: String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

extension DeleteServiceSpecificCredentialOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteServiceSpecificCredentialOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceSpecificCredentialOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceSpecificCredentialOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceSpecificCredentialOutputResponse()"}
}

extension DeleteServiceSpecificCredentialOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceSpecificCredentialOutputResponse: Equatable {

    public init() {}
}

struct DeleteServiceSpecificCredentialOutputResponseBody: Equatable {
}

extension DeleteServiceSpecificCredentialOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSigningCertificateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSigningCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSigningCertificateInput>
    public typealias MOutput = OperationOutput<DeleteSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSigningCertificateOutputError>
}

extension DeleteSigningCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSigningCertificateInput(certificateId: \(String(describing: certificateId)), userName: \(String(describing: userName)))"}
}

extension DeleteSigningCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: Key("CertificateId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteSigningCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteSigningCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSigningCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSigningCertificateInput>
    public typealias MOutput = OperationOutput<DeleteSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSigningCertificateOutputError>
}

public struct DeleteSigningCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSigningCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSigningCertificateInput>
    public typealias MOutput = OperationOutput<DeleteSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSigningCertificateOutputError>
}

public struct DeleteSigningCertificateInput: Equatable {
    /// <p>The ID of the signing certificate to delete.</p>
    ///         <p>The format of this parameter, as described by its <a href="http://wikipedia.org/wiki/regex">regex</a> pattern, is a string of
    ///             characters that can be upper- or lower-cased letters or digits.</p>
    public let certificateId: String?
    /// <p>The name of the user the signing certificate belongs to.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        certificateId: String? = nil,
        userName: String? = nil
    )
    {
        self.certificateId = certificateId
        self.userName = userName
    }
}

extension DeleteSigningCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSigningCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSigningCertificateOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSigningCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSigningCertificateOutputResponse()"}
}

extension DeleteSigningCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSigningCertificateOutputResponse: Equatable {

    public init() {}
}

struct DeleteSigningCertificateOutputResponseBody: Equatable {
}

extension DeleteSigningCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(userName: \(String(describing: userName)))"}
}

extension DeleteUserInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteUser", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>The name of the user to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        userName: String? = nil
    )
    {
        self.userName = userName
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserPermissionsBoundaryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserPermissionsBoundaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<DeleteUserPermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPermissionsBoundaryOutputError>
}

extension DeleteUserPermissionsBoundaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPermissionsBoundaryInput(userName: \(String(describing: userName)))"}
}

extension DeleteUserPermissionsBoundaryInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteUserPermissionsBoundary", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteUserPermissionsBoundaryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserPermissionsBoundaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<DeleteUserPermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPermissionsBoundaryOutputError>
}

public struct DeleteUserPermissionsBoundaryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserPermissionsBoundaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<DeleteUserPermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPermissionsBoundaryOutputError>
}

public struct DeleteUserPermissionsBoundaryInput: Equatable {
    /// <p>The name (friendly name, not ARN) of the IAM user from which you want to remove the
    ///             permissions boundary.</p>
    public let userName: String?

    public init (
        userName: String? = nil
    )
    {
        self.userName = userName
    }
}

extension DeleteUserPermissionsBoundaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUserPermissionsBoundaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserPermissionsBoundaryOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserPermissionsBoundaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPermissionsBoundaryOutputResponse()"}
}

extension DeleteUserPermissionsBoundaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserPermissionsBoundaryOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserPermissionsBoundaryOutputResponseBody: Equatable {
}

extension DeleteUserPermissionsBoundaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPolicyInput>
    public typealias MOutput = OperationOutput<DeleteUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPolicyOutputError>
}

extension DeleteUserPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPolicyInput(policyName: \(String(describing: policyName)), userName: \(String(describing: userName)))"}
}

extension DeleteUserPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DeleteUserPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteUserPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPolicyInput>
    public typealias MOutput = OperationOutput<DeleteUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPolicyOutputError>
}

public struct DeleteUserPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPolicyInput>
    public typealias MOutput = OperationOutput<DeleteUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPolicyOutputError>
}

public struct DeleteUserPolicyInput: Equatable {
    /// <p>The name identifying the policy document to delete.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?
    /// <p>The name (friendly name, not ARN) identifying the user that the policy is embedded
    ///             in.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        policyName: String? = nil,
        userName: String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

extension DeleteUserPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUserPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserPolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPolicyOutputResponse()"}
}

extension DeleteUserPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserPolicyOutputResponseBody: Equatable {
}

extension DeleteUserPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteVirtualMFADeviceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteVirtualMFADeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualMFADeviceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualMFADeviceOutputError>
}

extension DeleteVirtualMFADeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualMFADeviceInput(serialNumber: \(String(describing: serialNumber)))"}
}

extension DeleteVirtualMFADeviceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        try container.encode("DeleteVirtualMFADevice", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DeleteVirtualMFADeviceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVirtualMFADeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualMFADeviceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualMFADeviceOutputError>
}

public struct DeleteVirtualMFADeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVirtualMFADeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualMFADeviceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualMFADeviceOutputError>
}

public struct DeleteVirtualMFADeviceInput: Equatable {
    /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
    ///             the serial number is the same as the ARN.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
    ///     following characters: =,.@:/-</p>
    public let serialNumber: String?

    public init (
        serialNumber: String? = nil
    )
    {
        self.serialNumber = serialNumber
    }
}

extension DeleteVirtualMFADeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteVirtualMFADeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualMFADeviceOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualMFADeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualMFADeviceOutputResponse()"}
}

extension DeleteVirtualMFADeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVirtualMFADeviceOutputResponse: Equatable {

    public init() {}
}

struct DeleteVirtualMFADeviceOutputResponseBody: Equatable {
}

extension DeleteVirtualMFADeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletionTaskFailureReasonType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case roleUsageList = "RoleUsageList"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let reason = reason {
            try container.encode(reason, forKey: Key("Reason"))
        }
        if let roleUsageList = roleUsageList {
            var roleUsageListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RoleUsageList"))
            for (index0, roleusagetype0) in roleUsageList.enumerated() {
                try roleUsageListContainer.encode(roleusagetype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        if containerValues.contains(.roleUsageList) {
            struct KeyVal0{struct member{}}
            let roleUsageListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roleUsageList)
            if let roleUsageListWrappedContainer = roleUsageListWrappedContainer {
                let roleUsageListContainer = try roleUsageListWrappedContainer.decodeIfPresent([RoleUsageType].self, forKey: .member)
                var roleUsageListBuffer:[RoleUsageType]? = nil
                if let roleUsageListContainer = roleUsageListContainer {
                    roleUsageListBuffer = [RoleUsageType]()
                    for structureContainer0 in roleUsageListContainer {
                        roleUsageListBuffer?.append(structureContainer0)
                    }
                }
                roleUsageList = roleUsageListBuffer
            } else {
                roleUsageList = []
            }
        } else {
            roleUsageList = nil
        }
    }
}

extension DeletionTaskFailureReasonType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletionTaskFailureReasonType(reason: \(String(describing: reason)), roleUsageList: \(String(describing: roleUsageList)))"}
}

/// <p>The reason that the service-linked role deletion failed.</p>
///          <p>This data type is used as a response element in the <a>GetServiceLinkedRoleDeletionStatus</a> operation.</p>
public struct DeletionTaskFailureReasonType: Equatable {
    /// <p>A short description of the reason that the service-linked role deletion failed.</p>
    public let reason: String?
    /// <p>A list of objects that contains details about the service-linked role deletion failure,
    ///          if that information is returned by the service. If the service-linked role has active
    ///          sessions or if any resources that were used by the role have not been deleted from the
    ///          linked service, the role can't be deleted. This parameter includes a list of the resources
    ///          that are associated with the role and the Region in which the resources are being
    ///          used.</p>
    public let roleUsageList: [RoleUsageType]?

    public init (
        reason: String? = nil,
        roleUsageList: [RoleUsageType]? = nil
    )
    {
        self.reason = reason
        self.roleUsageList = roleUsageList
    }
}

public enum DeletionTaskStatusType {
    case failed
    case inProgress
    case notStarted
    case succeeded
    case sdkUnknown(String)
}

extension DeletionTaskStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeletionTaskStatusType] {
        return [
            .failed,
            .inProgress,
            .notStarted,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .notStarted: return "NOT_STARTED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeletionTaskStatusType(rawValue: rawValue) ?? DeletionTaskStatusType.sdkUnknown(rawValue)
    }
}

public struct DetachGroupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DetachGroupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachGroupPolicyInput>
    public typealias MOutput = OperationOutput<DetachGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachGroupPolicyOutputError>
}

extension DetachGroupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachGroupPolicyInput(groupName: \(String(describing: groupName)), policyArn: \(String(describing: policyArn)))"}
}

extension DetachGroupPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        try container.encode("DetachGroupPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DetachGroupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DetachGroupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachGroupPolicyInput>
    public typealias MOutput = OperationOutput<DetachGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachGroupPolicyOutputError>
}

public struct DetachGroupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachGroupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachGroupPolicyInput>
    public typealias MOutput = OperationOutput<DetachGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachGroupPolicyOutputError>
}

public struct DetachGroupPolicyInput: Equatable {
    /// <p>The name (friendly name, not ARN) of the IAM group to detach the policy from.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?

    public init (
        groupName: String? = nil,
        policyArn: String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

extension DetachGroupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachGroupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachGroupPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachGroupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachGroupPolicyOutputResponse()"}
}

extension DetachGroupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachGroupPolicyOutputResponse: Equatable {

    public init() {}
}

struct DetachGroupPolicyOutputResponseBody: Equatable {
}

extension DetachGroupPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DetachRolePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DetachRolePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachRolePolicyInput>
    public typealias MOutput = OperationOutput<DetachRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachRolePolicyOutputError>
}

extension DetachRolePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachRolePolicyInput(policyArn: \(String(describing: policyArn)), roleName: \(String(describing: roleName)))"}
}

extension DetachRolePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("DetachRolePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DetachRolePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DetachRolePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachRolePolicyInput>
    public typealias MOutput = OperationOutput<DetachRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachRolePolicyOutputError>
}

public struct DetachRolePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachRolePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachRolePolicyInput>
    public typealias MOutput = OperationOutput<DetachRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachRolePolicyOutputError>
}

public struct DetachRolePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The name (friendly name, not ARN) of the IAM role to detach the policy from.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        policyArn: String? = nil,
        roleName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

extension DetachRolePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachRolePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachRolePolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachRolePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachRolePolicyOutputResponse()"}
}

extension DetachRolePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachRolePolicyOutputResponse: Equatable {

    public init() {}
}

struct DetachRolePolicyOutputResponseBody: Equatable {
}

extension DetachRolePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DetachUserPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DetachUserPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachUserPolicyInput>
    public typealias MOutput = OperationOutput<DetachUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachUserPolicyOutputError>
}

extension DetachUserPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachUserPolicyInput(policyArn: \(String(describing: policyArn)), userName: \(String(describing: userName)))"}
}

extension DetachUserPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("DetachUserPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct DetachUserPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DetachUserPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachUserPolicyInput>
    public typealias MOutput = OperationOutput<DetachUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachUserPolicyOutputError>
}

public struct DetachUserPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachUserPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachUserPolicyInput>
    public typealias MOutput = OperationOutput<DetachUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachUserPolicyOutputError>
}

public struct DetachUserPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The name (friendly name, not ARN) of the IAM user to detach the policy from.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        policyArn: String? = nil,
        userName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

extension DetachUserPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachUserPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachUserPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachUserPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachUserPolicyOutputResponse()"}
}

extension DetachUserPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachUserPolicyOutputResponse: Equatable {

    public init() {}
}

struct DetachUserPolicyOutputResponseBody: Equatable {
}

extension DetachUserPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DuplicateCertificateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateCertificateException(message: \(String(describing: message)))"}
}

extension DuplicateCertificateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateCertificateExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the same certificate is associated with an IAM user in
///       the account.</p>
public struct DuplicateCertificateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateCertificateExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateCertificateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateSSHPublicKeyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateSSHPublicKeyException(message: \(String(describing: message)))"}
}

extension DuplicateSSHPublicKeyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateSSHPublicKeyExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the SSH public key is already associated with the
///       specified IAM user.</p>
public struct DuplicateSSHPublicKeyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateSSHPublicKeyExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateSSHPublicKeyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct EnableMFADeviceInputBodyMiddleware: Middleware {
    public let id: String = "EnableMFADeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableMFADeviceInput>
    public typealias MOutput = OperationOutput<EnableMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableMFADeviceOutputError>
}

extension EnableMFADeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableMFADeviceInput(authenticationCode1: \(String(describing: authenticationCode1)), authenticationCode2: \(String(describing: authenticationCode2)), serialNumber: \(String(describing: serialNumber)), userName: \(String(describing: userName)))"}
}

extension EnableMFADeviceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("EnableMFADevice", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct EnableMFADeviceInputHeadersMiddleware: Middleware {
    public let id: String = "EnableMFADeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableMFADeviceInput>
    public typealias MOutput = OperationOutput<EnableMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableMFADeviceOutputError>
}

public struct EnableMFADeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableMFADeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableMFADeviceInput>
    public typealias MOutput = OperationOutput<EnableMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableMFADeviceOutputError>
}

public struct EnableMFADeviceInput: Equatable {
    /// <p>An authentication code emitted by the device. </p>
    ///         <p>The format for this parameter is a string of six digits.</p>
    ///         <important>
    ///             <p>Submit your request immediately after generating the authentication codes. If you
    ///                 generate the codes and then wait too long to submit the request, the MFA device
    ///                 successfully associates with the user but the MFA device becomes out of sync. This
    ///                 happens because time-based one-time passwords (TOTP) expire after a short period of
    ///                 time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
    ///                 device</a>.</p>
    ///         </important>
    public let authenticationCode1: String?
    /// <p>A subsequent authentication code emitted by the device.</p>
    ///         <p>The format for this parameter is a string of six digits.</p>
    ///         <important>
    ///             <p>Submit your request immediately after generating the authentication codes. If you
    ///                 generate the codes and then wait too long to submit the request, the MFA device
    ///                 successfully associates with the user but the MFA device becomes out of sync. This
    ///                 happens because time-based one-time passwords (TOTP) expire after a short period of
    ///                 time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
    ///                 device</a>.</p>
    ///         </important>
    public let authenticationCode2: String?
    /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
    ///             the serial number is the device ARN.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
    ///     following characters: =,.@:/-</p>
    public let serialNumber: String?
    /// <p>The name of the IAM user for whom you want to enable the MFA device.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        authenticationCode1: String? = nil,
        authenticationCode2: String? = nil,
        serialNumber: String? = nil,
        userName: String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension EnableMFADeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableMFADeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityTemporarilyUnmodifiableException" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthenticationCodeException" : self = .invalidAuthenticationCodeException(try InvalidAuthenticationCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableMFADeviceOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case invalidAuthenticationCodeException(InvalidAuthenticationCodeException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableMFADeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableMFADeviceOutputResponse()"}
}

extension EnableMFADeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableMFADeviceOutputResponse: Equatable {

    public init() {}
}

struct EnableMFADeviceOutputResponseBody: Equatable {
}

extension EnableMFADeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum EncodingType {
    case pem
    case ssh
    case sdkUnknown(String)
}

extension EncodingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncodingType] {
        return [
            .pem,
            .ssh,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pem: return "PEM"
        case .ssh: return "SSH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
    }
}

extension EntityAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityAlreadyExistsException(message: \(String(describing: message)))"}
}

extension EntityAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EntityAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to create a resource that already
///       exists.</p>
public struct EntityAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension EntityAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityInfo = "EntityInfo"
        case lastAuthenticated = "LastAuthenticated"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let entityInfo = entityInfo {
            try container.encode(entityInfo, forKey: Key("EntityInfo"))
        }
        if let lastAuthenticated = lastAuthenticated {
            try container.encode(TimestampWrapper(lastAuthenticated, format: .dateTime), forKey: Key("lastAuthenticated"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityInfoDecoded = try containerValues.decodeIfPresent(EntityInfo.self, forKey: .entityInfo)
        entityInfo = entityInfoDecoded
        let lastAuthenticatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAuthenticated)
        var lastAuthenticatedBuffer:Date? = nil
        if let lastAuthenticatedDecoded = lastAuthenticatedDecoded {
            lastAuthenticatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastAuthenticatedDecoded, format: .dateTime)
        }
        lastAuthenticated = lastAuthenticatedBuffer
    }
}

extension EntityDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityDetails(entityInfo: \(String(describing: entityInfo)), lastAuthenticated: \(String(describing: lastAuthenticated)))"}
}

/// <p>An object that contains details about when the IAM entities (users or roles) were last
///          used in an attempt to access the specified AWS service.</p>
///          <p>This data type is a response element in the <a>GetServiceLastAccessedDetailsWithEntities</a> operation.</p>
public struct EntityDetails: Equatable {
    /// <p>The <code>EntityInfo</code> object that contains details about the entity (user or
    ///          role).</p>
    public let entityInfo: EntityInfo?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the authenticated entity last attempted to access AWS. AWS does
    ///          not report unauthenticated requests.</p>
    ///          <p>This field is null if no IAM entities attempted to access the service within the
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let lastAuthenticated: Date?

    public init (
        entityInfo: EntityInfo? = nil,
        lastAuthenticated: Date? = nil
    )
    {
        self.entityInfo = entityInfo
        self.lastAuthenticated = lastAuthenticated
    }
}

extension EntityInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case path = "Path"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PolicyOwnerEntityType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
    }
}

extension EntityInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityInfo(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)), path: \(String(describing: path)), type: \(String(describing: type)))"}
}

/// <p>Contains details about the specified entity (user or role).</p>
///          <p>This data type is an element of the <a>EntityDetails</a> object.</p>
public struct EntityInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let arn: String?
    /// <p>The identifier of the entity (user or role).</p>
    public let id: String?
    /// <p>The name of the entity (user or role).</p>
    public let name: String?
    /// <p>The path to the entity (user or role). For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let path: String?
    /// <p>The type of entity (user or role).</p>
    public let type: PolicyOwnerEntityType?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        path: String? = nil,
        type: PolicyOwnerEntityType? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.path = path
        self.type = type
    }
}

extension EntityTemporarilyUnmodifiableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityTemporarilyUnmodifiableException(message: \(String(describing: message)))"}
}

extension EntityTemporarilyUnmodifiableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EntityTemporarilyUnmodifiableExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it referenced an entity that is temporarily unmodifiable,
///       such as a user name that was deleted and then recreated. The error indicates that the request
///       is likely to succeed if you try again after waiting several minutes. The error message
///       describes the entity.</p>
public struct EntityTemporarilyUnmodifiableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityTemporarilyUnmodifiableExceptionBody: Equatable {
    public let message: String?
}

extension EntityTemporarilyUnmodifiableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum EntityType {
    case awsmanagedpolicy
    case group
    case localmanagedpolicy
    case role
    case user
    case sdkUnknown(String)
}

extension EntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityType] {
        return [
            .awsmanagedpolicy,
            .group,
            .localmanagedpolicy,
            .role,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsmanagedpolicy: return "AWSManagedPolicy"
        case .group: return "Group"
        case .localmanagedpolicy: return "LocalManagedPolicy"
        case .role: return "Role"
        case .user: return "User"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
    }
}

extension ErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let code = code {
            try container.encode(code, forKey: Key("Code"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetails(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Contains information about the reason that the operation failed.</p>
///          <p>This data type is used as a response element in the <a>GetOrganizationsAccessReport</a>, <a>GetServiceLastAccessedDetails</a>, and <a>GetServiceLastAccessedDetailsWithEntities</a> operations.</p>
public struct ErrorDetails: Equatable {
    /// <p>The error code associated with the operation failure.</p>
    public let code: String?
    /// <p>Detailed information about the reason that the operation failed.</p>
    public let message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

extension EvaluationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evalActionName = "EvalActionName"
        case evalDecision = "EvalDecision"
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case organizationsDecisionDetail = "OrganizationsDecisionDetail"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
        case resourceSpecificResults = "ResourceSpecificResults"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let evalActionName = evalActionName {
            try container.encode(evalActionName, forKey: Key("EvalActionName"))
        }
        if let evalDecision = evalDecision {
            try container.encode(evalDecision, forKey: Key("EvalDecision"))
        }
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: Key(""))
            }
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            var matchedStatementsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MatchedStatements"))
            for (index0, statement0) in matchedStatements.enumerated() {
                try matchedStatementsContainer.encode(statement0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let missingContextValues = missingContextValues {
            var missingContextValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MissingContextValues"))
            for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                try missingContextValuesContainer.encode(contextkeynametype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let organizationsDecisionDetail = organizationsDecisionDetail {
            try container.encode(organizationsDecisionDetail, forKey: Key("OrganizationsDecisionDetail"))
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: Key("PermissionsBoundaryDecisionDetail"))
        }
        if let resourceSpecificResults = resourceSpecificResults {
            var resourceSpecificResultsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceSpecificResults"))
            for (index0, resourcespecificresult0) in resourceSpecificResults.enumerated() {
                try resourceSpecificResultsContainer.encode(resourcespecificresult0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evalActionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evalActionName)
        evalActionName = evalActionNameDecoded
        let evalResourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evalResourceName)
        evalResourceName = evalResourceNameDecoded
        let evalDecisionDecoded = try containerValues.decodeIfPresent(PolicyEvaluationDecisionType.self, forKey: .evalDecision)
        evalDecision = evalDecisionDecoded
        if containerValues.contains(.matchedStatements) {
            struct KeyVal0{struct member{}}
            let matchedStatementsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchedStatements)
            if let matchedStatementsWrappedContainer = matchedStatementsWrappedContainer {
                let matchedStatementsContainer = try matchedStatementsWrappedContainer.decodeIfPresent([Statement].self, forKey: .member)
                var matchedStatementsBuffer:[Statement]? = nil
                if let matchedStatementsContainer = matchedStatementsContainer {
                    matchedStatementsBuffer = [Statement]()
                    for structureContainer0 in matchedStatementsContainer {
                        matchedStatementsBuffer?.append(structureContainer0)
                    }
                }
                matchedStatements = matchedStatementsBuffer
            } else {
                matchedStatements = []
            }
        } else {
            matchedStatements = nil
        }
        if containerValues.contains(.missingContextValues) {
            struct KeyVal0{struct member{}}
            let missingContextValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .missingContextValues)
            if let missingContextValuesWrappedContainer = missingContextValuesWrappedContainer {
                let missingContextValuesContainer = try missingContextValuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var missingContextValuesBuffer:[String]? = nil
                if let missingContextValuesContainer = missingContextValuesContainer {
                    missingContextValuesBuffer = [String]()
                    for stringContainer0 in missingContextValuesContainer {
                        missingContextValuesBuffer?.append(stringContainer0)
                    }
                }
                missingContextValues = missingContextValuesBuffer
            } else {
                missingContextValues = []
            }
        } else {
            missingContextValues = nil
        }
        let organizationsDecisionDetailDecoded = try containerValues.decodeIfPresent(OrganizationsDecisionDetail.self, forKey: .organizationsDecisionDetail)
        organizationsDecisionDetail = organizationsDecisionDetailDecoded
        let permissionsBoundaryDecisionDetailDecoded = try containerValues.decodeIfPresent(PermissionsBoundaryDecisionDetail.self, forKey: .permissionsBoundaryDecisionDetail)
        permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetailDecoded
        if containerValues.contains(.evalDecisionDetails) {
            struct KeyVal0{struct key{}; struct value{}}
            let evalDecisionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .evalDecisionDetails)
            if let evalDecisionDetailsWrappedContainer = evalDecisionDetailsWrappedContainer {
                let evalDecisionDetailsContainer = try evalDecisionDetailsWrappedContainer.decodeIfPresent([MapKeyValue<String, PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var evalDecisionDetailsBuffer: [String:PolicyEvaluationDecisionType]? = nil
                if let evalDecisionDetailsContainer = evalDecisionDetailsContainer {
                    evalDecisionDetailsBuffer = [String:PolicyEvaluationDecisionType]()
                    for stringContainer0 in evalDecisionDetailsContainer {
                        evalDecisionDetailsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                evalDecisionDetails = evalDecisionDetailsBuffer
            } else {
                evalDecisionDetails = [:]
            }
        } else {
            evalDecisionDetails = nil
        }
        if containerValues.contains(.resourceSpecificResults) {
            struct KeyVal0{struct member{}}
            let resourceSpecificResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceSpecificResults)
            if let resourceSpecificResultsWrappedContainer = resourceSpecificResultsWrappedContainer {
                let resourceSpecificResultsContainer = try resourceSpecificResultsWrappedContainer.decodeIfPresent([ResourceSpecificResult].self, forKey: .member)
                var resourceSpecificResultsBuffer:[ResourceSpecificResult]? = nil
                if let resourceSpecificResultsContainer = resourceSpecificResultsContainer {
                    resourceSpecificResultsBuffer = [ResourceSpecificResult]()
                    for structureContainer0 in resourceSpecificResultsContainer {
                        resourceSpecificResultsBuffer?.append(structureContainer0)
                    }
                }
                resourceSpecificResults = resourceSpecificResultsBuffer
            } else {
                resourceSpecificResults = []
            }
        } else {
            resourceSpecificResults = nil
        }
    }
}

extension EvaluationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationResult(evalActionName: \(String(describing: evalActionName)), evalDecision: \(String(describing: evalDecision)), evalDecisionDetails: \(String(describing: evalDecisionDetails)), evalResourceName: \(String(describing: evalResourceName)), matchedStatements: \(String(describing: matchedStatements)), missingContextValues: \(String(describing: missingContextValues)), organizationsDecisionDetail: \(String(describing: organizationsDecisionDetail)), permissionsBoundaryDecisionDetail: \(String(describing: permissionsBoundaryDecisionDetail)), resourceSpecificResults: \(String(describing: resourceSpecificResults)))"}
}

/// <p>Contains the results of a simulation.</p>
///          <p>This data type is used by the return parameter of <code>
///                <a>SimulateCustomPolicy</a>
///             </code> and <code>
///                <a>SimulatePrincipalPolicy</a>
///             </code>.</p>
public struct EvaluationResult: Equatable {
    /// <p>The name of the API operation tested on the indicated resource.</p>
    public let evalActionName: String?
    /// <p>The result of the simulation.</p>
    public let evalDecision: PolicyEvaluationDecisionType?
    /// <p>Additional details about the results of the cross-account evaluation decision. This
    ///          parameter is populated for only cross-account simulations. It contains a brief summary of
    ///          how each policy type contributes to the final evaluation decision.</p>
    ///          <p>If the simulation evaluates policies within the same account and includes a resource
    ///          ARN, then the parameter is present but the response is empty. If the simulation evaluates
    ///          policies within the same account and specifies all resources (<code>*</code>), then the
    ///          parameter is not returned.</p>
    ///          <p>When you make a cross-account request, AWS evaluates the request in the trusting
    ///          account and the trusted account. The request is allowed only if both evaluations return
    ///             <code>true</code>. For more information about how policies are evaluated, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html#policy-eval-basics">Evaluating policies within a single account</a>.</p>
    ///          <p>If an AWS Organizations SCP included in the evaluation denies access, the simulation ends. In
    ///          this case, policy evaluation does not proceed any further and this parameter is not
    ///          returned.</p>
    public let evalDecisionDetails: [String:PolicyEvaluationDecisionType]?
    /// <p>The ARN of the resource that the indicated API operation was tested on.</p>
    public let evalResourceName: String?
    /// <p>A list of the statements in the input policies that determine the result for this
    ///          scenario. Remember that even if multiple statements allow the operation on the resource, if
    ///          only one statement denies that operation, then the explicit deny overrides any allow. In
    ///          addition, the deny statement is the only entry included in the result.</p>
    public let matchedStatements: [Statement]?
    /// <p>A list of context keys that are required by the included input policies but that were
    ///          not provided by one of the input parameters. This list is used when the resource in a
    ///          simulation is "*", either explicitly, or when the <code>ResourceArns</code> parameter
    ///          blank. If you include a list of resources, then any missing context values are instead
    ///          included under the <code>ResourceSpecificResults</code> section. To discover the context
    ///          keys used by a set of policies, you can call <a>GetContextKeysForCustomPolicy</a> or <a>GetContextKeysForPrincipalPolicy</a>.</p>
    public let missingContextValues: [String]?
    /// <p>A structure that details how Organizations and its service control policies affect the results of
    ///          the simulation. Only applies if the simulated user's account is part of an
    ///          organization.</p>
    public let organizationsDecisionDetail: OrganizationsDecisionDetail?
    /// <p>Contains information about the effect that a permissions boundary has on a policy
    ///          simulation when the boundary is applied to an IAM entity.</p>
    public let permissionsBoundaryDecisionDetail: PermissionsBoundaryDecisionDetail?
    /// <p>The individual results of the simulation of the API operation specified in
    ///          EvalActionName on each resource.</p>
    public let resourceSpecificResults: [ResourceSpecificResult]?

    public init (
        evalActionName: String? = nil,
        evalDecision: PolicyEvaluationDecisionType? = nil,
        evalDecisionDetails: [String:PolicyEvaluationDecisionType]? = nil,
        evalResourceName: String? = nil,
        matchedStatements: [Statement]? = nil,
        missingContextValues: [String]? = nil,
        organizationsDecisionDetail: OrganizationsDecisionDetail? = nil,
        permissionsBoundaryDecisionDetail: PermissionsBoundaryDecisionDetail? = nil,
        resourceSpecificResults: [ResourceSpecificResult]? = nil
    )
    {
        self.evalActionName = evalActionName
        self.evalDecision = evalDecision
        self.evalDecisionDetails = evalDecisionDetails
        self.evalResourceName = evalResourceName
        self.matchedStatements = matchedStatements
        self.missingContextValues = missingContextValues
        self.organizationsDecisionDetail = organizationsDecisionDetail
        self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
        self.resourceSpecificResults = resourceSpecificResults
    }
}

public struct GenerateCredentialReportInputBodyMiddleware: Middleware {
    public let id: String = "GenerateCredentialReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateCredentialReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateCredentialReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateCredentialReportInput>
    public typealias MOutput = OperationOutput<GenerateCredentialReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateCredentialReportOutputError>
}

extension GenerateCredentialReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateCredentialReportInput()"}
}

extension GenerateCredentialReportInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GenerateCredentialReport", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GenerateCredentialReportInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateCredentialReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateCredentialReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateCredentialReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateCredentialReportInput>
    public typealias MOutput = OperationOutput<GenerateCredentialReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateCredentialReportOutputError>
}

public struct GenerateCredentialReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateCredentialReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateCredentialReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateCredentialReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateCredentialReportInput>
    public typealias MOutput = OperationOutput<GenerateCredentialReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateCredentialReportOutputError>
}

public struct GenerateCredentialReportInput: Equatable {

    public init() {}
}

extension GenerateCredentialReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GenerateCredentialReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateCredentialReportOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateCredentialReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateCredentialReportOutputResponse(description: \(String(describing: description)), state: \(String(describing: state)))"}
}

extension GenerateCredentialReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateCredentialReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.state = output.state
        } else {
            self.description = nil
            self.state = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GenerateCredentialReport</a>
///       request. </p>
public struct GenerateCredentialReportOutputResponse: Equatable {
    /// <p>Information about the credential report.</p>
    public let description: String?
    /// <p>Information about the state of the credential report.</p>
    public let state: ReportStateType?

    public init (
        description: String? = nil,
        state: ReportStateType? = nil
    )
    {
        self.description = description
        self.state = state
    }
}

struct GenerateCredentialReportOutputResponseBody: Equatable {
    public let state: ReportStateType?
    public let description: String?
}

extension GenerateCredentialReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GenerateCredentialReportResult"))
        let stateDecoded = try containerValues.decodeIfPresent(ReportStateType.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct GenerateOrganizationsAccessReportInputBodyMiddleware: Middleware {
    public let id: String = "GenerateOrganizationsAccessReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateOrganizationsAccessReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateOrganizationsAccessReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateOrganizationsAccessReportInput>
    public typealias MOutput = OperationOutput<GenerateOrganizationsAccessReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateOrganizationsAccessReportOutputError>
}

extension GenerateOrganizationsAccessReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateOrganizationsAccessReportInput(entityPath: \(String(describing: entityPath)), organizationsPolicyId: \(String(describing: organizationsPolicyId)))"}
}

extension GenerateOrganizationsAccessReportInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: Key("EntityPath"))
        }
        if let organizationsPolicyId = organizationsPolicyId {
            try container.encode(organizationsPolicyId, forKey: Key("OrganizationsPolicyId"))
        }
        try container.encode("GenerateOrganizationsAccessReport", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GenerateOrganizationsAccessReportInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateOrganizationsAccessReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateOrganizationsAccessReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateOrganizationsAccessReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateOrganizationsAccessReportInput>
    public typealias MOutput = OperationOutput<GenerateOrganizationsAccessReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateOrganizationsAccessReportOutputError>
}

public struct GenerateOrganizationsAccessReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateOrganizationsAccessReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateOrganizationsAccessReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateOrganizationsAccessReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateOrganizationsAccessReportInput>
    public typealias MOutput = OperationOutput<GenerateOrganizationsAccessReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateOrganizationsAccessReportOutputError>
}

public struct GenerateOrganizationsAccessReportInput: Equatable {
    /// <p>The path of the AWS Organizations entity (root, OU, or account). You can build an entity path using
    ///             the known structure of your organization. For example, assume that your account ID is
    ///                 <code>123456789012</code> and its parent OU ID is <code>ou-rge0-awsabcde</code>. The
    ///             organization root ID is <code>r-f6g7h8i9j0example</code> and your organization ID is
    ///                 <code>o-a1b2c3d4e5</code>. Your entity path is
    ///                 <code>o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012</code>.</p>
    public let entityPath: String?
    /// <p>The identifier of the AWS Organizations service control policy (SCP). This parameter is
    ///             optional.</p>
    ///         <p>This ID is used to generate information about when an account principal that is
    ///             limited by the SCP attempted to access an AWS service.</p>
    public let organizationsPolicyId: String?

    public init (
        entityPath: String? = nil,
        organizationsPolicyId: String? = nil
    )
    {
        self.entityPath = entityPath
        self.organizationsPolicyId = organizationsPolicyId
    }
}

extension GenerateOrganizationsAccessReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GenerateOrganizationsAccessReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ReportGenerationLimitExceededException" : self = .reportGenerationLimitExceededException(try ReportGenerationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateOrganizationsAccessReportOutputError: Equatable {
    case reportGenerationLimitExceededException(ReportGenerationLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateOrganizationsAccessReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateOrganizationsAccessReportOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension GenerateOrganizationsAccessReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateOrganizationsAccessReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct GenerateOrganizationsAccessReportOutputResponse: Equatable {
    /// <p>The job identifier that you can use in the <a>GetOrganizationsAccessReport</a> operation.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GenerateOrganizationsAccessReportOutputResponseBody: Equatable {
    public let jobId: String?
}

extension GenerateOrganizationsAccessReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GenerateOrganizationsAccessReportResult"))
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct GenerateServiceLastAccessedDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GenerateServiceLastAccessedDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateServiceLastAccessedDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateServiceLastAccessedDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateServiceLastAccessedDetailsInput>
    public typealias MOutput = OperationOutput<GenerateServiceLastAccessedDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateServiceLastAccessedDetailsOutputError>
}

extension GenerateServiceLastAccessedDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateServiceLastAccessedDetailsInput(arn: \(String(describing: arn)), granularity: \(String(describing: granularity)))"}
}

extension GenerateServiceLastAccessedDetailsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let granularity = granularity {
            try container.encode(granularity, forKey: Key("Granularity"))
        }
        try container.encode("GenerateServiceLastAccessedDetails", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GenerateServiceLastAccessedDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateServiceLastAccessedDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateServiceLastAccessedDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateServiceLastAccessedDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateServiceLastAccessedDetailsInput>
    public typealias MOutput = OperationOutput<GenerateServiceLastAccessedDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateServiceLastAccessedDetailsOutputError>
}

public struct GenerateServiceLastAccessedDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateServiceLastAccessedDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateServiceLastAccessedDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateServiceLastAccessedDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateServiceLastAccessedDetailsInput>
    public typealias MOutput = OperationOutput<GenerateServiceLastAccessedDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateServiceLastAccessedDetailsOutputError>
}

public struct GenerateServiceLastAccessedDetailsInput: Equatable {
    /// <p>The ARN of the IAM resource (user, group, role, or managed policy) used to generate
    ///             information about when the resource was last used in an attempt to access an AWS
    ///             service.</p>
    public let arn: String?
    /// <p>The level of detail that you want to generate. You can specify whether you want to
    ///             generate information about the last attempt to access services or actions. If you
    ///             specify service-level granularity, this operation generates only service data. If you
    ///             specify action-level granularity, it generates service and action data. If you don't
    ///             include this optional parameter, the operation generates service data.</p>
    public let granularity: AccessAdvisorUsageGranularityType?

    public init (
        arn: String? = nil,
        granularity: AccessAdvisorUsageGranularityType? = nil
    )
    {
        self.arn = arn
        self.granularity = granularity
    }
}

extension GenerateServiceLastAccessedDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GenerateServiceLastAccessedDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateServiceLastAccessedDetailsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateServiceLastAccessedDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateServiceLastAccessedDetailsOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension GenerateServiceLastAccessedDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateServiceLastAccessedDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct GenerateServiceLastAccessedDetailsOutputResponse: Equatable {
    /// <p>The <code>JobId</code> that you can use in the <a>GetServiceLastAccessedDetails</a> or <a>GetServiceLastAccessedDetailsWithEntities</a> operations. The
    ///                 <code>JobId</code> returned by <code>GenerateServiceLastAccessedDetail</code> must
    ///             be used by the same role within a session, or by the same user when used to call
    ///                 <code>GetServiceLastAccessedDetail</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GenerateServiceLastAccessedDetailsOutputResponseBody: Equatable {
    public let jobId: String?
}

extension GenerateServiceLastAccessedDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GenerateServiceLastAccessedDetailsResult"))
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct GetAccessKeyLastUsedInputBodyMiddleware: Middleware {
    public let id: String = "GetAccessKeyLastUsedInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessKeyLastUsedInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessKeyLastUsedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessKeyLastUsedInput>
    public typealias MOutput = OperationOutput<GetAccessKeyLastUsedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessKeyLastUsedOutputError>
}

extension GetAccessKeyLastUsedInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessKeyLastUsedInput(accessKeyId: \(String(describing: accessKeyId)))"}
}

extension GetAccessKeyLastUsedInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: Key("AccessKeyId"))
        }
        try container.encode("GetAccessKeyLastUsed", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetAccessKeyLastUsedInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessKeyLastUsedInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessKeyLastUsedInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessKeyLastUsedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessKeyLastUsedInput>
    public typealias MOutput = OperationOutput<GetAccessKeyLastUsedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessKeyLastUsedOutputError>
}

public struct GetAccessKeyLastUsedInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessKeyLastUsedInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessKeyLastUsedInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessKeyLastUsedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessKeyLastUsedInput>
    public typealias MOutput = OperationOutput<GetAccessKeyLastUsedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessKeyLastUsedOutputError>
}

public struct GetAccessKeyLastUsedInput: Equatable {
    /// <p>The identifier of an access key.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let accessKeyId: String?

    public init (
        accessKeyId: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

extension GetAccessKeyLastUsedOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessKeyLastUsedOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessKeyLastUsedOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessKeyLastUsedOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessKeyLastUsedOutputResponse(accessKeyLastUsed: \(String(describing: accessKeyLastUsed)), userName: \(String(describing: userName)))"}
}

extension GetAccessKeyLastUsedOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessKeyLastUsedOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessKeyLastUsed = output.accessKeyLastUsed
            self.userName = output.userName
        } else {
            self.accessKeyLastUsed = nil
            self.userName = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetAccessKeyLastUsed</a> request.
///       It is also returned as a member of the <a>AccessKeyMetaData</a> structure returned
///       by the <a>ListAccessKeys</a> action.</p>
public struct GetAccessKeyLastUsedOutputResponse: Equatable {
    /// <p>Contains information about the last time the access key was used.</p>
    public let accessKeyLastUsed: AccessKeyLastUsed?
    /// <p>The name of the AWS IAM user that owns this access key.</p>
    ///         <p></p>
    public let userName: String?

    public init (
        accessKeyLastUsed: AccessKeyLastUsed? = nil,
        userName: String? = nil
    )
    {
        self.accessKeyLastUsed = accessKeyLastUsed
        self.userName = userName
    }
}

struct GetAccessKeyLastUsedOutputResponseBody: Equatable {
    public let userName: String?
    public let accessKeyLastUsed: AccessKeyLastUsed?
}

extension GetAccessKeyLastUsedOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessKeyLastUsed = "AccessKeyLastUsed"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetAccessKeyLastUsedResult"))
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyLastUsedDecoded = try containerValues.decodeIfPresent(AccessKeyLastUsed.self, forKey: .accessKeyLastUsed)
        accessKeyLastUsed = accessKeyLastUsedDecoded
    }
}

public struct GetAccountAuthorizationDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetAccountAuthorizationDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountAuthorizationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountAuthorizationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountAuthorizationDetailsInput>
    public typealias MOutput = OperationOutput<GetAccountAuthorizationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountAuthorizationDetailsOutputError>
}

extension GetAccountAuthorizationDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountAuthorizationDetailsInput(filter: \(String(describing: filter)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension GetAccountAuthorizationDetailsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filter = filter {
            var filterContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filter"))
            for (index0, entitytype0) in filter.enumerated() {
                try filterContainer.encode(entitytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        try container.encode("GetAccountAuthorizationDetails", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetAccountAuthorizationDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountAuthorizationDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountAuthorizationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountAuthorizationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountAuthorizationDetailsInput>
    public typealias MOutput = OperationOutput<GetAccountAuthorizationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountAuthorizationDetailsOutputError>
}

public struct GetAccountAuthorizationDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountAuthorizationDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountAuthorizationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountAuthorizationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountAuthorizationDetailsInput>
    public typealias MOutput = OperationOutput<GetAccountAuthorizationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountAuthorizationDetailsOutputError>
}

public struct GetAccountAuthorizationDetailsInput: Equatable {
    /// <p>A list of entity types used to filter the results. Only the entities that match the
    ///             types you specify are included in the output. Use the value
    ///                 <code>LocalManagedPolicy</code> to include customer managed policies.</p>
    ///         <p>The format for this parameter is a comma-separated (if more than one) list of strings.
    ///             Each string value in the list must be one of the valid values listed below.</p>
    public let filter: [EntityType]?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?

    public init (
        filter: [EntityType]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.filter = filter
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension GetAccountAuthorizationDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccountAuthorizationDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountAuthorizationDetailsOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountAuthorizationDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountAuthorizationDetailsOutputResponse(groupDetailList: \(String(describing: groupDetailList)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), policies: \(String(describing: policies)), roleDetailList: \(String(describing: roleDetailList)), userDetailList: \(String(describing: userDetailList)))"}
}

extension GetAccountAuthorizationDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountAuthorizationDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupDetailList = output.groupDetailList
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policies = output.policies
            self.roleDetailList = output.roleDetailList
            self.userDetailList = output.userDetailList
        } else {
            self.groupDetailList = nil
            self.isTruncated = false
            self.marker = nil
            self.policies = nil
            self.roleDetailList = nil
            self.userDetailList = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetAccountAuthorizationDetails</a>
///       request. </p>
public struct GetAccountAuthorizationDetailsOutputResponse: Equatable {
    /// <p>A list containing information about IAM groups.</p>
    public let groupDetailList: [GroupDetail]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list containing information about managed policies.</p>
    public let policies: [ManagedPolicyDetail]?
    /// <p>A list containing information about IAM roles.</p>
    public let roleDetailList: [RoleDetail]?
    /// <p>A list containing information about IAM users.</p>
    public let userDetailList: [UserDetail]?

    public init (
        groupDetailList: [GroupDetail]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil,
        policies: [ManagedPolicyDetail]? = nil,
        roleDetailList: [RoleDetail]? = nil,
        userDetailList: [UserDetail]? = nil
    )
    {
        self.groupDetailList = groupDetailList
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
        self.roleDetailList = roleDetailList
        self.userDetailList = userDetailList
    }
}

struct GetAccountAuthorizationDetailsOutputResponseBody: Equatable {
    public let userDetailList: [UserDetail]?
    public let groupDetailList: [GroupDetail]?
    public let roleDetailList: [RoleDetail]?
    public let policies: [ManagedPolicyDetail]?
    public let isTruncated: Bool
    public let marker: String?
}

extension GetAccountAuthorizationDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupDetailList = "GroupDetailList"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policies = "Policies"
        case roleDetailList = "RoleDetailList"
        case userDetailList = "UserDetailList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetAccountAuthorizationDetailsResult"))
        if containerValues.contains(.userDetailList) {
            struct KeyVal0{struct member{}}
            let userDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userDetailList)
            if let userDetailListWrappedContainer = userDetailListWrappedContainer {
                let userDetailListContainer = try userDetailListWrappedContainer.decodeIfPresent([UserDetail].self, forKey: .member)
                var userDetailListBuffer:[UserDetail]? = nil
                if let userDetailListContainer = userDetailListContainer {
                    userDetailListBuffer = [UserDetail]()
                    for structureContainer0 in userDetailListContainer {
                        userDetailListBuffer?.append(structureContainer0)
                    }
                }
                userDetailList = userDetailListBuffer
            } else {
                userDetailList = []
            }
        } else {
            userDetailList = nil
        }
        if containerValues.contains(.groupDetailList) {
            struct KeyVal0{struct member{}}
            let groupDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupDetailList)
            if let groupDetailListWrappedContainer = groupDetailListWrappedContainer {
                let groupDetailListContainer = try groupDetailListWrappedContainer.decodeIfPresent([GroupDetail].self, forKey: .member)
                var groupDetailListBuffer:[GroupDetail]? = nil
                if let groupDetailListContainer = groupDetailListContainer {
                    groupDetailListBuffer = [GroupDetail]()
                    for structureContainer0 in groupDetailListContainer {
                        groupDetailListBuffer?.append(structureContainer0)
                    }
                }
                groupDetailList = groupDetailListBuffer
            } else {
                groupDetailList = []
            }
        } else {
            groupDetailList = nil
        }
        if containerValues.contains(.roleDetailList) {
            struct KeyVal0{struct member{}}
            let roleDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roleDetailList)
            if let roleDetailListWrappedContainer = roleDetailListWrappedContainer {
                let roleDetailListContainer = try roleDetailListWrappedContainer.decodeIfPresent([RoleDetail].self, forKey: .member)
                var roleDetailListBuffer:[RoleDetail]? = nil
                if let roleDetailListContainer = roleDetailListContainer {
                    roleDetailListBuffer = [RoleDetail]()
                    for structureContainer0 in roleDetailListContainer {
                        roleDetailListBuffer?.append(structureContainer0)
                    }
                }
                roleDetailList = roleDetailListBuffer
            } else {
                roleDetailList = []
            }
        } else {
            roleDetailList = nil
        }
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([ManagedPolicyDetail].self, forKey: .member)
                var policiesBuffer:[ManagedPolicyDetail]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [ManagedPolicyDetail]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct GetAccountPasswordPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetAccountPasswordPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<GetAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountPasswordPolicyOutputError>
}

extension GetAccountPasswordPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountPasswordPolicyInput()"}
}

extension GetAccountPasswordPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetAccountPasswordPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetAccountPasswordPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountPasswordPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<GetAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountPasswordPolicyOutputError>
}

public struct GetAccountPasswordPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountPasswordPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<GetAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountPasswordPolicyOutputError>
}

public struct GetAccountPasswordPolicyInput: Equatable {

    public init() {}
}

extension GetAccountPasswordPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccountPasswordPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountPasswordPolicyOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountPasswordPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountPasswordPolicyOutputResponse(passwordPolicy: \(String(describing: passwordPolicy)))"}
}

extension GetAccountPasswordPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountPasswordPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.passwordPolicy = output.passwordPolicy
        } else {
            self.passwordPolicy = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetAccountPasswordPolicy</a>
///       request. </p>
public struct GetAccountPasswordPolicyOutputResponse: Equatable {
    /// <p>A structure that contains details about the account's password policy.</p>
    public let passwordPolicy: PasswordPolicy?

    public init (
        passwordPolicy: PasswordPolicy? = nil
    )
    {
        self.passwordPolicy = passwordPolicy
    }
}

struct GetAccountPasswordPolicyOutputResponseBody: Equatable {
    public let passwordPolicy: PasswordPolicy?
}

extension GetAccountPasswordPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case passwordPolicy = "PasswordPolicy"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetAccountPasswordPolicyResult"))
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(PasswordPolicy.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
    }
}

public struct GetAccountSummaryInputBodyMiddleware: Middleware {
    public let id: String = "GetAccountSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSummaryInput>
    public typealias MOutput = OperationOutput<GetAccountSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSummaryOutputError>
}

extension GetAccountSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSummaryInput()"}
}

extension GetAccountSummaryInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetAccountSummary", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetAccountSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSummaryInput>
    public typealias MOutput = OperationOutput<GetAccountSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSummaryOutputError>
}

public struct GetAccountSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSummaryInput>
    public typealias MOutput = OperationOutput<GetAccountSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSummaryOutputError>
}

public struct GetAccountSummaryInput: Equatable {

    public init() {}
}

extension GetAccountSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccountSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSummaryOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSummaryOutputResponse(summaryMap: \(String(describing: summaryMap)))"}
}

extension GetAccountSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summaryMap = output.summaryMap
        } else {
            self.summaryMap = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetAccountSummary</a> request.
///     </p>
public struct GetAccountSummaryOutputResponse: Equatable {
    /// <p>A set of key–value pairs containing information about IAM entity usage and
    ///             IAM quotas.</p>
    public let summaryMap: [String:Int]?

    public init (
        summaryMap: [String:Int]? = nil
    )
    {
        self.summaryMap = summaryMap
    }
}

struct GetAccountSummaryOutputResponseBody: Equatable {
    public let summaryMap: [String:Int]?
}

extension GetAccountSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summaryMap = "SummaryMap"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetAccountSummaryResult"))
        if containerValues.contains(.summaryMap) {
            struct KeyVal0{struct key{}; struct value{}}
            let summaryMapWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, Int, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .summaryMap)
            if let summaryMapWrappedContainer = summaryMapWrappedContainer {
                let summaryMapContainer = try summaryMapWrappedContainer.decodeIfPresent([MapKeyValue<String, Int, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var summaryMapBuffer: [String:Int]? = nil
                if let summaryMapContainer = summaryMapContainer {
                    summaryMapBuffer = [String:Int]()
                    for integerContainer0 in summaryMapContainer {
                        summaryMapBuffer?[integerContainer0.key] = integerContainer0.value
                    }
                }
                summaryMap = summaryMapBuffer
            } else {
                summaryMap = [:]
            }
        } else {
            summaryMap = nil
        }
    }
}

public struct GetContextKeysForCustomPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetContextKeysForCustomPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContextKeysForCustomPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContextKeysForCustomPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContextKeysForCustomPolicyInput>
    public typealias MOutput = OperationOutput<GetContextKeysForCustomPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContextKeysForCustomPolicyOutputError>
}

extension GetContextKeysForCustomPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContextKeysForCustomPolicyInput(policyInputList: \(String(describing: policyInputList)))"}
}

extension GetContextKeysForCustomPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyInputList = policyInputList {
            var policyInputListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyInputList"))
            for (index0, policydocumenttype0) in policyInputList.enumerated() {
                try policyInputListContainer.encode(policydocumenttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetContextKeysForCustomPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetContextKeysForCustomPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetContextKeysForCustomPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContextKeysForCustomPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContextKeysForCustomPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContextKeysForCustomPolicyInput>
    public typealias MOutput = OperationOutput<GetContextKeysForCustomPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContextKeysForCustomPolicyOutputError>
}

public struct GetContextKeysForCustomPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContextKeysForCustomPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContextKeysForCustomPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContextKeysForCustomPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContextKeysForCustomPolicyInput>
    public typealias MOutput = OperationOutput<GetContextKeysForCustomPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContextKeysForCustomPolicyOutputError>
}

public struct GetContextKeysForCustomPolicyInput: Equatable {
    /// <p>A list of policies for which you want the list of context keys referenced in those
    ///             policies. Each document is specified as a string containing the complete, valid JSON
    ///             text of an IAM policy.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyInputList: [String]?

    public init (
        policyInputList: [String]? = nil
    )
    {
        self.policyInputList = policyInputList
    }
}

extension GetContextKeysForCustomPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetContextKeysForCustomPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContextKeysForCustomPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContextKeysForCustomPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContextKeysForCustomPolicyOutputResponse(contextKeyNames: \(String(describing: contextKeyNames)))"}
}

extension GetContextKeysForCustomPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContextKeysForCustomPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contextKeyNames = output.contextKeyNames
        } else {
            self.contextKeyNames = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetContextKeysForPrincipalPolicy</a> or <a>GetContextKeysForCustomPolicy</a> request. </p>
public struct GetContextKeysForCustomPolicyOutputResponse: Equatable {
    /// <p>The list of context keys that are referenced in the input policies.</p>
    public let contextKeyNames: [String]?

    public init (
        contextKeyNames: [String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

struct GetContextKeysForCustomPolicyOutputResponseBody: Equatable {
    public let contextKeyNames: [String]?
}

extension GetContextKeysForCustomPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contextKeyNames = "ContextKeyNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetContextKeysForCustomPolicyResult"))
        if containerValues.contains(.contextKeyNames) {
            struct KeyVal0{struct member{}}
            let contextKeyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyNames)
            if let contextKeyNamesWrappedContainer = contextKeyNamesWrappedContainer {
                let contextKeyNamesContainer = try contextKeyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var contextKeyNamesBuffer:[String]? = nil
                if let contextKeyNamesContainer = contextKeyNamesContainer {
                    contextKeyNamesBuffer = [String]()
                    for stringContainer0 in contextKeyNamesContainer {
                        contextKeyNamesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyNames = contextKeyNamesBuffer
            } else {
                contextKeyNames = []
            }
        } else {
            contextKeyNames = nil
        }
    }
}

public struct GetContextKeysForPrincipalPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetContextKeysForPrincipalPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContextKeysForPrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContextKeysForPrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContextKeysForPrincipalPolicyInput>
    public typealias MOutput = OperationOutput<GetContextKeysForPrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContextKeysForPrincipalPolicyOutputError>
}

extension GetContextKeysForPrincipalPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContextKeysForPrincipalPolicyInput(policyInputList: \(String(describing: policyInputList)), policySourceArn: \(String(describing: policySourceArn)))"}
}

extension GetContextKeysForPrincipalPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyInputList = policyInputList {
            var policyInputListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyInputList"))
            for (index0, policydocumenttype0) in policyInputList.enumerated() {
                try policyInputListContainer.encode(policydocumenttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: Key("PolicySourceArn"))
        }
        try container.encode("GetContextKeysForPrincipalPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetContextKeysForPrincipalPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetContextKeysForPrincipalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContextKeysForPrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContextKeysForPrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContextKeysForPrincipalPolicyInput>
    public typealias MOutput = OperationOutput<GetContextKeysForPrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContextKeysForPrincipalPolicyOutputError>
}

public struct GetContextKeysForPrincipalPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContextKeysForPrincipalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContextKeysForPrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContextKeysForPrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContextKeysForPrincipalPolicyInput>
    public typealias MOutput = OperationOutput<GetContextKeysForPrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContextKeysForPrincipalPolicyOutputError>
}

public struct GetContextKeysForPrincipalPolicyInput: Equatable {
    /// <p>An optional list of additional policies for which you want the list of context keys
    ///             that are referenced.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyInputList: [String]?
    /// <p>The ARN of a user, group, or role whose policies contain the context keys that you
    ///             want listed. If you specify a user, the list includes context keys that are found in all
    ///             policies that are attached to the user. The list also includes all groups that the user
    ///             is a member of. If you pick a group or a role, then it includes only those context keys
    ///             that are found in policies attached to that entity. Note that all parameters are shown
    ///             in unencoded form here for clarity, but must be URL encoded to be included as a part of
    ///             a real HTML request.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policySourceArn: String?

    public init (
        policyInputList: [String]? = nil,
        policySourceArn: String? = nil
    )
    {
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
    }
}

extension GetContextKeysForPrincipalPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetContextKeysForPrincipalPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContextKeysForPrincipalPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContextKeysForPrincipalPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContextKeysForPrincipalPolicyOutputResponse(contextKeyNames: \(String(describing: contextKeyNames)))"}
}

extension GetContextKeysForPrincipalPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContextKeysForPrincipalPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contextKeyNames = output.contextKeyNames
        } else {
            self.contextKeyNames = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetContextKeysForPrincipalPolicy</a> or <a>GetContextKeysForCustomPolicy</a> request. </p>
public struct GetContextKeysForPrincipalPolicyOutputResponse: Equatable {
    /// <p>The list of context keys that are referenced in the input policies.</p>
    public let contextKeyNames: [String]?

    public init (
        contextKeyNames: [String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

struct GetContextKeysForPrincipalPolicyOutputResponseBody: Equatable {
    public let contextKeyNames: [String]?
}

extension GetContextKeysForPrincipalPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contextKeyNames = "ContextKeyNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetContextKeysForPrincipalPolicyResult"))
        if containerValues.contains(.contextKeyNames) {
            struct KeyVal0{struct member{}}
            let contextKeyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyNames)
            if let contextKeyNamesWrappedContainer = contextKeyNamesWrappedContainer {
                let contextKeyNamesContainer = try contextKeyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var contextKeyNamesBuffer:[String]? = nil
                if let contextKeyNamesContainer = contextKeyNamesContainer {
                    contextKeyNamesBuffer = [String]()
                    for stringContainer0 in contextKeyNamesContainer {
                        contextKeyNamesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyNames = contextKeyNamesBuffer
            } else {
                contextKeyNames = []
            }
        } else {
            contextKeyNames = nil
        }
    }
}

public struct GetCredentialReportInputBodyMiddleware: Middleware {
    public let id: String = "GetCredentialReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCredentialReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCredentialReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCredentialReportInput>
    public typealias MOutput = OperationOutput<GetCredentialReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCredentialReportOutputError>
}

extension GetCredentialReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCredentialReportInput()"}
}

extension GetCredentialReportInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetCredentialReport", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetCredentialReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetCredentialReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCredentialReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCredentialReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCredentialReportInput>
    public typealias MOutput = OperationOutput<GetCredentialReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCredentialReportOutputError>
}

public struct GetCredentialReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCredentialReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCredentialReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCredentialReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCredentialReportInput>
    public typealias MOutput = OperationOutput<GetCredentialReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCredentialReportOutputError>
}

public struct GetCredentialReportInput: Equatable {

    public init() {}
}

extension GetCredentialReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCredentialReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CredentialReportExpiredException" : self = .credentialReportExpiredException(try CredentialReportExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CredentialReportNotPresentException" : self = .credentialReportNotPresentException(try CredentialReportNotPresentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CredentialReportNotReadyException" : self = .credentialReportNotReadyException(try CredentialReportNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCredentialReportOutputError: Equatable {
    case credentialReportExpiredException(CredentialReportExpiredException)
    case credentialReportNotPresentException(CredentialReportNotPresentException)
    case credentialReportNotReadyException(CredentialReportNotReadyException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCredentialReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCredentialReportOutputResponse(content: \(String(describing: content)), generatedTime: \(String(describing: generatedTime)), reportFormat: \(String(describing: reportFormat)))"}
}

extension GetCredentialReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCredentialReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.content = output.content
            self.generatedTime = output.generatedTime
            self.reportFormat = output.reportFormat
        } else {
            self.content = nil
            self.generatedTime = nil
            self.reportFormat = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetCredentialReport</a> request.
///     </p>
public struct GetCredentialReportOutputResponse: Equatable {
    /// <p>Contains the credential report. The report is Base64-encoded.</p>
    public let content: Data?
    /// <p> The date and time when the credential report was created, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time format</a>.</p>
    public let generatedTime: Date?
    /// <p>The format (MIME type) of the credential report.</p>
    public let reportFormat: ReportFormatType?

    public init (
        content: Data? = nil,
        generatedTime: Date? = nil,
        reportFormat: ReportFormatType? = nil
    )
    {
        self.content = content
        self.generatedTime = generatedTime
        self.reportFormat = reportFormat
    }
}

struct GetCredentialReportOutputResponseBody: Equatable {
    public let content: Data?
    public let reportFormat: ReportFormatType?
    public let generatedTime: Date?
}

extension GetCredentialReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case generatedTime = "GeneratedTime"
        case reportFormat = "ReportFormat"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetCredentialReportResult"))
        if containerValues.contains(.content) {
            do {
                let contentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .content)
                content = contentDecoded
            } catch {
                content = "".data(using: .utf8)
            }
        } else {
            content = nil
        }
        let reportFormatDecoded = try containerValues.decodeIfPresent(ReportFormatType.self, forKey: .reportFormat)
        reportFormat = reportFormatDecoded
        let generatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generatedTime)
        var generatedTimeBuffer:Date? = nil
        if let generatedTimeDecoded = generatedTimeDecoded {
            generatedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(generatedTimeDecoded, format: .dateTime)
        }
        generatedTime = generatedTimeBuffer
    }
}

public struct GetGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

extension GetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupInput(groupName: \(String(describing: groupName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension GetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        try container.encode("GetGroup", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInput: Equatable {
    /// <p>The name of the group.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?

    public init (
        groupName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension GetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupOutputResponse(group: \(String(describing: group)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), users: \(String(describing: users)))"}
}

extension GetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.users = output.users
        } else {
            self.group = nil
            self.isTruncated = false
            self.marker = nil
            self.users = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetGroup</a> request. </p>
public struct GetGroupOutputResponse: Equatable {
    /// <p>A structure that contains details about the group.</p>
    public let group: Group?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of users in the group.</p>
    public let users: [User]?

    public init (
        group: Group? = nil,
        isTruncated: Bool = false,
        marker: String? = nil,
        users: [User]? = nil
    )
    {
        self.group = group
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

struct GetGroupOutputResponseBody: Equatable {
    public let group: Group?
    public let users: [User]?
    public let isTruncated: Bool
    public let marker: String?
}

extension GetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetGroupResult"))
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
        if containerValues.contains(.users) {
            struct KeyVal0{struct member{}}
            let usersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .users)
            if let usersWrappedContainer = usersWrappedContainer {
                let usersContainer = try usersWrappedContainer.decodeIfPresent([User].self, forKey: .member)
                var usersBuffer:[User]? = nil
                if let usersContainer = usersContainer {
                    usersBuffer = [User]()
                    for structureContainer0 in usersContainer {
                        usersBuffer?.append(structureContainer0)
                    }
                }
                users = usersBuffer
            } else {
                users = []
            }
        } else {
            users = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct GetGroupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupPolicyInput>
    public typealias MOutput = OperationOutput<GetGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupPolicyOutputError>
}

extension GetGroupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupPolicyInput(groupName: \(String(describing: groupName)), policyName: \(String(describing: policyName)))"}
}

extension GetGroupPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("GetGroupPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetGroupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupPolicyInput>
    public typealias MOutput = OperationOutput<GetGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupPolicyOutputError>
}

public struct GetGroupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupPolicyInput>
    public typealias MOutput = OperationOutput<GetGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupPolicyOutputError>
}

public struct GetGroupPolicyInput: Equatable {
    /// <p>The name of the group the policy is associated with.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>The name of the policy document to get.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?

    public init (
        groupName: String? = nil,
        policyName: String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

extension GetGroupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetGroupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupPolicyOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupPolicyOutputResponse(groupName: \(String(describing: groupName)), policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)))"}
}

extension GetGroupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupName = output.groupName
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
        } else {
            self.groupName = nil
            self.policyDocument = nil
            self.policyName = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetGroupPolicy</a> request.
///     </p>
public struct GetGroupPolicyOutputResponse: Equatable {
    /// <p>The group the policy is associated with.</p>
    public let groupName: String?
    /// <p>The policy document.</p>
    ///         <p>IAM stores policies in JSON format. However, resources that were created using AWS
    ///             CloudFormation templates can be formatted in YAML. AWS CloudFormation always converts
    ///             a YAML policy to JSON format before submitting it to IAM.</p>
    public let policyDocument: String?
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        groupName: String? = nil,
        policyDocument: String? = nil,
        policyName: String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

struct GetGroupPolicyOutputResponseBody: Equatable {
    public let groupName: String?
    public let policyName: String?
    public let policyDocument: String?
}

extension GetGroupPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetGroupPolicyResult"))
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

public struct GetInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "GetInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceProfileOutputError>
}

extension GetInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstanceProfileInput(instanceProfileName: \(String(describing: instanceProfileName)))"}
}

extension GetInstanceProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        try container.encode("GetInstanceProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInput: Equatable {
    /// <p>The name of the instance profile to get information about.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let instanceProfileName: String?

    public init (
        instanceProfileName: String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

extension GetInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstanceProfileOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstanceProfileOutputResponse(instanceProfile: \(String(describing: instanceProfile)))"}
}

extension GetInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetInstanceProfile</a> request.
///     </p>
public struct GetInstanceProfileOutputResponse: Equatable {
    /// <p>A structure containing details about the instance profile.</p>
    public let instanceProfile: InstanceProfile?

    public init (
        instanceProfile: InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct GetInstanceProfileOutputResponseBody: Equatable {
    public let instanceProfile: InstanceProfile?
}

extension GetInstanceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetInstanceProfileResult"))
        let instanceProfileDecoded = try containerValues.decodeIfPresent(InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct GetLoginProfileInputBodyMiddleware: Middleware {
    public let id: String = "GetLoginProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoginProfileInput>
    public typealias MOutput = OperationOutput<GetLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoginProfileOutputError>
}

extension GetLoginProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoginProfileInput(userName: \(String(describing: userName)))"}
}

extension GetLoginProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("GetLoginProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetLoginProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetLoginProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoginProfileInput>
    public typealias MOutput = OperationOutput<GetLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoginProfileOutputError>
}

public struct GetLoginProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLoginProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoginProfileInput>
    public typealias MOutput = OperationOutput<GetLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoginProfileOutputError>
}

public struct GetLoginProfileInput: Equatable {
    /// <p>The name of the user whose login profile you want to retrieve.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        userName: String? = nil
    )
    {
        self.userName = userName
    }
}

extension GetLoginProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetLoginProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLoginProfileOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoginProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoginProfileOutputResponse(loginProfile: \(String(describing: loginProfile)))"}
}

extension GetLoginProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLoginProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loginProfile = output.loginProfile
        } else {
            self.loginProfile = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetLoginProfile</a> request.
///     </p>
public struct GetLoginProfileOutputResponse: Equatable {
    /// <p>A structure containing the user name and password create date for the user.</p>
    public let loginProfile: LoginProfile?

    public init (
        loginProfile: LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

struct GetLoginProfileOutputResponseBody: Equatable {
    public let loginProfile: LoginProfile?
}

extension GetLoginProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loginProfile = "LoginProfile"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetLoginProfileResult"))
        let loginProfileDecoded = try containerValues.decodeIfPresent(LoginProfile.self, forKey: .loginProfile)
        loginProfile = loginProfileDecoded
    }
}

public struct GetOpenIDConnectProviderInputBodyMiddleware: Middleware {
    public let id: String = "GetOpenIDConnectProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<GetOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIDConnectProviderOutputError>
}

extension GetOpenIDConnectProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpenIDConnectProviderInput(openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)))"}
}

extension GetOpenIDConnectProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        try container.encode("GetOpenIDConnectProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetOpenIDConnectProviderInputHeadersMiddleware: Middleware {
    public let id: String = "GetOpenIDConnectProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<GetOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIDConnectProviderOutputError>
}

public struct GetOpenIDConnectProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOpenIDConnectProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<GetOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIDConnectProviderOutputError>
}

public struct GetOpenIDConnectProviderInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get
    ///             information for. You can get a list of OIDC provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let openIDConnectProviderArn: String?

    public init (
        openIDConnectProviderArn: String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension GetOpenIDConnectProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOpenIDConnectProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpenIDConnectProviderOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIDConnectProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpenIDConnectProviderOutputResponse(clientIDList: \(String(describing: clientIDList)), createDate: \(String(describing: createDate)), tags: \(String(describing: tags)), thumbprintList: \(String(describing: thumbprintList)), url: \(String(describing: url)))"}
}

extension GetOpenIDConnectProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOpenIDConnectProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientIDList = output.clientIDList
            self.createDate = output.createDate
            self.tags = output.tags
            self.thumbprintList = output.thumbprintList
            self.url = output.url
        } else {
            self.clientIDList = nil
            self.createDate = nil
            self.tags = nil
            self.thumbprintList = nil
            self.url = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetOpenIDConnectProvider</a>
///       request. </p>
public struct GetOpenIDConnectProviderOutputResponse: Equatable {
    /// <p>A list of client IDs (also known as audiences) that are associated with the specified
    ///             IAM OIDC provider resource object. For more information, see <a>CreateOpenIDConnectProvider</a>.</p>
    public let clientIDList: [String]?
    /// <p>The date and time when the IAM OIDC provider resource object was created in the
    ///             AWS account.</p>
    public let createDate: Date?
    /// <p>A list of tags that are attached to the specified IAM OIDC provider. The returned list of tags is sorted by tag key.
    ///       For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>A list of certificate thumbprints that are associated with the specified IAM OIDC
    ///             provider resource object. For more information, see <a>CreateOpenIDConnectProvider</a>. </p>
    public let thumbprintList: [String]?
    /// <p>The URL that the IAM OIDC provider resource object is associated with. For more
    ///             information, see <a>CreateOpenIDConnectProvider</a>.</p>
    public let url: String?

    public init (
        clientIDList: [String]? = nil,
        createDate: Date? = nil,
        tags: [Tag]? = nil,
        thumbprintList: [String]? = nil,
        url: String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.createDate = createDate
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

struct GetOpenIDConnectProviderOutputResponseBody: Equatable {
    public let url: String?
    public let clientIDList: [String]?
    public let thumbprintList: [String]?
    public let createDate: Date?
    public let tags: [Tag]?
}

extension GetOpenIDConnectProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientIDList = "ClientIDList"
        case createDate = "CreateDate"
        case tags = "Tags"
        case thumbprintList = "ThumbprintList"
        case url = "Url"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetOpenIDConnectProviderResult"))
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        if containerValues.contains(.clientIDList) {
            struct KeyVal0{struct member{}}
            let clientIDListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clientIDList)
            if let clientIDListWrappedContainer = clientIDListWrappedContainer {
                let clientIDListContainer = try clientIDListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var clientIDListBuffer:[String]? = nil
                if let clientIDListContainer = clientIDListContainer {
                    clientIDListBuffer = [String]()
                    for stringContainer0 in clientIDListContainer {
                        clientIDListBuffer?.append(stringContainer0)
                    }
                }
                clientIDList = clientIDListBuffer
            } else {
                clientIDList = []
            }
        } else {
            clientIDList = nil
        }
        if containerValues.contains(.thumbprintList) {
            struct KeyVal0{struct member{}}
            let thumbprintListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .thumbprintList)
            if let thumbprintListWrappedContainer = thumbprintListWrappedContainer {
                let thumbprintListContainer = try thumbprintListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var thumbprintListBuffer:[String]? = nil
                if let thumbprintListContainer = thumbprintListContainer {
                    thumbprintListBuffer = [String]()
                    for stringContainer0 in thumbprintListContainer {
                        thumbprintListBuffer?.append(stringContainer0)
                    }
                }
                thumbprintList = thumbprintListBuffer
            } else {
                thumbprintList = []
            }
        } else {
            thumbprintList = nil
        }
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

public struct GetOrganizationsAccessReportInputBodyMiddleware: Middleware {
    public let id: String = "GetOrganizationsAccessReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationsAccessReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationsAccessReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationsAccessReportInput>
    public typealias MOutput = OperationOutput<GetOrganizationsAccessReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationsAccessReportOutputError>
}

extension GetOrganizationsAccessReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationsAccessReportInput(jobId: \(String(describing: jobId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), sortKey: \(String(describing: sortKey)))"}
}

extension GetOrganizationsAccessReportInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let sortKey = sortKey {
            try container.encode(sortKey, forKey: Key("SortKey"))
        }
        try container.encode("GetOrganizationsAccessReport", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetOrganizationsAccessReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetOrganizationsAccessReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationsAccessReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationsAccessReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationsAccessReportInput>
    public typealias MOutput = OperationOutput<GetOrganizationsAccessReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationsAccessReportOutputError>
}

public struct GetOrganizationsAccessReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOrganizationsAccessReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationsAccessReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationsAccessReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationsAccessReportInput>
    public typealias MOutput = OperationOutput<GetOrganizationsAccessReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationsAccessReportOutputError>
}

public struct GetOrganizationsAccessReportInput: Equatable {
    /// <p>The identifier of the request generated by the <a>GenerateOrganizationsAccessReport</a> operation.</p>
    public let jobId: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The key that is used to sort the results. If you choose the namespace key, the results
    ///             are returned in alphabetical order. If you choose the time key, the results are sorted
    ///             numerically by the date and time.</p>
    public let sortKey: SortKeyType?

    public init (
        jobId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        sortKey: SortKeyType? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.sortKey = sortKey
    }
}

extension GetOrganizationsAccessReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOrganizationsAccessReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOrganizationsAccessReportOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationsAccessReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationsAccessReportOutputResponse(accessDetails: \(String(describing: accessDetails)), errorDetails: \(String(describing: errorDetails)), isTruncated: \(String(describing: isTruncated)), jobCompletionDate: \(String(describing: jobCompletionDate)), jobCreationDate: \(String(describing: jobCreationDate)), jobStatus: \(String(describing: jobStatus)), marker: \(String(describing: marker)), numberOfServicesAccessible: \(String(describing: numberOfServicesAccessible)), numberOfServicesNotAccessed: \(String(describing: numberOfServicesNotAccessed)))"}
}

extension GetOrganizationsAccessReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOrganizationsAccessReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessDetails = output.accessDetails
            self.errorDetails = output.errorDetails
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.marker = output.marker
            self.numberOfServicesAccessible = output.numberOfServicesAccessible
            self.numberOfServicesNotAccessed = output.numberOfServicesNotAccessed
        } else {
            self.accessDetails = nil
            self.errorDetails = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.marker = nil
            self.numberOfServicesAccessible = nil
            self.numberOfServicesNotAccessed = nil
        }
    }
}

public struct GetOrganizationsAccessReportOutputResponse: Equatable {
    /// <p>An object that contains details about the most recent attempt to access the
    ///             service.</p>
    public let accessDetails: [AccessDetail]?
    /// <p>Contains information about the reason that the operation failed.</p>
    ///          <p>This data type is used as a response element in the <a>GetOrganizationsAccessReport</a>, <a>GetServiceLastAccessedDetails</a>, and <a>GetServiceLastAccessedDetailsWithEntities</a> operations.</p>
    public let errorDetails: ErrorDetails?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///                 format</a>, when the generated report job was completed or failed.</p>
    ///         <p>This field is null if the job is still in progress, as indicated by a job status value
    ///             of <code>IN_PROGRESS</code>.</p>
    public let jobCompletionDate: Date?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///                 format</a>, when the report job was created.</p>
    public let jobCreationDate: Date?
    /// <p>The status of the job.</p>
    public let jobStatus: JobStatusType?
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The number of services that the applicable SCPs allow account principals to
    ///             access.</p>
    public let numberOfServicesAccessible: Int?
    /// <p>The number of services that account principals are allowed but did not attempt to
    ///             access.</p>
    public let numberOfServicesNotAccessed: Int?

    public init (
        accessDetails: [AccessDetail]? = nil,
        errorDetails: ErrorDetails? = nil,
        isTruncated: Bool = false,
        jobCompletionDate: Date? = nil,
        jobCreationDate: Date? = nil,
        jobStatus: JobStatusType? = nil,
        marker: String? = nil,
        numberOfServicesAccessible: Int? = nil,
        numberOfServicesNotAccessed: Int? = nil
    )
    {
        self.accessDetails = accessDetails
        self.errorDetails = errorDetails
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
        self.numberOfServicesAccessible = numberOfServicesAccessible
        self.numberOfServicesNotAccessed = numberOfServicesNotAccessed
    }
}

struct GetOrganizationsAccessReportOutputResponseBody: Equatable {
    public let jobStatus: JobStatusType?
    public let jobCreationDate: Date?
    public let jobCompletionDate: Date?
    public let numberOfServicesAccessible: Int?
    public let numberOfServicesNotAccessed: Int?
    public let accessDetails: [AccessDetail]?
    public let isTruncated: Bool
    public let marker: String?
    public let errorDetails: ErrorDetails?
}

extension GetOrganizationsAccessReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessDetails = "AccessDetails"
        case errorDetails = "ErrorDetails"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case marker = "Marker"
        case numberOfServicesAccessible = "NumberOfServicesAccessible"
        case numberOfServicesNotAccessed = "NumberOfServicesNotAccessed"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetOrganizationsAccessReportResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobCreationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCreationDate)
        var jobCreationDateBuffer:Date? = nil
        if let jobCreationDateDecoded = jobCreationDateDecoded {
            jobCreationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCreationDateDecoded, format: .dateTime)
        }
        jobCreationDate = jobCreationDateBuffer
        let jobCompletionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCompletionDate)
        var jobCompletionDateBuffer:Date? = nil
        if let jobCompletionDateDecoded = jobCompletionDateDecoded {
            jobCompletionDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCompletionDateDecoded, format: .dateTime)
        }
        jobCompletionDate = jobCompletionDateBuffer
        let numberOfServicesAccessibleDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfServicesAccessible)
        numberOfServicesAccessible = numberOfServicesAccessibleDecoded
        let numberOfServicesNotAccessedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfServicesNotAccessed)
        numberOfServicesNotAccessed = numberOfServicesNotAccessedDecoded
        if containerValues.contains(.accessDetails) {
            struct KeyVal0{struct member{}}
            let accessDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessDetails)
            if let accessDetailsWrappedContainer = accessDetailsWrappedContainer {
                let accessDetailsContainer = try accessDetailsWrappedContainer.decodeIfPresent([AccessDetail].self, forKey: .member)
                var accessDetailsBuffer:[AccessDetail]? = nil
                if let accessDetailsContainer = accessDetailsContainer {
                    accessDetailsBuffer = [AccessDetail]()
                    for structureContainer0 in accessDetailsContainer {
                        accessDetailsBuffer?.append(structureContainer0)
                    }
                }
                accessDetails = accessDetailsBuffer
            } else {
                accessDetails = []
            }
        } else {
            accessDetails = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

public struct GetPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

extension GetPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyInput(policyArn: \(String(describing: policyArn)))"}
}

extension GetPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        try container.encode("GetPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
    ///             about.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?

    public init (
        policyArn: String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

extension GetPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetPolicy</a> request. </p>
public struct GetPolicyOutputResponse: Equatable {
    /// <p>A structure containing details about the policy.</p>
    public let policy: Policy?

    public init (
        policy: Policy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetPolicyOutputResponseBody: Equatable {
    public let policy: Policy?
}

extension GetPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetPolicyResult"))
        let policyDecoded = try containerValues.decodeIfPresent(Policy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct GetPolicyVersionInputBodyMiddleware: Middleware {
    public let id: String = "GetPolicyVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyVersionInput>
    public typealias MOutput = OperationOutput<GetPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyVersionOutputError>
}

extension GetPolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyVersionInput(policyArn: \(String(describing: policyArn)), versionId: \(String(describing: versionId)))"}
}

extension GetPolicyVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
        try container.encode("GetPolicyVersion", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetPolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyVersionInput>
    public typealias MOutput = OperationOutput<GetPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyVersionOutputError>
}

public struct GetPolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyVersionInput>
    public typealias MOutput = OperationOutput<GetPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyVersionOutputError>
}

public struct GetPolicyVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
    ///             about.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>Identifies the policy version to retrieve.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
    ///     consists of the lowercase letter 'v' followed by one or two digits, and optionally
    ///     followed by a period '.' and a string of letters and digits.</p>
    public let versionId: String?

    public init (
        policyArn: String? = nil,
        versionId: String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

extension GetPolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyVersionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyVersionOutputResponse(policyVersion: \(String(describing: policyVersion)))"}
}

extension GetPolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyVersion = output.policyVersion
        } else {
            self.policyVersion = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetPolicyVersion</a> request.
///     </p>
public struct GetPolicyVersionOutputResponse: Equatable {
    /// <p>A structure containing details about the policy version.</p>
    public let policyVersion: PolicyVersion?

    public init (
        policyVersion: PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

struct GetPolicyVersionOutputResponseBody: Equatable {
    public let policyVersion: PolicyVersion?
}

extension GetPolicyVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyVersion = "PolicyVersion"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetPolicyVersionResult"))
        let policyVersionDecoded = try containerValues.decodeIfPresent(PolicyVersion.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
    }
}

public struct GetRoleInputBodyMiddleware: Middleware {
    public let id: String = "GetRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoleInput>
    public typealias MOutput = OperationOutput<GetRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoleOutputError>
}

extension GetRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoleInput(roleName: \(String(describing: roleName)))"}
}

extension GetRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("GetRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetRoleInputHeadersMiddleware: Middleware {
    public let id: String = "GetRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoleInput>
    public typealias MOutput = OperationOutput<GetRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoleOutputError>
}

public struct GetRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoleInput>
    public typealias MOutput = OperationOutput<GetRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoleOutputError>
}

public struct GetRoleInput: Equatable {
    /// <p>The name of the IAM role to get information about.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        roleName: String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension GetRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoleOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoleOutputResponse(role: \(String(describing: role)))"}
}

extension GetRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetRole</a> request. </p>
public struct GetRoleOutputResponse: Equatable {
    /// <p>A structure containing details about the IAM role.</p>
    public let role: Role?

    public init (
        role: Role? = nil
    )
    {
        self.role = role
    }
}

struct GetRoleOutputResponseBody: Equatable {
    public let role: Role?
}

extension GetRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case role = "Role"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(Role.self, forKey: .role)
        role = roleDecoded
    }
}

public struct GetRolePolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetRolePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRolePolicyInput>
    public typealias MOutput = OperationOutput<GetRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRolePolicyOutputError>
}

extension GetRolePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRolePolicyInput(policyName: \(String(describing: policyName)), roleName: \(String(describing: roleName)))"}
}

extension GetRolePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("GetRolePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetRolePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetRolePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRolePolicyInput>
    public typealias MOutput = OperationOutput<GetRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRolePolicyOutputError>
}

public struct GetRolePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRolePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRolePolicyInput>
    public typealias MOutput = OperationOutput<GetRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRolePolicyOutputError>
}

public struct GetRolePolicyInput: Equatable {
    /// <p>The name of the policy document to get.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?
    /// <p>The name of the role associated with the policy.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        policyName: String? = nil,
        roleName: String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

extension GetRolePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRolePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRolePolicyOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRolePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRolePolicyOutputResponse(policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), roleName: \(String(describing: roleName)))"}
}

extension GetRolePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRolePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.roleName = output.roleName
        } else {
            self.policyDocument = nil
            self.policyName = nil
            self.roleName = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetRolePolicy</a> request.
///     </p>
public struct GetRolePolicyOutputResponse: Equatable {
    /// <p>The policy document.</p>
    ///         <p>IAM stores policies in JSON format. However, resources that were created using AWS
    ///             CloudFormation templates can be formatted in YAML. AWS CloudFormation always converts
    ///             a YAML policy to JSON format before submitting it to IAM.</p>
    public let policyDocument: String?
    /// <p>The name of the policy.</p>
    public let policyName: String?
    /// <p>The role the policy is associated with.</p>
    public let roleName: String?

    public init (
        policyDocument: String? = nil,
        policyName: String? = nil,
        roleName: String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct GetRolePolicyOutputResponseBody: Equatable {
    public let roleName: String?
    public let policyName: String?
    public let policyDocument: String?
}

extension GetRolePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetRolePolicyResult"))
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

public struct GetSAMLProviderInputBodyMiddleware: Middleware {
    public let id: String = "GetSAMLProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSAMLProviderInput>
    public typealias MOutput = OperationOutput<GetSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSAMLProviderOutputError>
}

extension GetSAMLProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSAMLProviderInput(sAMLProviderArn: \(String(describing: sAMLProviderArn)))"}
}

extension GetSAMLProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sAMLProviderArn = sAMLProviderArn {
            try container.encode(sAMLProviderArn, forKey: Key("SAMLProviderArn"))
        }
        try container.encode("GetSAMLProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetSAMLProviderInputHeadersMiddleware: Middleware {
    public let id: String = "GetSAMLProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSAMLProviderInput>
    public typealias MOutput = OperationOutput<GetSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSAMLProviderOutputError>
}

public struct GetSAMLProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSAMLProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSAMLProviderInput>
    public typealias MOutput = OperationOutput<GetSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSAMLProviderOutputError>
}

public struct GetSAMLProviderInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get
    ///             information about.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let sAMLProviderArn: String?

    public init (
        sAMLProviderArn: String? = nil
    )
    {
        self.sAMLProviderArn = sAMLProviderArn
    }
}

extension GetSAMLProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSAMLProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSAMLProviderOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSAMLProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSAMLProviderOutputResponse(createDate: \(String(describing: createDate)), sAMLMetadataDocument: \(String(describing: sAMLMetadataDocument)), tags: \(String(describing: tags)), validUntil: \(String(describing: validUntil)))"}
}

extension GetSAMLProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSAMLProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createDate = output.createDate
            self.sAMLMetadataDocument = output.sAMLMetadataDocument
            self.tags = output.tags
            self.validUntil = output.validUntil
        } else {
            self.createDate = nil
            self.sAMLMetadataDocument = nil
            self.tags = nil
            self.validUntil = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetSAMLProvider</a> request.
///     </p>
public struct GetSAMLProviderOutputResponse: Equatable {
    /// <p>The date and time when the SAML provider was created.</p>
    public let createDate: Date?
    /// <p>The XML metadata document that includes information about an identity provider.</p>
    public let sAMLMetadataDocument: String?
    /// <p>A list of tags that are attached to the specified IAM SAML provider. The returned list of tags is sorted by tag key.
    ///       For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The expiration date and time for the SAML provider.</p>
    public let validUntil: Date?

    public init (
        createDate: Date? = nil,
        sAMLMetadataDocument: String? = nil,
        tags: [Tag]? = nil,
        validUntil: Date? = nil
    )
    {
        self.createDate = createDate
        self.sAMLMetadataDocument = sAMLMetadataDocument
        self.tags = tags
        self.validUntil = validUntil
    }
}

struct GetSAMLProviderOutputResponseBody: Equatable {
    public let sAMLMetadataDocument: String?
    public let createDate: Date?
    public let validUntil: Date?
    public let tags: [Tag]?
}

extension GetSAMLProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case sAMLMetadataDocument = "SAMLMetadataDocument"
        case tags = "Tags"
        case validUntil = "ValidUntil"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSAMLProviderResult"))
        let sAMLMetadataDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sAMLMetadataDocument)
        sAMLMetadataDocument = sAMLMetadataDocumentDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let validUntilDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validUntil)
        var validUntilBuffer:Date? = nil
        if let validUntilDecoded = validUntilDecoded {
            validUntilBuffer = try TimestampWrapperDecoder.parseDateStringValue(validUntilDecoded, format: .dateTime)
        }
        validUntil = validUntilBuffer
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

public struct GetSSHPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "GetSSHPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<GetSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSSHPublicKeyOutputError>
}

extension GetSSHPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSSHPublicKeyInput(encoding: \(String(describing: encoding)), sSHPublicKeyId: \(String(describing: sSHPublicKeyId)), userName: \(String(describing: userName)))"}
}

extension GetSSHPublicKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let encoding = encoding {
            try container.encode(encoding, forKey: Key("Encoding"))
        }
        if let sSHPublicKeyId = sSHPublicKeyId {
            try container.encode(sSHPublicKeyId, forKey: Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("GetSSHPublicKey", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetSSHPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GetSSHPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<GetSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSSHPublicKeyOutputError>
}

public struct GetSSHPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSSHPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<GetSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSSHPublicKeyOutputError>
}

public struct GetSSHPublicKeyInput: Equatable {
    /// <p>Specifies the public key encoding format to use in the response. To retrieve the
    ///             public key in ssh-rsa format, use <code>SSH</code>. To retrieve the public key in PEM
    ///             format, use <code>PEM</code>.</p>
    public let encoding: EncodingType?
    /// <p>The unique identifier for the SSH public key.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let sSHPublicKeyId: String?
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        encoding: EncodingType? = nil,
        sSHPublicKeyId: String? = nil,
        userName: String? = nil
    )
    {
        self.encoding = encoding
        self.sSHPublicKeyId = sSHPublicKeyId
        self.userName = userName
    }
}

extension GetSSHPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSSHPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnrecognizedPublicKeyEncodingException" : self = .unrecognizedPublicKeyEncodingException(try UnrecognizedPublicKeyEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSSHPublicKeyOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unrecognizedPublicKeyEncodingException(UnrecognizedPublicKeyEncodingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSSHPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSSHPublicKeyOutputResponse(sSHPublicKey: \(String(describing: sSHPublicKey)))"}
}

extension GetSSHPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSSHPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sSHPublicKey = output.sSHPublicKey
        } else {
            self.sSHPublicKey = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetSSHPublicKey</a>
///       request.</p>
public struct GetSSHPublicKeyOutputResponse: Equatable {
    /// <p>A structure containing details about the SSH public key.</p>
    public let sSHPublicKey: SSHPublicKey?

    public init (
        sSHPublicKey: SSHPublicKey? = nil
    )
    {
        self.sSHPublicKey = sSHPublicKey
    }
}

struct GetSSHPublicKeyOutputResponseBody: Equatable {
    public let sSHPublicKey: SSHPublicKey?
}

extension GetSSHPublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sSHPublicKey = "SSHPublicKey"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSSHPublicKeyResult"))
        let sSHPublicKeyDecoded = try containerValues.decodeIfPresent(SSHPublicKey.self, forKey: .sSHPublicKey)
        sSHPublicKey = sSHPublicKeyDecoded
    }
}

public struct GetServerCertificateInputBodyMiddleware: Middleware {
    public let id: String = "GetServerCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServerCertificateInput>
    public typealias MOutput = OperationOutput<GetServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServerCertificateOutputError>
}

extension GetServerCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServerCertificateInput(serverCertificateName: \(String(describing: serverCertificateName)))"}
}

extension GetServerCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        try container.encode("GetServerCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetServerCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "GetServerCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServerCertificateInput>
    public typealias MOutput = OperationOutput<GetServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServerCertificateOutputError>
}

public struct GetServerCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServerCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServerCertificateInput>
    public typealias MOutput = OperationOutput<GetServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServerCertificateOutputError>
}

public struct GetServerCertificateInput: Equatable {
    /// <p>The name of the server certificate you want to retrieve information about.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let serverCertificateName: String?

    public init (
        serverCertificateName: String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

extension GetServerCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServerCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServerCertificateOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServerCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServerCertificateOutputResponse(serverCertificate: \(String(describing: serverCertificate)))"}
}

extension GetServerCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServerCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverCertificate = output.serverCertificate
        } else {
            self.serverCertificate = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetServerCertificate</a> request.
///     </p>
public struct GetServerCertificateOutputResponse: Equatable {
    /// <p>A structure containing details about the server certificate.</p>
    public let serverCertificate: ServerCertificate?

    public init (
        serverCertificate: ServerCertificate? = nil
    )
    {
        self.serverCertificate = serverCertificate
    }
}

struct GetServerCertificateOutputResponseBody: Equatable {
    public let serverCertificate: ServerCertificate?
}

extension GetServerCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverCertificate = "ServerCertificate"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetServerCertificateResult"))
        let serverCertificateDecoded = try containerValues.decodeIfPresent(ServerCertificate.self, forKey: .serverCertificate)
        serverCertificate = serverCertificateDecoded
    }
}

public struct GetServiceLastAccessedDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceLastAccessedDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLastAccessedDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLastAccessedDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLastAccessedDetailsInput>
    public typealias MOutput = OperationOutput<GetServiceLastAccessedDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLastAccessedDetailsOutputError>
}

extension GetServiceLastAccessedDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceLastAccessedDetailsInput(jobId: \(String(describing: jobId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension GetServiceLastAccessedDetailsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        try container.encode("GetServiceLastAccessedDetails", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetServiceLastAccessedDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceLastAccessedDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLastAccessedDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLastAccessedDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLastAccessedDetailsInput>
    public typealias MOutput = OperationOutput<GetServiceLastAccessedDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLastAccessedDetailsOutputError>
}

public struct GetServiceLastAccessedDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceLastAccessedDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLastAccessedDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLastAccessedDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLastAccessedDetailsInput>
    public typealias MOutput = OperationOutput<GetServiceLastAccessedDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLastAccessedDetailsOutputError>
}

public struct GetServiceLastAccessedDetailsInput: Equatable {
    /// <p>The ID of the request generated by the <a>GenerateServiceLastAccessedDetails</a> operation. The <code>JobId</code>
    ///             returned by <code>GenerateServiceLastAccessedDetail</code> must be used by the same role
    ///             within a session, or by the same user when used to call
    ///                 <code>GetServiceLastAccessedDetail</code>.</p>
    public let jobId: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?

    public init (
        jobId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension GetServiceLastAccessedDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServiceLastAccessedDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceLastAccessedDetailsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceLastAccessedDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceLastAccessedDetailsOutputResponse(error: \(String(describing: error)), isTruncated: \(String(describing: isTruncated)), jobCompletionDate: \(String(describing: jobCompletionDate)), jobCreationDate: \(String(describing: jobCreationDate)), jobStatus: \(String(describing: jobStatus)), jobType: \(String(describing: jobType)), marker: \(String(describing: marker)), servicesLastAccessed: \(String(describing: servicesLastAccessed)))"}
}

extension GetServiceLastAccessedDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceLastAccessedDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.jobType = output.jobType
            self.marker = output.marker
            self.servicesLastAccessed = output.servicesLastAccessed
        } else {
            self.error = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.jobType = nil
            self.marker = nil
            self.servicesLastAccessed = nil
        }
    }
}

public struct GetServiceLastAccessedDetailsOutputResponse: Equatable {
    /// <p>An object that contains details about the reason the operation failed.</p>
    public let error: ErrorDetails?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///                 format</a>, when the generated report job was completed or failed.</p>
    ///         <p>This field is null if the job is still in progress, as indicated by a job status value
    ///             of <code>IN_PROGRESS</code>.</p>
    public let jobCompletionDate: Date?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///                 format</a>, when the report job was created.</p>
    public let jobCreationDate: Date?
    /// <p>The status of the job.</p>
    public let jobStatus: JobStatusType?
    /// <p>The type of job. Service jobs return information about when each service was last
    ///             accessed. Action jobs also include information about when tracked actions within the
    ///             service were last accessed.</p>
    public let jobType: AccessAdvisorUsageGranularityType?
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p> A <code>ServiceLastAccessed</code> object that contains details about the most recent
    ///             attempt to access the service.</p>
    public let servicesLastAccessed: [ServiceLastAccessed]?

    public init (
        error: ErrorDetails? = nil,
        isTruncated: Bool = false,
        jobCompletionDate: Date? = nil,
        jobCreationDate: Date? = nil,
        jobStatus: JobStatusType? = nil,
        jobType: AccessAdvisorUsageGranularityType? = nil,
        marker: String? = nil,
        servicesLastAccessed: [ServiceLastAccessed]? = nil
    )
    {
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.marker = marker
        self.servicesLastAccessed = servicesLastAccessed
    }
}

struct GetServiceLastAccessedDetailsOutputResponseBody: Equatable {
    public let jobStatus: JobStatusType?
    public let jobType: AccessAdvisorUsageGranularityType?
    public let jobCreationDate: Date?
    public let servicesLastAccessed: [ServiceLastAccessed]?
    public let jobCompletionDate: Date?
    public let isTruncated: Bool
    public let marker: String?
    public let error: ErrorDetails?
}

extension GetServiceLastAccessedDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case jobType = "JobType"
        case marker = "Marker"
        case servicesLastAccessed = "ServicesLastAccessed"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetServiceLastAccessedDetailsResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(AccessAdvisorUsageGranularityType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let jobCreationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCreationDate)
        var jobCreationDateBuffer:Date? = nil
        if let jobCreationDateDecoded = jobCreationDateDecoded {
            jobCreationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCreationDateDecoded, format: .dateTime)
        }
        jobCreationDate = jobCreationDateBuffer
        if containerValues.contains(.servicesLastAccessed) {
            struct KeyVal0{struct member{}}
            let servicesLastAccessedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .servicesLastAccessed)
            if let servicesLastAccessedWrappedContainer = servicesLastAccessedWrappedContainer {
                let servicesLastAccessedContainer = try servicesLastAccessedWrappedContainer.decodeIfPresent([ServiceLastAccessed].self, forKey: .member)
                var servicesLastAccessedBuffer:[ServiceLastAccessed]? = nil
                if let servicesLastAccessedContainer = servicesLastAccessedContainer {
                    servicesLastAccessedBuffer = [ServiceLastAccessed]()
                    for structureContainer0 in servicesLastAccessedContainer {
                        servicesLastAccessedBuffer?.append(structureContainer0)
                    }
                }
                servicesLastAccessed = servicesLastAccessedBuffer
            } else {
                servicesLastAccessed = []
            }
        } else {
            servicesLastAccessed = nil
        }
        let jobCompletionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCompletionDate)
        var jobCompletionDateBuffer:Date? = nil
        if let jobCompletionDateDecoded = jobCompletionDateDecoded {
            jobCompletionDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCompletionDateDecoded, format: .dateTime)
        }
        jobCompletionDate = jobCompletionDateBuffer
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceLastAccessedDetailsWithEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLastAccessedDetailsWithEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLastAccessedDetailsWithEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLastAccessedDetailsWithEntitiesInput>
    public typealias MOutput = OperationOutput<GetServiceLastAccessedDetailsWithEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLastAccessedDetailsWithEntitiesOutputError>
}

extension GetServiceLastAccessedDetailsWithEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceLastAccessedDetailsWithEntitiesInput(jobId: \(String(describing: jobId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), serviceNamespace: \(String(describing: serviceNamespace)))"}
}

extension GetServiceLastAccessedDetailsWithEntitiesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: Key("ServiceNamespace"))
        }
        try container.encode("GetServiceLastAccessedDetailsWithEntities", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceLastAccessedDetailsWithEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLastAccessedDetailsWithEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLastAccessedDetailsWithEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLastAccessedDetailsWithEntitiesInput>
    public typealias MOutput = OperationOutput<GetServiceLastAccessedDetailsWithEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLastAccessedDetailsWithEntitiesOutputError>
}

public struct GetServiceLastAccessedDetailsWithEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceLastAccessedDetailsWithEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLastAccessedDetailsWithEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLastAccessedDetailsWithEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLastAccessedDetailsWithEntitiesInput>
    public typealias MOutput = OperationOutput<GetServiceLastAccessedDetailsWithEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLastAccessedDetailsWithEntitiesOutputError>
}

public struct GetServiceLastAccessedDetailsWithEntitiesInput: Equatable {
    /// <p>The ID of the request generated by the <code>GenerateServiceLastAccessedDetails</code>
    ///             operation.</p>
    public let jobId: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The service namespace for an AWS service. Provide the service namespace to learn
    ///             when the IAM entity last attempted to access the specified service.</p>
    ///         <p>To learn the service namespace for a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
    ///                 <i>IAM User Guide</i>. Choose the name of the service to view
    ///             details for that service. In the first paragraph, find the service prefix. For example,
    ///                 <code>(service prefix: a4b)</code>. For more information about service namespaces,
    ///             see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
    ///                 service namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let serviceNamespace: String?

    public init (
        jobId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        serviceNamespace: String? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.serviceNamespace = serviceNamespace
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceLastAccessedDetailsWithEntitiesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceLastAccessedDetailsWithEntitiesOutputResponse(entityDetailsList: \(String(describing: entityDetailsList)), error: \(String(describing: error)), isTruncated: \(String(describing: isTruncated)), jobCompletionDate: \(String(describing: jobCompletionDate)), jobCreationDate: \(String(describing: jobCreationDate)), jobStatus: \(String(describing: jobStatus)), marker: \(String(describing: marker)))"}
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceLastAccessedDetailsWithEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entityDetailsList = output.entityDetailsList
            self.error = output.error
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.marker = output.marker
        } else {
            self.entityDetailsList = nil
            self.error = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.marker = nil
        }
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesOutputResponse: Equatable {
    /// <p>An <code>EntityDetailsList</code> object that contains details about when an IAM
    ///             entity (user or role) used group or policy permissions in an attempt to access the
    ///             specified AWS service.</p>
    public let entityDetailsList: [EntityDetails]?
    /// <p>An object that contains details about the reason the operation failed.</p>
    public let error: ErrorDetails?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///                 format</a>, when the generated report job was completed or failed.</p>
    ///         <p>This field is null if the job is still in progress, as indicated by a job status value
    ///             of <code>IN_PROGRESS</code>.</p>
    public let jobCompletionDate: Date?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///                 format</a>, when the report job was created.</p>
    public let jobCreationDate: Date?
    /// <p>The status of the job.</p>
    public let jobStatus: JobStatusType?
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        entityDetailsList: [EntityDetails]? = nil,
        error: ErrorDetails? = nil,
        isTruncated: Bool = false,
        jobCompletionDate: Date? = nil,
        jobCreationDate: Date? = nil,
        jobStatus: JobStatusType? = nil,
        marker: String? = nil
    )
    {
        self.entityDetailsList = entityDetailsList
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
    }
}

struct GetServiceLastAccessedDetailsWithEntitiesOutputResponseBody: Equatable {
    public let jobStatus: JobStatusType?
    public let jobCreationDate: Date?
    public let jobCompletionDate: Date?
    public let entityDetailsList: [EntityDetails]?
    public let isTruncated: Bool
    public let marker: String?
    public let error: ErrorDetails?
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityDetailsList = "EntityDetailsList"
        case error = "Error"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetServiceLastAccessedDetailsWithEntitiesResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobCreationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCreationDate)
        var jobCreationDateBuffer:Date? = nil
        if let jobCreationDateDecoded = jobCreationDateDecoded {
            jobCreationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCreationDateDecoded, format: .dateTime)
        }
        jobCreationDate = jobCreationDateBuffer
        let jobCompletionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCompletionDate)
        var jobCompletionDateBuffer:Date? = nil
        if let jobCompletionDateDecoded = jobCompletionDateDecoded {
            jobCompletionDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCompletionDateDecoded, format: .dateTime)
        }
        jobCompletionDate = jobCompletionDateBuffer
        if containerValues.contains(.entityDetailsList) {
            struct KeyVal0{struct member{}}
            let entityDetailsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .entityDetailsList)
            if let entityDetailsListWrappedContainer = entityDetailsListWrappedContainer {
                let entityDetailsListContainer = try entityDetailsListWrappedContainer.decodeIfPresent([EntityDetails].self, forKey: .member)
                var entityDetailsListBuffer:[EntityDetails]? = nil
                if let entityDetailsListContainer = entityDetailsListContainer {
                    entityDetailsListBuffer = [EntityDetails]()
                    for structureContainer0 in entityDetailsListContainer {
                        entityDetailsListBuffer?.append(structureContainer0)
                    }
                }
                entityDetailsList = entityDetailsListBuffer
            } else {
                entityDetailsList = []
            }
        } else {
            entityDetailsList = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

public struct GetServiceLinkedRoleDeletionStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceLinkedRoleDeletionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLinkedRoleDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLinkedRoleDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLinkedRoleDeletionStatusInput>
    public typealias MOutput = OperationOutput<GetServiceLinkedRoleDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLinkedRoleDeletionStatusOutputError>
}

extension GetServiceLinkedRoleDeletionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceLinkedRoleDeletionStatusInput(deletionTaskId: \(String(describing: deletionTaskId)))"}
}

extension GetServiceLinkedRoleDeletionStatusInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deletionTaskId = deletionTaskId {
            try container.encode(deletionTaskId, forKey: Key("DeletionTaskId"))
        }
        try container.encode("GetServiceLinkedRoleDeletionStatus", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetServiceLinkedRoleDeletionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceLinkedRoleDeletionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLinkedRoleDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLinkedRoleDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLinkedRoleDeletionStatusInput>
    public typealias MOutput = OperationOutput<GetServiceLinkedRoleDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLinkedRoleDeletionStatusOutputError>
}

public struct GetServiceLinkedRoleDeletionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceLinkedRoleDeletionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceLinkedRoleDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceLinkedRoleDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceLinkedRoleDeletionStatusInput>
    public typealias MOutput = OperationOutput<GetServiceLinkedRoleDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceLinkedRoleDeletionStatusOutputError>
}

public struct GetServiceLinkedRoleDeletionStatusInput: Equatable {
    /// <p>The deletion task identifier. This identifier is returned by the <a>DeleteServiceLinkedRole</a> operation in the format
    ///                 <code>task/aws-service-role/<service-principal-name>/<role-name>/<task-uuid></code>.</p>
    public let deletionTaskId: String?

    public init (
        deletionTaskId: String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

extension GetServiceLinkedRoleDeletionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServiceLinkedRoleDeletionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceLinkedRoleDeletionStatusOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceLinkedRoleDeletionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceLinkedRoleDeletionStatusOutputResponse(reason: \(String(describing: reason)), status: \(String(describing: status)))"}
}

extension GetServiceLinkedRoleDeletionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceLinkedRoleDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reason = output.reason
            self.status = output.status
        } else {
            self.reason = nil
            self.status = nil
        }
    }
}

public struct GetServiceLinkedRoleDeletionStatusOutputResponse: Equatable {
    /// <p>An object that contains details about the reason the deletion failed.</p>
    public let reason: DeletionTaskFailureReasonType?
    /// <p>The status of the deletion.</p>
    public let status: DeletionTaskStatusType?

    public init (
        reason: DeletionTaskFailureReasonType? = nil,
        status: DeletionTaskStatusType? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

struct GetServiceLinkedRoleDeletionStatusOutputResponseBody: Equatable {
    public let status: DeletionTaskStatusType?
    public let reason: DeletionTaskFailureReasonType?
}

extension GetServiceLinkedRoleDeletionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetServiceLinkedRoleDeletionStatusResult"))
        let statusDecoded = try containerValues.decodeIfPresent(DeletionTaskStatusType.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DeletionTaskFailureReasonType.self, forKey: .reason)
        reason = reasonDecoded
    }
}

public struct GetUserInputBodyMiddleware: Middleware {
    public let id: String = "GetUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserInput>
    public typealias MOutput = OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserOutputError>
}

extension GetUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserInput(userName: \(String(describing: userName)))"}
}

extension GetUserInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("GetUser", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetUserInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserInput>
    public typealias MOutput = OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserOutputError>
}

public struct GetUserInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserInput>
    public typealias MOutput = OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserOutputError>
}

public struct GetUserInput: Equatable {
    /// <p>The name of the user to get information about.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to the user making the
    ///             request. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        userName: String? = nil
    )
    {
        self.userName = userName
    }
}

extension GetUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserOutputResponse(user: \(String(describing: user)))"}
}

extension GetUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetUser</a> request. </p>
public struct GetUserOutputResponse: Equatable {
    /// <p>A structure containing details about the IAM user.</p>
    ///         <important>
    ///             <p>Due to a service issue, password last used data does not include password use from
    ///                 May 3, 2018 22:50 PDT to May 23, 2018 14:08 PDT. This affects <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_finding-unused.html">last sign-in</a> dates shown in the IAM console and password last used
    ///                 dates in the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_getting-report.html">IAM credential
    ///                     report</a>, and returned by this operation. If users signed in during the
    ///                 affected time, the password last used date that is returned is the date the user
    ///                 last signed in before May 3, 2018. For users that signed in after May 23, 2018 14:08
    ///                 PDT, the returned password last used date is accurate.</p>
    ///             <p>You can use password last used information to identify unused credentials for
    ///                 deletion. For example, you might delete users who did not sign in to AWS in the last
    ///                 90 days. In cases like this, we recommend that you adjust your evaluation window to
    ///                 include dates after May 23, 2018. Alternatively, if your users use access keys to
    ///                 access AWS programmatically you can refer to access key last used information
    ///                 because it is accurate for all dates. </p>
    ///         </important>
    public let user: User?

    public init (
        user: User? = nil
    )
    {
        self.user = user
    }
}

struct GetUserOutputResponseBody: Equatable {
    public let user: User?
}

extension GetUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetUserResult"))
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
    }
}

public struct GetUserPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetUserPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserPolicyInput>
    public typealias MOutput = OperationOutput<GetUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserPolicyOutputError>
}

extension GetUserPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserPolicyInput(policyName: \(String(describing: policyName)), userName: \(String(describing: userName)))"}
}

extension GetUserPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("GetUserPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct GetUserPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserPolicyInput>
    public typealias MOutput = OperationOutput<GetUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserPolicyOutputError>
}

public struct GetUserPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserPolicyInput>
    public typealias MOutput = OperationOutput<GetUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserPolicyOutputError>
}

public struct GetUserPolicyInput: Equatable {
    /// <p>The name of the policy document to get.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?
    /// <p>The name of the user who the policy is associated with.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        policyName: String? = nil,
        userName: String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

extension GetUserPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetUserPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserPolicyOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserPolicyOutputResponse(policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), userName: \(String(describing: userName)))"}
}

extension GetUserPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUserPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.userName = output.userName
        } else {
            self.policyDocument = nil
            self.policyName = nil
            self.userName = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetUserPolicy</a> request.
///     </p>
public struct GetUserPolicyOutputResponse: Equatable {
    /// <p>The policy document.</p>
    ///         <p>IAM stores policies in JSON format. However, resources that were created using AWS
    ///             CloudFormation templates can be formatted in YAML. AWS CloudFormation always converts
    ///             a YAML policy to JSON format before submitting it to IAM.</p>
    public let policyDocument: String?
    /// <p>The name of the policy.</p>
    public let policyName: String?
    /// <p>The user the policy is associated with.</p>
    public let userName: String?

    public init (
        policyDocument: String? = nil,
        policyName: String? = nil,
        userName: String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

struct GetUserPolicyOutputResponseBody: Equatable {
    public let userName: String?
    public let policyName: String?
    public let policyDocument: String?
}

extension GetUserPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetUserPolicyResult"))
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

public enum GlobalEndpointTokenVersion {
    case v1token
    case v2token
    case sdkUnknown(String)
}

extension GlobalEndpointTokenVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GlobalEndpointTokenVersion] {
        return [
            .v1token,
            .v2token,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .v1token: return "v1Token"
        case .v2token: return "v2Token"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GlobalEndpointTokenVersion(rawValue: rawValue) ?? GlobalEndpointTokenVersion.sdkUnknown(rawValue)
    }
}

extension Group: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
    }
}

extension Group: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Group(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)), path: \(String(describing: path)))"}
}

/// <p>Contains information about an IAM group entity.</p>
///          <p>This data type is used as a response element in the following operations:</p>
///          <ul>
///             <li>
///                <p>
///                   <a>CreateGroup</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>GetGroup</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListGroups</a>
///                </p>
///             </li>
///          </ul>
public struct Group: Equatable {
    /// <p> The Amazon Resource Name (ARN) specifying the group. For more information about ARNs
    ///          and how to use them in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>. </p>
    public let arn: String?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the group was created.</p>
    public let createDate: Date?
    /// <p> The stable and unique string identifying the group. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let groupId: String?
    /// <p>The friendly name that identifies the group.</p>
    public let groupName: String?
    /// <p>The path to the group. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>. </p>
    public let path: String?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        groupId: String? = nil,
        groupName: String? = nil,
        path: String? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.groupId = groupId
        self.groupName = groupName
        self.path = path
    }
}

extension GroupDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case groupPolicyList = "GroupPolicyList"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttachedManagedPolicies"))
            for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let groupPolicyList = groupPolicyList {
            var groupPolicyListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("GroupPolicyList"))
            for (index0, policydetail0) in groupPolicyList.enumerated() {
                try groupPolicyListContainer.encode(policydetail0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        if containerValues.contains(.groupPolicyList) {
            struct KeyVal0{struct member{}}
            let groupPolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupPolicyList)
            if let groupPolicyListWrappedContainer = groupPolicyListWrappedContainer {
                let groupPolicyListContainer = try groupPolicyListWrappedContainer.decodeIfPresent([PolicyDetail].self, forKey: .member)
                var groupPolicyListBuffer:[PolicyDetail]? = nil
                if let groupPolicyListContainer = groupPolicyListContainer {
                    groupPolicyListBuffer = [PolicyDetail]()
                    for structureContainer0 in groupPolicyListContainer {
                        groupPolicyListBuffer?.append(structureContainer0)
                    }
                }
                groupPolicyList = groupPolicyListBuffer
            } else {
                groupPolicyList = []
            }
        } else {
            groupPolicyList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
    }
}

extension GroupDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupDetail(arn: \(String(describing: arn)), attachedManagedPolicies: \(String(describing: attachedManagedPolicies)), createDate: \(String(describing: createDate)), groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)), groupPolicyList: \(String(describing: groupPolicyList)), path: \(String(describing: path)))"}
}

/// <p>Contains information about an IAM group, including all of the group's policies.</p>
///          <p>This data type is used as a response element in the <a>GetAccountAuthorizationDetails</a> operation.</p>
public struct GroupDetail: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let arn: String?
    /// <p>A list of the managed policies attached to the group.</p>
    public let attachedManagedPolicies: [AttachedPolicy]?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the group was created.</p>
    public let createDate: Date?
    /// <p>The stable and unique string identifying the group. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>.</p>
    public let groupId: String?
    /// <p>The friendly name that identifies the group.</p>
    public let groupName: String?
    /// <p>A list of the inline policies embedded in the group.</p>
    public let groupPolicyList: [PolicyDetail]?
    /// <p>The path to the group. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let path: String?

    public init (
        arn: String? = nil,
        attachedManagedPolicies: [AttachedPolicy]? = nil,
        createDate: Date? = nil,
        groupId: String? = nil,
        groupName: String? = nil,
        groupPolicyList: [PolicyDetail]? = nil,
        path: String? = nil
    )
    {
        self.arn = arn
        self.attachedManagedPolicies = attachedManagedPolicies
        self.createDate = createDate
        self.groupId = groupId
        self.groupName = groupName
        self.groupPolicyList = groupPolicyList
        self.path = path
    }
}

extension InstanceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case instanceProfileId = "InstanceProfileId"
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case roles = "Roles"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let instanceProfileId = instanceProfileId {
            try container.encode(instanceProfileId, forKey: Key("InstanceProfileId"))
        }
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let roles = roles {
            var rolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Roles"))
            for (index0, role0) in roles.enumerated() {
                try rolesContainer.encode(role0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let instanceProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileId)
        instanceProfileId = instanceProfileIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        if containerValues.contains(.roles) {
            struct KeyVal0{struct member{}}
            let rolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roles)
            if let rolesWrappedContainer = rolesWrappedContainer {
                let rolesContainer = try rolesWrappedContainer.decodeIfPresent([Role].self, forKey: .member)
                var rolesBuffer:[Role]? = nil
                if let rolesContainer = rolesContainer {
                    rolesBuffer = [Role]()
                    for structureContainer0 in rolesContainer {
                        rolesBuffer?.append(structureContainer0)
                    }
                }
                roles = rolesBuffer
            } else {
                roles = []
            }
        } else {
            roles = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension InstanceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceProfile(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), instanceProfileId: \(String(describing: instanceProfileId)), instanceProfileName: \(String(describing: instanceProfileName)), path: \(String(describing: path)), roles: \(String(describing: roles)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about an instance profile.</p>
///          <p>This data type is used as a response element in the following operations:</p>
///          <ul>
///             <li>
///                <p>
///                   <a>CreateInstanceProfile</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>GetInstanceProfile</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListInstanceProfiles</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListInstanceProfilesForRole</a>
///                </p>
///             </li>
///          </ul>
public struct InstanceProfile: Equatable {
    /// <p> The Amazon Resource Name (ARN) specifying the instance profile. For more information
    ///          about ARNs and how to use them in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>. </p>
    public let arn: String?
    /// <p>The date when the instance profile was created.</p>
    public let createDate: Date?
    /// <p> The stable and unique string identifying the instance profile. For more information
    ///          about IDs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let instanceProfileId: String?
    /// <p>The name identifying the instance profile.</p>
    public let instanceProfileName: String?
    /// <p> The path to the instance profile. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let path: String?
    /// <p>The role associated with the instance profile.</p>
    public let roles: [Role]?
    /// <p>A list of tags that are attached to the instance profile. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        instanceProfileId: String? = nil,
        instanceProfileName: String? = nil,
        path: String? = nil,
        roles: [Role]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.instanceProfileId = instanceProfileId
        self.instanceProfileName = instanceProfileName
        self.path = path
        self.roles = roles
        self.tags = tags
    }
}

extension InvalidAuthenticationCodeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAuthenticationCodeException(message: \(String(describing: message)))"}
}

extension InvalidAuthenticationCodeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidAuthenticationCodeExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the authentication code was not recognized. The error
///       message describes the specific error.</p>
public struct InvalidAuthenticationCodeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthenticationCodeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAuthenticationCodeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCertificateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCertificateException(message: \(String(describing: message)))"}
}

extension InvalidCertificateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidCertificateExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the certificate is invalid.</p>
public struct InvalidCertificateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCertificateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCertificateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidInputExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because an invalid or out-of-range value was supplied for an
///       input parameter.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPublicKeyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPublicKeyException(message: \(String(describing: message)))"}
}

extension InvalidPublicKeyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidPublicKeyExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the public key is malformed or otherwise invalid.</p>
public struct InvalidPublicKeyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPublicKeyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPublicKeyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidUserTypeException(message: \(String(describing: message)))"}
}

extension InvalidUserTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidUserTypeExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the type of user for the transaction was
///       incorrect.</p>
public struct InvalidUserTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUserTypeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidUserTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum JobStatusType {
    case completed
    case failed
    case inProgress
    case sdkUnknown(String)
}

extension JobStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatusType] {
        return [
            .completed,
            .failed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatusType(rawValue: rawValue) ?? JobStatusType.sdkUnknown(rawValue)
    }
}

extension KeyPairMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyPairMismatchException(message: \(String(describing: message)))"}
}

extension KeyPairMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KeyPairMismatchExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the public key certificate and the private key do not
///       match.</p>
public struct KeyPairMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KeyPairMismatchExceptionBody: Equatable {
    public let message: String?
}

extension KeyPairMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current AWS
///       account limits. The error message describes the limit exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAccessKeysInputBodyMiddleware: Middleware {
    public let id: String = "ListAccessKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessKeysInput>
    public typealias MOutput = OperationOutput<ListAccessKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessKeysOutputError>
}

extension ListAccessKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessKeysInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), userName: \(String(describing: userName)))"}
}

extension ListAccessKeysInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListAccessKeys", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListAccessKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessKeysInput>
    public typealias MOutput = OperationOutput<ListAccessKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessKeysOutputError>
}

public struct ListAccessKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessKeysInput>
    public typealias MOutput = OperationOutput<ListAccessKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessKeysOutputError>
}

public struct ListAccessKeysInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the user.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListAccessKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAccessKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessKeysOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessKeysOutputResponse(accessKeyMetadata: \(String(describing: accessKeyMetadata)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListAccessKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessKeyMetadata = output.accessKeyMetadata
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.accessKeyMetadata = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListAccessKeys</a> request.
///     </p>
public struct ListAccessKeysOutputResponse: Equatable {
    /// <p>A list of objects containing metadata about the access keys.</p>
    public let accessKeyMetadata: [AccessKeyMetadata]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        accessKeyMetadata: [AccessKeyMetadata]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.accessKeyMetadata = accessKeyMetadata
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAccessKeysOutputResponseBody: Equatable {
    public let accessKeyMetadata: [AccessKeyMetadata]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListAccessKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessKeyMetadata = "AccessKeyMetadata"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListAccessKeysResult"))
        if containerValues.contains(.accessKeyMetadata) {
            struct KeyVal0{struct member{}}
            let accessKeyMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessKeyMetadata)
            if let accessKeyMetadataWrappedContainer = accessKeyMetadataWrappedContainer {
                let accessKeyMetadataContainer = try accessKeyMetadataWrappedContainer.decodeIfPresent([AccessKeyMetadata].self, forKey: .member)
                var accessKeyMetadataBuffer:[AccessKeyMetadata]? = nil
                if let accessKeyMetadataContainer = accessKeyMetadataContainer {
                    accessKeyMetadataBuffer = [AccessKeyMetadata]()
                    for structureContainer0 in accessKeyMetadataContainer {
                        accessKeyMetadataBuffer?.append(structureContainer0)
                    }
                }
                accessKeyMetadata = accessKeyMetadataBuffer
            } else {
                accessKeyMetadata = []
            }
        } else {
            accessKeyMetadata = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListAccountAliasesInputBodyMiddleware: Middleware {
    public let id: String = "ListAccountAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAliasesInput>
    public typealias MOutput = OperationOutput<ListAccountAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAliasesOutputError>
}

extension ListAccountAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAliasesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListAccountAliasesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        try container.encode("ListAccountAliases", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListAccountAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAliasesInput>
    public typealias MOutput = OperationOutput<ListAccountAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAliasesOutputError>
}

public struct ListAccountAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAliasesInput>
    public typealias MOutput = OperationOutput<ListAccountAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAliasesOutputError>
}

public struct ListAccountAliasesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListAccountAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAccountAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountAliasesOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAliasesOutputResponse(accountAliases: \(String(describing: accountAliases)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListAccountAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAliases = output.accountAliases
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.accountAliases = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListAccountAliases</a> request.
///     </p>
public struct ListAccountAliasesOutputResponse: Equatable {
    /// <p>A list of aliases associated with the account. AWS supports only one alias per
    ///             account.</p>
    public let accountAliases: [String]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        accountAliases: [String]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.accountAliases = accountAliases
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAccountAliasesOutputResponseBody: Equatable {
    public let accountAliases: [String]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListAccountAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAliases = "AccountAliases"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListAccountAliasesResult"))
        if containerValues.contains(.accountAliases) {
            struct KeyVal0{struct member{}}
            let accountAliasesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accountAliases)
            if let accountAliasesWrappedContainer = accountAliasesWrappedContainer {
                let accountAliasesContainer = try accountAliasesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var accountAliasesBuffer:[String]? = nil
                if let accountAliasesContainer = accountAliasesContainer {
                    accountAliasesBuffer = [String]()
                    for stringContainer0 in accountAliasesContainer {
                        accountAliasesBuffer?.append(stringContainer0)
                    }
                }
                accountAliases = accountAliasesBuffer
            } else {
                accountAliases = []
            }
        } else {
            accountAliases = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListAttachedGroupPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListAttachedGroupPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedGroupPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedGroupPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedGroupPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedGroupPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedGroupPoliciesOutputError>
}

extension ListAttachedGroupPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedGroupPoliciesInput(groupName: \(String(describing: groupName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)))"}
}

extension ListAttachedGroupPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        try container.encode("ListAttachedGroupPolicies", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListAttachedGroupPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAttachedGroupPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedGroupPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedGroupPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedGroupPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedGroupPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedGroupPoliciesOutputError>
}

public struct ListAttachedGroupPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAttachedGroupPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedGroupPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedGroupPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedGroupPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedGroupPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedGroupPoliciesOutputError>
}

public struct ListAttachedGroupPoliciesInput: Equatable {
    /// <p>The name (friendly name, not ARN) of the group to list attached policies for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    ///             included, it defaults to a slash (/), listing all policies.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?

    public init (
        groupName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListAttachedGroupPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAttachedGroupPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttachedGroupPoliciesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedGroupPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedGroupPoliciesOutputResponse(attachedPolicies: \(String(describing: attachedPolicies)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListAttachedGroupPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAttachedGroupPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListAttachedGroupPolicies</a>
///       request. </p>
public struct ListAttachedGroupPoliciesOutputResponse: Equatable {
    /// <p>A list of the attached policies.</p>
    public let attachedPolicies: [AttachedPolicy]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        attachedPolicies: [AttachedPolicy]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedGroupPoliciesOutputResponseBody: Equatable {
    public let attachedPolicies: [AttachedPolicy]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListAttachedGroupPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListAttachedGroupPoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListAttachedRolePoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListAttachedRolePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedRolePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedRolePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedRolePoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedRolePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedRolePoliciesOutputError>
}

extension ListAttachedRolePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedRolePoliciesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)), roleName: \(String(describing: roleName)))"}
}

extension ListAttachedRolePoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("ListAttachedRolePolicies", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListAttachedRolePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAttachedRolePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedRolePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedRolePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedRolePoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedRolePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedRolePoliciesOutputError>
}

public struct ListAttachedRolePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAttachedRolePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedRolePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedRolePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedRolePoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedRolePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedRolePoliciesOutputError>
}

public struct ListAttachedRolePoliciesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    ///             included, it defaults to a slash (/), listing all policies.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?
    /// <p>The name (friendly name, not ARN) of the role to list attached policies for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil,
        roleName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.roleName = roleName
    }
}

extension ListAttachedRolePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAttachedRolePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttachedRolePoliciesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedRolePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedRolePoliciesOutputResponse(attachedPolicies: \(String(describing: attachedPolicies)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListAttachedRolePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAttachedRolePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListAttachedRolePolicies</a>
///       request. </p>
public struct ListAttachedRolePoliciesOutputResponse: Equatable {
    /// <p>A list of the attached policies.</p>
    public let attachedPolicies: [AttachedPolicy]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        attachedPolicies: [AttachedPolicy]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedRolePoliciesOutputResponseBody: Equatable {
    public let attachedPolicies: [AttachedPolicy]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListAttachedRolePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListAttachedRolePoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListAttachedUserPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListAttachedUserPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedUserPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedUserPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedUserPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedUserPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedUserPoliciesOutputError>
}

extension ListAttachedUserPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedUserPoliciesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)), userName: \(String(describing: userName)))"}
}

extension ListAttachedUserPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListAttachedUserPolicies", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListAttachedUserPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAttachedUserPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedUserPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedUserPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedUserPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedUserPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedUserPoliciesOutputError>
}

public struct ListAttachedUserPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAttachedUserPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedUserPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedUserPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedUserPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedUserPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedUserPoliciesOutputError>
}

public struct ListAttachedUserPoliciesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    ///             included, it defaults to a slash (/), listing all policies.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?
    /// <p>The name (friendly name, not ARN) of the user to list attached policies for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.userName = userName
    }
}

extension ListAttachedUserPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAttachedUserPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttachedUserPoliciesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedUserPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedUserPoliciesOutputResponse(attachedPolicies: \(String(describing: attachedPolicies)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListAttachedUserPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAttachedUserPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListAttachedUserPolicies</a>
///       request. </p>
public struct ListAttachedUserPoliciesOutputResponse: Equatable {
    /// <p>A list of the attached policies.</p>
    public let attachedPolicies: [AttachedPolicy]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        attachedPolicies: [AttachedPolicy]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedUserPoliciesOutputResponseBody: Equatable {
    public let attachedPolicies: [AttachedPolicy]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListAttachedUserPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListAttachedUserPoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListEntitiesForPolicyInputBodyMiddleware: Middleware {
    public let id: String = "ListEntitiesForPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesForPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesForPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesForPolicyInput>
    public typealias MOutput = OperationOutput<ListEntitiesForPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesForPolicyOutputError>
}

extension ListEntitiesForPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesForPolicyInput(entityFilter: \(String(describing: entityFilter)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)), policyArn: \(String(describing: policyArn)), policyUsageFilter: \(String(describing: policyUsageFilter)))"}
}

extension ListEntitiesForPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let entityFilter = entityFilter {
            try container.encode(entityFilter, forKey: Key("EntityFilter"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: Key("PolicyUsageFilter"))
        }
        try container.encode("ListEntitiesForPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListEntitiesForPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "ListEntitiesForPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesForPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesForPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesForPolicyInput>
    public typealias MOutput = OperationOutput<ListEntitiesForPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesForPolicyOutputError>
}

public struct ListEntitiesForPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEntitiesForPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesForPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesForPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesForPolicyInput>
    public typealias MOutput = OperationOutput<ListEntitiesForPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesForPolicyOutputError>
}

public struct ListEntitiesForPolicyInput: Equatable {
    /// <p>The entity type to use for filtering the results.</p>
    ///         <p>For example, when <code>EntityFilter</code> is <code>Role</code>, only the roles that
    ///             are attached to the specified policy are returned. This parameter is optional. If it is
    ///             not included, all attached entities (users, groups, and roles) are returned. The
    ///             argument for this parameter must be one of the valid values listed below.</p>
    public let entityFilter: EntityType?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    ///             included, it defaults to a slash (/), listing all entities.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
    ///             versions.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The policy usage method to use for filtering the results.</p>
    ///         <p>To list only permissions policies,
    ///                 set <code>PolicyUsageFilter</code> to <code>PermissionsPolicy</code>. To list only
    ///             the policies used to set permissions boundaries, set the value
    ///                 to <code>PermissionsBoundary</code>.</p>
    ///         <p>This parameter is optional. If it is not included, all policies are returned. </p>
    public let policyUsageFilter: PolicyUsageType?

    public init (
        entityFilter: EntityType? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil,
        policyArn: String? = nil,
        policyUsageFilter: PolicyUsageType? = nil
    )
    {
        self.entityFilter = entityFilter
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.policyArn = policyArn
        self.policyUsageFilter = policyUsageFilter
    }
}

extension ListEntitiesForPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListEntitiesForPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitiesForPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesForPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesForPolicyOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), policyGroups: \(String(describing: policyGroups)), policyRoles: \(String(describing: policyRoles)), policyUsers: \(String(describing: policyUsers)))"}
}

extension ListEntitiesForPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEntitiesForPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyGroups = output.policyGroups
            self.policyRoles = output.policyRoles
            self.policyUsers = output.policyUsers
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyGroups = nil
            self.policyRoles = nil
            self.policyUsers = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListEntitiesForPolicy</a> request.
///     </p>
public struct ListEntitiesForPolicyOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of IAM groups that the policy is attached to.</p>
    public let policyGroups: [PolicyGroup]?
    /// <p>A list of IAM roles that the policy is attached to.</p>
    public let policyRoles: [PolicyRole]?
    /// <p>A list of IAM users that the policy is attached to.</p>
    public let policyUsers: [PolicyUser]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        policyGroups: [PolicyGroup]? = nil,
        policyRoles: [PolicyRole]? = nil,
        policyUsers: [PolicyUser]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyGroups = policyGroups
        self.policyRoles = policyRoles
        self.policyUsers = policyUsers
    }
}

struct ListEntitiesForPolicyOutputResponseBody: Equatable {
    public let policyGroups: [PolicyGroup]?
    public let policyUsers: [PolicyUser]?
    public let policyRoles: [PolicyRole]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListEntitiesForPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyGroups = "PolicyGroups"
        case policyRoles = "PolicyRoles"
        case policyUsers = "PolicyUsers"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListEntitiesForPolicyResult"))
        if containerValues.contains(.policyGroups) {
            struct KeyVal0{struct member{}}
            let policyGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyGroups)
            if let policyGroupsWrappedContainer = policyGroupsWrappedContainer {
                let policyGroupsContainer = try policyGroupsWrappedContainer.decodeIfPresent([PolicyGroup].self, forKey: .member)
                var policyGroupsBuffer:[PolicyGroup]? = nil
                if let policyGroupsContainer = policyGroupsContainer {
                    policyGroupsBuffer = [PolicyGroup]()
                    for structureContainer0 in policyGroupsContainer {
                        policyGroupsBuffer?.append(structureContainer0)
                    }
                }
                policyGroups = policyGroupsBuffer
            } else {
                policyGroups = []
            }
        } else {
            policyGroups = nil
        }
        if containerValues.contains(.policyUsers) {
            struct KeyVal0{struct member{}}
            let policyUsersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyUsers)
            if let policyUsersWrappedContainer = policyUsersWrappedContainer {
                let policyUsersContainer = try policyUsersWrappedContainer.decodeIfPresent([PolicyUser].self, forKey: .member)
                var policyUsersBuffer:[PolicyUser]? = nil
                if let policyUsersContainer = policyUsersContainer {
                    policyUsersBuffer = [PolicyUser]()
                    for structureContainer0 in policyUsersContainer {
                        policyUsersBuffer?.append(structureContainer0)
                    }
                }
                policyUsers = policyUsersBuffer
            } else {
                policyUsers = []
            }
        } else {
            policyUsers = nil
        }
        if containerValues.contains(.policyRoles) {
            struct KeyVal0{struct member{}}
            let policyRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyRoles)
            if let policyRolesWrappedContainer = policyRolesWrappedContainer {
                let policyRolesContainer = try policyRolesWrappedContainer.decodeIfPresent([PolicyRole].self, forKey: .member)
                var policyRolesBuffer:[PolicyRole]? = nil
                if let policyRolesContainer = policyRolesContainer {
                    policyRolesBuffer = [PolicyRole]()
                    for structureContainer0 in policyRolesContainer {
                        policyRolesBuffer?.append(structureContainer0)
                    }
                }
                policyRoles = policyRolesBuffer
            } else {
                policyRoles = []
            }
        } else {
            policyRoles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListGroupPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupPoliciesInput>
    public typealias MOutput = OperationOutput<ListGroupPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupPoliciesOutputError>
}

extension ListGroupPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupPoliciesInput(groupName: \(String(describing: groupName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListGroupPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        try container.encode("ListGroupPolicies", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListGroupPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupPoliciesInput>
    public typealias MOutput = OperationOutput<ListGroupPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupPoliciesOutputError>
}

public struct ListGroupPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupPoliciesInput>
    public typealias MOutput = OperationOutput<ListGroupPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupPoliciesOutputError>
}

public struct ListGroupPoliciesInput: Equatable {
    /// <p>The name of the group to list policies for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?

    public init (
        groupName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListGroupPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListGroupPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupPoliciesOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupPoliciesOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), policyNames: \(String(describing: policyNames)))"}
}

extension ListGroupPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListGroupPolicies</a> request.
///     </p>
public struct ListGroupPoliciesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of policy names.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyNames: [String]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        policyNames: [String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListGroupPoliciesOutputResponseBody: Equatable {
    public let policyNames: [String]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListGroupPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListGroupPoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var policyNamesBuffer:[String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListGroupsForUserInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupsForUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsForUserInput>
    public typealias MOutput = OperationOutput<ListGroupsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsForUserOutputError>
}

extension ListGroupsForUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsForUserInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), userName: \(String(describing: userName)))"}
}

extension ListGroupsForUserInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListGroupsForUser", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListGroupsForUserInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupsForUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsForUserInput>
    public typealias MOutput = OperationOutput<ListGroupsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsForUserOutputError>
}

public struct ListGroupsForUserInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupsForUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsForUserInput>
    public typealias MOutput = OperationOutput<ListGroupsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsForUserOutputError>
}

public struct ListGroupsForUserInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the user to list groups for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListGroupsForUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListGroupsForUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsForUserOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsForUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsForUserOutputResponse(groups: \(String(describing: groups)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListGroupsForUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupsForUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.groups = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListGroupsForUser</a> request.
///     </p>
public struct ListGroupsForUserOutputResponse: Equatable {
    /// <p>A list of groups.</p>
    public let groups: [Group]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        groups: [Group]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListGroupsForUserOutputResponseBody: Equatable {
    public let groups: [Group]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListGroupsForUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListGroupsForUserResult"))
        if containerValues.contains(.groups) {
            struct KeyVal0{struct member{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([Group].self, forKey: .member)
                var groupsBuffer:[Group]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [Group]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

extension ListGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)))"}
}

extension ListGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        try container.encode("ListGroups", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p> The path prefix for filtering the results. For example, the prefix
    ///                 <code>/division_abc/subdivision_xyz/</code> gets all groups whose path starts with
    ///                 <code>/division_abc/subdivision_xyz/</code>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    ///             all groups. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsOutputResponse(groups: \(String(describing: groups)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.groups = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListGroups</a> request. </p>
public struct ListGroupsOutputResponse: Equatable {
    /// <p>A list of groups.</p>
    public let groups: [Group]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        groups: [Group]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListGroupsOutputResponseBody: Equatable {
    public let groups: [Group]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListGroupsResult"))
        if containerValues.contains(.groups) {
            struct KeyVal0{struct member{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([Group].self, forKey: .member)
                var groupsBuffer:[Group]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [Group]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListInstanceProfileTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListInstanceProfileTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfileTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfileTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfileTagsInput>
    public typealias MOutput = OperationOutput<ListInstanceProfileTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfileTagsOutputError>
}

extension ListInstanceProfileTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfileTagsInput(instanceProfileName: \(String(describing: instanceProfileName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListInstanceProfileTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        try container.encode("ListInstanceProfileTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListInstanceProfileTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstanceProfileTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfileTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfileTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfileTagsInput>
    public typealias MOutput = OperationOutput<ListInstanceProfileTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfileTagsOutputError>
}

public struct ListInstanceProfileTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstanceProfileTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfileTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfileTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfileTagsInput>
    public typealias MOutput = OperationOutput<ListInstanceProfileTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfileTagsOutputError>
}

public struct ListInstanceProfileTagsInput: Equatable {
    /// <p>The name of the IAM instance profile whose tags you want to see.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let instanceProfileName: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?

    public init (
        instanceProfileName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListInstanceProfileTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInstanceProfileTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceProfileTagsOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfileTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfileTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListInstanceProfileTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstanceProfileTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListInstanceProfileTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the IAM instance profile. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListInstanceProfileTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListInstanceProfileTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListInstanceProfileTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListInstanceProfilesForRoleInputBodyMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesForRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesForRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesForRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesForRoleInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesForRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesForRoleOutputError>
}

extension ListInstanceProfilesForRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfilesForRoleInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), roleName: \(String(describing: roleName)))"}
}

extension ListInstanceProfilesForRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("ListInstanceProfilesForRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListInstanceProfilesForRoleInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesForRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesForRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesForRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesForRoleInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesForRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesForRoleOutputError>
}

public struct ListInstanceProfilesForRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesForRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesForRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesForRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesForRoleInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesForRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesForRoleOutputError>
}

public struct ListInstanceProfilesForRoleInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the role to list instance profiles for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        roleName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

extension ListInstanceProfilesForRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInstanceProfilesForRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceProfilesForRoleOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfilesForRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfilesForRoleOutputResponse(instanceProfiles: \(String(describing: instanceProfiles)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListInstanceProfilesForRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstanceProfilesForRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfiles = output.instanceProfiles
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.instanceProfiles = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListInstanceProfilesForRole</a>
///       request. </p>
public struct ListInstanceProfilesForRoleOutputResponse: Equatable {
    /// <p>A list of instance profiles.</p>
    public let instanceProfiles: [InstanceProfile]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        instanceProfiles: [InstanceProfile]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListInstanceProfilesForRoleOutputResponseBody: Equatable {
    public let instanceProfiles: [InstanceProfile]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListInstanceProfilesForRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfiles = "InstanceProfiles"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListInstanceProfilesForRoleResult"))
        if containerValues.contains(.instanceProfiles) {
            struct KeyVal0{struct member{}}
            let instanceProfilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfiles)
            if let instanceProfilesWrappedContainer = instanceProfilesWrappedContainer {
                let instanceProfilesContainer = try instanceProfilesWrappedContainer.decodeIfPresent([InstanceProfile].self, forKey: .member)
                var instanceProfilesBuffer:[InstanceProfile]? = nil
                if let instanceProfilesContainer = instanceProfilesContainer {
                    instanceProfilesBuffer = [InstanceProfile]()
                    for structureContainer0 in instanceProfilesContainer {
                        instanceProfilesBuffer?.append(structureContainer0)
                    }
                }
                instanceProfiles = instanceProfilesBuffer
            } else {
                instanceProfiles = []
            }
        } else {
            instanceProfiles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListInstanceProfilesInputBodyMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesOutputError>
}

extension ListInstanceProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfilesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)))"}
}

extension ListInstanceProfilesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        try container.encode("ListInstanceProfiles", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListInstanceProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p> The path prefix for filtering the results. For example, the prefix
    ///                 <code>/application_abc/component_xyz/</code> gets all instance profiles whose path
    ///             starts with <code>/application_abc/component_xyz/</code>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    ///             all instance profiles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListInstanceProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInstanceProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceProfilesOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfilesOutputResponse(instanceProfiles: \(String(describing: instanceProfiles)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListInstanceProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstanceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfiles = output.instanceProfiles
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.instanceProfiles = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListInstanceProfiles</a> request.
///     </p>
public struct ListInstanceProfilesOutputResponse: Equatable {
    /// <p>A list of instance profiles.</p>
    public let instanceProfiles: [InstanceProfile]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        instanceProfiles: [InstanceProfile]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListInstanceProfilesOutputResponseBody: Equatable {
    public let instanceProfiles: [InstanceProfile]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListInstanceProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfiles = "InstanceProfiles"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListInstanceProfilesResult"))
        if containerValues.contains(.instanceProfiles) {
            struct KeyVal0{struct member{}}
            let instanceProfilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfiles)
            if let instanceProfilesWrappedContainer = instanceProfilesWrappedContainer {
                let instanceProfilesContainer = try instanceProfilesWrappedContainer.decodeIfPresent([InstanceProfile].self, forKey: .member)
                var instanceProfilesBuffer:[InstanceProfile]? = nil
                if let instanceProfilesContainer = instanceProfilesContainer {
                    instanceProfilesBuffer = [InstanceProfile]()
                    for structureContainer0 in instanceProfilesContainer {
                        instanceProfilesBuffer?.append(structureContainer0)
                    }
                }
                instanceProfiles = instanceProfilesBuffer
            } else {
                instanceProfiles = []
            }
        } else {
            instanceProfiles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListMFADeviceTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListMFADeviceTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMFADeviceTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMFADeviceTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMFADeviceTagsInput>
    public typealias MOutput = OperationOutput<ListMFADeviceTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMFADeviceTagsOutputError>
}

extension ListMFADeviceTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMFADeviceTagsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), serialNumber: \(String(describing: serialNumber)))"}
}

extension ListMFADeviceTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        try container.encode("ListMFADeviceTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListMFADeviceTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMFADeviceTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMFADeviceTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMFADeviceTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMFADeviceTagsInput>
    public typealias MOutput = OperationOutput<ListMFADeviceTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMFADeviceTagsOutputError>
}

public struct ListMFADeviceTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMFADeviceTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMFADeviceTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMFADeviceTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMFADeviceTagsInput>
    public typealias MOutput = OperationOutput<ListMFADeviceTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMFADeviceTagsOutputError>
}

public struct ListMFADeviceTagsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The unique identifier for the IAM virtual MFA device whose tags you want to see.
    ///       For virtual MFA devices, the serial number is the same as the ARN.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let serialNumber: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        serialNumber: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serialNumber = serialNumber
    }
}

extension ListMFADeviceTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListMFADeviceTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMFADeviceTagsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMFADeviceTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMFADeviceTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListMFADeviceTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMFADeviceTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListMFADeviceTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the virtual MFA device. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListMFADeviceTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListMFADeviceTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListMFADeviceTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListMFADevicesInputBodyMiddleware: Middleware {
    public let id: String = "ListMFADevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMFADevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMFADevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMFADevicesInput>
    public typealias MOutput = OperationOutput<ListMFADevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMFADevicesOutputError>
}

extension ListMFADevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMFADevicesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), userName: \(String(describing: userName)))"}
}

extension ListMFADevicesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListMFADevices", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListMFADevicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListMFADevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMFADevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMFADevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMFADevicesInput>
    public typealias MOutput = OperationOutput<ListMFADevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMFADevicesOutputError>
}

public struct ListMFADevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMFADevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMFADevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMFADevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMFADevicesInput>
    public typealias MOutput = OperationOutput<ListMFADevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMFADevicesOutputError>
}

public struct ListMFADevicesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the user whose MFA devices you want to list.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListMFADevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListMFADevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMFADevicesOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMFADevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMFADevicesOutputResponse(isTruncated: \(String(describing: isTruncated)), mFADevices: \(String(describing: mFADevices)), marker: \(String(describing: marker)))"}
}

extension ListMFADevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMFADevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.mFADevices = output.mFADevices
            self.marker = output.marker
        } else {
            self.isTruncated = false
            self.mFADevices = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListMFADevices</a> request.
///     </p>
public struct ListMFADevicesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>A list of MFA devices.</p>
    public let mFADevices: [MFADevice]?
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        isTruncated: Bool = false,
        mFADevices: [MFADevice]? = nil,
        marker: String? = nil
    )
    {
        self.isTruncated = isTruncated
        self.mFADevices = mFADevices
        self.marker = marker
    }
}

struct ListMFADevicesOutputResponseBody: Equatable {
    public let mFADevices: [MFADevice]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListMFADevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case mFADevices = "MFADevices"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListMFADevicesResult"))
        if containerValues.contains(.mFADevices) {
            struct KeyVal0{struct member{}}
            let mFADevicesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .mFADevices)
            if let mFADevicesWrappedContainer = mFADevicesWrappedContainer {
                let mFADevicesContainer = try mFADevicesWrappedContainer.decodeIfPresent([MFADevice].self, forKey: .member)
                var mFADevicesBuffer:[MFADevice]? = nil
                if let mFADevicesContainer = mFADevicesContainer {
                    mFADevicesBuffer = [MFADevice]()
                    for structureContainer0 in mFADevicesContainer {
                        mFADevicesBuffer?.append(structureContainer0)
                    }
                }
                mFADevices = mFADevicesBuffer
            } else {
                mFADevices = []
            }
        } else {
            mFADevices = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListOpenIDConnectProviderTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListOpenIDConnectProviderTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpenIDConnectProviderTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpenIDConnectProviderTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpenIDConnectProviderTagsInput>
    public typealias MOutput = OperationOutput<ListOpenIDConnectProviderTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpenIDConnectProviderTagsOutputError>
}

extension ListOpenIDConnectProviderTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpenIDConnectProviderTagsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)))"}
}

extension ListOpenIDConnectProviderTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        try container.encode("ListOpenIDConnectProviderTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListOpenIDConnectProviderTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOpenIDConnectProviderTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpenIDConnectProviderTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpenIDConnectProviderTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpenIDConnectProviderTagsInput>
    public typealias MOutput = OperationOutput<ListOpenIDConnectProviderTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpenIDConnectProviderTagsOutputError>
}

public struct ListOpenIDConnectProviderTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOpenIDConnectProviderTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpenIDConnectProviderTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpenIDConnectProviderTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpenIDConnectProviderTagsInput>
    public typealias MOutput = OperationOutput<ListOpenIDConnectProviderTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpenIDConnectProviderTagsOutputError>
}

public struct ListOpenIDConnectProviderTagsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to
    ///       see.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let openIDConnectProviderArn: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        openIDConnectProviderArn: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension ListOpenIDConnectProviderTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOpenIDConnectProviderTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpenIDConnectProviderTagsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpenIDConnectProviderTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpenIDConnectProviderTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListOpenIDConnectProviderTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOpenIDConnectProviderTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListOpenIDConnectProviderTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the OpenID Connect (OIDC) identity
    ///       provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListOpenIDConnectProviderTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListOpenIDConnectProviderTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListOpenIDConnectProviderTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListOpenIDConnectProvidersInputBodyMiddleware: Middleware {
    public let id: String = "ListOpenIDConnectProvidersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpenIDConnectProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpenIDConnectProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpenIDConnectProvidersInput>
    public typealias MOutput = OperationOutput<ListOpenIDConnectProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpenIDConnectProvidersOutputError>
}

extension ListOpenIDConnectProvidersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpenIDConnectProvidersInput()"}
}

extension ListOpenIDConnectProvidersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("ListOpenIDConnectProviders", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListOpenIDConnectProvidersInputHeadersMiddleware: Middleware {
    public let id: String = "ListOpenIDConnectProvidersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpenIDConnectProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpenIDConnectProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpenIDConnectProvidersInput>
    public typealias MOutput = OperationOutput<ListOpenIDConnectProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpenIDConnectProvidersOutputError>
}

public struct ListOpenIDConnectProvidersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOpenIDConnectProvidersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpenIDConnectProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpenIDConnectProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpenIDConnectProvidersInput>
    public typealias MOutput = OperationOutput<ListOpenIDConnectProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpenIDConnectProvidersOutputError>
}

public struct ListOpenIDConnectProvidersInput: Equatable {

    public init() {}
}

extension ListOpenIDConnectProvidersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOpenIDConnectProvidersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpenIDConnectProvidersOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpenIDConnectProvidersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpenIDConnectProvidersOutputResponse(openIDConnectProviderList: \(String(describing: openIDConnectProviderList)))"}
}

extension ListOpenIDConnectProvidersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOpenIDConnectProvidersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.openIDConnectProviderList = output.openIDConnectProviderList
        } else {
            self.openIDConnectProviderList = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListOpenIDConnectProviders</a>
///       request. </p>
public struct ListOpenIDConnectProvidersOutputResponse: Equatable {
    /// <p>The list of IAM OIDC provider resource objects defined in the AWS account.</p>
    public let openIDConnectProviderList: [OpenIDConnectProviderListEntry]?

    public init (
        openIDConnectProviderList: [OpenIDConnectProviderListEntry]? = nil
    )
    {
        self.openIDConnectProviderList = openIDConnectProviderList
    }
}

struct ListOpenIDConnectProvidersOutputResponseBody: Equatable {
    public let openIDConnectProviderList: [OpenIDConnectProviderListEntry]?
}

extension ListOpenIDConnectProvidersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case openIDConnectProviderList = "OpenIDConnectProviderList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListOpenIDConnectProvidersResult"))
        if containerValues.contains(.openIDConnectProviderList) {
            struct KeyVal0{struct member{}}
            let openIDConnectProviderListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .openIDConnectProviderList)
            if let openIDConnectProviderListWrappedContainer = openIDConnectProviderListWrappedContainer {
                let openIDConnectProviderListContainer = try openIDConnectProviderListWrappedContainer.decodeIfPresent([OpenIDConnectProviderListEntry].self, forKey: .member)
                var openIDConnectProviderListBuffer:[OpenIDConnectProviderListEntry]? = nil
                if let openIDConnectProviderListContainer = openIDConnectProviderListContainer {
                    openIDConnectProviderListBuffer = [OpenIDConnectProviderListEntry]()
                    for structureContainer0 in openIDConnectProviderListContainer {
                        openIDConnectProviderListBuffer?.append(structureContainer0)
                    }
                }
                openIDConnectProviderList = openIDConnectProviderListBuffer
            } else {
                openIDConnectProviderList = []
            }
        } else {
            openIDConnectProviderList = nil
        }
    }
}

extension ListPoliciesGrantingServiceAccessEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policies = "Policies"
        case serviceNamespace = "ServiceNamespace"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policies = policies {
            var policiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Policies"))
            for (index0, policygrantingserviceaccess0) in policies.enumerated() {
                try policiesContainer.encode(policygrantingserviceaccess0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: Key("ServiceNamespace"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([PolicyGrantingServiceAccess].self, forKey: .member)
                var policiesBuffer:[PolicyGrantingServiceAccess]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [PolicyGrantingServiceAccess]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
    }
}

extension ListPoliciesGrantingServiceAccessEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesGrantingServiceAccessEntry(policies: \(String(describing: policies)), serviceNamespace: \(String(describing: serviceNamespace)))"}
}

/// <p>Contains details about the permissions policies that are attached to the specified
///          identity (user, group, or role).</p>
///          <p>This data type is used as a response element in the <a>ListPoliciesGrantingServiceAccess</a> operation.</p>
public struct ListPoliciesGrantingServiceAccessEntry: Equatable {
    /// <p>The <code>PoliciesGrantingServiceAccess</code> object that contains details about the
    ///          policy.</p>
    public let policies: [PolicyGrantingServiceAccess]?
    /// <p>The namespace of the service that was accessed.</p>
    ///          <p>To learn the service namespace of a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
    ///             <i>Service Authorization Reference</i>. Choose the name of the service to
    ///          view details for that service. In the first paragraph, find the service prefix. For
    ///          example, <code>(service prefix: a4b)</code>. For more information about service namespaces,
    ///          see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
    ///             service namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let serviceNamespace: String?

    public init (
        policies: [PolicyGrantingServiceAccess]? = nil,
        serviceNamespace: String? = nil
    )
    {
        self.policies = policies
        self.serviceNamespace = serviceNamespace
    }
}

public struct ListPoliciesGrantingServiceAccessInputBodyMiddleware: Middleware {
    public let id: String = "ListPoliciesGrantingServiceAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesGrantingServiceAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesGrantingServiceAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesGrantingServiceAccessInput>
    public typealias MOutput = OperationOutput<ListPoliciesGrantingServiceAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesGrantingServiceAccessOutputError>
}

extension ListPoliciesGrantingServiceAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesGrantingServiceAccessInput(arn: \(String(describing: arn)), marker: \(String(describing: marker)), serviceNamespaces: \(String(describing: serviceNamespaces)))"}
}

extension ListPoliciesGrantingServiceAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let serviceNamespaces = serviceNamespaces {
            var serviceNamespacesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ServiceNamespaces"))
            for (index0, servicenamespacetype0) in serviceNamespaces.enumerated() {
                try serviceNamespacesContainer.encode(servicenamespacetype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ListPoliciesGrantingServiceAccess", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListPoliciesGrantingServiceAccessInputHeadersMiddleware: Middleware {
    public let id: String = "ListPoliciesGrantingServiceAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesGrantingServiceAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesGrantingServiceAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesGrantingServiceAccessInput>
    public typealias MOutput = OperationOutput<ListPoliciesGrantingServiceAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesGrantingServiceAccessOutputError>
}

public struct ListPoliciesGrantingServiceAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPoliciesGrantingServiceAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesGrantingServiceAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesGrantingServiceAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesGrantingServiceAccessInput>
    public typealias MOutput = OperationOutput<ListPoliciesGrantingServiceAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesGrantingServiceAccessOutputError>
}

public struct ListPoliciesGrantingServiceAccessInput: Equatable {
    /// <p>The ARN of the IAM identity (user, group, or role) whose policies you want to
    ///             list.</p>
    public let arn: String?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>The service namespace for the AWS services whose policies you want to list.</p>
    ///         <p>To learn the service namespace for a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
    ///                 <i>IAM User Guide</i>. Choose the name of the service to view
    ///             details for that service. In the first paragraph, find the service prefix. For example,
    ///                 <code>(service prefix: a4b)</code>. For more information about service namespaces,
    ///             see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
    ///                 service namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let serviceNamespaces: [String]?

    public init (
        arn: String? = nil,
        marker: String? = nil,
        serviceNamespaces: [String]? = nil
    )
    {
        self.arn = arn
        self.marker = marker
        self.serviceNamespaces = serviceNamespaces
    }
}

extension ListPoliciesGrantingServiceAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPoliciesGrantingServiceAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPoliciesGrantingServiceAccessOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesGrantingServiceAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesGrantingServiceAccessOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), policiesGrantingServiceAccess: \(String(describing: policiesGrantingServiceAccess)))"}
}

extension ListPoliciesGrantingServiceAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPoliciesGrantingServiceAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policiesGrantingServiceAccess = output.policiesGrantingServiceAccess
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policiesGrantingServiceAccess = nil
        }
    }
}

public struct ListPoliciesGrantingServiceAccessOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your results were
    ///             truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///             request parameter to retrieve more items. We recommend that you check
    ///                 <code>IsTruncated</code> after every call to ensure that you receive all your
    ///             results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A <code>ListPoliciesGrantingServiceAccess</code> object that contains details about
    ///             the permissions policies attached to the specified identity (user, group, or
    ///             role).</p>
    public let policiesGrantingServiceAccess: [ListPoliciesGrantingServiceAccessEntry]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        policiesGrantingServiceAccess: [ListPoliciesGrantingServiceAccessEntry]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policiesGrantingServiceAccess = policiesGrantingServiceAccess
    }
}

struct ListPoliciesGrantingServiceAccessOutputResponseBody: Equatable {
    public let policiesGrantingServiceAccess: [ListPoliciesGrantingServiceAccessEntry]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListPoliciesGrantingServiceAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policiesGrantingServiceAccess = "PoliciesGrantingServiceAccess"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPoliciesGrantingServiceAccessResult"))
        if containerValues.contains(.policiesGrantingServiceAccess) {
            struct KeyVal0{struct member{}}
            let policiesGrantingServiceAccessWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policiesGrantingServiceAccess)
            if let policiesGrantingServiceAccessWrappedContainer = policiesGrantingServiceAccessWrappedContainer {
                let policiesGrantingServiceAccessContainer = try policiesGrantingServiceAccessWrappedContainer.decodeIfPresent([ListPoliciesGrantingServiceAccessEntry].self, forKey: .member)
                var policiesGrantingServiceAccessBuffer:[ListPoliciesGrantingServiceAccessEntry]? = nil
                if let policiesGrantingServiceAccessContainer = policiesGrantingServiceAccessContainer {
                    policiesGrantingServiceAccessBuffer = [ListPoliciesGrantingServiceAccessEntry]()
                    for structureContainer0 in policiesGrantingServiceAccessContainer {
                        policiesGrantingServiceAccessBuffer?.append(structureContainer0)
                    }
                }
                policiesGrantingServiceAccess = policiesGrantingServiceAccessBuffer
            } else {
                policiesGrantingServiceAccess = []
            }
        } else {
            policiesGrantingServiceAccess = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

extension ListPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), onlyAttached: \(String(describing: onlyAttached)), pathPrefix: \(String(describing: pathPrefix)), policyUsageFilter: \(String(describing: policyUsageFilter)), scope: \(String(describing: scope)))"}
}

extension ListPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if onlyAttached != false {
            try container.encode(onlyAttached, forKey: Key("OnlyAttached"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: Key("PolicyUsageFilter"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: Key("Scope"))
        }
        try container.encode("ListPolicies", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

public struct ListPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

public struct ListPoliciesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>A flag to filter the results to only the attached policies.</p>
    ///         <p>When <code>OnlyAttached</code> is <code>true</code>, the returned list contains only
    ///             the policies that are attached to an IAM user, group, or role. When
    ///                 <code>OnlyAttached</code> is <code>false</code>, or when the parameter is not
    ///             included, all policies are returned.</p>
    public let onlyAttached: Bool
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    ///             included, it defaults to a slash (/), listing all policies. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?
    /// <p>The policy usage method to use for filtering the results.</p>
    ///         <p>To list only permissions policies,
    ///                 set <code>PolicyUsageFilter</code> to <code>PermissionsPolicy</code>. To list only
    ///             the policies used to set permissions boundaries, set the value
    ///                 to <code>PermissionsBoundary</code>.</p>
    ///         <p>This parameter is optional. If it is not included, all policies are returned. </p>
    public let policyUsageFilter: PolicyUsageType?
    /// <p>The scope to use for filtering the results.</p>
    ///         <p>To list only AWS managed policies, set <code>Scope</code> to <code>AWS</code>. To
    ///             list only the customer managed policies in your AWS account, set <code>Scope</code> to
    ///                 <code>Local</code>.</p>
    ///         <p>This parameter is optional. If it is not included, or if it is set to
    ///             <code>All</code>, all policies are returned.</p>
    public let scope: PolicyScopeType?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        onlyAttached: Bool = false,
        pathPrefix: String? = nil,
        policyUsageFilter: PolicyUsageType? = nil,
        scope: PolicyScopeType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.onlyAttached = onlyAttached
        self.pathPrefix = pathPrefix
        self.policyUsageFilter = policyUsageFilter
        self.scope = scope
    }
}

extension ListPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPoliciesOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), policies: \(String(describing: policies)))"}
}

extension ListPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policies = output.policies
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policies = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListPolicies</a> request.
///     </p>
public struct ListPoliciesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of policies.</p>
    public let policies: [Policy]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        policies: [Policy]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
    }
}

struct ListPoliciesOutputResponseBody: Equatable {
    public let policies: [Policy]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policies = "Policies"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPoliciesResult"))
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([Policy].self, forKey: .member)
                var policiesBuffer:[Policy]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [Policy]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListPolicyTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListPolicyTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyTagsInput>
    public typealias MOutput = OperationOutput<ListPolicyTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyTagsOutputError>
}

extension ListPolicyTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyTagsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), policyArn: \(String(describing: policyArn)))"}
}

extension ListPolicyTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        try container.encode("ListPolicyTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListPolicyTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPolicyTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyTagsInput>
    public typealias MOutput = OperationOutput<ListPolicyTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyTagsOutputError>
}

public struct ListPolicyTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPolicyTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyTagsInput>
    public typealias MOutput = OperationOutput<ListPolicyTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyTagsOutputError>
}

public struct ListPolicyTagsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The ARN of the IAM customer managed policy whose tags you want to see.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let policyArn: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        policyArn: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

extension ListPolicyTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPolicyTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyTagsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListPolicyTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPolicyTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListPolicyTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the IAM customer managed policy.
    ///       Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListPolicyTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListPolicyTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPolicyTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListPolicyVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListPolicyVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyVersionsInput>
    public typealias MOutput = OperationOutput<ListPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyVersionsOutputError>
}

extension ListPolicyVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyVersionsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), policyArn: \(String(describing: policyArn)))"}
}

extension ListPolicyVersionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        try container.encode("ListPolicyVersions", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListPolicyVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPolicyVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyVersionsInput>
    public typealias MOutput = OperationOutput<ListPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyVersionsOutputError>
}

public struct ListPolicyVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPolicyVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyVersionsInput>
    public typealias MOutput = OperationOutput<ListPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyVersionsOutputError>
}

public struct ListPolicyVersionsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
    ///             versions.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        policyArn: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

extension ListPolicyVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPolicyVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyVersionsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyVersionsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), versions: \(String(describing: versions)))"}
}

extension ListPolicyVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPolicyVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.versions = output.versions
        } else {
            self.isTruncated = false
            self.marker = nil
            self.versions = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListPolicyVersions</a> request.
///     </p>
public struct ListPolicyVersionsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of policy versions.</p>
    ///         <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    ///                 policies</a> in the <i>IAM User Guide</i>.</p>
    public let versions: [PolicyVersion]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        versions: [PolicyVersion]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.versions = versions
    }
}

struct ListPolicyVersionsOutputResponseBody: Equatable {
    public let versions: [PolicyVersion]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListPolicyVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPolicyVersionsResult"))
        if containerValues.contains(.versions) {
            struct KeyVal0{struct member{}}
            let versionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .versions)
            if let versionsWrappedContainer = versionsWrappedContainer {
                let versionsContainer = try versionsWrappedContainer.decodeIfPresent([PolicyVersion].self, forKey: .member)
                var versionsBuffer:[PolicyVersion]? = nil
                if let versionsContainer = versionsContainer {
                    versionsBuffer = [PolicyVersion]()
                    for structureContainer0 in versionsContainer {
                        versionsBuffer?.append(structureContainer0)
                    }
                }
                versions = versionsBuffer
            } else {
                versions = []
            }
        } else {
            versions = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListRolePoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListRolePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRolePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRolePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRolePoliciesInput>
    public typealias MOutput = OperationOutput<ListRolePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRolePoliciesOutputError>
}

extension ListRolePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRolePoliciesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), roleName: \(String(describing: roleName)))"}
}

extension ListRolePoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("ListRolePolicies", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListRolePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRolePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRolePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRolePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRolePoliciesInput>
    public typealias MOutput = OperationOutput<ListRolePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRolePoliciesOutputError>
}

public struct ListRolePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRolePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRolePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRolePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRolePoliciesInput>
    public typealias MOutput = OperationOutput<ListRolePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRolePoliciesOutputError>
}

public struct ListRolePoliciesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the role to list policies for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        roleName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

extension ListRolePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRolePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRolePoliciesOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRolePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRolePoliciesOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), policyNames: \(String(describing: policyNames)))"}
}

extension ListRolePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRolePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListRolePolicies</a> request.
///     </p>
public struct ListRolePoliciesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of policy names.</p>
    public let policyNames: [String]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        policyNames: [String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListRolePoliciesOutputResponseBody: Equatable {
    public let policyNames: [String]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListRolePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListRolePoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var policyNamesBuffer:[String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListRoleTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListRoleTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoleTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoleTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoleTagsInput>
    public typealias MOutput = OperationOutput<ListRoleTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoleTagsOutputError>
}

extension ListRoleTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoleTagsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), roleName: \(String(describing: roleName)))"}
}

extension ListRoleTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("ListRoleTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListRoleTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRoleTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoleTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoleTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoleTagsInput>
    public typealias MOutput = OperationOutput<ListRoleTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoleTagsOutputError>
}

public struct ListRoleTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRoleTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoleTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoleTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoleTagsInput>
    public typealias MOutput = OperationOutput<ListRoleTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoleTagsOutputError>
}

public struct ListRoleTagsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the IAM role for which you want to see the list of tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        roleName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

extension ListRoleTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRoleTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoleTagsOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoleTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoleTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListRoleTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRoleTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListRoleTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the role. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListRoleTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListRoleTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListRoleTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListRolesInputBodyMiddleware: Middleware {
    public let id: String = "ListRolesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRolesInput>
    public typealias MOutput = OperationOutput<ListRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRolesOutputError>
}

extension ListRolesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRolesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)))"}
}

extension ListRolesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        try container.encode("ListRoles", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListRolesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRolesInput>
    public typealias MOutput = OperationOutput<ListRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRolesOutputError>
}

public struct ListRolesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRolesInput>
    public typealias MOutput = OperationOutput<ListRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRolesOutputError>
}

public struct ListRolesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p> The path prefix for filtering the results. For example, the prefix
    ///                 <code>/application_abc/component_xyz/</code> gets all roles whose path starts with
    ///                 <code>/application_abc/component_xyz/</code>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    ///             all roles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListRolesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRolesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRolesOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRolesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRolesOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), roles: \(String(describing: roles)))"}
}

extension ListRolesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRolesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.roles = output.roles
        } else {
            self.isTruncated = false
            self.marker = nil
            self.roles = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListRoles</a> request. </p>
public struct ListRolesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of roles.</p>
    public let roles: [Role]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        roles: [Role]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.roles = roles
    }
}

struct ListRolesOutputResponseBody: Equatable {
    public let roles: [Role]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListRolesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case roles = "Roles"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListRolesResult"))
        if containerValues.contains(.roles) {
            struct KeyVal0{struct member{}}
            let rolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roles)
            if let rolesWrappedContainer = rolesWrappedContainer {
                let rolesContainer = try rolesWrappedContainer.decodeIfPresent([Role].self, forKey: .member)
                var rolesBuffer:[Role]? = nil
                if let rolesContainer = rolesContainer {
                    rolesBuffer = [Role]()
                    for structureContainer0 in rolesContainer {
                        rolesBuffer?.append(structureContainer0)
                    }
                }
                roles = rolesBuffer
            } else {
                roles = []
            }
        } else {
            roles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListSAMLProviderTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListSAMLProviderTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSAMLProviderTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSAMLProviderTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSAMLProviderTagsInput>
    public typealias MOutput = OperationOutput<ListSAMLProviderTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSAMLProviderTagsOutputError>
}

extension ListSAMLProviderTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSAMLProviderTagsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), sAMLProviderArn: \(String(describing: sAMLProviderArn)))"}
}

extension ListSAMLProviderTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let sAMLProviderArn = sAMLProviderArn {
            try container.encode(sAMLProviderArn, forKey: Key("SAMLProviderArn"))
        }
        try container.encode("ListSAMLProviderTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListSAMLProviderTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSAMLProviderTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSAMLProviderTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSAMLProviderTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSAMLProviderTagsInput>
    public typealias MOutput = OperationOutput<ListSAMLProviderTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSAMLProviderTagsOutputError>
}

public struct ListSAMLProviderTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSAMLProviderTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSAMLProviderTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSAMLProviderTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSAMLProviderTagsInput>
    public typealias MOutput = OperationOutput<ListSAMLProviderTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSAMLProviderTagsOutputError>
}

public struct ListSAMLProviderTagsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags
    ///       you want to see.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let sAMLProviderArn: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        sAMLProviderArn: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.sAMLProviderArn = sAMLProviderArn
    }
}

extension ListSAMLProviderTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSAMLProviderTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSAMLProviderTagsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSAMLProviderTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSAMLProviderTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListSAMLProviderTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSAMLProviderTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListSAMLProviderTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the Security Assertion Markup Language
    ///       (SAML) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListSAMLProviderTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListSAMLProviderTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListSAMLProviderTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListSAMLProvidersInputBodyMiddleware: Middleware {
    public let id: String = "ListSAMLProvidersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSAMLProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSAMLProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSAMLProvidersInput>
    public typealias MOutput = OperationOutput<ListSAMLProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSAMLProvidersOutputError>
}

extension ListSAMLProvidersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSAMLProvidersInput()"}
}

extension ListSAMLProvidersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("ListSAMLProviders", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListSAMLProvidersInputHeadersMiddleware: Middleware {
    public let id: String = "ListSAMLProvidersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSAMLProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSAMLProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSAMLProvidersInput>
    public typealias MOutput = OperationOutput<ListSAMLProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSAMLProvidersOutputError>
}

public struct ListSAMLProvidersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSAMLProvidersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSAMLProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSAMLProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSAMLProvidersInput>
    public typealias MOutput = OperationOutput<ListSAMLProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSAMLProvidersOutputError>
}

public struct ListSAMLProvidersInput: Equatable {

    public init() {}
}

extension ListSAMLProvidersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSAMLProvidersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSAMLProvidersOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSAMLProvidersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSAMLProvidersOutputResponse(sAMLProviderList: \(String(describing: sAMLProviderList)))"}
}

extension ListSAMLProvidersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSAMLProvidersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sAMLProviderList = output.sAMLProviderList
        } else {
            self.sAMLProviderList = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListSAMLProviders</a> request.
///     </p>
public struct ListSAMLProvidersOutputResponse: Equatable {
    /// <p>The list of SAML provider resource objects defined in IAM for this AWS
    ///             account.</p>
    public let sAMLProviderList: [SAMLProviderListEntry]?

    public init (
        sAMLProviderList: [SAMLProviderListEntry]? = nil
    )
    {
        self.sAMLProviderList = sAMLProviderList
    }
}

struct ListSAMLProvidersOutputResponseBody: Equatable {
    public let sAMLProviderList: [SAMLProviderListEntry]?
}

extension ListSAMLProvidersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sAMLProviderList = "SAMLProviderList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListSAMLProvidersResult"))
        if containerValues.contains(.sAMLProviderList) {
            struct KeyVal0{struct member{}}
            let sAMLProviderListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sAMLProviderList)
            if let sAMLProviderListWrappedContainer = sAMLProviderListWrappedContainer {
                let sAMLProviderListContainer = try sAMLProviderListWrappedContainer.decodeIfPresent([SAMLProviderListEntry].self, forKey: .member)
                var sAMLProviderListBuffer:[SAMLProviderListEntry]? = nil
                if let sAMLProviderListContainer = sAMLProviderListContainer {
                    sAMLProviderListBuffer = [SAMLProviderListEntry]()
                    for structureContainer0 in sAMLProviderListContainer {
                        sAMLProviderListBuffer?.append(structureContainer0)
                    }
                }
                sAMLProviderList = sAMLProviderListBuffer
            } else {
                sAMLProviderList = []
            }
        } else {
            sAMLProviderList = nil
        }
    }
}

public struct ListSSHPublicKeysInputBodyMiddleware: Middleware {
    public let id: String = "ListSSHPublicKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSSHPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSSHPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSSHPublicKeysInput>
    public typealias MOutput = OperationOutput<ListSSHPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSSHPublicKeysOutputError>
}

extension ListSSHPublicKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSSHPublicKeysInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), userName: \(String(describing: userName)))"}
}

extension ListSSHPublicKeysInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListSSHPublicKeys", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListSSHPublicKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListSSHPublicKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSSHPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSSHPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSSHPublicKeysInput>
    public typealias MOutput = OperationOutput<ListSSHPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSSHPublicKeysOutputError>
}

public struct ListSSHPublicKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSSHPublicKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSSHPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSSHPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSSHPublicKeysInput>
    public typealias MOutput = OperationOutput<ListSSHPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSSHPublicKeysOutputError>
}

public struct ListSSHPublicKeysInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the IAM user to list SSH public keys for. If none is specified, the
    ///                 <code>UserName</code> field is determined implicitly based on the AWS access key
    ///             used to sign the request.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListSSHPublicKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSSHPublicKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSSHPublicKeysOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSSHPublicKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSSHPublicKeysOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), sSHPublicKeys: \(String(describing: sSHPublicKeys)))"}
}

extension ListSSHPublicKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSSHPublicKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.sSHPublicKeys = output.sSHPublicKeys
        } else {
            self.isTruncated = false
            self.marker = nil
            self.sSHPublicKeys = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListSSHPublicKeys</a>
///       request.</p>
public struct ListSSHPublicKeysOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of the SSH public keys assigned to IAM user.</p>
    public let sSHPublicKeys: [SSHPublicKeyMetadata]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        sSHPublicKeys: [SSHPublicKeyMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.sSHPublicKeys = sSHPublicKeys
    }
}

struct ListSSHPublicKeysOutputResponseBody: Equatable {
    public let sSHPublicKeys: [SSHPublicKeyMetadata]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListSSHPublicKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case sSHPublicKeys = "SSHPublicKeys"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListSSHPublicKeysResult"))
        if containerValues.contains(.sSHPublicKeys) {
            struct KeyVal0{struct member{}}
            let sSHPublicKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sSHPublicKeys)
            if let sSHPublicKeysWrappedContainer = sSHPublicKeysWrappedContainer {
                let sSHPublicKeysContainer = try sSHPublicKeysWrappedContainer.decodeIfPresent([SSHPublicKeyMetadata].self, forKey: .member)
                var sSHPublicKeysBuffer:[SSHPublicKeyMetadata]? = nil
                if let sSHPublicKeysContainer = sSHPublicKeysContainer {
                    sSHPublicKeysBuffer = [SSHPublicKeyMetadata]()
                    for structureContainer0 in sSHPublicKeysContainer {
                        sSHPublicKeysBuffer?.append(structureContainer0)
                    }
                }
                sSHPublicKeys = sSHPublicKeysBuffer
            } else {
                sSHPublicKeys = []
            }
        } else {
            sSHPublicKeys = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListServerCertificateTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListServerCertificateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerCertificateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerCertificateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerCertificateTagsInput>
    public typealias MOutput = OperationOutput<ListServerCertificateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerCertificateTagsOutputError>
}

extension ListServerCertificateTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServerCertificateTagsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), serverCertificateName: \(String(describing: serverCertificateName)))"}
}

extension ListServerCertificateTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        try container.encode("ListServerCertificateTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListServerCertificateTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListServerCertificateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerCertificateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerCertificateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerCertificateTagsInput>
    public typealias MOutput = OperationOutput<ListServerCertificateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerCertificateTagsOutputError>
}

public struct ListServerCertificateTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServerCertificateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerCertificateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerCertificateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerCertificateTagsInput>
    public typealias MOutput = OperationOutput<ListServerCertificateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerCertificateTagsOutputError>
}

public struct ListServerCertificateTagsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the IAM server certificate whose tags you want to see.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let serverCertificateName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        serverCertificateName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serverCertificateName = serverCertificateName
    }
}

extension ListServerCertificateTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListServerCertificateTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServerCertificateTagsOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServerCertificateTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServerCertificateTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListServerCertificateTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServerCertificateTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListServerCertificateTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the IAM server certificate.
    ///       Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListServerCertificateTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListServerCertificateTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListServerCertificateTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListServerCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "ListServerCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerCertificatesInput>
    public typealias MOutput = OperationOutput<ListServerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerCertificatesOutputError>
}

extension ListServerCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServerCertificatesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)))"}
}

extension ListServerCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        try container.encode("ListServerCertificates", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListServerCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListServerCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerCertificatesInput>
    public typealias MOutput = OperationOutput<ListServerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerCertificatesOutputError>
}

public struct ListServerCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServerCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerCertificatesInput>
    public typealias MOutput = OperationOutput<ListServerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerCertificatesOutputError>
}

public struct ListServerCertificatesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p> The path prefix for filtering the results. For example:
    ///                 <code>/company/servercerts</code> would get all server certificates for which the
    ///             path starts with <code>/company/servercerts</code>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    ///             all server certificates. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListServerCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListServerCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServerCertificatesOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServerCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServerCertificatesOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), serverCertificateMetadataList: \(String(describing: serverCertificateMetadataList)))"}
}

extension ListServerCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServerCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.serverCertificateMetadataList = output.serverCertificateMetadataList
        } else {
            self.isTruncated = false
            self.marker = nil
            self.serverCertificateMetadataList = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListServerCertificates</a> request.
///     </p>
public struct ListServerCertificatesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of server certificates.</p>
    public let serverCertificateMetadataList: [ServerCertificateMetadata]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        serverCertificateMetadataList: [ServerCertificateMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.serverCertificateMetadataList = serverCertificateMetadataList
    }
}

struct ListServerCertificatesOutputResponseBody: Equatable {
    public let serverCertificateMetadataList: [ServerCertificateMetadata]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListServerCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case serverCertificateMetadataList = "ServerCertificateMetadataList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListServerCertificatesResult"))
        if containerValues.contains(.serverCertificateMetadataList) {
            struct KeyVal0{struct member{}}
            let serverCertificateMetadataListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serverCertificateMetadataList)
            if let serverCertificateMetadataListWrappedContainer = serverCertificateMetadataListWrappedContainer {
                let serverCertificateMetadataListContainer = try serverCertificateMetadataListWrappedContainer.decodeIfPresent([ServerCertificateMetadata].self, forKey: .member)
                var serverCertificateMetadataListBuffer:[ServerCertificateMetadata]? = nil
                if let serverCertificateMetadataListContainer = serverCertificateMetadataListContainer {
                    serverCertificateMetadataListBuffer = [ServerCertificateMetadata]()
                    for structureContainer0 in serverCertificateMetadataListContainer {
                        serverCertificateMetadataListBuffer?.append(structureContainer0)
                    }
                }
                serverCertificateMetadataList = serverCertificateMetadataListBuffer
            } else {
                serverCertificateMetadataList = []
            }
        } else {
            serverCertificateMetadataList = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListServiceSpecificCredentialsInputBodyMiddleware: Middleware {
    public let id: String = "ListServiceSpecificCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceSpecificCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceSpecificCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceSpecificCredentialsInput>
    public typealias MOutput = OperationOutput<ListServiceSpecificCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceSpecificCredentialsOutputError>
}

extension ListServiceSpecificCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceSpecificCredentialsInput(serviceName: \(String(describing: serviceName)), userName: \(String(describing: userName)))"}
}

extension ListServiceSpecificCredentialsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListServiceSpecificCredentials", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListServiceSpecificCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "ListServiceSpecificCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceSpecificCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceSpecificCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceSpecificCredentialsInput>
    public typealias MOutput = OperationOutput<ListServiceSpecificCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceSpecificCredentialsOutputError>
}

public struct ListServiceSpecificCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServiceSpecificCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceSpecificCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceSpecificCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceSpecificCredentialsInput>
    public typealias MOutput = OperationOutput<ListServiceSpecificCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceSpecificCredentialsOutputError>
}

public struct ListServiceSpecificCredentialsInput: Equatable {
    /// <p>Filters the returned results to only those for the specified AWS service. If not
    ///             specified, then AWS returns service-specific credentials for all services.</p>
    public let serviceName: String?
    /// <p>The name of the user whose service-specific credentials you want information about. If
    ///             this value is not specified, then the operation assumes the user whose credentials are
    ///             used to call the operation.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        serviceName: String? = nil,
        userName: String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

extension ListServiceSpecificCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListServiceSpecificCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotSupportedException" : self = .serviceNotSupportedException(try ServiceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceSpecificCredentialsOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceNotSupportedException(ServiceNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceSpecificCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceSpecificCredentialsOutputResponse(serviceSpecificCredentials: \(String(describing: serviceSpecificCredentials)))"}
}

extension ListServiceSpecificCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServiceSpecificCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceSpecificCredentials = output.serviceSpecificCredentials
        } else {
            self.serviceSpecificCredentials = nil
        }
    }
}

public struct ListServiceSpecificCredentialsOutputResponse: Equatable {
    /// <p>A list of structures that each contain details about a service-specific
    ///             credential.</p>
    public let serviceSpecificCredentials: [ServiceSpecificCredentialMetadata]?

    public init (
        serviceSpecificCredentials: [ServiceSpecificCredentialMetadata]? = nil
    )
    {
        self.serviceSpecificCredentials = serviceSpecificCredentials
    }
}

struct ListServiceSpecificCredentialsOutputResponseBody: Equatable {
    public let serviceSpecificCredentials: [ServiceSpecificCredentialMetadata]?
}

extension ListServiceSpecificCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceSpecificCredentials = "ServiceSpecificCredentials"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListServiceSpecificCredentialsResult"))
        if containerValues.contains(.serviceSpecificCredentials) {
            struct KeyVal0{struct member{}}
            let serviceSpecificCredentialsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serviceSpecificCredentials)
            if let serviceSpecificCredentialsWrappedContainer = serviceSpecificCredentialsWrappedContainer {
                let serviceSpecificCredentialsContainer = try serviceSpecificCredentialsWrappedContainer.decodeIfPresent([ServiceSpecificCredentialMetadata].self, forKey: .member)
                var serviceSpecificCredentialsBuffer:[ServiceSpecificCredentialMetadata]? = nil
                if let serviceSpecificCredentialsContainer = serviceSpecificCredentialsContainer {
                    serviceSpecificCredentialsBuffer = [ServiceSpecificCredentialMetadata]()
                    for structureContainer0 in serviceSpecificCredentialsContainer {
                        serviceSpecificCredentialsBuffer?.append(structureContainer0)
                    }
                }
                serviceSpecificCredentials = serviceSpecificCredentialsBuffer
            } else {
                serviceSpecificCredentials = []
            }
        } else {
            serviceSpecificCredentials = nil
        }
    }
}

public struct ListSigningCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "ListSigningCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningCertificatesInput>
    public typealias MOutput = OperationOutput<ListSigningCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningCertificatesOutputError>
}

extension ListSigningCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningCertificatesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), userName: \(String(describing: userName)))"}
}

extension ListSigningCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListSigningCertificates", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListSigningCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSigningCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningCertificatesInput>
    public typealias MOutput = OperationOutput<ListSigningCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningCertificatesOutputError>
}

public struct ListSigningCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSigningCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningCertificatesInput>
    public typealias MOutput = OperationOutput<ListSigningCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningCertificatesOutputError>
}

public struct ListSigningCertificatesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the IAM user whose signing certificates you want to examine.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListSigningCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSigningCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSigningCertificatesOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningCertificatesOutputResponse(certificates: \(String(describing: certificates)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension ListSigningCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSigningCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListSigningCertificates</a>
///       request. </p>
public struct ListSigningCertificatesOutputResponse: Equatable {
    /// <p>A list of the user's signing certificate information.</p>
    public let certificates: [SigningCertificate]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        certificates: [SigningCertificate]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.certificates = certificates
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListSigningCertificatesOutputResponseBody: Equatable {
    public let certificates: [SigningCertificate]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListSigningCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates = "Certificates"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListSigningCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([SigningCertificate].self, forKey: .member)
                var certificatesBuffer:[SigningCertificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [SigningCertificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListUserPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListUserPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoliciesInput>
    public typealias MOutput = OperationOutput<ListUserPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoliciesOutputError>
}

extension ListUserPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserPoliciesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), userName: \(String(describing: userName)))"}
}

extension ListUserPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListUserPolicies", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListUserPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoliciesInput>
    public typealias MOutput = OperationOutput<ListUserPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoliciesOutputError>
}

public struct ListUserPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoliciesInput>
    public typealias MOutput = OperationOutput<ListUserPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoliciesOutputError>
}

public struct ListUserPoliciesInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the user to list policies for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListUserPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListUserPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserPoliciesOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserPoliciesOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), policyNames: \(String(describing: policyNames)))"}
}

extension ListUserPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListUserPolicies</a> request.
///     </p>
public struct ListUserPoliciesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of policy names.</p>
    public let policyNames: [String]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        policyNames: [String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListUserPoliciesOutputResponseBody: Equatable {
    public let policyNames: [String]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListUserPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListUserPoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var policyNamesBuffer:[String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListUserTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListUserTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserTagsInput>
    public typealias MOutput = OperationOutput<ListUserTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserTagsOutputError>
}

extension ListUserTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserTagsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), userName: \(String(describing: userName)))"}
}

extension ListUserTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ListUserTags", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListUserTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserTagsInput>
    public typealias MOutput = OperationOutput<ListUserTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserTagsOutputError>
}

public struct ListUserTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserTagsInput>
    public typealias MOutput = OperationOutput<ListUserTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserTagsOutputError>
}

public struct ListUserTagsInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>(Optional) Use this only when paginating results to indicate the
    ///     maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, it defaults to 100. Note that
    ///     IAM might return fewer results, even when more results are available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The name of the IAM user whose tags you want to see.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let userName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        userName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListUserTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListUserTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserTagsOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserTagsOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), tags: \(String(describing: tags)))"}
}

extension ListUserTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListUserTagsOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can use the <code>Marker</code> request parameter to make a subsequent pagination request that retrieves more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when more results are available. Check <code>IsTruncated</code> after every call to ensure that you receive all of your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>The list of tags that are currently attached to the user. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.</p>
    public let tags: [Tag]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListUserTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListUserTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListUserTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListUsersInputBodyMiddleware: Middleware {
    public let id: String = "ListUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

extension ListUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), pathPrefix: \(String(describing: pathPrefix)))"}
}

extension ListUsersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: Key("PathPrefix"))
        }
        try container.encode("ListUsers", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListUsersInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Equatable {
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p> The path prefix for filtering the results. For example:
    ///                 <code>/division_abc/subdivision_xyz/</code>, which would get all user names whose
    ///             path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    ///             all user names. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let pathPrefix: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        pathPrefix: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), users: \(String(describing: users)))"}
}

extension ListUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.users = output.users
        } else {
            self.isTruncated = false
            self.marker = nil
            self.users = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListUsers</a> request. </p>
public struct ListUsersOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?
    /// <p>A list of users.</p>
    public let users: [User]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        users: [User]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Equatable {
    public let users: [User]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListUsersResult"))
        if containerValues.contains(.users) {
            struct KeyVal0{struct member{}}
            let usersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .users)
            if let usersWrappedContainer = usersWrappedContainer {
                let usersContainer = try usersWrappedContainer.decodeIfPresent([User].self, forKey: .member)
                var usersBuffer:[User]? = nil
                if let usersContainer = usersContainer {
                    usersBuffer = [User]()
                    for structureContainer0 in usersContainer {
                        usersBuffer?.append(structureContainer0)
                    }
                }
                users = usersBuffer
            } else {
                users = []
            }
        } else {
            users = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListVirtualMFADevicesInputBodyMiddleware: Middleware {
    public let id: String = "ListVirtualMFADevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualMFADevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualMFADevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualMFADevicesInput>
    public typealias MOutput = OperationOutput<ListVirtualMFADevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualMFADevicesOutputError>
}

extension ListVirtualMFADevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualMFADevicesInput(assignmentStatus: \(String(describing: assignmentStatus)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListVirtualMFADevicesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let assignmentStatus = assignmentStatus {
            try container.encode(assignmentStatus, forKey: Key("AssignmentStatus"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        try container.encode("ListVirtualMFADevices", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ListVirtualMFADevicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListVirtualMFADevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualMFADevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualMFADevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualMFADevicesInput>
    public typealias MOutput = OperationOutput<ListVirtualMFADevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualMFADevicesOutputError>
}

public struct ListVirtualMFADevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVirtualMFADevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualMFADevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualMFADevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualMFADevicesInput>
    public typealias MOutput = OperationOutput<ListVirtualMFADevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualMFADevicesOutputError>
}

public struct ListVirtualMFADevicesInput: Equatable {
    /// <p> The status (<code>Unassigned</code> or <code>Assigned</code>) of the devices to list.
    ///             If you do not specify an <code>AssignmentStatus</code>, the operation defaults to
    ///                 <code>Any</code>, which lists both assigned and unassigned virtual MFA
    ///             devices.,</p>
    public let assignmentStatus: AssignmentStatusType?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?

    public init (
        assignmentStatus: AssignmentStatusType? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListVirtualMFADevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListVirtualMFADevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualMFADevicesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualMFADevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualMFADevicesOutputResponse(isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), virtualMFADevices: \(String(describing: virtualMFADevices)))"}
}

extension ListVirtualMFADevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVirtualMFADevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.virtualMFADevices = output.virtualMFADevices
        } else {
            self.isTruncated = false
            self.marker = nil
            self.virtualMFADevices = nil
        }
    }
}

/// <p>Contains the response to a successful <a>ListVirtualMFADevices</a> request.
///     </p>
public struct ListVirtualMFADevicesOutputResponse: Equatable {
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element is present and
    ///             contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///             pagination request.</p>
    public let marker: String?
    /// <p> The list of virtual MFA devices in the current account that match the
    ///                 <code>AssignmentStatus</code> value that was passed in the request.</p>
    public let virtualMFADevices: [VirtualMFADevice]?

    public init (
        isTruncated: Bool = false,
        marker: String? = nil,
        virtualMFADevices: [VirtualMFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.virtualMFADevices = virtualMFADevices
    }
}

struct ListVirtualMFADevicesOutputResponseBody: Equatable {
    public let virtualMFADevices: [VirtualMFADevice]?
    public let isTruncated: Bool
    public let marker: String?
}

extension ListVirtualMFADevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case virtualMFADevices = "VirtualMFADevices"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListVirtualMFADevicesResult"))
        if containerValues.contains(.virtualMFADevices) {
            struct KeyVal0{struct member{}}
            let virtualMFADevicesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .virtualMFADevices)
            if let virtualMFADevicesWrappedContainer = virtualMFADevicesWrappedContainer {
                let virtualMFADevicesContainer = try virtualMFADevicesWrappedContainer.decodeIfPresent([VirtualMFADevice].self, forKey: .member)
                var virtualMFADevicesBuffer:[VirtualMFADevice]? = nil
                if let virtualMFADevicesContainer = virtualMFADevicesContainer {
                    virtualMFADevicesBuffer = [VirtualMFADevice]()
                    for structureContainer0 in virtualMFADevicesContainer {
                        virtualMFADevicesBuffer?.append(structureContainer0)
                    }
                }
                virtualMFADevices = virtualMFADevicesBuffer
            } else {
                virtualMFADevices = []
            }
        } else {
            virtualMFADevices = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension LoginProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if passwordResetRequired != false {
            try container.encode(passwordResetRequired, forKey: Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let passwordResetRequiredDecoded = try containerValues.decode(Bool.self, forKey: .passwordResetRequired)
        passwordResetRequired = passwordResetRequiredDecoded
    }
}

extension LoginProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoginProfile(createDate: \(String(describing: createDate)), passwordResetRequired: \(String(describing: passwordResetRequired)), userName: \(String(describing: userName)))"}
}

/// <p>Contains the user name and password create date for a user.</p>
///          <p> This data type is used as a response element in the <a>CreateLoginProfile</a> and <a>GetLoginProfile</a> operations. </p>
public struct LoginProfile: Equatable {
    /// <p>The date when the password for the user was created.</p>
    public let createDate: Date?
    /// <p>Specifies whether the user is required to set a new password on next sign-in.</p>
    public let passwordResetRequired: Bool
    /// <p>The name of the user, which can be used for signing in to the AWS Management
    ///          Console.</p>
    public let userName: String?

    public init (
        createDate: Date? = nil,
        passwordResetRequired: Bool = false,
        userName: String? = nil
    )
    {
        self.createDate = createDate
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

extension MFADevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableDate = "EnableDate"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enableDate = enableDate {
            try container.encode(TimestampWrapper(enableDate, format: .dateTime), forKey: Key("enableDate"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let enableDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enableDate)
        var enableDateBuffer:Date? = nil
        if let enableDateDecoded = enableDateDecoded {
            enableDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(enableDateDecoded, format: .dateTime)
        }
        enableDate = enableDateBuffer
    }
}

extension MFADevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MFADevice(enableDate: \(String(describing: enableDate)), serialNumber: \(String(describing: serialNumber)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about an MFA device.</p>
///          <p>This data type is used as a response element in the <a>ListMFADevices</a>
///          operation.</p>
public struct MFADevice: Equatable {
    /// <p>The date when the MFA device was enabled for the user.</p>
    public let enableDate: Date?
    /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices, the
    ///          serial number is the device ARN.</p>
    public let serialNumber: String?
    /// <p>The user with whom the MFA device is associated.</p>
    public let userName: String?

    public init (
        enableDate: Date? = nil,
        serialNumber: String? = nil,
        userName: String? = nil
    )
    {
        self.enableDate = enableDate
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension MalformedCertificateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedCertificateException(message: \(String(describing: message)))"}
}

extension MalformedCertificateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<MalformedCertificateExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the certificate was malformed or expired. The error
///       message describes the specific error.</p>
public struct MalformedCertificateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedCertificateExceptionBody: Equatable {
    public let message: String?
}

extension MalformedCertificateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyDocumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedPolicyDocumentException(message: \(String(describing: message)))"}
}

extension MalformedPolicyDocumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<MalformedPolicyDocumentExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the policy document was malformed. The error message
///       describes the specific error.</p>
public struct MalformedPolicyDocumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Equatable {
    public let message: String?
}

extension MalformedPolicyDocumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ManagedPolicyDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyVersionList = "PolicyVersionList"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let policyVersionList = policyVersionList {
            var policyVersionListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyVersionList"))
            for (index0, policyversion0) in policyVersionList.enumerated() {
                try policyVersionListContainer.encode(policyversion0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let updateDate = updateDate {
            try container.encode(TimestampWrapper(updateDate, format: .dateTime), forKey: Key("updateDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let attachmentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .attachmentCount)
        attachmentCount = attachmentCountDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .permissionsBoundaryUsageCount)
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let isAttachableDecoded = try containerValues.decode(Bool.self, forKey: .isAttachable)
        isAttachable = isAttachableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let updateDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateDate)
        var updateDateBuffer:Date? = nil
        if let updateDateDecoded = updateDateDecoded {
            updateDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updateDateDecoded, format: .dateTime)
        }
        updateDate = updateDateBuffer
        if containerValues.contains(.policyVersionList) {
            struct KeyVal0{struct member{}}
            let policyVersionListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyVersionList)
            if let policyVersionListWrappedContainer = policyVersionListWrappedContainer {
                let policyVersionListContainer = try policyVersionListWrappedContainer.decodeIfPresent([PolicyVersion].self, forKey: .member)
                var policyVersionListBuffer:[PolicyVersion]? = nil
                if let policyVersionListContainer = policyVersionListContainer {
                    policyVersionListBuffer = [PolicyVersion]()
                    for structureContainer0 in policyVersionListContainer {
                        policyVersionListBuffer?.append(structureContainer0)
                    }
                }
                policyVersionList = policyVersionListBuffer
            } else {
                policyVersionList = []
            }
        } else {
            policyVersionList = nil
        }
    }
}

extension ManagedPolicyDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedPolicyDetail(arn: \(String(describing: arn)), attachmentCount: \(String(describing: attachmentCount)), createDate: \(String(describing: createDate)), defaultVersionId: \(String(describing: defaultVersionId)), description: \(String(describing: description)), isAttachable: \(String(describing: isAttachable)), path: \(String(describing: path)), permissionsBoundaryUsageCount: \(String(describing: permissionsBoundaryUsageCount)), policyId: \(String(describing: policyId)), policyName: \(String(describing: policyName)), policyVersionList: \(String(describing: policyVersionList)), updateDate: \(String(describing: updateDate)))"}
}

/// <p>Contains information about a managed policy, including the policy's ARN, versions, and
///          the number of principal entities (users, groups, and roles) that the policy is attached
///          to.</p>
///          <p>This data type is used as a response element in the <a>GetAccountAuthorizationDetails</a> operation.</p>
///          <p>For more information about managed policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html">Managed policies and inline
///             policies</a> in the <i>IAM User Guide</i>. </p>
public struct ManagedPolicyDetail: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let arn: String?
    /// <p>The number of principal entities (users, groups, and roles) that the policy is attached
    ///          to.</p>
    public let attachmentCount: Int?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the policy was created.</p>
    public let createDate: Date?
    /// <p>The identifier for the version of the policy that is set as the default (operative)
    ///          version.</p>
    ///          <p>For more information about policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    ///             policies</a> in the <i>IAM User Guide</i>. </p>
    public let defaultVersionId: String?
    /// <p>A friendly description of the policy.</p>
    public let description: String?
    /// <p>Specifies whether the policy can be attached to an IAM user, group, or role.</p>
    public let isAttachable: Bool
    /// <p>The path to the policy.</p>
    ///          <p>For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let path: String?
    /// <p>The number of entities (users and roles) for which the policy is used as the permissions
    ///          boundary. </p>
    ///          <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///             identities </a> in the <i>IAM User Guide</i>.</p>
    public let permissionsBoundaryUsageCount: Int?
    /// <p>The stable and unique string identifying the policy.</p>
    ///          <p>For more information about IDs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let policyId: String?
    /// <p>The friendly name (not ARN) identifying the policy.</p>
    public let policyName: String?
    /// <p>A list containing information about the versions of the policy.</p>
    public let policyVersionList: [PolicyVersion]?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the policy was last updated.</p>
    ///          <p>When a policy has only one version, this field contains the date and time when the
    ///          policy was created. When a policy has more than one version, this field contains the date
    ///          and time when the most recent policy version was created.</p>
    public let updateDate: Date?

    public init (
        arn: String? = nil,
        attachmentCount: Int? = nil,
        createDate: Date? = nil,
        defaultVersionId: String? = nil,
        description: String? = nil,
        isAttachable: Bool = false,
        path: String? = nil,
        permissionsBoundaryUsageCount: Int? = nil,
        policyId: String? = nil,
        policyName: String? = nil,
        policyVersionList: [PolicyVersion]? = nil,
        updateDate: Date? = nil
    )
    {
        self.arn = arn
        self.attachmentCount = attachmentCount
        self.createDate = createDate
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.isAttachable = isAttachable
        self.path = path
        self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
        self.policyId = policyId
        self.policyName = policyName
        self.policyVersionList = policyVersionList
        self.updateDate = updateDate
    }
}

extension NoSuchEntityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchEntityException(message: \(String(describing: message)))"}
}

extension NoSuchEntityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchEntityExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it referenced a resource entity that does not exist. The
///       error message describes the resource.</p>
public struct NoSuchEntityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchEntityExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchEntityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenIDConnectProviderListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension OpenIDConnectProviderListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpenIDConnectProviderListEntry(arn: \(String(describing: arn)))"}
}

/// <p>Contains the Amazon Resource Name (ARN) for an IAM OpenID Connect provider.</p>
public struct OpenIDConnectProviderListEntry: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension OrganizationsDecisionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedByOrganizations = "AllowedByOrganizations"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowedByOrganizations != false {
            try container.encode(allowedByOrganizations, forKey: Key("AllowedByOrganizations"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedByOrganizationsDecoded = try containerValues.decode(Bool.self, forKey: .allowedByOrganizations)
        allowedByOrganizations = allowedByOrganizationsDecoded
    }
}

extension OrganizationsDecisionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationsDecisionDetail(allowedByOrganizations: \(String(describing: allowedByOrganizations)))"}
}

/// <p>Contains information about the effect that Organizations has on a policy simulation.</p>
public struct OrganizationsDecisionDetail: Equatable {
    /// <p>Specifies whether the simulated operation is allowed by the Organizations service control
    ///          policies that impact the simulated user's account.</p>
    public let allowedByOrganizations: Bool

    public init (
        allowedByOrganizations: Bool = false
    )
    {
        self.allowedByOrganizations = allowedByOrganizations
    }
}

extension PasswordPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowUsersToChangePassword = "AllowUsersToChangePassword"
        case expirePasswords = "ExpirePasswords"
        case hardExpiry = "HardExpiry"
        case maxPasswordAge = "MaxPasswordAge"
        case minimumPasswordLength = "MinimumPasswordLength"
        case passwordReusePrevention = "PasswordReusePrevention"
        case requireLowercaseCharacters = "RequireLowercaseCharacters"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercaseCharacters = "RequireUppercaseCharacters"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowUsersToChangePassword != false {
            try container.encode(allowUsersToChangePassword, forKey: Key("AllowUsersToChangePassword"))
        }
        if expirePasswords != false {
            try container.encode(expirePasswords, forKey: Key("ExpirePasswords"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: Key("PasswordReusePrevention"))
        }
        if requireLowercaseCharacters != false {
            try container.encode(requireLowercaseCharacters, forKey: Key("RequireLowercaseCharacters"))
        }
        if requireNumbers != false {
            try container.encode(requireNumbers, forKey: Key("RequireNumbers"))
        }
        if requireSymbols != false {
            try container.encode(requireSymbols, forKey: Key("RequireSymbols"))
        }
        if requireUppercaseCharacters != false {
            try container.encode(requireUppercaseCharacters, forKey: Key("RequireUppercaseCharacters"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumPasswordLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumPasswordLength)
        minimumPasswordLength = minimumPasswordLengthDecoded
        let requireSymbolsDecoded = try containerValues.decode(Bool.self, forKey: .requireSymbols)
        requireSymbols = requireSymbolsDecoded
        let requireNumbersDecoded = try containerValues.decode(Bool.self, forKey: .requireNumbers)
        requireNumbers = requireNumbersDecoded
        let requireUppercaseCharactersDecoded = try containerValues.decode(Bool.self, forKey: .requireUppercaseCharacters)
        requireUppercaseCharacters = requireUppercaseCharactersDecoded
        let requireLowercaseCharactersDecoded = try containerValues.decode(Bool.self, forKey: .requireLowercaseCharacters)
        requireLowercaseCharacters = requireLowercaseCharactersDecoded
        let allowUsersToChangePasswordDecoded = try containerValues.decode(Bool.self, forKey: .allowUsersToChangePassword)
        allowUsersToChangePassword = allowUsersToChangePasswordDecoded
        let expirePasswordsDecoded = try containerValues.decode(Bool.self, forKey: .expirePasswords)
        expirePasswords = expirePasswordsDecoded
        let maxPasswordAgeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxPasswordAge)
        maxPasswordAge = maxPasswordAgeDecoded
        let passwordReusePreventionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .passwordReusePrevention)
        passwordReusePrevention = passwordReusePreventionDecoded
        let hardExpiryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hardExpiry)
        hardExpiry = hardExpiryDecoded
    }
}

extension PasswordPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PasswordPolicy(allowUsersToChangePassword: \(String(describing: allowUsersToChangePassword)), expirePasswords: \(String(describing: expirePasswords)), hardExpiry: \(String(describing: hardExpiry)), maxPasswordAge: \(String(describing: maxPasswordAge)), minimumPasswordLength: \(String(describing: minimumPasswordLength)), passwordReusePrevention: \(String(describing: passwordReusePrevention)), requireLowercaseCharacters: \(String(describing: requireLowercaseCharacters)), requireNumbers: \(String(describing: requireNumbers)), requireSymbols: \(String(describing: requireSymbols)), requireUppercaseCharacters: \(String(describing: requireUppercaseCharacters)))"}
}

/// <p>Contains information about the account password policy.</p>
///          <p> This data type is used as a response element in the <a>GetAccountPasswordPolicy</a> operation. </p>
public struct PasswordPolicy: Equatable {
    /// <p>Specifies whether IAM users are allowed to change their own password.</p>
    public let allowUsersToChangePassword: Bool
    /// <p>Indicates whether passwords in the account expire. Returns true if
    ///             <code>MaxPasswordAge</code> contains a value greater than 0. Returns false if
    ///          MaxPasswordAge is 0 or not present.</p>
    public let expirePasswords: Bool
    /// <p>Specifies whether IAM users are prevented from setting a new password after their
    ///          password has expired.</p>
    public let hardExpiry: Bool?
    /// <p>The number of days that an IAM user password is valid.</p>
    public let maxPasswordAge: Int?
    /// <p>Minimum length to require for IAM user passwords.</p>
    public let minimumPasswordLength: Int?
    /// <p>Specifies the number of previous passwords that IAM users are prevented from
    ///          reusing.</p>
    public let passwordReusePrevention: Int?
    /// <p>Specifies whether IAM user passwords must contain at least one lowercase character (a to z).</p>
    public let requireLowercaseCharacters: Bool
    /// <p>Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).</p>
    public let requireNumbers: Bool
    /// <p>Specifies whether IAM user passwords must contain at least one of the following symbols:</p>
    ///          <p>! @ # $ % ^ & * ( ) _ + - = [ ] { } | '</p>
    public let requireSymbols: Bool
    /// <p>Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).</p>
    public let requireUppercaseCharacters: Bool

    public init (
        allowUsersToChangePassword: Bool = false,
        expirePasswords: Bool = false,
        hardExpiry: Bool? = nil,
        maxPasswordAge: Int? = nil,
        minimumPasswordLength: Int? = nil,
        passwordReusePrevention: Int? = nil,
        requireLowercaseCharacters: Bool = false,
        requireNumbers: Bool = false,
        requireSymbols: Bool = false,
        requireUppercaseCharacters: Bool = false
    )
    {
        self.allowUsersToChangePassword = allowUsersToChangePassword
        self.expirePasswords = expirePasswords
        self.hardExpiry = hardExpiry
        self.maxPasswordAge = maxPasswordAge
        self.minimumPasswordLength = minimumPasswordLength
        self.passwordReusePrevention = passwordReusePrevention
        self.requireLowercaseCharacters = requireLowercaseCharacters
        self.requireNumbers = requireNumbers
        self.requireSymbols = requireSymbols
        self.requireUppercaseCharacters = requireUppercaseCharacters
    }
}

extension PasswordPolicyViolationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PasswordPolicyViolationException(message: \(String(describing: message)))"}
}

extension PasswordPolicyViolationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PasswordPolicyViolationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the provided password did not meet the requirements
///       imposed by the account password policy.</p>
public struct PasswordPolicyViolationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PasswordPolicyViolationExceptionBody: Equatable {
    public let message: String?
}

extension PasswordPolicyViolationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PermissionsBoundaryAttachmentType {
    case policy
    case sdkUnknown(String)
}

extension PermissionsBoundaryAttachmentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PermissionsBoundaryAttachmentType] {
        return [
            .policy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .policy: return "PermissionsBoundaryPolicy"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PermissionsBoundaryAttachmentType(rawValue: rawValue) ?? PermissionsBoundaryAttachmentType.sdkUnknown(rawValue)
    }
}

extension PermissionsBoundaryDecisionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedByPermissionsBoundary = "AllowedByPermissionsBoundary"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowedByPermissionsBoundary != false {
            try container.encode(allowedByPermissionsBoundary, forKey: Key("AllowedByPermissionsBoundary"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedByPermissionsBoundaryDecoded = try containerValues.decode(Bool.self, forKey: .allowedByPermissionsBoundary)
        allowedByPermissionsBoundary = allowedByPermissionsBoundaryDecoded
    }
}

extension PermissionsBoundaryDecisionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PermissionsBoundaryDecisionDetail(allowedByPermissionsBoundary: \(String(describing: allowedByPermissionsBoundary)))"}
}

/// <p>Contains information about the effect that a permissions boundary has on a policy
///          simulation when the boundary is applied to an IAM entity.</p>
public struct PermissionsBoundaryDecisionDetail: Equatable {
    /// <p>Specifies whether an action is allowed by a permissions boundary that is applied to an
    ///          IAM entity (user or role). A value of <code>true</code> means that the permissions
    ///          boundary does not deny the action. This means that the policy includes an
    ///             <code>Allow</code> statement that matches the request. In this case, if an
    ///          identity-based policy also allows the action, the request is allowed. A value of
    ///             <code>false</code> means that either the requested action is not allowed (implicitly
    ///          denied) or that the action is explicitly denied by the permissions boundary. In both of
    ///          these cases, the action is not allowed, regardless of the identity-based policy.</p>
    public let allowedByPermissionsBoundary: Bool

    public init (
        allowedByPermissionsBoundary: Bool = false
    )
    {
        self.allowedByPermissionsBoundary = allowedByPermissionsBoundary
    }
}

extension Policy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case tags = "Tags"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let updateDate = updateDate {
            try container.encode(TimestampWrapper(updateDate, format: .dateTime), forKey: Key("updateDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let attachmentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .attachmentCount)
        attachmentCount = attachmentCountDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .permissionsBoundaryUsageCount)
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let isAttachableDecoded = try containerValues.decode(Bool.self, forKey: .isAttachable)
        isAttachable = isAttachableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let updateDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateDate)
        var updateDateBuffer:Date? = nil
        if let updateDateDecoded = updateDateDecoded {
            updateDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updateDateDecoded, format: .dateTime)
        }
        updateDate = updateDateBuffer
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension Policy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Policy(arn: \(String(describing: arn)), attachmentCount: \(String(describing: attachmentCount)), createDate: \(String(describing: createDate)), defaultVersionId: \(String(describing: defaultVersionId)), description: \(String(describing: description)), isAttachable: \(String(describing: isAttachable)), path: \(String(describing: path)), permissionsBoundaryUsageCount: \(String(describing: permissionsBoundaryUsageCount)), policyId: \(String(describing: policyId)), policyName: \(String(describing: policyName)), tags: \(String(describing: tags)), updateDate: \(String(describing: updateDate)))"}
}

/// <p>Contains information about a managed policy.</p>
///          <p>This data type is used as a response element in the <a>CreatePolicy</a>,
///             <a>GetPolicy</a>, and <a>ListPolicies</a> operations. </p>
///          <p>For more information about managed policies, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html">Managed policies and inline
///             policies</a> in the <i>IAM User Guide</i>. </p>
public struct Policy: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let arn: String?
    /// <p>The number of entities (users, groups, and roles) that the policy is attached to.</p>
    public let attachmentCount: Int?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the policy was created.</p>
    public let createDate: Date?
    /// <p>The identifier for the version of the policy that is set as the default version.</p>
    public let defaultVersionId: String?
    /// <p>A friendly description of the policy.</p>
    ///          <p>This element is included in the response to the <a>GetPolicy</a> operation.
    ///          It is not included in the response to the <a>ListPolicies</a> operation. </p>
    public let description: String?
    /// <p>Specifies whether the policy can be attached to an IAM user, group, or role.</p>
    public let isAttachable: Bool
    /// <p>The path to the policy.</p>
    ///          <p>For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let path: String?
    /// <p>The number of entities (users and roles) for which the policy is used to set the
    ///          permissions boundary. </p>
    ///          <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///             identities </a> in the <i>IAM User Guide</i>.</p>
    public let permissionsBoundaryUsageCount: Int?
    /// <p>The stable and unique string identifying the policy.</p>
    ///          <p>For more information about IDs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let policyId: String?
    /// <p>The friendly name (not ARN) identifying the policy.</p>
    public let policyName: String?
    /// <p>A list of tags that are attached to the instance profile. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the policy was last updated.</p>
    ///          <p>When a policy has only one version, this field contains the date and time when the
    ///          policy was created. When a policy has more than one version, this field contains the date
    ///          and time when the most recent policy version was created.</p>
    public let updateDate: Date?

    public init (
        arn: String? = nil,
        attachmentCount: Int? = nil,
        createDate: Date? = nil,
        defaultVersionId: String? = nil,
        description: String? = nil,
        isAttachable: Bool = false,
        path: String? = nil,
        permissionsBoundaryUsageCount: Int? = nil,
        policyId: String? = nil,
        policyName: String? = nil,
        tags: [Tag]? = nil,
        updateDate: Date? = nil
    )
    {
        self.arn = arn
        self.attachmentCount = attachmentCount
        self.createDate = createDate
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.isAttachable = isAttachable
        self.path = path
        self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
        self.policyId = policyId
        self.policyName = policyName
        self.tags = tags
        self.updateDate = updateDate
    }
}

extension PolicyDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PolicyDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyDetail(policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)))"}
}

/// <p>Contains information about an IAM policy, including the policy document.</p>
///          <p>This data type is used as a response element in the <a>GetAccountAuthorizationDetails</a> operation.</p>
public struct PolicyDetail: Equatable {
    /// <p>The policy document.</p>
    public let policyDocument: String?
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        policyDocument: String? = nil,
        policyName: String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

public enum PolicyEvaluationDecisionType {
    case allowed
    case explicitDeny
    case implicitDeny
    case sdkUnknown(String)
}

extension PolicyEvaluationDecisionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyEvaluationDecisionType] {
        return [
            .allowed,
            .explicitDeny,
            .implicitDeny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allowed: return "allowed"
        case .explicitDeny: return "explicitDeny"
        case .implicitDeny: return "implicitDeny"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyEvaluationDecisionType(rawValue: rawValue) ?? PolicyEvaluationDecisionType.sdkUnknown(rawValue)
    }
}

extension PolicyEvaluationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyEvaluationException(message: \(String(describing: message)))"}
}

extension PolicyEvaluationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PolicyEvaluationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because a provided policy could not be successfully evaluated. An
///       additional detailed message indicates the source of the failure.</p>
public struct PolicyEvaluationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyEvaluationExceptionBody: Equatable {
    public let message: String?
}

extension PolicyEvaluationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PolicyGrantingServiceAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityName = "EntityName"
        case entityType = "EntityType"
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let entityName = entityName {
            try container.encode(entityName, forKey: Key("EntityName"))
        }
        if let entityType = entityType {
            try container.encode(entityType, forKey: Key("EntityType"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let policyType = policyType {
            try container.encode(policyType, forKey: Key("PolicyType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(PolicyOwnerEntityType.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityName)
        entityName = entityNameDecoded
    }
}

extension PolicyGrantingServiceAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyGrantingServiceAccess(entityName: \(String(describing: entityName)), entityType: \(String(describing: entityType)), policyArn: \(String(describing: policyArn)), policyName: \(String(describing: policyName)), policyType: \(String(describing: policyType)))"}
}

/// <p>Contains details about the permissions policies that are attached to the specified
///          identity (user, group, or role).</p>
///          <p>This data type is an element of the <a>ListPoliciesGrantingServiceAccessEntry</a> object.</p>
public struct PolicyGrantingServiceAccess: Equatable {
    /// <p>The name of the entity (user or role) to which the inline policy is attached.</p>
    ///          <p>This field is null for managed policies. For more information about these policy types,
    ///          see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html">Managed policies and inline policies</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let entityName: String?
    /// <p>The type of entity (user or role) that used the policy to access the service to which
    ///          the inline policy is attached.</p>
    ///          <p>This field is null for managed policies. For more information about these policy types,
    ///          see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html">Managed policies and inline policies</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let entityType: PolicyOwnerEntityType?
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let policyArn: String?
    /// <p>The policy name.</p>
    public let policyName: String?
    /// <p>The policy type. For more information about these policy types, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html">Managed
    ///             policies and inline policies</a> in the
    ///          <i>IAM User Guide</i>.</p>
    public let policyType: PolicyType?

    public init (
        entityName: String? = nil,
        entityType: PolicyOwnerEntityType? = nil,
        policyArn: String? = nil,
        policyName: String? = nil,
        policyType: PolicyType? = nil
    )
    {
        self.entityName = entityName
        self.entityType = entityType
        self.policyArn = policyArn
        self.policyName = policyName
        self.policyType = policyType
    }
}

extension PolicyGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupId = groupId {
            try container.encode(groupId, forKey: Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension PolicyGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyGroup(groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)))"}
}

/// <p>Contains information about a group that a managed policy is attached to.</p>
///          <p>This data type is used as a response element in the <a>ListEntitiesForPolicy</a> operation. </p>
///          <p>For more information about managed policies, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html">Managed policies and inline
///             policies</a> in the <i>IAM User Guide</i>. </p>
public struct PolicyGroup: Equatable {
    /// <p>The stable and unique string identifying the group. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>.</p>
    public let groupId: String?
    /// <p>The name (friendly name, not ARN) identifying the group.</p>
    public let groupName: String?

    public init (
        groupId: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupId = groupId
        self.groupName = groupName
    }
}

extension PolicyNotAttachableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyNotAttachableException(message: \(String(describing: message)))"}
}

extension PolicyNotAttachableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PolicyNotAttachableExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because AWS service role policies can only be attached to the
///       service-linked role for that service.</p>
public struct PolicyNotAttachableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyNotAttachableExceptionBody: Equatable {
    public let message: String?
}

extension PolicyNotAttachableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PolicyOwnerEntityType {
    case group
    case role
    case user
    case sdkUnknown(String)
}

extension PolicyOwnerEntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyOwnerEntityType] {
        return [
            .group,
            .role,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .group: return "GROUP"
        case .role: return "ROLE"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyOwnerEntityType(rawValue: rawValue) ?? PolicyOwnerEntityType.sdkUnknown(rawValue)
    }
}

extension PolicyRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleId = "RoleId"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let roleId = roleId {
            try container.encode(roleId, forKey: Key("RoleId"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleId)
        roleId = roleIdDecoded
    }
}

extension PolicyRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyRole(roleId: \(String(describing: roleId)), roleName: \(String(describing: roleName)))"}
}

/// <p>Contains information about a role that a managed policy is attached to.</p>
///          <p>This data type is used as a response element in the <a>ListEntitiesForPolicy</a> operation. </p>
///          <p>For more information about managed policies, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html">Managed policies and inline
///             policies</a> in the <i>IAM User Guide</i>. </p>
public struct PolicyRole: Equatable {
    /// <p>The stable and unique string identifying the role. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>.</p>
    public let roleId: String?
    /// <p>The name (friendly name, not ARN) identifying the role.</p>
    public let roleName: String?

    public init (
        roleId: String? = nil,
        roleName: String? = nil
    )
    {
        self.roleId = roleId
        self.roleName = roleName
    }
}

public enum PolicyScopeType {
    case aws
    case all
    case local
    case sdkUnknown(String)
}

extension PolicyScopeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyScopeType] {
        return [
            .aws,
            .all,
            .local,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "AWS"
        case .all: return "All"
        case .local: return "Local"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyScopeType(rawValue: rawValue) ?? PolicyScopeType.sdkUnknown(rawValue)
    }
}

public enum PolicySourceType {
    case awsManaged
    case group
    case `none`
    case resource
    case role
    case user
    case userManaged
    case sdkUnknown(String)
}

extension PolicySourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicySourceType] {
        return [
            .awsManaged,
            .group,
            .none,
            .resource,
            .role,
            .user,
            .userManaged,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsManaged: return "aws-managed"
        case .group: return "group"
        case .none: return "none"
        case .resource: return "resource"
        case .role: return "role"
        case .user: return "user"
        case .userManaged: return "user-managed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicySourceType(rawValue: rawValue) ?? PolicySourceType.sdkUnknown(rawValue)
    }
}

public enum PolicyType {
    case inline
    case managed
    case sdkUnknown(String)
}

extension PolicyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyType] {
        return [
            .inline,
            .managed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inline: return "INLINE"
        case .managed: return "MANAGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
    }
}

/// <p>The policy usage type that indicates whether the policy is used as a permissions policy
///          or as the permissions boundary for an entity.</p>
///          <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
///             identities </a> in the <i>IAM User Guide</i>.</p>
public enum PolicyUsageType {
    case permissionsboundary
    case permissionspolicy
    case sdkUnknown(String)
}

extension PolicyUsageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyUsageType] {
        return [
            .permissionsboundary,
            .permissionspolicy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .permissionsboundary: return "PermissionsBoundary"
        case .permissionspolicy: return "PermissionsPolicy"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyUsageType(rawValue: rawValue) ?? PolicyUsageType.sdkUnknown(rawValue)
    }
}

extension PolicyUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let userId = userId {
            try container.encode(userId, forKey: Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension PolicyUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyUser(userId: \(String(describing: userId)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about a user that a managed policy is attached to.</p>
///          <p>This data type is used as a response element in the <a>ListEntitiesForPolicy</a> operation. </p>
///          <p>For more information about managed policies, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html">Managed policies and inline
///             policies</a> in the <i>IAM User Guide</i>. </p>
public struct PolicyUser: Equatable {
    /// <p>The stable and unique string identifying the user. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>.</p>
    public let userId: String?
    /// <p>The name (friendly name, not ARN) identifying the user.</p>
    public let userName: String?

    public init (
        userId: String? = nil,
        userName: String? = nil
    )
    {
        self.userId = userId
        self.userName = userName
    }
}

extension PolicyVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case document = "Document"
        case isDefaultVersion = "IsDefaultVersion"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let document = document {
            try container.encode(document, forKey: Key("Document"))
        }
        if isDefaultVersion != false {
            try container.encode(isDefaultVersion, forKey: Key("IsDefaultVersion"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
    }
}

extension PolicyVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyVersion(createDate: \(String(describing: createDate)), document: \(String(describing: document)), isDefaultVersion: \(String(describing: isDefaultVersion)), versionId: \(String(describing: versionId)))"}
}

/// <p>Contains information about a version of a managed policy.</p>
///          <p>This data type is used as a response element in the <a>CreatePolicyVersion</a>, <a>GetPolicyVersion</a>, <a>ListPolicyVersions</a>, and <a>GetAccountAuthorizationDetails</a> operations. </p>
///          <p>For more information about managed policies, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html">Managed policies and inline
///             policies</a> in the <i>IAM User Guide</i>. </p>
public struct PolicyVersion: Equatable {
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the policy version was created.</p>
    public let createDate: Date?
    /// <p>The policy document.</p>
    ///          <p>The policy document is returned in the response to the <a>GetPolicyVersion</a> and <a>GetAccountAuthorizationDetails</a> operations. It is not returned in
    ///          the response to the <a>CreatePolicyVersion</a> or <a>ListPolicyVersions</a> operations. </p>
    ///          <p>The policy document returned in this structure is URL-encoded compliant with <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>. You can use a URL decoding
    ///          method to convert the policy back to plain JSON text. For example, if you use Java, you can
    ///          use the <code>decode</code> method of the <code>java.net.URLDecoder</code> utility class in
    ///          the Java SDK. Other languages and SDKs provide similar functionality.</p>
    public let document: String?
    /// <p>Specifies whether the policy version is set as the policy's default version.</p>
    public let isDefaultVersion: Bool
    /// <p>The identifier for the policy version.</p>
    ///          <p>Policy version identifiers always begin with <code>v</code> (always lowercase). When a
    ///          policy is created, the first policy version is <code>v1</code>. </p>
    public let versionId: String?

    public init (
        createDate: Date? = nil,
        document: String? = nil,
        isDefaultVersion: Bool = false,
        versionId: String? = nil
    )
    {
        self.createDate = createDate
        self.document = document
        self.isDefaultVersion = isDefaultVersion
        self.versionId = versionId
    }
}

extension Position: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case column = "Column"
        case line = "Line"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if column != 0 {
            try container.encode(column, forKey: Key("Column"))
        }
        if line != 0 {
            try container.encode(line, forKey: Key("Line"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineDecoded = try containerValues.decode(Int.self, forKey: .line)
        line = lineDecoded
        let columnDecoded = try containerValues.decode(Int.self, forKey: .column)
        column = columnDecoded
    }
}

extension Position: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Position(column: \(String(describing: column)), line: \(String(describing: line)))"}
}

/// <p>Contains the row and column of a location of a <code>Statement</code> element in a
///          policy document.</p>
///          <p>This data type is used as a member of the <code>
///                <a>Statement</a>
///             </code> type.</p>
public struct Position: Equatable {
    /// <p>The column in the line containing the specified position in the document.</p>
    public let column: Int
    /// <p>The line containing the specified position in the document.</p>
    public let line: Int

    public init (
        column: Int = 0,
        line: Int = 0
    )
    {
        self.column = column
        self.line = line
    }
}

public struct PutGroupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutGroupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGroupPolicyInput>
    public typealias MOutput = OperationOutput<PutGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGroupPolicyOutputError>
}

extension PutGroupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutGroupPolicyInput(groupName: \(String(describing: groupName)), policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)))"}
}

extension PutGroupPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("PutGroupPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct PutGroupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutGroupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGroupPolicyInput>
    public typealias MOutput = OperationOutput<PutGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGroupPolicyOutputError>
}

public struct PutGroupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutGroupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGroupPolicyInput>
    public typealias MOutput = OperationOutput<PutGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGroupPolicyOutputError>
}

public struct PutGroupPolicyInput: Equatable {
    /// <p>The name of the group to associate the policy with.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-.</p>
    public let groupName: String?
    /// <p>The policy document.</p>
    ///         <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    ///             templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    ///             CloudFormation always converts a YAML policy to JSON format before submitting it to
    ///             IAM.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyDocument: String?
    /// <p>The name of the policy document.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?

    public init (
        groupName: String? = nil,
        policyDocument: String? = nil,
        policyName: String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

extension PutGroupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutGroupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutGroupPolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutGroupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutGroupPolicyOutputResponse()"}
}

extension PutGroupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutGroupPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutGroupPolicyOutputResponseBody: Equatable {
}

extension PutGroupPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutRolePermissionsBoundaryInputBodyMiddleware: Middleware {
    public let id: String = "PutRolePermissionsBoundaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRolePermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRolePermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRolePermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<PutRolePermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRolePermissionsBoundaryOutputError>
}

extension PutRolePermissionsBoundaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRolePermissionsBoundaryInput(permissionsBoundary: \(String(describing: permissionsBoundary)), roleName: \(String(describing: roleName)))"}
}

extension PutRolePermissionsBoundaryInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("PutRolePermissionsBoundary", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct PutRolePermissionsBoundaryInputHeadersMiddleware: Middleware {
    public let id: String = "PutRolePermissionsBoundaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRolePermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRolePermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRolePermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<PutRolePermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRolePermissionsBoundaryOutputError>
}

public struct PutRolePermissionsBoundaryInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRolePermissionsBoundaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRolePermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRolePermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRolePermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<PutRolePermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRolePermissionsBoundaryOutputError>
}

public struct PutRolePermissionsBoundaryInput: Equatable {
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    ///             role.</p>
    public let permissionsBoundary: String?
    /// <p>The name (friendly name, not ARN) of the IAM role for which you want to set the
    ///             permissions boundary.</p>
    public let roleName: String?

    public init (
        permissionsBoundary: String? = nil,
        roleName: String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
    }
}

extension PutRolePermissionsBoundaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutRolePermissionsBoundaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachableException" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRolePermissionsBoundaryOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRolePermissionsBoundaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRolePermissionsBoundaryOutputResponse()"}
}

extension PutRolePermissionsBoundaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutRolePermissionsBoundaryOutputResponse: Equatable {

    public init() {}
}

struct PutRolePermissionsBoundaryOutputResponseBody: Equatable {
}

extension PutRolePermissionsBoundaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutRolePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutRolePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRolePolicyInput>
    public typealias MOutput = OperationOutput<PutRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRolePolicyOutputError>
}

extension PutRolePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRolePolicyInput(policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), roleName: \(String(describing: roleName)))"}
}

extension PutRolePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("PutRolePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct PutRolePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutRolePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRolePolicyInput>
    public typealias MOutput = OperationOutput<PutRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRolePolicyOutputError>
}

public struct PutRolePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRolePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRolePolicyInput>
    public typealias MOutput = OperationOutput<PutRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRolePolicyOutputError>
}

public struct PutRolePolicyInput: Equatable {
    /// <p>The policy document.</p>
    ///         <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    ///             templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    ///             CloudFormation always converts a YAML policy to JSON format before submitting it to
    ///             IAM.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyDocument: String?
    /// <p>The name of the policy document.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?
    /// <p>The name of the role to associate the policy with.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        policyDocument: String? = nil,
        policyName: String? = nil,
        roleName: String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

extension PutRolePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutRolePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRolePolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRolePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRolePolicyOutputResponse()"}
}

extension PutRolePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutRolePolicyOutputResponse: Equatable {

    public init() {}
}

struct PutRolePolicyOutputResponseBody: Equatable {
}

extension PutRolePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutUserPermissionsBoundaryInputBodyMiddleware: Middleware {
    public let id: String = "PutUserPermissionsBoundaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUserPermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUserPermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUserPermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<PutUserPermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUserPermissionsBoundaryOutputError>
}

extension PutUserPermissionsBoundaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutUserPermissionsBoundaryInput(permissionsBoundary: \(String(describing: permissionsBoundary)), userName: \(String(describing: userName)))"}
}

extension PutUserPermissionsBoundaryInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("PutUserPermissionsBoundary", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct PutUserPermissionsBoundaryInputHeadersMiddleware: Middleware {
    public let id: String = "PutUserPermissionsBoundaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUserPermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUserPermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUserPermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<PutUserPermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUserPermissionsBoundaryOutputError>
}

public struct PutUserPermissionsBoundaryInputQueryItemMiddleware: Middleware {
    public let id: String = "PutUserPermissionsBoundaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUserPermissionsBoundaryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUserPermissionsBoundaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUserPermissionsBoundaryInput>
    public typealias MOutput = OperationOutput<PutUserPermissionsBoundaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUserPermissionsBoundaryOutputError>
}

public struct PutUserPermissionsBoundaryInput: Equatable {
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    ///             user.</p>
    public let permissionsBoundary: String?
    /// <p>The name (friendly name, not ARN) of the IAM user for which you want to set the
    ///             permissions boundary.</p>
    public let userName: String?

    public init (
        permissionsBoundary: String? = nil,
        userName: String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.userName = userName
    }
}

extension PutUserPermissionsBoundaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutUserPermissionsBoundaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachableException" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutUserPermissionsBoundaryOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutUserPermissionsBoundaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutUserPermissionsBoundaryOutputResponse()"}
}

extension PutUserPermissionsBoundaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutUserPermissionsBoundaryOutputResponse: Equatable {

    public init() {}
}

struct PutUserPermissionsBoundaryOutputResponseBody: Equatable {
}

extension PutUserPermissionsBoundaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutUserPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutUserPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUserPolicyInput>
    public typealias MOutput = OperationOutput<PutUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUserPolicyOutputError>
}

extension PutUserPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutUserPolicyInput(policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), userName: \(String(describing: userName)))"}
}

extension PutUserPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("PutUserPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct PutUserPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutUserPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUserPolicyInput>
    public typealias MOutput = OperationOutput<PutUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUserPolicyOutputError>
}

public struct PutUserPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutUserPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUserPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUserPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUserPolicyInput>
    public typealias MOutput = OperationOutput<PutUserPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUserPolicyOutputError>
}

public struct PutUserPolicyInput: Equatable {
    /// <p>The policy document.</p>
    ///         <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    ///             templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    ///             CloudFormation always converts a YAML policy to JSON format before submitting it to
    ///             IAM.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyDocument: String?
    /// <p>The name of the policy document.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let policyName: String?
    /// <p>The name of the user to associate the policy with.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        policyDocument: String? = nil,
        policyName: String? = nil,
        userName: String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

extension PutUserPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutUserPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutUserPolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutUserPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutUserPolicyOutputResponse()"}
}

extension PutUserPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutUserPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutUserPolicyOutputResponseBody: Equatable {
}

extension PutUserPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderInputBodyMiddleware: Middleware {
    public let id: String = "RemoveClientIDFromOpenIDConnectProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveClientIDFromOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveClientIDFromOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveClientIDFromOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<RemoveClientIDFromOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveClientIDFromOpenIDConnectProviderOutputError>
}

extension RemoveClientIDFromOpenIDConnectProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveClientIDFromOpenIDConnectProviderInput(clientID: \(String(describing: clientID)), openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)))"}
}

extension RemoveClientIDFromOpenIDConnectProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        try container.encode("RemoveClientIDFromOpenIDConnectProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveClientIDFromOpenIDConnectProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveClientIDFromOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveClientIDFromOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveClientIDFromOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<RemoveClientIDFromOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveClientIDFromOpenIDConnectProviderOutputError>
}

public struct RemoveClientIDFromOpenIDConnectProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveClientIDFromOpenIDConnectProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveClientIDFromOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveClientIDFromOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveClientIDFromOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<RemoveClientIDFromOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveClientIDFromOpenIDConnectProviderOutputError>
}

public struct RemoveClientIDFromOpenIDConnectProviderInput: Equatable {
    /// <p>The client ID (also known as audience) to remove from the IAM OIDC provider
    ///             resource. For more information about client IDs, see <a>CreateOpenIDConnectProvider</a>.</p>
    public let clientID: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the
    ///             client ID from. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let openIDConnectProviderArn: String?

    public init (
        clientID: String? = nil,
        openIDConnectProviderArn: String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension RemoveClientIDFromOpenIDConnectProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveClientIDFromOpenIDConnectProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveClientIDFromOpenIDConnectProviderOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveClientIDFromOpenIDConnectProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveClientIDFromOpenIDConnectProviderOutputResponse()"}
}

extension RemoveClientIDFromOpenIDConnectProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderOutputResponse: Equatable {

    public init() {}
}

struct RemoveClientIDFromOpenIDConnectProviderOutputResponseBody: Equatable {
}

extension RemoveClientIDFromOpenIDConnectProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveRoleFromInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "RemoveRoleFromInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromInstanceProfileInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromInstanceProfileOutputError>
}

extension RemoveRoleFromInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromInstanceProfileInput(instanceProfileName: \(String(describing: instanceProfileName)), roleName: \(String(describing: roleName)))"}
}

extension RemoveRoleFromInstanceProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("RemoveRoleFromInstanceProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct RemoveRoleFromInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveRoleFromInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromInstanceProfileInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromInstanceProfileOutputError>
}

public struct RemoveRoleFromInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveRoleFromInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromInstanceProfileInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromInstanceProfileOutputError>
}

public struct RemoveRoleFromInstanceProfileInput: Equatable {
    /// <p>The name of the instance profile to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let instanceProfileName: String?
    /// <p>The name of the role to remove.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        instanceProfileName: String? = nil,
        roleName: String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

extension RemoveRoleFromInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromInstanceProfileOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromInstanceProfileOutputResponse()"}
}

extension RemoveRoleFromInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromInstanceProfileOutputResponse: Equatable {

    public init() {}
}

struct RemoveRoleFromInstanceProfileOutputResponseBody: Equatable {
}

extension RemoveRoleFromInstanceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveUserFromGroupInputBodyMiddleware: Middleware {
    public let id: String = "RemoveUserFromGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveUserFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveUserFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveUserFromGroupInput>
    public typealias MOutput = OperationOutput<RemoveUserFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveUserFromGroupOutputError>
}

extension RemoveUserFromGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveUserFromGroupInput(groupName: \(String(describing: groupName)), userName: \(String(describing: userName)))"}
}

extension RemoveUserFromGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("RemoveUserFromGroup", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct RemoveUserFromGroupInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveUserFromGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveUserFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveUserFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveUserFromGroupInput>
    public typealias MOutput = OperationOutput<RemoveUserFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveUserFromGroupOutputError>
}

public struct RemoveUserFromGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveUserFromGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveUserFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveUserFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveUserFromGroupInput>
    public typealias MOutput = OperationOutput<RemoveUserFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveUserFromGroupOutputError>
}

public struct RemoveUserFromGroupInput: Equatable {
    /// <p>The name of the group to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>The name of the user to remove.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        groupName: String? = nil,
        userName: String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

extension RemoveUserFromGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveUserFromGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveUserFromGroupOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveUserFromGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveUserFromGroupOutputResponse()"}
}

extension RemoveUserFromGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveUserFromGroupOutputResponse: Equatable {

    public init() {}
}

struct RemoveUserFromGroupOutputResponseBody: Equatable {
}

extension RemoveUserFromGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ReportFormatType {
    case textCsv
    case sdkUnknown(String)
}

extension ReportFormatType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportFormatType] {
        return [
            .textCsv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .textCsv: return "text/csv"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportFormatType(rawValue: rawValue) ?? ReportFormatType.sdkUnknown(rawValue)
    }
}

extension ReportGenerationLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportGenerationLimitExceededException(message: \(String(describing: message)))"}
}

extension ReportGenerationLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReportGenerationLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because the maximum number of concurrent requests for this account are
///       already running.</p>
public struct ReportGenerationLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReportGenerationLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ReportGenerationLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ReportStateType {
    case complete
    case inprogress
    case started
    case sdkUnknown(String)
}

extension ReportStateType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportStateType] {
        return [
            .complete,
            .inprogress,
            .started,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .inprogress: return "INPROGRESS"
        case .started: return "STARTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportStateType(rawValue: rawValue) ?? ReportStateType.sdkUnknown(rawValue)
    }
}

public struct ResetServiceSpecificCredentialInputBodyMiddleware: Middleware {
    public let id: String = "ResetServiceSpecificCredentialInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<ResetServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetServiceSpecificCredentialOutputError>
}

extension ResetServiceSpecificCredentialInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetServiceSpecificCredentialInput(serviceSpecificCredentialId: \(String(describing: serviceSpecificCredentialId)), userName: \(String(describing: userName)))"}
}

extension ResetServiceSpecificCredentialInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ResetServiceSpecificCredential", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ResetServiceSpecificCredentialInputHeadersMiddleware: Middleware {
    public let id: String = "ResetServiceSpecificCredentialInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<ResetServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetServiceSpecificCredentialOutputError>
}

public struct ResetServiceSpecificCredentialInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetServiceSpecificCredentialInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<ResetServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetServiceSpecificCredentialOutputError>
}

public struct ResetServiceSpecificCredentialInput: Equatable {
    /// <p>The unique identifier of the service-specific credential.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let serviceSpecificCredentialId: String?
    /// <p>The name of the IAM user associated with the service-specific credential. If this
    ///             value is not specified, then the operation assumes the user whose credentials are used
    ///             to call the operation.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        serviceSpecificCredentialId: String? = nil,
        userName: String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

extension ResetServiceSpecificCredentialOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetServiceSpecificCredentialOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetServiceSpecificCredentialOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetServiceSpecificCredentialOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetServiceSpecificCredentialOutputResponse(serviceSpecificCredential: \(String(describing: serviceSpecificCredential)))"}
}

extension ResetServiceSpecificCredentialOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetServiceSpecificCredentialOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceSpecificCredential = output.serviceSpecificCredential
        } else {
            self.serviceSpecificCredential = nil
        }
    }
}

public struct ResetServiceSpecificCredentialOutputResponse: Equatable {
    /// <p>A structure with details about the updated service-specific credential, including the
    ///             new password.</p>
    ///         <important>
    ///             <p>This is the <b>only</b> time that you can access the
    ///                 password. You cannot recover the password later, but you can reset it again.</p>
    ///         </important>
    public let serviceSpecificCredential: ServiceSpecificCredential?

    public init (
        serviceSpecificCredential: ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

struct ResetServiceSpecificCredentialOutputResponseBody: Equatable {
    public let serviceSpecificCredential: ServiceSpecificCredential?
}

extension ResetServiceSpecificCredentialOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceSpecificCredential = "ServiceSpecificCredential"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResetServiceSpecificCredentialResult"))
        let serviceSpecificCredentialDecoded = try containerValues.decodeIfPresent(ServiceSpecificCredential.self, forKey: .serviceSpecificCredential)
        serviceSpecificCredential = serviceSpecificCredentialDecoded
    }
}

extension ResourceSpecificResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceDecision = "EvalResourceDecision"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: Key(""))
            }
        }
        if let evalResourceDecision = evalResourceDecision {
            try container.encode(evalResourceDecision, forKey: Key("EvalResourceDecision"))
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            var matchedStatementsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MatchedStatements"))
            for (index0, statement0) in matchedStatements.enumerated() {
                try matchedStatementsContainer.encode(statement0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let missingContextValues = missingContextValues {
            var missingContextValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MissingContextValues"))
            for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                try missingContextValuesContainer.encode(contextkeynametype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: Key("PermissionsBoundaryDecisionDetail"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evalResourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evalResourceName)
        evalResourceName = evalResourceNameDecoded
        let evalResourceDecisionDecoded = try containerValues.decodeIfPresent(PolicyEvaluationDecisionType.self, forKey: .evalResourceDecision)
        evalResourceDecision = evalResourceDecisionDecoded
        if containerValues.contains(.matchedStatements) {
            struct KeyVal0{struct member{}}
            let matchedStatementsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchedStatements)
            if let matchedStatementsWrappedContainer = matchedStatementsWrappedContainer {
                let matchedStatementsContainer = try matchedStatementsWrappedContainer.decodeIfPresent([Statement].self, forKey: .member)
                var matchedStatementsBuffer:[Statement]? = nil
                if let matchedStatementsContainer = matchedStatementsContainer {
                    matchedStatementsBuffer = [Statement]()
                    for structureContainer0 in matchedStatementsContainer {
                        matchedStatementsBuffer?.append(structureContainer0)
                    }
                }
                matchedStatements = matchedStatementsBuffer
            } else {
                matchedStatements = []
            }
        } else {
            matchedStatements = nil
        }
        if containerValues.contains(.missingContextValues) {
            struct KeyVal0{struct member{}}
            let missingContextValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .missingContextValues)
            if let missingContextValuesWrappedContainer = missingContextValuesWrappedContainer {
                let missingContextValuesContainer = try missingContextValuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var missingContextValuesBuffer:[String]? = nil
                if let missingContextValuesContainer = missingContextValuesContainer {
                    missingContextValuesBuffer = [String]()
                    for stringContainer0 in missingContextValuesContainer {
                        missingContextValuesBuffer?.append(stringContainer0)
                    }
                }
                missingContextValues = missingContextValuesBuffer
            } else {
                missingContextValues = []
            }
        } else {
            missingContextValues = nil
        }
        if containerValues.contains(.evalDecisionDetails) {
            struct KeyVal0{struct key{}; struct value{}}
            let evalDecisionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .evalDecisionDetails)
            if let evalDecisionDetailsWrappedContainer = evalDecisionDetailsWrappedContainer {
                let evalDecisionDetailsContainer = try evalDecisionDetailsWrappedContainer.decodeIfPresent([MapKeyValue<String, PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var evalDecisionDetailsBuffer: [String:PolicyEvaluationDecisionType]? = nil
                if let evalDecisionDetailsContainer = evalDecisionDetailsContainer {
                    evalDecisionDetailsBuffer = [String:PolicyEvaluationDecisionType]()
                    for stringContainer0 in evalDecisionDetailsContainer {
                        evalDecisionDetailsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                evalDecisionDetails = evalDecisionDetailsBuffer
            } else {
                evalDecisionDetails = [:]
            }
        } else {
            evalDecisionDetails = nil
        }
        let permissionsBoundaryDecisionDetailDecoded = try containerValues.decodeIfPresent(PermissionsBoundaryDecisionDetail.self, forKey: .permissionsBoundaryDecisionDetail)
        permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetailDecoded
    }
}

extension ResourceSpecificResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceSpecificResult(evalDecisionDetails: \(String(describing: evalDecisionDetails)), evalResourceDecision: \(String(describing: evalResourceDecision)), evalResourceName: \(String(describing: evalResourceName)), matchedStatements: \(String(describing: matchedStatements)), missingContextValues: \(String(describing: missingContextValues)), permissionsBoundaryDecisionDetail: \(String(describing: permissionsBoundaryDecisionDetail)))"}
}

/// <p>Contains the result of the simulation of a single API operation call on a single
///          resource.</p>
///          <p>This data type is used by a member of the <a>EvaluationResult</a> data
///          type.</p>
public struct ResourceSpecificResult: Equatable {
    /// <p>Additional details about the results of the evaluation decision on a single resource.
    ///          This parameter is returned only for cross-account simulations. This parameter explains how
    ///          each policy type contributes to the resource-specific evaluation decision.</p>
    public let evalDecisionDetails: [String:PolicyEvaluationDecisionType]?
    /// <p>The result of the simulation of the simulated API operation on the resource specified in
    ///             <code>EvalResourceName</code>.</p>
    public let evalResourceDecision: PolicyEvaluationDecisionType?
    /// <p>The name of the simulated resource, in Amazon Resource Name (ARN) format.</p>
    public let evalResourceName: String?
    /// <p>A list of the statements in the input policies that determine the result for this part
    ///          of the simulation. Remember that even if multiple statements allow the operation on the
    ///          resource, if <i>any</i> statement denies that operation, then the explicit
    ///          deny overrides any allow. In addition, the deny statement is the only entry included in the
    ///          result.</p>
    public let matchedStatements: [Statement]?
    /// <p>A list of context keys that are required by the included input policies but that were
    ///          not provided by one of the input parameters. This list is used when a list of ARNs is
    ///          included in the <code>ResourceArns</code> parameter instead of "*". If you do not specify
    ///          individual resources, by setting <code>ResourceArns</code> to "*" or by not including the
    ///             <code>ResourceArns</code> parameter, then any missing context values are instead
    ///          included under the <code>EvaluationResults</code> section. To discover the context keys
    ///          used by a set of policies, you can call <a>GetContextKeysForCustomPolicy</a> or
    ///             <a>GetContextKeysForPrincipalPolicy</a>.</p>
    public let missingContextValues: [String]?
    /// <p>Contains information about the effect that a permissions boundary has on a policy
    ///          simulation when that boundary is applied to an IAM entity.</p>
    public let permissionsBoundaryDecisionDetail: PermissionsBoundaryDecisionDetail?

    public init (
        evalDecisionDetails: [String:PolicyEvaluationDecisionType]? = nil,
        evalResourceDecision: PolicyEvaluationDecisionType? = nil,
        evalResourceName: String? = nil,
        matchedStatements: [Statement]? = nil,
        missingContextValues: [String]? = nil,
        permissionsBoundaryDecisionDetail: PermissionsBoundaryDecisionDetail? = nil
    )
    {
        self.evalDecisionDetails = evalDecisionDetails
        self.evalResourceDecision = evalResourceDecision
        self.evalResourceName = evalResourceName
        self.matchedStatements = matchedStatements
        self.missingContextValues = missingContextValues
        self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
    }
}

public struct ResyncMFADeviceInputBodyMiddleware: Middleware {
    public let id: String = "ResyncMFADeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResyncMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ResyncMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResyncMFADeviceInput>
    public typealias MOutput = OperationOutput<ResyncMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResyncMFADeviceOutputError>
}

extension ResyncMFADeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResyncMFADeviceInput(authenticationCode1: \(String(describing: authenticationCode1)), authenticationCode2: \(String(describing: authenticationCode2)), serialNumber: \(String(describing: serialNumber)), userName: \(String(describing: userName)))"}
}

extension ResyncMFADeviceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("ResyncMFADevice", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct ResyncMFADeviceInputHeadersMiddleware: Middleware {
    public let id: String = "ResyncMFADeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResyncMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ResyncMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResyncMFADeviceInput>
    public typealias MOutput = OperationOutput<ResyncMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResyncMFADeviceOutputError>
}

public struct ResyncMFADeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "ResyncMFADeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResyncMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ResyncMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResyncMFADeviceInput>
    public typealias MOutput = OperationOutput<ResyncMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResyncMFADeviceOutputError>
}

public struct ResyncMFADeviceInput: Equatable {
    /// <p>An authentication code emitted by the device.</p>
    ///         <p>The format for this parameter is a sequence of six digits.</p>
    public let authenticationCode1: String?
    /// <p>A subsequent authentication code emitted by the device.</p>
    ///         <p>The format for this parameter is a sequence of six digits.</p>
    public let authenticationCode2: String?
    /// <p>Serial number that uniquely identifies the MFA device.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let serialNumber: String?
    /// <p>The name of the user whose MFA device you want to resynchronize.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        authenticationCode1: String? = nil,
        authenticationCode2: String? = nil,
        serialNumber: String? = nil,
        userName: String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension ResyncMFADeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResyncMFADeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAuthenticationCodeException" : self = .invalidAuthenticationCodeException(try InvalidAuthenticationCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResyncMFADeviceOutputError: Equatable {
    case invalidAuthenticationCodeException(InvalidAuthenticationCodeException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResyncMFADeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResyncMFADeviceOutputResponse()"}
}

extension ResyncMFADeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ResyncMFADeviceOutputResponse: Equatable {

    public init() {}
}

struct ResyncMFADeviceOutputResponseBody: Equatable {
}

extension ResyncMFADeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Role: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case createDate = "CreateDate"
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: Key("AssumeRolePolicyDocument"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let roleLastUsedDecoded = try containerValues.decodeIfPresent(RoleLastUsed.self, forKey: .roleLastUsed)
        roleLastUsed = roleLastUsedDecoded
    }
}

extension Role: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Role(arn: \(String(describing: arn)), assumeRolePolicyDocument: \(String(describing: assumeRolePolicyDocument)), createDate: \(String(describing: createDate)), description: \(String(describing: description)), maxSessionDuration: \(String(describing: maxSessionDuration)), path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), roleId: \(String(describing: roleId)), roleLastUsed: \(String(describing: roleLastUsed)), roleName: \(String(describing: roleName)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about an IAM role. This structure is returned as a response
///          element in several API operations that interact with roles.</p>
public struct Role: Equatable {
    /// <p> The Amazon Resource Name (ARN) specifying the role. For more information about ARNs and
    ///          how to use them in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i> guide. </p>
    public let arn: String?
    /// <p>The policy that grants an entity permission to assume the role.</p>
    public let assumeRolePolicyDocument: String?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the role was created.</p>
    public let createDate: Date?
    /// <p>A description of the role that you provide.</p>
    public let description: String?
    /// <p>The maximum session duration (in seconds) for the specified role. Anyone who uses the
    ///          AWS CLI, or API to assume the role can specify the duration using the optional
    ///             <code>DurationSeconds</code> API parameter or <code>duration-seconds</code> CLI
    ///          parameter.</p>
    public let maxSessionDuration: Int?
    /// <p> The path to the role. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>. </p>
    public let path: String?
    /// <p>The ARN of the policy used to set the permissions boundary for the role.</p>
    ///          <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///             identities </a> in the <i>IAM User Guide</i>.</p>
    public let permissionsBoundary: AttachedPermissionsBoundary?
    /// <p> The stable and unique string identifying the role. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let roleId: String?
    /// <p>Contains information about the last time that an IAM role was used. This includes the
    ///          date and time and the Region in which the role was last used. Activity is only reported for
    ///          the trailing 400 days. This period can be shorter if your Region began supporting these
    ///          features within the last year. The role might have been used more than 400 days ago. For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period">Regions where data is tracked</a> in the <i>IAM User
    ///          Guide</i>.</p>
    public let roleLastUsed: RoleLastUsed?
    /// <p>The friendly name that identifies the role.</p>
    public let roleName: String?
    /// <p>A list of tags that are attached to the role. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        assumeRolePolicyDocument: String? = nil,
        createDate: Date? = nil,
        description: String? = nil,
        maxSessionDuration: Int? = nil,
        path: String? = nil,
        permissionsBoundary: AttachedPermissionsBoundary? = nil,
        roleId: String? = nil,
        roleLastUsed: RoleLastUsed? = nil,
        roleName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.createDate = createDate
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleId = roleId
        self.roleLastUsed = roleLastUsed
        self.roleName = roleName
        self.tags = tags
    }
}

extension RoleDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case instanceProfileList = "InstanceProfileList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case rolePolicyList = "RolePolicyList"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: Key("AssumeRolePolicyDocument"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttachedManagedPolicies"))
            for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let instanceProfileList = instanceProfileList {
            var instanceProfileListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("InstanceProfileList"))
            for (index0, instanceprofile0) in instanceProfileList.enumerated() {
                try instanceProfileListContainer.encode(instanceprofile0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        if let rolePolicyList = rolePolicyList {
            var rolePolicyListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RolePolicyList"))
            for (index0, policydetail0) in rolePolicyList.enumerated() {
                try rolePolicyListContainer.encode(policydetail0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        if containerValues.contains(.instanceProfileList) {
            struct KeyVal0{struct member{}}
            let instanceProfileListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfileList)
            if let instanceProfileListWrappedContainer = instanceProfileListWrappedContainer {
                let instanceProfileListContainer = try instanceProfileListWrappedContainer.decodeIfPresent([InstanceProfile].self, forKey: .member)
                var instanceProfileListBuffer:[InstanceProfile]? = nil
                if let instanceProfileListContainer = instanceProfileListContainer {
                    instanceProfileListBuffer = [InstanceProfile]()
                    for structureContainer0 in instanceProfileListContainer {
                        instanceProfileListBuffer?.append(structureContainer0)
                    }
                }
                instanceProfileList = instanceProfileListBuffer
            } else {
                instanceProfileList = []
            }
        } else {
            instanceProfileList = nil
        }
        if containerValues.contains(.rolePolicyList) {
            struct KeyVal0{struct member{}}
            let rolePolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rolePolicyList)
            if let rolePolicyListWrappedContainer = rolePolicyListWrappedContainer {
                let rolePolicyListContainer = try rolePolicyListWrappedContainer.decodeIfPresent([PolicyDetail].self, forKey: .member)
                var rolePolicyListBuffer:[PolicyDetail]? = nil
                if let rolePolicyListContainer = rolePolicyListContainer {
                    rolePolicyListBuffer = [PolicyDetail]()
                    for structureContainer0 in rolePolicyListContainer {
                        rolePolicyListBuffer?.append(structureContainer0)
                    }
                }
                rolePolicyList = rolePolicyListBuffer
            } else {
                rolePolicyList = []
            }
        } else {
            rolePolicyList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let roleLastUsedDecoded = try containerValues.decodeIfPresent(RoleLastUsed.self, forKey: .roleLastUsed)
        roleLastUsed = roleLastUsedDecoded
    }
}

extension RoleDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoleDetail(arn: \(String(describing: arn)), assumeRolePolicyDocument: \(String(describing: assumeRolePolicyDocument)), attachedManagedPolicies: \(String(describing: attachedManagedPolicies)), createDate: \(String(describing: createDate)), instanceProfileList: \(String(describing: instanceProfileList)), path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), roleId: \(String(describing: roleId)), roleLastUsed: \(String(describing: roleLastUsed)), roleName: \(String(describing: roleName)), rolePolicyList: \(String(describing: rolePolicyList)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about an IAM role, including all of the role's policies.</p>
///          <p>This data type is used as a response element in the <a>GetAccountAuthorizationDetails</a> operation.</p>
public struct RoleDetail: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let arn: String?
    /// <p>The trust policy that grants permission to assume the role.</p>
    public let assumeRolePolicyDocument: String?
    /// <p>A list of managed policies attached to the role. These policies are the role's access
    ///          (permissions) policies.</p>
    public let attachedManagedPolicies: [AttachedPolicy]?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the role was created.</p>
    public let createDate: Date?
    /// <p>A list of instance profiles that contain this role.</p>
    public let instanceProfileList: [InstanceProfile]?
    /// <p>The path to the role. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let path: String?
    /// <p>The ARN of the policy used to set the permissions boundary for the role.</p>
    ///          <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///             identities </a> in the <i>IAM User Guide</i>.</p>
    public let permissionsBoundary: AttachedPermissionsBoundary?
    /// <p>The stable and unique string identifying the role. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>.</p>
    public let roleId: String?
    /// <p>Contains information about the last time that an IAM role was used. This includes the
    ///          date and time and the Region in which the role was last used. Activity is only reported for
    ///          the trailing 400 days. This period can be shorter if your Region began supporting these
    ///          features within the last year. The role might have been used more than 400 days ago. For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period">Regions where data is tracked</a> in the <i>IAM User
    ///          Guide</i>.</p>
    public let roleLastUsed: RoleLastUsed?
    /// <p>The friendly name that identifies the role.</p>
    public let roleName: String?
    /// <p>A list of inline policies embedded in the role. These policies are the role's access
    ///          (permissions) policies.</p>
    public let rolePolicyList: [PolicyDetail]?
    /// <p>A list of tags that are attached to the role. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        assumeRolePolicyDocument: String? = nil,
        attachedManagedPolicies: [AttachedPolicy]? = nil,
        createDate: Date? = nil,
        instanceProfileList: [InstanceProfile]? = nil,
        path: String? = nil,
        permissionsBoundary: AttachedPermissionsBoundary? = nil,
        roleId: String? = nil,
        roleLastUsed: RoleLastUsed? = nil,
        roleName: String? = nil,
        rolePolicyList: [PolicyDetail]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.attachedManagedPolicies = attachedManagedPolicies
        self.createDate = createDate
        self.instanceProfileList = instanceProfileList
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleId = roleId
        self.roleLastUsed = roleLastUsed
        self.roleName = roleName
        self.rolePolicyList = rolePolicyList
        self.tags = tags
    }
}

extension RoleLastUsed: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encode(TimestampWrapper(lastUsedDate, format: .dateTime), forKey: Key("lastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUsedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUsedDate)
        var lastUsedDateBuffer:Date? = nil
        if let lastUsedDateDecoded = lastUsedDateDecoded {
            lastUsedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUsedDateDecoded, format: .dateTime)
        }
        lastUsedDate = lastUsedDateBuffer
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension RoleLastUsed: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoleLastUsed(lastUsedDate: \(String(describing: lastUsedDate)), region: \(String(describing: region)))"}
}

/// <p>Contains information about the last time that an IAM role was used. This includes the
///          date and time and the Region in which the role was last used. Activity is only reported for
///          the trailing 400 days. This period can be shorter if your Region began supporting these
///          features within the last year. The role might have been used more than 400 days ago. For
///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period">Regions where data is tracked</a> in the <i>IAM User
///          Guide</i>.</p>
///          <p>This data type is returned as a response element in the <a>GetRole</a> and
///             <a>GetAccountAuthorizationDetails</a> operations.</p>
public struct RoleLastUsed: Equatable {
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a> that the role was last used.</p>
    ///          <p>This field is null if the role has not been used within the IAM tracking period. For
    ///          more information about the tracking period, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period">Regions where data is tracked</a> in the <i>IAM User Guide</i>. </p>
    public let lastUsedDate: Date?
    /// <p>The name of the AWS Region in which the role was last used.</p>
    public let region: String?

    public init (
        lastUsedDate: Date? = nil,
        region: String? = nil
    )
    {
        self.lastUsedDate = lastUsedDate
        self.region = region
    }
}

extension RoleUsageType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case region = "Region"
        case resources = "Resources"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
        if let resources = resources {
            var resourcesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Resources"))
            for (index0, arntype0) in resources.enumerated() {
                try resourcesContainer.encode(arntype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        if containerValues.contains(.resources) {
            struct KeyVal0{struct member{}}
            let resourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resources)
            if let resourcesWrappedContainer = resourcesWrappedContainer {
                let resourcesContainer = try resourcesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var resourcesBuffer:[String]? = nil
                if let resourcesContainer = resourcesContainer {
                    resourcesBuffer = [String]()
                    for stringContainer0 in resourcesContainer {
                        resourcesBuffer?.append(stringContainer0)
                    }
                }
                resources = resourcesBuffer
            } else {
                resources = []
            }
        } else {
            resources = nil
        }
    }
}

extension RoleUsageType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoleUsageType(region: \(String(describing: region)), resources: \(String(describing: resources)))"}
}

/// <p>An object that contains details about how a service-linked role is used, if that
///          information is returned by the service.</p>
///          <p>This data type is used as a response element in the <a>GetServiceLinkedRoleDeletionStatus</a> operation.</p>
public struct RoleUsageType: Equatable {
    /// <p>The name of the Region where the service-linked role is being used.</p>
    public let region: String?
    /// <p>The name of the resource that is using the service-linked role.</p>
    public let resources: [String]?

    public init (
        region: String? = nil,
        resources: [String]? = nil
    )
    {
        self.region = region
        self.resources = resources
    }
}

extension SAMLProviderListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case validUntil = "ValidUntil"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let validUntil = validUntil {
            try container.encode(TimestampWrapper(validUntil, format: .dateTime), forKey: Key("validUntil"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let validUntilDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validUntil)
        var validUntilBuffer:Date? = nil
        if let validUntilDecoded = validUntilDecoded {
            validUntilBuffer = try TimestampWrapperDecoder.parseDateStringValue(validUntilDecoded, format: .dateTime)
        }
        validUntil = validUntilBuffer
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
    }
}

extension SAMLProviderListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SAMLProviderListEntry(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), validUntil: \(String(describing: validUntil)))"}
}

/// <p>Contains the list of SAML providers for this account.</p>
public struct SAMLProviderListEntry: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the SAML provider.</p>
    public let arn: String?
    /// <p>The date and time when the SAML provider was created.</p>
    public let createDate: Date?
    /// <p>The expiration date and time for the SAML provider.</p>
    public let validUntil: Date?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        validUntil: Date? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.validUntil = validUntil
    }
}

extension SSHPublicKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fingerprint = "Fingerprint"
        case sSHPublicKeyBody = "SSHPublicKeyBody"
        case sSHPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let fingerprint = fingerprint {
            try container.encode(fingerprint, forKey: Key("Fingerprint"))
        }
        if let sSHPublicKeyBody = sSHPublicKeyBody {
            try container.encode(sSHPublicKeyBody, forKey: Key("SSHPublicKeyBody"))
        }
        if let sSHPublicKeyId = sSHPublicKeyId {
            try container.encode(sSHPublicKeyId, forKey: Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encode(TimestampWrapper(uploadDate, format: .dateTime), forKey: Key("uploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let sSHPublicKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSHPublicKeyId)
        sSHPublicKeyId = sSHPublicKeyIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let sSHPublicKeyBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSHPublicKeyBody)
        sSHPublicKeyBody = sSHPublicKeyBodyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadDate)
        var uploadDateBuffer:Date? = nil
        if let uploadDateDecoded = uploadDateDecoded {
            uploadDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(uploadDateDecoded, format: .dateTime)
        }
        uploadDate = uploadDateBuffer
    }
}

extension SSHPublicKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSHPublicKey(fingerprint: \(String(describing: fingerprint)), sSHPublicKeyBody: \(String(describing: sSHPublicKeyBody)), sSHPublicKeyId: \(String(describing: sSHPublicKeyId)), status: \(String(describing: status)), uploadDate: \(String(describing: uploadDate)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about an SSH public key.</p>
///          <p>This data type is used as a response element in the <a>GetSSHPublicKey</a>
///          and <a>UploadSSHPublicKey</a> operations. </p>
public struct SSHPublicKey: Equatable {
    /// <p>The MD5 message digest of the SSH public key.</p>
    public let fingerprint: String?
    /// <p>The SSH public key.</p>
    public let sSHPublicKeyBody: String?
    /// <p>The unique identifier for the SSH public key.</p>
    public let sSHPublicKeyId: String?
    /// <p>The status of the SSH public key. <code>Active</code> means that the key can be used for
    ///          authentication with an AWS CodeCommit repository. <code>Inactive</code> means that the key
    ///          cannot be used.</p>
    public let status: StatusType?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the SSH public key was uploaded.</p>
    public let uploadDate: Date?
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    public let userName: String?

    public init (
        fingerprint: String? = nil,
        sSHPublicKeyBody: String? = nil,
        sSHPublicKeyId: String? = nil,
        status: StatusType? = nil,
        uploadDate: Date? = nil,
        userName: String? = nil
    )
    {
        self.fingerprint = fingerprint
        self.sSHPublicKeyBody = sSHPublicKeyBody
        self.sSHPublicKeyId = sSHPublicKeyId
        self.status = status
        self.uploadDate = uploadDate
        self.userName = userName
    }
}

extension SSHPublicKeyMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sSHPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sSHPublicKeyId = sSHPublicKeyId {
            try container.encode(sSHPublicKeyId, forKey: Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encode(TimestampWrapper(uploadDate, format: .dateTime), forKey: Key("uploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let sSHPublicKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSHPublicKeyId)
        sSHPublicKeyId = sSHPublicKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadDate)
        var uploadDateBuffer:Date? = nil
        if let uploadDateDecoded = uploadDateDecoded {
            uploadDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(uploadDateDecoded, format: .dateTime)
        }
        uploadDate = uploadDateBuffer
    }
}

extension SSHPublicKeyMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSHPublicKeyMetadata(sSHPublicKeyId: \(String(describing: sSHPublicKeyId)), status: \(String(describing: status)), uploadDate: \(String(describing: uploadDate)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about an SSH public key, without the key's body or
///          fingerprint.</p>
///          <p>This data type is used as a response element in the <a>ListSSHPublicKeys</a>
///          operation.</p>
public struct SSHPublicKeyMetadata: Equatable {
    /// <p>The unique identifier for the SSH public key.</p>
    public let sSHPublicKeyId: String?
    /// <p>The status of the SSH public key. <code>Active</code> means that the key can be used for
    ///          authentication with an AWS CodeCommit repository. <code>Inactive</code> means that the key
    ///          cannot be used.</p>
    public let status: StatusType?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the SSH public key was uploaded.</p>
    public let uploadDate: Date?
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    public let userName: String?

    public init (
        sSHPublicKeyId: String? = nil,
        status: StatusType? = nil,
        uploadDate: Date? = nil,
        userName: String? = nil
    )
    {
        self.sSHPublicKeyId = sSHPublicKeyId
        self.status = status
        self.uploadDate = uploadDate
        self.userName = userName
    }
}

extension ServerCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateBody = "CertificateBody"
        case certificateChain = "CertificateChain"
        case serverCertificateMetadata = "ServerCertificateMetadata"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: Key("CertificateChain"))
        }
        if let serverCertificateMetadata = serverCertificateMetadata {
            try container.encode(serverCertificateMetadata, forKey: Key("ServerCertificateMetadata"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateMetadataDecoded = try containerValues.decodeIfPresent(ServerCertificateMetadata.self, forKey: .serverCertificateMetadata)
        serverCertificateMetadata = serverCertificateMetadataDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ServerCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerCertificate(certificateBody: \(String(describing: certificateBody)), certificateChain: \(String(describing: certificateChain)), serverCertificateMetadata: \(String(describing: serverCertificateMetadata)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about a server certificate.</p>
///          <p> This data type is used as a response element in the <a>GetServerCertificate</a> operation. </p>
public struct ServerCertificate: Equatable {
    /// <p>The contents of the public key certificate.</p>
    public let certificateBody: String?
    /// <p>The contents of the public key certificate chain.</p>
    public let certificateChain: String?
    /// <p>The meta information of the server certificate, such as its name, path, ID, and
    ///          ARN.</p>
    public let serverCertificateMetadata: ServerCertificateMetadata?
    /// <p>A list of tags that are attached to the server certificate. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        certificateBody: String? = nil,
        certificateChain: String? = nil,
        serverCertificateMetadata: ServerCertificateMetadata? = nil,
        tags: [Tag]? = nil
    )
    {
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.serverCertificateMetadata = serverCertificateMetadata
        self.tags = tags
    }
}

extension ServerCertificateMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case expiration = "Expiration"
        case path = "Path"
        case serverCertificateId = "ServerCertificateId"
        case serverCertificateName = "ServerCertificateName"
        case uploadDate = "UploadDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let expiration = expiration {
            try container.encode(TimestampWrapper(expiration, format: .dateTime), forKey: Key("expiration"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let serverCertificateId = serverCertificateId {
            try container.encode(serverCertificateId, forKey: Key("ServerCertificateId"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        if let uploadDate = uploadDate {
            try container.encode(TimestampWrapper(uploadDate, format: .dateTime), forKey: Key("uploadDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let serverCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverCertificateId)
        serverCertificateId = serverCertificateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let uploadDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadDate)
        var uploadDateBuffer:Date? = nil
        if let uploadDateDecoded = uploadDateDecoded {
            uploadDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(uploadDateDecoded, format: .dateTime)
        }
        uploadDate = uploadDateBuffer
        let expirationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiration)
        var expirationBuffer:Date? = nil
        if let expirationDecoded = expirationDecoded {
            expirationBuffer = try TimestampWrapperDecoder.parseDateStringValue(expirationDecoded, format: .dateTime)
        }
        expiration = expirationBuffer
    }
}

extension ServerCertificateMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerCertificateMetadata(arn: \(String(describing: arn)), expiration: \(String(describing: expiration)), path: \(String(describing: path)), serverCertificateId: \(String(describing: serverCertificateId)), serverCertificateName: \(String(describing: serverCertificateName)), uploadDate: \(String(describing: uploadDate)))"}
}

/// <p>Contains information about a server certificate without its certificate body,
///          certificate chain, and private key.</p>
///          <p> This data type is used as a response element in the <a>UploadServerCertificate</a> and <a>ListServerCertificates</a>
///          operations. </p>
public struct ServerCertificateMetadata: Equatable {
    /// <p> The Amazon Resource Name (ARN) specifying the server certificate. For more information
    ///          about ARNs and how to use them in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>. </p>
    public let arn: String?
    /// <p>The date on which the certificate is set to expire.</p>
    public let expiration: Date?
    /// <p> The path to the server certificate. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let path: String?
    /// <p> The stable and unique string identifying the server certificate. For more information
    ///          about IDs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let serverCertificateId: String?
    /// <p>The name that identifies the server certificate.</p>
    public let serverCertificateName: String?
    /// <p>The date when the server certificate was uploaded.</p>
    public let uploadDate: Date?

    public init (
        arn: String? = nil,
        expiration: Date? = nil,
        path: String? = nil,
        serverCertificateId: String? = nil,
        serverCertificateName: String? = nil,
        uploadDate: Date? = nil
    )
    {
        self.arn = arn
        self.expiration = expiration
        self.path = path
        self.serverCertificateId = serverCertificateId
        self.serverCertificateName = serverCertificateName
        self.uploadDate = uploadDate
    }
}

extension ServiceFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceFailureException(message: \(String(describing: message)))"}
}

extension ServiceFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ServiceFailureExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception or
///       failure.</p>
public struct ServiceFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Equatable {
    public let message: String?
}

extension ServiceFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceLastAccessed: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastAuthenticated = "LastAuthenticated"
        case lastAuthenticatedEntity = "LastAuthenticatedEntity"
        case lastAuthenticatedRegion = "LastAuthenticatedRegion"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
        case trackedActionsLastAccessed = "TrackedActionsLastAccessed"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastAuthenticated = lastAuthenticated {
            try container.encode(TimestampWrapper(lastAuthenticated, format: .dateTime), forKey: Key("lastAuthenticated"))
        }
        if let lastAuthenticatedEntity = lastAuthenticatedEntity {
            try container.encode(lastAuthenticatedEntity, forKey: Key("LastAuthenticatedEntity"))
        }
        if let lastAuthenticatedRegion = lastAuthenticatedRegion {
            try container.encode(lastAuthenticatedRegion, forKey: Key("LastAuthenticatedRegion"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: Key("TotalAuthenticatedEntities"))
        }
        if let trackedActionsLastAccessed = trackedActionsLastAccessed {
            var trackedActionsLastAccessedContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TrackedActionsLastAccessed"))
            for (index0, trackedactionlastaccessed0) in trackedActionsLastAccessed.enumerated() {
                try trackedActionsLastAccessedContainer.encode(trackedactionlastaccessed0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let lastAuthenticatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAuthenticated)
        var lastAuthenticatedBuffer:Date? = nil
        if let lastAuthenticatedDecoded = lastAuthenticatedDecoded {
            lastAuthenticatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastAuthenticatedDecoded, format: .dateTime)
        }
        lastAuthenticated = lastAuthenticatedBuffer
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let lastAuthenticatedEntityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAuthenticatedEntity)
        lastAuthenticatedEntity = lastAuthenticatedEntityDecoded
        let lastAuthenticatedRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAuthenticatedRegion)
        lastAuthenticatedRegion = lastAuthenticatedRegionDecoded
        let totalAuthenticatedEntitiesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalAuthenticatedEntities)
        totalAuthenticatedEntities = totalAuthenticatedEntitiesDecoded
        if containerValues.contains(.trackedActionsLastAccessed) {
            struct KeyVal0{struct member{}}
            let trackedActionsLastAccessedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .trackedActionsLastAccessed)
            if let trackedActionsLastAccessedWrappedContainer = trackedActionsLastAccessedWrappedContainer {
                let trackedActionsLastAccessedContainer = try trackedActionsLastAccessedWrappedContainer.decodeIfPresent([TrackedActionLastAccessed].self, forKey: .member)
                var trackedActionsLastAccessedBuffer:[TrackedActionLastAccessed]? = nil
                if let trackedActionsLastAccessedContainer = trackedActionsLastAccessedContainer {
                    trackedActionsLastAccessedBuffer = [TrackedActionLastAccessed]()
                    for structureContainer0 in trackedActionsLastAccessedContainer {
                        trackedActionsLastAccessedBuffer?.append(structureContainer0)
                    }
                }
                trackedActionsLastAccessed = trackedActionsLastAccessedBuffer
            } else {
                trackedActionsLastAccessed = []
            }
        } else {
            trackedActionsLastAccessed = nil
        }
    }
}

extension ServiceLastAccessed: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceLastAccessed(lastAuthenticated: \(String(describing: lastAuthenticated)), lastAuthenticatedEntity: \(String(describing: lastAuthenticatedEntity)), lastAuthenticatedRegion: \(String(describing: lastAuthenticatedRegion)), serviceName: \(String(describing: serviceName)), serviceNamespace: \(String(describing: serviceNamespace)), totalAuthenticatedEntities: \(String(describing: totalAuthenticatedEntities)), trackedActionsLastAccessed: \(String(describing: trackedActionsLastAccessed)))"}
}

/// <p>Contains details about the most recent attempt to access the service.</p>
///          <p>This data type is used as a response element in the <a>GetServiceLastAccessedDetails</a> operation.</p>
public struct ServiceLastAccessed: Equatable {
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when an authenticated entity most recently attempted to access the
    ///          service. AWS does not report unauthenticated requests.</p>
    ///          <p>This field is null if no IAM entities attempted to access the service within the
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let lastAuthenticated: Date?
    /// <p>The ARN of the authenticated entity (user or role) that last attempted to access the
    ///          service. AWS does not report unauthenticated requests.</p>
    ///          <p>This field is null if no IAM entities attempted to access the service within the
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let lastAuthenticatedEntity: String?
    /// <p>The Region from which the authenticated entity (user or role) last attempted to access
    ///          the service. AWS does not report unauthenticated requests.</p>
    ///          <p>This field is null if no IAM entities attempted to access the service within the
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let lastAuthenticatedRegion: String?
    /// <p>The name of the service in which access was attempted.</p>
    public let serviceName: String?
    /// <p>The namespace of the service in which access was attempted.</p>
    ///          <p>To learn the service namespace of a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
    ///             <i>Service Authorization Reference</i>. Choose the name of the service to
    ///          view details for that service. In the first paragraph, find the service prefix. For
    ///          example, <code>(service prefix: a4b)</code>. For more information about service namespaces,
    ///          see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
    ///             Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let serviceNamespace: String?
    /// <p>The total number of authenticated principals (root user, IAM users, or IAM roles)
    ///          that have attempted to access the service.</p>
    ///          <p>This field is null if no principals attempted to access the service within the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let totalAuthenticatedEntities: Int?
    /// <p>An object that contains details about the most recent attempt to access a tracked action
    ///          within the service.</p>
    ///          <p>This field is null if there no tracked actions or if the principal did not use the
    ///          tracked actions within the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>. This field is also null if the report was generated at the
    ///          service level and not the action level. For more information, see the
    ///             <code>Granularity</code> field in <a>GenerateServiceLastAccessedDetails</a>.</p>
    public let trackedActionsLastAccessed: [TrackedActionLastAccessed]?

    public init (
        lastAuthenticated: Date? = nil,
        lastAuthenticatedEntity: String? = nil,
        lastAuthenticatedRegion: String? = nil,
        serviceName: String? = nil,
        serviceNamespace: String? = nil,
        totalAuthenticatedEntities: Int? = nil,
        trackedActionsLastAccessed: [TrackedActionLastAccessed]? = nil
    )
    {
        self.lastAuthenticated = lastAuthenticated
        self.lastAuthenticatedEntity = lastAuthenticatedEntity
        self.lastAuthenticatedRegion = lastAuthenticatedRegion
        self.serviceName = serviceName
        self.serviceNamespace = serviceNamespace
        self.totalAuthenticatedEntities = totalAuthenticatedEntities
        self.trackedActionsLastAccessed = trackedActionsLastAccessed
    }
}

extension ServiceNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNotSupportedException(message: \(String(describing: message)))"}
}

extension ServiceNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ServiceNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified service does not support service-specific credentials.</p>
public struct ServiceNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension ServiceNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceSpecificCredential: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case servicePassword = "ServicePassword"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let servicePassword = servicePassword {
            try container.encode(servicePassword, forKey: Key("ServicePassword"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceUserNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceUserName)
        serviceUserName = serviceUserNameDecoded
        let servicePasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .servicePassword)
        servicePassword = servicePasswordDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceSpecificCredential: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceSpecificCredential(createDate: \(String(describing: createDate)), serviceName: \(String(describing: serviceName)), servicePassword: \(String(describing: servicePassword)), serviceSpecificCredentialId: \(String(describing: serviceSpecificCredentialId)), serviceUserName: \(String(describing: serviceUserName)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

/// <p>Contains the details of a service-specific credential.</p>
public struct ServiceSpecificCredential: Equatable {
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the service-specific credential were created.</p>
    public let createDate: Date?
    /// <p>The name of the service associated with the service-specific credential.</p>
    public let serviceName: String?
    /// <p>The generated password for the service-specific credential.</p>
    public let servicePassword: String?
    /// <p>The unique identifier for the service-specific credential.</p>
    public let serviceSpecificCredentialId: String?
    /// <p>The generated user name for the service-specific credential. This value is generated by
    ///          combining the IAM user's name combined with the ID number of the AWS account, as in
    ///             <code>jane-at-123456789012</code>, for example. This value cannot be configured by the
    ///          user.</p>
    public let serviceUserName: String?
    /// <p>The status of the service-specific credential. <code>Active</code> means that the key is
    ///          valid for API calls, while <code>Inactive</code> means it is not.</p>
    public let status: StatusType?
    /// <p>The name of the IAM user associated with the service-specific credential.</p>
    public let userName: String?

    public init (
        createDate: Date? = nil,
        serviceName: String? = nil,
        servicePassword: String? = nil,
        serviceSpecificCredentialId: String? = nil,
        serviceUserName: String? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.createDate = createDate
        self.serviceName = serviceName
        self.servicePassword = servicePassword
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.serviceUserName = serviceUserName
        self.status = status
        self.userName = userName
    }
}

extension ServiceSpecificCredentialMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let serviceUserNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceUserName)
        serviceUserName = serviceUserNameDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ServiceSpecificCredentialMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceSpecificCredentialMetadata(createDate: \(String(describing: createDate)), serviceName: \(String(describing: serviceName)), serviceSpecificCredentialId: \(String(describing: serviceSpecificCredentialId)), serviceUserName: \(String(describing: serviceUserName)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

/// <p>Contains additional details about a service-specific credential.</p>
public struct ServiceSpecificCredentialMetadata: Equatable {
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the service-specific credential were created.</p>
    public let createDate: Date?
    /// <p>The name of the service associated with the service-specific credential.</p>
    public let serviceName: String?
    /// <p>The unique identifier for the service-specific credential.</p>
    public let serviceSpecificCredentialId: String?
    /// <p>The generated user name for the service-specific credential.</p>
    public let serviceUserName: String?
    /// <p>The status of the service-specific credential. <code>Active</code> means that the key is
    ///          valid for API calls, while <code>Inactive</code> means it is not.</p>
    public let status: StatusType?
    /// <p>The name of the IAM user associated with the service-specific credential.</p>
    public let userName: String?

    public init (
        createDate: Date? = nil,
        serviceName: String? = nil,
        serviceSpecificCredentialId: String? = nil,
        serviceUserName: String? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.createDate = createDate
        self.serviceName = serviceName
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.serviceUserName = serviceUserName
        self.status = status
        self.userName = userName
    }
}

public struct SetDefaultPolicyVersionInputBodyMiddleware: Middleware {
    public let id: String = "SetDefaultPolicyVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultPolicyVersionInput>
    public typealias MOutput = OperationOutput<SetDefaultPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultPolicyVersionOutputError>
}

extension SetDefaultPolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDefaultPolicyVersionInput(policyArn: \(String(describing: policyArn)), versionId: \(String(describing: versionId)))"}
}

extension SetDefaultPolicyVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
        try container.encode("SetDefaultPolicyVersion", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct SetDefaultPolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "SetDefaultPolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultPolicyVersionInput>
    public typealias MOutput = OperationOutput<SetDefaultPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultPolicyVersionOutputError>
}

public struct SetDefaultPolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "SetDefaultPolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultPolicyVersionInput>
    public typealias MOutput = OperationOutput<SetDefaultPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultPolicyVersionOutputError>
}

public struct SetDefaultPolicyVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy whose default version you want to
    ///             set.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policyArn: String?
    /// <p>The version of the policy to set as the default (operative) version.</p>
    ///         <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    ///                 policies</a> in the <i>IAM User Guide</i>.</p>
    public let versionId: String?

    public init (
        policyArn: String? = nil,
        versionId: String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

extension SetDefaultPolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetDefaultPolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetDefaultPolicyVersionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetDefaultPolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDefaultPolicyVersionOutputResponse()"}
}

extension SetDefaultPolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetDefaultPolicyVersionOutputResponse: Equatable {

    public init() {}
}

struct SetDefaultPolicyVersionOutputResponseBody: Equatable {
}

extension SetDefaultPolicyVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetSecurityTokenServicePreferencesInputBodyMiddleware: Middleware {
    public let id: String = "SetSecurityTokenServicePreferencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSecurityTokenServicePreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSecurityTokenServicePreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSecurityTokenServicePreferencesInput>
    public typealias MOutput = OperationOutput<SetSecurityTokenServicePreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSecurityTokenServicePreferencesOutputError>
}

extension SetSecurityTokenServicePreferencesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSecurityTokenServicePreferencesInput(globalEndpointTokenVersion: \(String(describing: globalEndpointTokenVersion)))"}
}

extension SetSecurityTokenServicePreferencesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let globalEndpointTokenVersion = globalEndpointTokenVersion {
            try container.encode(globalEndpointTokenVersion, forKey: Key("GlobalEndpointTokenVersion"))
        }
        try container.encode("SetSecurityTokenServicePreferences", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct SetSecurityTokenServicePreferencesInputHeadersMiddleware: Middleware {
    public let id: String = "SetSecurityTokenServicePreferencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSecurityTokenServicePreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSecurityTokenServicePreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSecurityTokenServicePreferencesInput>
    public typealias MOutput = OperationOutput<SetSecurityTokenServicePreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSecurityTokenServicePreferencesOutputError>
}

public struct SetSecurityTokenServicePreferencesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetSecurityTokenServicePreferencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSecurityTokenServicePreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSecurityTokenServicePreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSecurityTokenServicePreferencesInput>
    public typealias MOutput = OperationOutput<SetSecurityTokenServicePreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSecurityTokenServicePreferencesOutputError>
}

public struct SetSecurityTokenServicePreferencesInput: Equatable {
    /// <p>The version of the global endpoint token. Version 1 tokens are valid only in AWS
    ///             Regions that are available by default. These tokens do not work in manually enabled
    ///             Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions.
    ///             However, version 2 tokens are longer and might affect systems where you temporarily
    ///             store tokens.</p>
    ///         <p>For information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
    ///                 deactivating STS in an AWS region</a> in the
    ///                 <i>IAM User Guide</i>.</p>
    public let globalEndpointTokenVersion: GlobalEndpointTokenVersion?

    public init (
        globalEndpointTokenVersion: GlobalEndpointTokenVersion? = nil
    )
    {
        self.globalEndpointTokenVersion = globalEndpointTokenVersion
    }
}

extension SetSecurityTokenServicePreferencesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSecurityTokenServicePreferencesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSecurityTokenServicePreferencesOutputError: Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSecurityTokenServicePreferencesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSecurityTokenServicePreferencesOutputResponse()"}
}

extension SetSecurityTokenServicePreferencesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetSecurityTokenServicePreferencesOutputResponse: Equatable {

    public init() {}
}

struct SetSecurityTokenServicePreferencesOutputResponseBody: Equatable {
}

extension SetSecurityTokenServicePreferencesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SigningCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateBody = "CertificateBody"
        case certificateId = "CertificateId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: Key("CertificateBody"))
        }
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encode(TimestampWrapper(uploadDate, format: .dateTime), forKey: Key("uploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadDate)
        var uploadDateBuffer:Date? = nil
        if let uploadDateDecoded = uploadDateDecoded {
            uploadDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(uploadDateDecoded, format: .dateTime)
        }
        uploadDate = uploadDateBuffer
    }
}

extension SigningCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningCertificate(certificateBody: \(String(describing: certificateBody)), certificateId: \(String(describing: certificateId)), status: \(String(describing: status)), uploadDate: \(String(describing: uploadDate)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about an X.509 signing certificate.</p>
///          <p>This data type is used as a response element in the <a>UploadSigningCertificate</a> and <a>ListSigningCertificates</a>
///          operations. </p>
public struct SigningCertificate: Equatable {
    /// <p>The contents of the signing certificate.</p>
    public let certificateBody: String?
    /// <p>The ID for the signing certificate.</p>
    public let certificateId: String?
    /// <p>The status of the signing certificate. <code>Active</code> means that the key is valid
    ///          for API calls, while <code>Inactive</code> means it is not.</p>
    public let status: StatusType?
    /// <p>The date when the signing certificate was uploaded.</p>
    public let uploadDate: Date?
    /// <p>The name of the user the signing certificate is associated with.</p>
    public let userName: String?

    public init (
        certificateBody: String? = nil,
        certificateId: String? = nil,
        status: StatusType? = nil,
        uploadDate: Date? = nil,
        userName: String? = nil
    )
    {
        self.certificateBody = certificateBody
        self.certificateId = certificateId
        self.status = status
        self.uploadDate = uploadDate
        self.userName = userName
    }
}

public struct SimulateCustomPolicyInputBodyMiddleware: Middleware {
    public let id: String = "SimulateCustomPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SimulateCustomPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SimulateCustomPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SimulateCustomPolicyInput>
    public typealias MOutput = OperationOutput<SimulateCustomPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SimulateCustomPolicyOutputError>
}

extension SimulateCustomPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulateCustomPolicyInput(actionNames: \(String(describing: actionNames)), callerArn: \(String(describing: callerArn)), contextEntries: \(String(describing: contextEntries)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), permissionsBoundaryPolicyInputList: \(String(describing: permissionsBoundaryPolicyInputList)), policyInputList: \(String(describing: policyInputList)), resourceArns: \(String(describing: resourceArns)), resourceHandlingOption: \(String(describing: resourceHandlingOption)), resourceOwner: \(String(describing: resourceOwner)), resourcePolicy: \(String(describing: resourcePolicy)))"}
}

extension SimulateCustomPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionNames = actionNames {
            var actionNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ActionNames"))
            for (index0, actionnametype0) in actionNames.enumerated() {
                try actionNamesContainer.encode(actionnametype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            var contextEntriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ContextEntries"))
            for (index0, contextentry0) in contextEntries.enumerated() {
                try contextEntriesContainer.encode(contextentry0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PermissionsBoundaryPolicyInputList"))
            for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let policyInputList = policyInputList {
            var policyInputListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyInputList"))
            for (index0, policydocumenttype0) in policyInputList.enumerated() {
                try policyInputListContainer.encode(policydocumenttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceArns"))
            for (index0, resourcenametype0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcenametype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: Key("ResourcePolicy"))
        }
        try container.encode("SimulateCustomPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct SimulateCustomPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "SimulateCustomPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SimulateCustomPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SimulateCustomPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SimulateCustomPolicyInput>
    public typealias MOutput = OperationOutput<SimulateCustomPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SimulateCustomPolicyOutputError>
}

public struct SimulateCustomPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "SimulateCustomPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SimulateCustomPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SimulateCustomPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SimulateCustomPolicyInput>
    public typealias MOutput = OperationOutput<SimulateCustomPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SimulateCustomPolicyOutputError>
}

public struct SimulateCustomPolicyInput: Equatable {
    /// <p>A list of names of API operations to evaluate in the simulation. Each operation is
    ///             evaluated against each resource. Each operation must include the service identifier,
    ///             such as <code>iam:CreateUser</code>. This operation does not support using wildcards (*)
    ///             in an action name.</p>
    public let actionNames: [String]?
    /// <p>The ARN of the IAM user that you want to use as the simulated caller of the API
    ///             operations. <code>CallerArn</code> is required if you include a
    ///                 <code>ResourcePolicy</code> so that the policy's <code>Principal</code> element has
    ///             a value to use in evaluating the policy.</p>
    ///         <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
    ///             assumed role, federated user, or a service principal.</p>
    public let callerArn: String?
    /// <p>A list of context keys and corresponding values for the simulation to use. Whenever a
    ///             context key is evaluated in one of the simulated IAM permissions policies, the
    ///             corresponding value is supplied.</p>
    public let contextEntries: [ContextEntry]?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The IAM permissions boundary policy to simulate. The permissions boundary sets the
    ///             maximum permissions that an IAM entity can have. You can input only one permissions
    ///             boundary when you pass a policy to this operation. For more information about
    ///             permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///                 entities</a> in the <i>IAM User Guide</i>. The policy input is
    ///             specified as a string that contains the complete, valid JSON text of a permissions
    ///             boundary policy.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let permissionsBoundaryPolicyInputList: [String]?
    /// <p>A list of policy documents to include in the simulation. Each document is specified as
    ///             a string containing the complete, valid JSON text of an IAM policy. Do not include any
    ///             resource-based policies in this parameter. Any resource-based policy must be submitted
    ///             with the <code>ResourcePolicy</code> parameter. The policies cannot be "scope-down"
    ///             policies, such as you could include in a call to <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetFederationToken.html">GetFederationToken</a> or one of
    ///             the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_AssumeRole.html">AssumeRole</a> API operations. In other words, do not use policies designed to
    ///             restrict what a user can do while using the temporary credentials.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyInputList: [String]?
    /// <p>A list of ARNs of AWS resources to include in the simulation. If this parameter is
    ///             not provided, then the value defaults to <code>*</code> (all resources). Each API in the
    ///                 <code>ActionNames</code> parameter is evaluated for each resource in this list. The
    ///             simulation determines the access result (allowed or denied) of each combination and
    ///             reports it in the response. You can simulate resources that don't exist in your
    ///             account.</p>
    ///         <p>The simulation does not automatically retrieve policies for the specified resources.
    ///             If you want to include a resource policy in the simulation, then you must include the
    ///             policy as a string in the <code>ResourcePolicy</code> parameter.</p>
    ///         <p>If you include a <code>ResourcePolicy</code>, then it must be applicable to all of the
    ///             resources included in the simulation or you receive an invalid input error.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let resourceArns: [String]?
    /// <p>Specifies the type of simulation to run. Different API operations that support
    ///             resource-based policies require different combinations of resources. By specifying the
    ///             type of simulation to run, you enable the policy simulator to enforce the presence of
    ///             the required resources to ensure reliable simulation results. If your simulation does
    ///             not match one of the following scenarios, then you can omit this parameter. The
    ///             following list shows each of the supported scenario values and the resources that you
    ///             must define to run the simulation.</p>
    ///         <p>Each of the EC2 scenarios requires that you specify instance, image, and
    ///             security-group resources. If your scenario includes an EBS volume, then you must specify
    ///             that volume as a resource. If the EC2 scenario includes VPC, then you must supply the
    ///             network-interface resource. If it includes an IP subnet, then you must specify the
    ///             subnet resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
    ///             Guide</i>.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-Classic-InstanceStore</b>
    ///                 </p>
    ///                 <p>instance, image, security-group</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-Classic-EBS</b>
    ///                 </p>
    ///                 <p>instance, image, security-group, volume</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-InstanceStore</b>
    ///                 </p>
    ///                 <p>instance, image, security-group, network-interface</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-InstanceStore-Subnet</b>
    ///                 </p>
    ///                 <p>instance, image, security-group, network-interface, subnet</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-EBS</b>
    ///                 </p>
    ///                 <p>instance, image, security-group, network-interface, volume</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-EBS-Subnet</b>
    ///                 </p>
    ///                 <p>instance, image, security-group, network-interface, subnet, volume</p>
    ///             </li>
    ///          </ul>
    public let resourceHandlingOption: String?
    /// <p>An ARN representing the AWS account ID that specifies the owner of any simulated
    ///             resource that does not identify its owner in the resource ARN. Examples of resource ARNs
    ///             include an S3 bucket or object. If <code>ResourceOwner</code> is specified, it is also
    ///             used as the account owner of any <code>ResourcePolicy</code> included in the simulation.
    ///             If the <code>ResourceOwner</code> parameter is not specified, then the owner of the
    ///             resources and the resource policy defaults to the account of the identity provided in
    ///                 <code>CallerArn</code>. This parameter is required only if you specify a
    ///             resource-based policy and account that owns the resource is different from the account
    ///             that owns the simulated calling user <code>CallerArn</code>.</p>
    ///         <p>The ARN for an account uses the following syntax:
    ///                     <code>arn:aws:iam::<i>AWS-account-ID</i>:root</code>. For example,
    ///             to represent the account with the 112233445566 ID, use the following ARN:
    ///                 <code>arn:aws:iam::112233445566-ID:root</code>. </p>
    public let resourceOwner: String?
    /// <p>A resource-based policy to include in the simulation provided as a string. Each
    ///             resource in the simulation is treated as if it had this policy attached. You can include
    ///             only one resource-based policy in a simulation.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let resourcePolicy: String?

    public init (
        actionNames: [String]? = nil,
        callerArn: String? = nil,
        contextEntries: [ContextEntry]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        permissionsBoundaryPolicyInputList: [String]? = nil,
        policyInputList: [String]? = nil,
        resourceArns: [String]? = nil,
        resourceHandlingOption: String? = nil,
        resourceOwner: String? = nil,
        resourcePolicy: String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

extension SimulateCustomPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SimulateCustomPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyEvaluationException" : self = .policyEvaluationException(try PolicyEvaluationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SimulateCustomPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case policyEvaluationException(PolicyEvaluationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SimulateCustomPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulateCustomPolicyOutputResponse(evaluationResults: \(String(describing: evaluationResults)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension SimulateCustomPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SimulateCustomPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evaluationResults = output.evaluationResults
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.evaluationResults = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>SimulatePrincipalPolicy</a> or
///       <a>SimulateCustomPolicy</a> request.</p>
public struct SimulateCustomPolicyOutputResponse: Equatable {
    /// <p>The results of the simulation.</p>
    public let evaluationResults: [EvaluationResult]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        evaluationResults: [EvaluationResult]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct SimulateCustomPolicyOutputResponseBody: Equatable {
    public let evaluationResults: [EvaluationResult]?
    public let isTruncated: Bool
    public let marker: String?
}

extension SimulateCustomPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluationResults = "EvaluationResults"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SimulateCustomPolicyResult"))
        if containerValues.contains(.evaluationResults) {
            struct KeyVal0{struct member{}}
            let evaluationResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .evaluationResults)
            if let evaluationResultsWrappedContainer = evaluationResultsWrappedContainer {
                let evaluationResultsContainer = try evaluationResultsWrappedContainer.decodeIfPresent([EvaluationResult].self, forKey: .member)
                var evaluationResultsBuffer:[EvaluationResult]? = nil
                if let evaluationResultsContainer = evaluationResultsContainer {
                    evaluationResultsBuffer = [EvaluationResult]()
                    for structureContainer0 in evaluationResultsContainer {
                        evaluationResultsBuffer?.append(structureContainer0)
                    }
                }
                evaluationResults = evaluationResultsBuffer
            } else {
                evaluationResults = []
            }
        } else {
            evaluationResults = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct SimulatePrincipalPolicyInputBodyMiddleware: Middleware {
    public let id: String = "SimulatePrincipalPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SimulatePrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SimulatePrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SimulatePrincipalPolicyInput>
    public typealias MOutput = OperationOutput<SimulatePrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SimulatePrincipalPolicyOutputError>
}

extension SimulatePrincipalPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulatePrincipalPolicyInput(actionNames: \(String(describing: actionNames)), callerArn: \(String(describing: callerArn)), contextEntries: \(String(describing: contextEntries)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), permissionsBoundaryPolicyInputList: \(String(describing: permissionsBoundaryPolicyInputList)), policyInputList: \(String(describing: policyInputList)), policySourceArn: \(String(describing: policySourceArn)), resourceArns: \(String(describing: resourceArns)), resourceHandlingOption: \(String(describing: resourceHandlingOption)), resourceOwner: \(String(describing: resourceOwner)), resourcePolicy: \(String(describing: resourcePolicy)))"}
}

extension SimulatePrincipalPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionNames = actionNames {
            var actionNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ActionNames"))
            for (index0, actionnametype0) in actionNames.enumerated() {
                try actionNamesContainer.encode(actionnametype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            var contextEntriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ContextEntries"))
            for (index0, contextentry0) in contextEntries.enumerated() {
                try contextEntriesContainer.encode(contextentry0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PermissionsBoundaryPolicyInputList"))
            for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let policyInputList = policyInputList {
            var policyInputListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyInputList"))
            for (index0, policydocumenttype0) in policyInputList.enumerated() {
                try policyInputListContainer.encode(policydocumenttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: Key("PolicySourceArn"))
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceArns"))
            for (index0, resourcenametype0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcenametype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: Key("ResourcePolicy"))
        }
        try container.encode("SimulatePrincipalPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct SimulatePrincipalPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "SimulatePrincipalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SimulatePrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SimulatePrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SimulatePrincipalPolicyInput>
    public typealias MOutput = OperationOutput<SimulatePrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SimulatePrincipalPolicyOutputError>
}

public struct SimulatePrincipalPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "SimulatePrincipalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SimulatePrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SimulatePrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SimulatePrincipalPolicyInput>
    public typealias MOutput = OperationOutput<SimulatePrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SimulatePrincipalPolicyOutputError>
}

public struct SimulatePrincipalPolicyInput: Equatable {
    /// <p>A list of names of API operations to evaluate in the simulation. Each operation is
    ///             evaluated for each resource. Each operation must include the service identifier, such as
    ///                 <code>iam:CreateUser</code>.</p>
    public let actionNames: [String]?
    /// <p>The ARN of the IAM user that you want to specify as the simulated caller of the API
    ///             operations. If you do not specify a <code>CallerArn</code>, it defaults to the ARN of
    ///             the user that you specify in <code>PolicySourceArn</code>, if you specified a user. If
    ///             you include both a <code>PolicySourceArn</code> (for example,
    ///                 <code>arn:aws:iam::123456789012:user/David</code>) and a <code>CallerArn</code> (for
    ///             example, <code>arn:aws:iam::123456789012:user/Bob</code>), the result is that you
    ///             simulate calling the API operations as Bob, as if Bob had David's policies.</p>
    ///         <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
    ///             assumed role, federated user, or a service principal.</p>
    ///         <p>
    ///             <code>CallerArn</code> is required if you include a <code>ResourcePolicy</code> and
    ///             the <code>PolicySourceArn</code> is not the ARN for an IAM user. This is required so
    ///             that the resource-based policy's <code>Principal</code> element has a value to use in
    ///             evaluating the policy.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let callerArn: String?
    /// <p>A list of context keys and corresponding values for the simulation to use. Whenever a
    ///             context key is evaluated in one of the simulated IAM permissions policies, the
    ///             corresponding value is supplied.</p>
    public let contextEntries: [ContextEntry]?
    /// <p>Use this parameter only when paginating results and only after
    ///     you receive a response indicating that the results are truncated. Set it to the value of the
    ///     <code>Marker</code> element in the response that you received to indicate where the next call
    ///     should start.</p>
    public let marker: String?
    /// <p>Use this only when paginating results to indicate the
    ///     maximum number of items you want in the response. If additional items exist beyond the maximum
    ///     you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    ///          <p>If you do not include this parameter, the number of items defaults to 100. Note that
    ///     IAM might return fewer results, even when there are more results available. In that case, the
    ///     <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    ///     contains a value to include in the subsequent call that tells the service where to continue
    ///     from.</p>
    public let maxItems: Int?
    /// <p>The IAM permissions boundary policy to simulate. The permissions boundary sets the
    ///             maximum permissions that the entity can have. You can input only one permissions
    ///             boundary when you pass a policy to this operation. An IAM entity can only have one
    ///             permissions boundary in effect at a time. For example, if a permissions boundary is
    ///             attached to an entity and you pass in a different permissions boundary policy using this
    ///             parameter, then the new permissions boundary policy is used for the simulation. For more
    ///             information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///                 entities</a> in the <i>IAM User Guide</i>. The policy input is
    ///             specified as a string containing the complete, valid JSON text of a permissions boundary
    ///             policy.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let permissionsBoundaryPolicyInputList: [String]?
    /// <p>An optional list of additional policy documents to include in the simulation. Each
    ///             document is specified as a string containing the complete, valid JSON text of an IAM
    ///             policy.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyInputList: [String]?
    /// <p>The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to
    ///             include in the simulation. If you specify a user, group, or role, the simulation
    ///             includes all policies that are associated with that entity. If you specify a user, the
    ///             simulation also includes all policies that are attached to any groups the user belongs
    ///             to.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let policySourceArn: String?
    /// <p>A list of ARNs of AWS resources to include in the simulation. If this parameter is
    ///             not provided, then the value defaults to <code>*</code> (all resources). Each API in the
    ///                 <code>ActionNames</code> parameter is evaluated for each resource in this list. The
    ///             simulation determines the access result (allowed or denied) of each combination and
    ///             reports it in the response. You can simulate resources that don't exist in your
    ///             account.</p>
    ///         <p>The simulation does not automatically retrieve policies for the specified resources.
    ///             If you want to include a resource policy in the simulation, then you must include the
    ///             policy as a string in the <code>ResourcePolicy</code> parameter.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let resourceArns: [String]?
    /// <p>Specifies the type of simulation to run. Different API operations that support
    ///             resource-based policies require different combinations of resources. By specifying the
    ///             type of simulation to run, you enable the policy simulator to enforce the presence of
    ///             the required resources to ensure reliable simulation results. If your simulation does
    ///             not match one of the following scenarios, then you can omit this parameter. The
    ///             following list shows each of the supported scenario values and the resources that you
    ///             must define to run the simulation.</p>
    ///         <p>Each of the EC2 scenarios requires that you specify instance, image, and security
    ///             group resources. If your scenario includes an EBS volume, then you must specify that
    ///             volume as a resource. If the EC2 scenario includes VPC, then you must supply the network
    ///             interface resource. If it includes an IP subnet, then you must specify the subnet
    ///             resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
    ///             Guide</i>.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-Classic-InstanceStore</b>
    ///                 </p>
    ///                 <p>instance, image, security group</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-Classic-EBS</b>
    ///                 </p>
    ///                 <p>instance, image, security group, volume</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-InstanceStore</b>
    ///                 </p>
    ///                 <p>instance, image, security group, network interface</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-InstanceStore-Subnet</b>
    ///                 </p>
    ///                 <p>instance, image, security group, network interface, subnet</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-EBS</b>
    ///                 </p>
    ///                 <p>instance, image, security group, network interface, volume</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2-VPC-EBS-Subnet</b>
    ///                 </p>
    ///                 <p>instance, image, security group, network interface, subnet, volume</p>
    ///             </li>
    ///          </ul>
    public let resourceHandlingOption: String?
    /// <p>An AWS account ID that specifies the owner of any simulated resource that does not
    ///             identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket
    ///             or object. If <code>ResourceOwner</code> is specified, it is also used as the account
    ///             owner of any <code>ResourcePolicy</code> included in the simulation. If the
    ///                 <code>ResourceOwner</code> parameter is not specified, then the owner of the
    ///             resources and the resource policy defaults to the account of the identity provided in
    ///                 <code>CallerArn</code>. This parameter is required only if you specify a
    ///             resource-based policy and account that owns the resource is different from the account
    ///             that owns the simulated calling user <code>CallerArn</code>.</p>
    public let resourceOwner: String?
    /// <p>A resource-based policy to include in the simulation provided as a string. Each
    ///             resource in the simulation is treated as if it had this policy attached. You can include
    ///             only one resource-based policy in a simulation.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let resourcePolicy: String?

    public init (
        actionNames: [String]? = nil,
        callerArn: String? = nil,
        contextEntries: [ContextEntry]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        permissionsBoundaryPolicyInputList: [String]? = nil,
        policyInputList: [String]? = nil,
        policySourceArn: String? = nil,
        resourceArns: [String]? = nil,
        resourceHandlingOption: String? = nil,
        resourceOwner: String? = nil,
        resourcePolicy: String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

extension SimulatePrincipalPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SimulatePrincipalPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyEvaluationException" : self = .policyEvaluationException(try PolicyEvaluationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SimulatePrincipalPolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case policyEvaluationException(PolicyEvaluationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SimulatePrincipalPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulatePrincipalPolicyOutputResponse(evaluationResults: \(String(describing: evaluationResults)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)))"}
}

extension SimulatePrincipalPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SimulatePrincipalPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evaluationResults = output.evaluationResults
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.evaluationResults = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// <p>Contains the response to a successful <a>SimulatePrincipalPolicy</a> or
///       <a>SimulateCustomPolicy</a> request.</p>
public struct SimulatePrincipalPolicyOutputResponse: Equatable {
    /// <p>The results of the simulation.</p>
    public let evaluationResults: [EvaluationResult]?
    /// <p>A flag that indicates whether there are more items to return. If your
    ///     results were truncated, you can make a subsequent pagination request using the <code>Marker</code>
    ///     request parameter to retrieve more items. Note that IAM might return fewer than the
    ///     <code>MaxItems</code> number of results even when there are more results available. We recommend
    ///     that you check <code>IsTruncated</code> after every call to ensure that you receive all your
    ///     results.</p>
    public let isTruncated: Bool
    /// <p>When <code>IsTruncated</code> is <code>true</code>, this element
    ///     is present and contains the value to use for the <code>Marker</code> parameter in a subsequent
    ///     pagination request.</p>
    public let marker: String?

    public init (
        evaluationResults: [EvaluationResult]? = nil,
        isTruncated: Bool = false,
        marker: String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct SimulatePrincipalPolicyOutputResponseBody: Equatable {
    public let evaluationResults: [EvaluationResult]?
    public let isTruncated: Bool
    public let marker: String?
}

extension SimulatePrincipalPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluationResults = "EvaluationResults"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SimulatePrincipalPolicyResult"))
        if containerValues.contains(.evaluationResults) {
            struct KeyVal0{struct member{}}
            let evaluationResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .evaluationResults)
            if let evaluationResultsWrappedContainer = evaluationResultsWrappedContainer {
                let evaluationResultsContainer = try evaluationResultsWrappedContainer.decodeIfPresent([EvaluationResult].self, forKey: .member)
                var evaluationResultsBuffer:[EvaluationResult]? = nil
                if let evaluationResultsContainer = evaluationResultsContainer {
                    evaluationResultsBuffer = [EvaluationResult]()
                    for structureContainer0 in evaluationResultsContainer {
                        evaluationResultsBuffer?.append(structureContainer0)
                    }
                }
                evaluationResults = evaluationResultsBuffer
            } else {
                evaluationResults = []
            }
        } else {
            evaluationResults = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public enum SortKeyType {
    case lastAuthenticatedTimeAscending
    case lastAuthenticatedTimeDescending
    case serviceNamespaceAscending
    case serviceNamespaceDescending
    case sdkUnknown(String)
}

extension SortKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortKeyType] {
        return [
            .lastAuthenticatedTimeAscending,
            .lastAuthenticatedTimeDescending,
            .serviceNamespaceAscending,
            .serviceNamespaceDescending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastAuthenticatedTimeAscending: return "LAST_AUTHENTICATED_TIME_ASCENDING"
        case .lastAuthenticatedTimeDescending: return "LAST_AUTHENTICATED_TIME_DESCENDING"
        case .serviceNamespaceAscending: return "SERVICE_NAMESPACE_ASCENDING"
        case .serviceNamespaceDescending: return "SERVICE_NAMESPACE_DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortKeyType(rawValue: rawValue) ?? SortKeyType.sdkUnknown(rawValue)
    }
}

extension Statement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endPosition = "EndPosition"
        case sourcePolicyId = "SourcePolicyId"
        case sourcePolicyType = "SourcePolicyType"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endPosition = endPosition {
            try container.encode(endPosition, forKey: Key("EndPosition"))
        }
        if let sourcePolicyId = sourcePolicyId {
            try container.encode(sourcePolicyId, forKey: Key("SourcePolicyId"))
        }
        if let sourcePolicyType = sourcePolicyType {
            try container.encode(sourcePolicyType, forKey: Key("SourcePolicyType"))
        }
        if let startPosition = startPosition {
            try container.encode(startPosition, forKey: Key("StartPosition"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePolicyId)
        sourcePolicyId = sourcePolicyIdDecoded
        let sourcePolicyTypeDecoded = try containerValues.decodeIfPresent(PolicySourceType.self, forKey: .sourcePolicyType)
        sourcePolicyType = sourcePolicyTypeDecoded
        let startPositionDecoded = try containerValues.decodeIfPresent(Position.self, forKey: .startPosition)
        startPosition = startPositionDecoded
        let endPositionDecoded = try containerValues.decodeIfPresent(Position.self, forKey: .endPosition)
        endPosition = endPositionDecoded
    }
}

extension Statement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Statement(endPosition: \(String(describing: endPosition)), sourcePolicyId: \(String(describing: sourcePolicyId)), sourcePolicyType: \(String(describing: sourcePolicyType)), startPosition: \(String(describing: startPosition)))"}
}

/// <p>Contains a reference to a <code>Statement</code> element in a policy document that
///          determines the result of the simulation.</p>
///          <p>This data type is used by the <code>MatchedStatements</code> member of the <code>
///                <a>EvaluationResult</a>
///             </code> type.</p>
public struct Statement: Equatable {
    /// <p>The row and column of the end of a <code>Statement</code> in an IAM policy.</p>
    public let endPosition: Position?
    /// <p>The identifier of the policy that was provided as an input.</p>
    public let sourcePolicyId: String?
    /// <p>The type of the policy.</p>
    public let sourcePolicyType: PolicySourceType?
    /// <p>The row and column of the beginning of the <code>Statement</code> in an IAM
    ///          policy.</p>
    public let startPosition: Position?

    public init (
        endPosition: Position? = nil,
        sourcePolicyId: String? = nil,
        sourcePolicyType: PolicySourceType? = nil,
        startPosition: Position? = nil
    )
    {
        self.endPosition = endPosition
        self.sourcePolicyId = sourcePolicyId
        self.sourcePolicyType = sourcePolicyType
        self.startPosition = startPosition
    }
}

public enum StatusType {
    case active
    case inactive
    case sdkUnknown(String)
}

extension StatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatusType] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .inactive: return "Inactive"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
    }
}

public enum SummaryKeyType {
    case accesskeysperuserquota
    case accountaccesskeyspresent
    case accountmfaenabled
    case accountsigningcertificatespresent
    case attachedpoliciespergroupquota
    case attachedpoliciesperrolequota
    case attachedpoliciesperuserquota
    case globalendpointtokenversion
    case grouppolicysizequota
    case groups
    case groupsperuserquota
    case groupsquota
    case mfadevices
    case mfadevicesinuse
    case policies
    case policiesquota
    case policysizequota
    case policyversionsinuse
    case policyversionsinusequota
    case servercertificates
    case servercertificatesquota
    case signingcertificatesperuserquota
    case userpolicysizequota
    case users
    case usersquota
    case versionsperpolicyquota
    case sdkUnknown(String)
}

extension SummaryKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SummaryKeyType] {
        return [
            .accesskeysperuserquota,
            .accountaccesskeyspresent,
            .accountmfaenabled,
            .accountsigningcertificatespresent,
            .attachedpoliciespergroupquota,
            .attachedpoliciesperrolequota,
            .attachedpoliciesperuserquota,
            .globalendpointtokenversion,
            .grouppolicysizequota,
            .groups,
            .groupsperuserquota,
            .groupsquota,
            .mfadevices,
            .mfadevicesinuse,
            .policies,
            .policiesquota,
            .policysizequota,
            .policyversionsinuse,
            .policyversionsinusequota,
            .servercertificates,
            .servercertificatesquota,
            .signingcertificatesperuserquota,
            .userpolicysizequota,
            .users,
            .usersquota,
            .versionsperpolicyquota,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accesskeysperuserquota: return "AccessKeysPerUserQuota"
        case .accountaccesskeyspresent: return "AccountAccessKeysPresent"
        case .accountmfaenabled: return "AccountMFAEnabled"
        case .accountsigningcertificatespresent: return "AccountSigningCertificatesPresent"
        case .attachedpoliciespergroupquota: return "AttachedPoliciesPerGroupQuota"
        case .attachedpoliciesperrolequota: return "AttachedPoliciesPerRoleQuota"
        case .attachedpoliciesperuserquota: return "AttachedPoliciesPerUserQuota"
        case .globalendpointtokenversion: return "GlobalEndpointTokenVersion"
        case .grouppolicysizequota: return "GroupPolicySizeQuota"
        case .groups: return "Groups"
        case .groupsperuserquota: return "GroupsPerUserQuota"
        case .groupsquota: return "GroupsQuota"
        case .mfadevices: return "MFADevices"
        case .mfadevicesinuse: return "MFADevicesInUse"
        case .policies: return "Policies"
        case .policiesquota: return "PoliciesQuota"
        case .policysizequota: return "PolicySizeQuota"
        case .policyversionsinuse: return "PolicyVersionsInUse"
        case .policyversionsinusequota: return "PolicyVersionsInUseQuota"
        case .servercertificates: return "ServerCertificates"
        case .servercertificatesquota: return "ServerCertificatesQuota"
        case .signingcertificatesperuserquota: return "SigningCertificatesPerUserQuota"
        case .userpolicysizequota: return "UserPolicySizeQuota"
        case .users: return "Users"
        case .usersquota: return "UsersQuota"
        case .versionsperpolicyquota: return "VersionsPerPolicyQuota"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SummaryKeyType(rawValue: rawValue) ?? SummaryKeyType.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A structure that represents user-provided metadata that can be associated with an IAM
///       resource. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
///       <i>IAM User Guide</i>.</p>
public struct Tag: Equatable {
    /// <p>The key name that can be used to look up or retrieve the associated value. For example,
    ///         <code>Department</code> or <code>Cost Center</code> are common choices.</p>
    public let key: String?
    /// <p>The value associated with this tag. For example, tags with a key name of
    ///         <code>Department</code> could have values such as <code>Human Resources</code>,
    ///         <code>Accounting</code>, and <code>Support</code>. Tags with a key name of <code>Cost
    ///         Center</code> might have values that consist of the number associated with the different
    ///       cost centers in your company. Typically, many resources have tags with the same key name but
    ///       with different values.</p>
    ///          <note>
    ///             <p>AWS always interprets the tag <code>Value</code> as a single string. If you need to
    ///         store an array, you can store comma-separated values in the string. However, you must
    ///         interpret the value in your code.</p>
    ///          </note>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "TagInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<TagInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagInstanceProfileInput>
    public typealias MOutput = OperationOutput<TagInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagInstanceProfileOutputError>
}

extension TagInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagInstanceProfileInput(instanceProfileName: \(String(describing: instanceProfileName)), tags: \(String(describing: tags)))"}
}

extension TagInstanceProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagInstanceProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "TagInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<TagInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagInstanceProfileInput>
    public typealias MOutput = OperationOutput<TagInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagInstanceProfileOutputError>
}

public struct TagInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "TagInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<TagInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagInstanceProfileInput>
    public typealias MOutput = OperationOutput<TagInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagInstanceProfileOutputError>
}

public struct TagInstanceProfileInput: Equatable {
    /// <p>The name of the IAM instance profile to which you want to add tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let instanceProfileName: String?
    /// <p>The list of tags that you want to attach to the IAM instance profile.
    ///       Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?

    public init (
        instanceProfileName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tags = tags
    }
}

extension TagInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagInstanceProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagInstanceProfileOutputResponse()"}
}

extension TagInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagInstanceProfileOutputResponse: Equatable {

    public init() {}
}

struct TagInstanceProfileOutputResponseBody: Equatable {
}

extension TagInstanceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagMFADeviceInputBodyMiddleware: Middleware {
    public let id: String = "TagMFADeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagMFADeviceInput>
    public typealias MOutput = OperationOutput<TagMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagMFADeviceOutputError>
}

extension TagMFADeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagMFADeviceInput(serialNumber: \(String(describing: serialNumber)), tags: \(String(describing: tags)))"}
}

extension TagMFADeviceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagMFADevice", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagMFADeviceInputHeadersMiddleware: Middleware {
    public let id: String = "TagMFADeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagMFADeviceInput>
    public typealias MOutput = OperationOutput<TagMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagMFADeviceOutputError>
}

public struct TagMFADeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagMFADeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagMFADeviceInput>
    public typealias MOutput = OperationOutput<TagMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagMFADeviceOutputError>
}

public struct TagMFADeviceInput: Equatable {
    /// <p>The unique identifier for the IAM virtual MFA device to which you want to add tags.
    ///       For virtual MFA devices, the serial number is the same as the ARN.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let serialNumber: String?
    /// <p>The list of tags that you want to attach to the IAM virtual MFA device.
    ///       Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?

    public init (
        serialNumber: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tags = tags
    }
}

extension TagMFADeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagMFADeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagMFADeviceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagMFADeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagMFADeviceOutputResponse()"}
}

extension TagMFADeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagMFADeviceOutputResponse: Equatable {

    public init() {}
}

struct TagMFADeviceOutputResponseBody: Equatable {
}

extension TagMFADeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagOpenIDConnectProviderInputBodyMiddleware: Middleware {
    public let id: String = "TagOpenIDConnectProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TagOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<TagOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagOpenIDConnectProviderOutputError>
}

extension TagOpenIDConnectProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagOpenIDConnectProviderInput(openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)), tags: \(String(describing: tags)))"}
}

extension TagOpenIDConnectProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagOpenIDConnectProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagOpenIDConnectProviderInputHeadersMiddleware: Middleware {
    public let id: String = "TagOpenIDConnectProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TagOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<TagOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagOpenIDConnectProviderOutputError>
}

public struct TagOpenIDConnectProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "TagOpenIDConnectProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TagOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<TagOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagOpenIDConnectProviderOutputError>
}

public struct TagOpenIDConnectProviderInput: Equatable {
    /// <p>The ARN of the OIDC identity provider in IAM to which you want to add tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let openIDConnectProviderArn: String?
    /// <p>The list of tags that you want to attach to the OIDC identity provider in IAM.
    ///       Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?

    public init (
        openIDConnectProviderArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

extension TagOpenIDConnectProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagOpenIDConnectProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagOpenIDConnectProviderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagOpenIDConnectProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagOpenIDConnectProviderOutputResponse()"}
}

extension TagOpenIDConnectProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagOpenIDConnectProviderOutputResponse: Equatable {

    public init() {}
}

struct TagOpenIDConnectProviderOutputResponseBody: Equatable {
}

extension TagOpenIDConnectProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagPolicyInputBodyMiddleware: Middleware {
    public let id: String = "TagPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<TagPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagPolicyInput>
    public typealias MOutput = OperationOutput<TagPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagPolicyOutputError>
}

extension TagPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagPolicyInput(policyArn: \(String(describing: policyArn)), tags: \(String(describing: tags)))"}
}

extension TagPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "TagPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<TagPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagPolicyInput>
    public typealias MOutput = OperationOutput<TagPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagPolicyOutputError>
}

public struct TagPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "TagPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<TagPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagPolicyInput>
    public typealias MOutput = OperationOutput<TagPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagPolicyOutputError>
}

public struct TagPolicyInput: Equatable {
    /// <p>The ARN of the IAM customer managed policy to which you want to add tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let policyArn: String?
    /// <p>The list of tags that you want to attach to the IAM customer managed policy.
    ///       Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?

    public init (
        policyArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.policyArn = policyArn
        self.tags = tags
    }
}

extension TagPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagPolicyOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagPolicyOutputResponse()"}
}

extension TagPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagPolicyOutputResponse: Equatable {

    public init() {}
}

struct TagPolicyOutputResponseBody: Equatable {
}

extension TagPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagRoleInputBodyMiddleware: Middleware {
    public let id: String = "TagRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<TagRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagRoleInput>
    public typealias MOutput = OperationOutput<TagRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagRoleOutputError>
}

extension TagRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagRoleInput(roleName: \(String(describing: roleName)), tags: \(String(describing: tags)))"}
}

extension TagRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagRoleInputHeadersMiddleware: Middleware {
    public let id: String = "TagRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<TagRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagRoleInput>
    public typealias MOutput = OperationOutput<TagRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagRoleOutputError>
}

public struct TagRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "TagRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<TagRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagRoleInput>
    public typealias MOutput = OperationOutput<TagRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagRoleOutputError>
}

public struct TagRoleInput: Equatable {
    /// <p>The name of the IAM role to which you want to add tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?
    /// <p>The list of tags that you want to attach to the IAM role. Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?

    public init (
        roleName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.roleName = roleName
        self.tags = tags
    }
}

extension TagRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagRoleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagRoleOutputResponse()"}
}

extension TagRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagRoleOutputResponse: Equatable {

    public init() {}
}

struct TagRoleOutputResponseBody: Equatable {
}

extension TagRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagSAMLProviderInputBodyMiddleware: Middleware {
    public let id: String = "TagSAMLProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TagSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagSAMLProviderInput>
    public typealias MOutput = OperationOutput<TagSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagSAMLProviderOutputError>
}

extension TagSAMLProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagSAMLProviderInput(sAMLProviderArn: \(String(describing: sAMLProviderArn)), tags: \(String(describing: tags)))"}
}

extension TagSAMLProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sAMLProviderArn = sAMLProviderArn {
            try container.encode(sAMLProviderArn, forKey: Key("SAMLProviderArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagSAMLProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagSAMLProviderInputHeadersMiddleware: Middleware {
    public let id: String = "TagSAMLProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TagSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagSAMLProviderInput>
    public typealias MOutput = OperationOutput<TagSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagSAMLProviderOutputError>
}

public struct TagSAMLProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "TagSAMLProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TagSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagSAMLProviderInput>
    public typealias MOutput = OperationOutput<TagSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagSAMLProviderOutputError>
}

public struct TagSAMLProviderInput: Equatable {
    /// <p>The ARN of the SAML identity provider in IAM to which you want to add tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let sAMLProviderArn: String?
    /// <p>The list of tags that you want to attach to the SAML identity provider in IAM.
    ///       Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?

    public init (
        sAMLProviderArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.sAMLProviderArn = sAMLProviderArn
        self.tags = tags
    }
}

extension TagSAMLProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagSAMLProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagSAMLProviderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagSAMLProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagSAMLProviderOutputResponse()"}
}

extension TagSAMLProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagSAMLProviderOutputResponse: Equatable {

    public init() {}
}

struct TagSAMLProviderOutputResponseBody: Equatable {
}

extension TagSAMLProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagServerCertificateInputBodyMiddleware: Middleware {
    public let id: String = "TagServerCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<TagServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagServerCertificateInput>
    public typealias MOutput = OperationOutput<TagServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagServerCertificateOutputError>
}

extension TagServerCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagServerCertificateInput(serverCertificateName: \(String(describing: serverCertificateName)), tags: \(String(describing: tags)))"}
}

extension TagServerCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagServerCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagServerCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "TagServerCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<TagServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagServerCertificateInput>
    public typealias MOutput = OperationOutput<TagServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagServerCertificateOutputError>
}

public struct TagServerCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "TagServerCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<TagServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagServerCertificateInput>
    public typealias MOutput = OperationOutput<TagServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagServerCertificateOutputError>
}

public struct TagServerCertificateInput: Equatable {
    /// <p>The name of the IAM server certificate to which you want to add tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let serverCertificateName: String?
    /// <p>The list of tags that you want to attach to the IAM server certificate.
    ///       Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?

    public init (
        serverCertificateName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

extension TagServerCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagServerCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagServerCertificateOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagServerCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagServerCertificateOutputResponse()"}
}

extension TagServerCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagServerCertificateOutputResponse: Equatable {

    public init() {}
}

struct TagServerCertificateOutputResponseBody: Equatable {
}

extension TagServerCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagUserInputBodyMiddleware: Middleware {
    public let id: String = "TagUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagUserInput>,
                  next: H) -> Swift.Result<OperationOutput<TagUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagUserInput>
    public typealias MOutput = OperationOutput<TagUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagUserOutputError>
}

extension TagUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagUserInput(tags: \(String(describing: tags)), userName: \(String(describing: userName)))"}
}

extension TagUserInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("TagUser", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct TagUserInputHeadersMiddleware: Middleware {
    public let id: String = "TagUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagUserInput>,
                  next: H) -> Swift.Result<OperationOutput<TagUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagUserInput>
    public typealias MOutput = OperationOutput<TagUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagUserOutputError>
}

public struct TagUserInputQueryItemMiddleware: Middleware {
    public let id: String = "TagUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagUserInput>,
                  next: H) -> Swift.Result<OperationOutput<TagUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagUserInput>
    public typealias MOutput = OperationOutput<TagUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagUserOutputError>
}

public struct TagUserInput: Equatable {
    /// <p>The list of tags that you want to attach to the IAM user. Each tag consists of a key name and an associated value.</p>
    public let tags: [Tag]?
    /// <p>The name of the IAM user to which you want to add tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let userName: String?

    public init (
        tags: [Tag]? = nil,
        userName: String? = nil
    )
    {
        self.tags = tags
        self.userName = userName
    }
}

extension TagUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagUserOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagUserOutputResponse()"}
}

extension TagUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagUserOutputResponse: Equatable {

    public init() {}
}

struct TagUserOutputResponseBody: Equatable {
}

extension TagUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TrackedActionLastAccessed: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName = "ActionName"
        case lastAccessedEntity = "LastAccessedEntity"
        case lastAccessedRegion = "LastAccessedRegion"
        case lastAccessedTime = "LastAccessedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionName = actionName {
            try container.encode(actionName, forKey: Key("ActionName"))
        }
        if let lastAccessedEntity = lastAccessedEntity {
            try container.encode(lastAccessedEntity, forKey: Key("LastAccessedEntity"))
        }
        if let lastAccessedRegion = lastAccessedRegion {
            try container.encode(lastAccessedRegion, forKey: Key("LastAccessedRegion"))
        }
        if let lastAccessedTime = lastAccessedTime {
            try container.encode(TimestampWrapper(lastAccessedTime, format: .dateTime), forKey: Key("lastAccessedTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let lastAccessedEntityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAccessedEntity)
        lastAccessedEntity = lastAccessedEntityDecoded
        let lastAccessedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAccessedTime)
        var lastAccessedTimeBuffer:Date? = nil
        if let lastAccessedTimeDecoded = lastAccessedTimeDecoded {
            lastAccessedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastAccessedTimeDecoded, format: .dateTime)
        }
        lastAccessedTime = lastAccessedTimeBuffer
        let lastAccessedRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAccessedRegion)
        lastAccessedRegion = lastAccessedRegionDecoded
    }
}

extension TrackedActionLastAccessed: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrackedActionLastAccessed(actionName: \(String(describing: actionName)), lastAccessedEntity: \(String(describing: lastAccessedEntity)), lastAccessedRegion: \(String(describing: lastAccessedRegion)), lastAccessedTime: \(String(describing: lastAccessedTime)))"}
}

/// <p>Contains details about the most recent attempt to access an action within the service.</p>
///          <p>This data type is used as a response element in the <a>GetServiceLastAccessedDetails</a> operation.</p>
public struct TrackedActionLastAccessed: Equatable {
    /// <p>The name of the tracked action to which access was attempted. Tracked actions are
    ///          actions that report activity to IAM.</p>
    public let actionName: String?
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let lastAccessedEntity: String?
    /// <p>The Region from which the authenticated entity (user or role) last attempted to access
    ///          the tracked action. AWS does not report unauthenticated requests.</p>
    ///          <p>This field is null if no IAM entities attempted to access the service within the
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let lastAccessedRegion: String?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when an authenticated entity most recently attempted to access the
    ///          tracked service. AWS does not report unauthenticated requests.</p>
    ///          <p>This field is null if no IAM entities attempted to access the service within the
    ///          <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period">reporting period</a>.</p>
    public let lastAccessedTime: Date?

    public init (
        actionName: String? = nil,
        lastAccessedEntity: String? = nil,
        lastAccessedRegion: String? = nil,
        lastAccessedTime: Date? = nil
    )
    {
        self.actionName = actionName
        self.lastAccessedEntity = lastAccessedEntity
        self.lastAccessedRegion = lastAccessedRegion
        self.lastAccessedTime = lastAccessedTime
    }
}

extension UnmodifiableEntityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnmodifiableEntityException(message: \(String(describing: message)))"}
}

extension UnmodifiableEntityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnmodifiableEntityExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because only the service that depends on the service-linked role
///       can modify or delete the role on your behalf. The error message includes the name of the
///       service that depends on this service-linked role. You must request the change through that
///       service.</p>
public struct UnmodifiableEntityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnmodifiableEntityExceptionBody: Equatable {
    public let message: String?
}

extension UnmodifiableEntityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnrecognizedPublicKeyEncodingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnrecognizedPublicKeyEncodingException(message: \(String(describing: message)))"}
}

extension UnrecognizedPublicKeyEncodingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnrecognizedPublicKeyEncodingExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the public key encoding format is unsupported or
///       unrecognized.</p>
public struct UnrecognizedPublicKeyEncodingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnrecognizedPublicKeyEncodingExceptionBody: Equatable {
    public let message: String?
}

extension UnrecognizedPublicKeyEncodingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "UntagInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagInstanceProfileInput>
    public typealias MOutput = OperationOutput<UntagInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagInstanceProfileOutputError>
}

extension UntagInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagInstanceProfileInput(instanceProfileName: \(String(describing: instanceProfileName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagInstanceProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: Key("InstanceProfileName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagInstanceProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UntagInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagInstanceProfileInput>
    public typealias MOutput = OperationOutput<UntagInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagInstanceProfileOutputError>
}

public struct UntagInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagInstanceProfileInput>
    public typealias MOutput = OperationOutput<UntagInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagInstanceProfileOutputError>
}

public struct UntagInstanceProfileInput: Equatable {
    /// <p>The name of the IAM instance profile from which you want to remove tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let instanceProfileName: String?
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified instance profile.</p>
    public let tagKeys: [String]?

    public init (
        instanceProfileName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tagKeys = tagKeys
    }
}

extension UntagInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagInstanceProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagInstanceProfileOutputResponse()"}
}

extension UntagInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagInstanceProfileOutputResponse: Equatable {

    public init() {}
}

struct UntagInstanceProfileOutputResponseBody: Equatable {
}

extension UntagInstanceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagMFADeviceInputBodyMiddleware: Middleware {
    public let id: String = "UntagMFADeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagMFADeviceInput>
    public typealias MOutput = OperationOutput<UntagMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagMFADeviceOutputError>
}

extension UntagMFADeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagMFADeviceInput(serialNumber: \(String(describing: serialNumber)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagMFADeviceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagMFADevice", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagMFADeviceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagMFADeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagMFADeviceInput>
    public typealias MOutput = OperationOutput<UntagMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagMFADeviceOutputError>
}

public struct UntagMFADeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagMFADeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagMFADeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagMFADeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagMFADeviceInput>
    public typealias MOutput = OperationOutput<UntagMFADeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagMFADeviceOutputError>
}

public struct UntagMFADeviceInput: Equatable {
    /// <p>The unique identifier for the IAM virtual MFA device from which you want to remove
    ///       tags. For virtual MFA devices, the serial number is the same as the ARN.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let serialNumber: String?
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified instance profile.</p>
    public let tagKeys: [String]?

    public init (
        serialNumber: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tagKeys = tagKeys
    }
}

extension UntagMFADeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagMFADeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagMFADeviceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagMFADeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagMFADeviceOutputResponse()"}
}

extension UntagMFADeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagMFADeviceOutputResponse: Equatable {

    public init() {}
}

struct UntagMFADeviceOutputResponseBody: Equatable {
}

extension UntagMFADeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagOpenIDConnectProviderInputBodyMiddleware: Middleware {
    public let id: String = "UntagOpenIDConnectProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<UntagOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagOpenIDConnectProviderOutputError>
}

extension UntagOpenIDConnectProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagOpenIDConnectProviderInput(openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagOpenIDConnectProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagOpenIDConnectProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagOpenIDConnectProviderInputHeadersMiddleware: Middleware {
    public let id: String = "UntagOpenIDConnectProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<UntagOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagOpenIDConnectProviderOutputError>
}

public struct UntagOpenIDConnectProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagOpenIDConnectProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagOpenIDConnectProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagOpenIDConnectProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagOpenIDConnectProviderInput>
    public typealias MOutput = OperationOutput<UntagOpenIDConnectProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagOpenIDConnectProviderOutputError>
}

public struct UntagOpenIDConnectProviderInput: Equatable {
    /// <p>The ARN of the OIDC provider in IAM from which you want to remove tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let openIDConnectProviderArn: String?
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified OIDC provider.</p>
    public let tagKeys: [String]?

    public init (
        openIDConnectProviderArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tagKeys = tagKeys
    }
}

extension UntagOpenIDConnectProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagOpenIDConnectProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagOpenIDConnectProviderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagOpenIDConnectProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagOpenIDConnectProviderOutputResponse()"}
}

extension UntagOpenIDConnectProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagOpenIDConnectProviderOutputResponse: Equatable {

    public init() {}
}

struct UntagOpenIDConnectProviderOutputResponseBody: Equatable {
}

extension UntagOpenIDConnectProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagPolicyInputBodyMiddleware: Middleware {
    public let id: String = "UntagPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagPolicyInput>
    public typealias MOutput = OperationOutput<UntagPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagPolicyOutputError>
}

extension UntagPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagPolicyInput(policyArn: \(String(describing: policyArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: Key("PolicyArn"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UntagPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagPolicyInput>
    public typealias MOutput = OperationOutput<UntagPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagPolicyOutputError>
}

public struct UntagPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagPolicyInput>
    public typealias MOutput = OperationOutput<UntagPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagPolicyOutputError>
}

public struct UntagPolicyInput: Equatable {
    /// <p>The ARN of the IAM customer managed policy from which you want to remove
    ///       tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let policyArn: String?
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified policy.</p>
    public let tagKeys: [String]?

    public init (
        policyArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.policyArn = policyArn
        self.tagKeys = tagKeys
    }
}

extension UntagPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagPolicyOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagPolicyOutputResponse()"}
}

extension UntagPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagPolicyOutputResponse: Equatable {

    public init() {}
}

struct UntagPolicyOutputResponseBody: Equatable {
}

extension UntagPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagRoleInputBodyMiddleware: Middleware {
    public let id: String = "UntagRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagRoleInput>
    public typealias MOutput = OperationOutput<UntagRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagRoleOutputError>
}

extension UntagRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagRoleInput(roleName: \(String(describing: roleName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagRoleInputHeadersMiddleware: Middleware {
    public let id: String = "UntagRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagRoleInput>
    public typealias MOutput = OperationOutput<UntagRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagRoleOutputError>
}

public struct UntagRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagRoleInput>
    public typealias MOutput = OperationOutput<UntagRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagRoleOutputError>
}

public struct UntagRoleInput: Equatable {
    /// <p>The name of the IAM role from which you want to remove tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified role.</p>
    public let tagKeys: [String]?

    public init (
        roleName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.roleName = roleName
        self.tagKeys = tagKeys
    }
}

extension UntagRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagRoleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagRoleOutputResponse()"}
}

extension UntagRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagRoleOutputResponse: Equatable {

    public init() {}
}

struct UntagRoleOutputResponseBody: Equatable {
}

extension UntagRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagSAMLProviderInputBodyMiddleware: Middleware {
    public let id: String = "UntagSAMLProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagSAMLProviderInput>
    public typealias MOutput = OperationOutput<UntagSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagSAMLProviderOutputError>
}

extension UntagSAMLProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagSAMLProviderInput(sAMLProviderArn: \(String(describing: sAMLProviderArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagSAMLProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sAMLProviderArn = sAMLProviderArn {
            try container.encode(sAMLProviderArn, forKey: Key("SAMLProviderArn"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagSAMLProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagSAMLProviderInputHeadersMiddleware: Middleware {
    public let id: String = "UntagSAMLProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagSAMLProviderInput>
    public typealias MOutput = OperationOutput<UntagSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagSAMLProviderOutputError>
}

public struct UntagSAMLProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagSAMLProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagSAMLProviderInput>
    public typealias MOutput = OperationOutput<UntagSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagSAMLProviderOutputError>
}

public struct UntagSAMLProviderInput: Equatable {
    /// <p>The ARN of the SAML identity provider in IAM from which you want to remove
    ///       tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let sAMLProviderArn: String?
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified SAML identity provider.</p>
    public let tagKeys: [String]?

    public init (
        sAMLProviderArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.sAMLProviderArn = sAMLProviderArn
        self.tagKeys = tagKeys
    }
}

extension UntagSAMLProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagSAMLProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagSAMLProviderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagSAMLProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagSAMLProviderOutputResponse()"}
}

extension UntagSAMLProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagSAMLProviderOutputResponse: Equatable {

    public init() {}
}

struct UntagSAMLProviderOutputResponseBody: Equatable {
}

extension UntagSAMLProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagServerCertificateInputBodyMiddleware: Middleware {
    public let id: String = "UntagServerCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagServerCertificateInput>
    public typealias MOutput = OperationOutput<UntagServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagServerCertificateOutputError>
}

extension UntagServerCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagServerCertificateInput(serverCertificateName: \(String(describing: serverCertificateName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagServerCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagServerCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagServerCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UntagServerCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagServerCertificateInput>
    public typealias MOutput = OperationOutput<UntagServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagServerCertificateOutputError>
}

public struct UntagServerCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagServerCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagServerCertificateInput>
    public typealias MOutput = OperationOutput<UntagServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagServerCertificateOutputError>
}

public struct UntagServerCertificateInput: Equatable {
    /// <p>The name of the IAM server certificate from which you want to remove tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let serverCertificateName: String?
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified IAM server certificate.</p>
    public let tagKeys: [String]?

    public init (
        serverCertificateName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tagKeys = tagKeys
    }
}

extension UntagServerCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagServerCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagServerCertificateOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagServerCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagServerCertificateOutputResponse()"}
}

extension UntagServerCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagServerCertificateOutputResponse: Equatable {

    public init() {}
}

struct UntagServerCertificateOutputResponseBody: Equatable {
}

extension UntagServerCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagUserInputBodyMiddleware: Middleware {
    public let id: String = "UntagUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagUserInput>
    public typealias MOutput = OperationOutput<UntagUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagUserOutputError>
}

extension UntagUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagUserInput(tagKeys: \(String(describing: tagKeys)), userName: \(String(describing: userName)))"}
}

extension UntagUserInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkeytype0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UntagUser", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UntagUserInputHeadersMiddleware: Middleware {
    public let id: String = "UntagUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagUserInput>
    public typealias MOutput = OperationOutput<UntagUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagUserOutputError>
}

public struct UntagUserInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagUserInput>
    public typealias MOutput = OperationOutput<UntagUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagUserOutputError>
}

public struct UntagUserInput: Equatable {
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    ///       removed from the specified user.</p>
    public let tagKeys: [String]?
    /// <p>The name of the IAM user from which you want to remove tags.</p>
    ///          <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: =,.@-</p>
    public let userName: String?

    public init (
        tagKeys: [String]? = nil,
        userName: String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.userName = userName
    }
}

extension UntagUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagUserOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagUserOutputResponse()"}
}

extension UntagUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagUserOutputResponse: Equatable {

    public init() {}
}

struct UntagUserOutputResponseBody: Equatable {
}

extension UntagUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAccessKeyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccessKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessKeyInput>
    public typealias MOutput = OperationOutput<UpdateAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessKeyOutputError>
}

extension UpdateAccessKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccessKeyInput(accessKeyId: \(String(describing: accessKeyId)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

extension UpdateAccessKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: Key("AccessKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UpdateAccessKey", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateAccessKeyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccessKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessKeyInput>
    public typealias MOutput = OperationOutput<UpdateAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessKeyOutputError>
}

public struct UpdateAccessKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccessKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessKeyInput>
    public typealias MOutput = OperationOutput<UpdateAccessKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessKeyOutputError>
}

public struct UpdateAccessKeyInput: Equatable {
    /// <p>The access key ID of the secret access key you want to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let accessKeyId: String?
    /// <p> The status you want to assign to the secret access key. <code>Active</code> means
    ///             that the key can be used for programmatic calls to AWS, while <code>Inactive</code>
    ///             means that the key cannot be used.</p>
    public let status: StatusType?
    /// <p>The name of the user whose key you want to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        accessKeyId: String? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.status = status
        self.userName = userName
    }
}

extension UpdateAccessKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAccessKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccessKeyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccessKeyOutputResponse()"}
}

extension UpdateAccessKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccessKeyOutputResponse: Equatable {

    public init() {}
}

struct UpdateAccessKeyOutputResponseBody: Equatable {
}

extension UpdateAccessKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAccountPasswordPolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccountPasswordPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountPasswordPolicyOutputError>
}

extension UpdateAccountPasswordPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountPasswordPolicyInput(allowUsersToChangePassword: \(String(describing: allowUsersToChangePassword)), hardExpiry: \(String(describing: hardExpiry)), maxPasswordAge: \(String(describing: maxPasswordAge)), minimumPasswordLength: \(String(describing: minimumPasswordLength)), passwordReusePrevention: \(String(describing: passwordReusePrevention)), requireLowercaseCharacters: \(String(describing: requireLowercaseCharacters)), requireNumbers: \(String(describing: requireNumbers)), requireSymbols: \(String(describing: requireSymbols)), requireUppercaseCharacters: \(String(describing: requireUppercaseCharacters)))"}
}

extension UpdateAccountPasswordPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowUsersToChangePassword != false {
            try container.encode(allowUsersToChangePassword, forKey: Key("AllowUsersToChangePassword"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: Key("PasswordReusePrevention"))
        }
        if requireLowercaseCharacters != false {
            try container.encode(requireLowercaseCharacters, forKey: Key("RequireLowercaseCharacters"))
        }
        if requireNumbers != false {
            try container.encode(requireNumbers, forKey: Key("RequireNumbers"))
        }
        if requireSymbols != false {
            try container.encode(requireSymbols, forKey: Key("RequireSymbols"))
        }
        if requireUppercaseCharacters != false {
            try container.encode(requireUppercaseCharacters, forKey: Key("RequireUppercaseCharacters"))
        }
        try container.encode("UpdateAccountPasswordPolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateAccountPasswordPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccountPasswordPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountPasswordPolicyOutputError>
}

public struct UpdateAccountPasswordPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccountPasswordPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountPasswordPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountPasswordPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountPasswordPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAccountPasswordPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountPasswordPolicyOutputError>
}

public struct UpdateAccountPasswordPolicyInput: Equatable {
    /// <p> Allows all IAM users in your account to use the AWS Management Console to change their own
    ///             passwords. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/HowToPwdIAMUser.html">Letting IAM users change their own
    ///                 passwords</a> in the <i>IAM User Guide</i>.</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>false</code>. The result is that IAM users in the account do not
    ///             automatically have permissions to change their own password.</p>
    public let allowUsersToChangePassword: Bool
    /// <p>Prevents IAM users from setting a new password after their password has expired. The
    ///             IAM user cannot be accessed until an administrator resets the password.</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>false</code>. The result is that IAM users can change their passwords
    ///             after they expire and continue to sign in as the user.</p>
    public let hardExpiry: Bool?
    /// <p>The number of days that an IAM user password is valid.</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>0</code>. The result is that IAM user passwords never expire.</p>
    public let maxPasswordAge: Int?
    /// <p>The minimum number of characters allowed in an IAM user password.</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>6</code>.</p>
    public let minimumPasswordLength: Int?
    /// <p>Specifies the number of previous passwords that IAM users are prevented from
    ///             reusing.</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>0</code>. The result is that IAM users are not prevented from reusing
    ///             previous passwords.</p>
    public let passwordReusePrevention: Int?
    /// <p>Specifies whether IAM user passwords must contain at least one lowercase character
    ///             from the ISO basic Latin alphabet (a to z).</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>false</code>. The result is that passwords do not require at least one
    ///             lowercase character.</p>
    public let requireLowercaseCharacters: Bool
    /// <p>Specifies whether IAM user passwords must contain at least one numeric character (0
    ///             to 9).</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>false</code>. The result is that passwords do not require at least one
    ///             numeric character.</p>
    public let requireNumbers: Bool
    /// <p>Specifies whether IAM user passwords must contain at least one of the following
    ///             non-alphanumeric characters:</p>
    ///         <p>! @ # $ % ^ & * ( ) _ + - = [ ] { } | '</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>false</code>. The result is that passwords do not require at least one
    ///             symbol character.</p>
    public let requireSymbols: Bool
    /// <p>Specifies whether IAM user passwords must contain at least one uppercase character
    ///             from the ISO basic Latin alphabet (A to Z).</p>
    ///         <p>If you do not specify a value for this parameter, then the operation uses the default
    ///             value of <code>false</code>. The result is that passwords do not require at least one
    ///             uppercase character.</p>
    public let requireUppercaseCharacters: Bool

    public init (
        allowUsersToChangePassword: Bool = false,
        hardExpiry: Bool? = nil,
        maxPasswordAge: Int? = nil,
        minimumPasswordLength: Int? = nil,
        passwordReusePrevention: Int? = nil,
        requireLowercaseCharacters: Bool = false,
        requireNumbers: Bool = false,
        requireSymbols: Bool = false,
        requireUppercaseCharacters: Bool = false
    )
    {
        self.allowUsersToChangePassword = allowUsersToChangePassword
        self.hardExpiry = hardExpiry
        self.maxPasswordAge = maxPasswordAge
        self.minimumPasswordLength = minimumPasswordLength
        self.passwordReusePrevention = passwordReusePrevention
        self.requireLowercaseCharacters = requireLowercaseCharacters
        self.requireNumbers = requireNumbers
        self.requireSymbols = requireSymbols
        self.requireUppercaseCharacters = requireUppercaseCharacters
    }
}

extension UpdateAccountPasswordPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAccountPasswordPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountPasswordPolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountPasswordPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountPasswordPolicyOutputResponse()"}
}

extension UpdateAccountPasswordPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccountPasswordPolicyOutputResponse: Equatable {

    public init() {}
}

struct UpdateAccountPasswordPolicyOutputResponseBody: Equatable {
}

extension UpdateAccountPasswordPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAssumeRolePolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssumeRolePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssumeRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssumeRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssumeRolePolicyInput>
    public typealias MOutput = OperationOutput<UpdateAssumeRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssumeRolePolicyOutputError>
}

extension UpdateAssumeRolePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssumeRolePolicyInput(policyDocument: \(String(describing: policyDocument)), roleName: \(String(describing: roleName)))"}
}

extension UpdateAssumeRolePolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: Key("PolicyDocument"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("UpdateAssumeRolePolicy", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateAssumeRolePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssumeRolePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssumeRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssumeRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssumeRolePolicyInput>
    public typealias MOutput = OperationOutput<UpdateAssumeRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssumeRolePolicyOutputError>
}

public struct UpdateAssumeRolePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssumeRolePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssumeRolePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssumeRolePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssumeRolePolicyInput>
    public typealias MOutput = OperationOutput<UpdateAssumeRolePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssumeRolePolicyOutputError>
}

public struct UpdateAssumeRolePolicyInput: Equatable {
    /// <p>The policy that grants an entity permission to assume the role.</p>
    ///         <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    ///             templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    ///             CloudFormation always converts a YAML policy to JSON format before submitting it to
    ///             IAM.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let policyDocument: String?
    /// <p>The name of the role to update with the new policy.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let roleName: String?

    public init (
        policyDocument: String? = nil,
        roleName: String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.roleName = roleName
    }
}

extension UpdateAssumeRolePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAssumeRolePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssumeRolePolicyOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssumeRolePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssumeRolePolicyOutputResponse()"}
}

extension UpdateAssumeRolePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAssumeRolePolicyOutputResponse: Equatable {

    public init() {}
}

struct UpdateAssumeRolePolicyOutputResponseBody: Equatable {
}

extension UpdateAssumeRolePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

extension UpdateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupInput(groupName: \(String(describing: groupName)), newGroupName: \(String(describing: newGroupName)), newPath: \(String(describing: newPath)))"}
}

extension UpdateGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let newGroupName = newGroupName {
            try container.encode(newGroupName, forKey: Key("NewGroupName"))
        }
        if let newPath = newPath {
            try container.encode(newPath, forKey: Key("NewPath"))
        }
        try container.encode("UpdateGroup", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInput: Equatable {
    /// <p>Name of the IAM group to update. If you're changing the name of the group, this is
    ///             the original name.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let groupName: String?
    /// <p>New name for the IAM group. Only include this if changing the group's name.</p>
    ///         <p>IAM user, group, role, and policy names must be unique within the account. Names are
    ///             not distinguished by case. For example, you cannot create resources named both
    ///             "MyResource" and "myresource".</p>
    public let newGroupName: String?
    /// <p>New path for the IAM group. Only include this if changing the group's path.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let newPath: String?

    public init (
        groupName: String? = nil,
        newGroupName: String? = nil,
        newPath: String? = nil
    )
    {
        self.groupName = groupName
        self.newGroupName = newGroupName
        self.newPath = newPath
    }
}

extension UpdateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupOutputResponse()"}
}

extension UpdateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateGroupOutputResponseBody: Equatable {
}

extension UpdateGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLoginProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLoginProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoginProfileInput>
    public typealias MOutput = OperationOutput<UpdateLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoginProfileOutputError>
}

extension UpdateLoginProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLoginProfileInput(password: \(String(describing: password)), passwordResetRequired: \(String(describing: passwordResetRequired)), userName: \(String(describing: userName)))"}
}

extension UpdateLoginProfileInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let password = password {
            try container.encode(password, forKey: Key("Password"))
        }
        if let passwordResetRequired = passwordResetRequired {
            try container.encode(passwordResetRequired, forKey: Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UpdateLoginProfile", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateLoginProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLoginProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoginProfileInput>
    public typealias MOutput = OperationOutput<UpdateLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoginProfileOutputError>
}

public struct UpdateLoginProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLoginProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoginProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoginProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoginProfileInput>
    public typealias MOutput = OperationOutput<UpdateLoginProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoginProfileOutputError>
}

public struct UpdateLoginProfileInput: Equatable {
    /// <p>The new password for the specified IAM user.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    ///         <p>However, the format can be further restricted by the account administrator by setting
    ///             a password policy on the AWS account. For more information, see <a>UpdateAccountPasswordPolicy</a>.</p>
    public let password: String?
    /// <p>Allows this new password to be used only once by requiring the specified IAM user to
    ///             set a new password on next sign-in.</p>
    public let passwordResetRequired: Bool?
    /// <p>The name of the user whose password you want to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        password: String? = nil,
        passwordResetRequired: Bool? = nil,
        userName: String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

extension UpdateLoginProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateLoginProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiableException" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordPolicyViolationException" : self = .passwordPolicyViolationException(try PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLoginProfileOutputError: Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case passwordPolicyViolationException(PasswordPolicyViolationException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLoginProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLoginProfileOutputResponse()"}
}

extension UpdateLoginProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLoginProfileOutputResponse: Equatable {

    public init() {}
}

struct UpdateLoginProfileOutputResponseBody: Equatable {
}

extension UpdateLoginProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateOpenIDConnectProviderThumbprintInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOpenIDConnectProviderThumbprintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpenIDConnectProviderThumbprintInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpenIDConnectProviderThumbprintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpenIDConnectProviderThumbprintInput>
    public typealias MOutput = OperationOutput<UpdateOpenIDConnectProviderThumbprintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpenIDConnectProviderThumbprintOutputError>
}

extension UpdateOpenIDConnectProviderThumbprintInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOpenIDConnectProviderThumbprintInput(openIDConnectProviderArn: \(String(describing: openIDConnectProviderArn)), thumbprintList: \(String(describing: thumbprintList)))"}
}

extension UpdateOpenIDConnectProviderThumbprintInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: Key("OpenIDConnectProviderArn"))
        }
        if let thumbprintList = thumbprintList {
            var thumbprintListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ThumbprintList"))
            for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                try thumbprintListContainer.encode(thumbprinttype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UpdateOpenIDConnectProviderThumbprint", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateOpenIDConnectProviderThumbprintInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOpenIDConnectProviderThumbprintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpenIDConnectProviderThumbprintInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpenIDConnectProviderThumbprintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpenIDConnectProviderThumbprintInput>
    public typealias MOutput = OperationOutput<UpdateOpenIDConnectProviderThumbprintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpenIDConnectProviderThumbprintOutputError>
}

public struct UpdateOpenIDConnectProviderThumbprintInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOpenIDConnectProviderThumbprintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpenIDConnectProviderThumbprintInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpenIDConnectProviderThumbprintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpenIDConnectProviderThumbprintInput>
    public typealias MOutput = OperationOutput<UpdateOpenIDConnectProviderThumbprintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpenIDConnectProviderThumbprintOutputError>
}

public struct UpdateOpenIDConnectProviderThumbprintInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which
    ///             you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the
    ///                 <a>ListOpenIDConnectProviders</a> operation.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let openIDConnectProviderArn: String?
    /// <p>A list of certificate thumbprints that are associated with the specified IAM OpenID
    ///             Connect provider. For more information, see <a>CreateOpenIDConnectProvider</a>. </p>
    public let thumbprintList: [String]?

    public init (
        openIDConnectProviderArn: String? = nil,
        thumbprintList: [String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.thumbprintList = thumbprintList
    }
}

extension UpdateOpenIDConnectProviderThumbprintOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateOpenIDConnectProviderThumbprintOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOpenIDConnectProviderThumbprintOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpenIDConnectProviderThumbprintOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOpenIDConnectProviderThumbprintOutputResponse()"}
}

extension UpdateOpenIDConnectProviderThumbprintOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOpenIDConnectProviderThumbprintOutputResponse: Equatable {

    public init() {}
}

struct UpdateOpenIDConnectProviderThumbprintOutputResponseBody: Equatable {
}

extension UpdateOpenIDConnectProviderThumbprintOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRoleDescriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoleDescriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateRoleDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleDescriptionOutputError>
}

extension UpdateRoleDescriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoleDescriptionInput(description: \(String(describing: description)), roleName: \(String(describing: roleName)))"}
}

extension UpdateRoleDescriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("UpdateRoleDescription", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateRoleDescriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoleDescriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateRoleDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleDescriptionOutputError>
}

public struct UpdateRoleDescriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoleDescriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateRoleDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleDescriptionOutputError>
}

public struct UpdateRoleDescriptionInput: Equatable {
    /// <p>The new description that you want to apply to the specified role.</p>
    public let description: String?
    /// <p>The name of the role that you want to modify.</p>
    public let roleName: String?

    public init (
        description: String? = nil,
        roleName: String? = nil
    )
    {
        self.description = description
        self.roleName = roleName
    }
}

extension UpdateRoleDescriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRoleDescriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoleDescriptionOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoleDescriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoleDescriptionOutputResponse(role: \(String(describing: role)))"}
}

extension UpdateRoleDescriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRoleDescriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

public struct UpdateRoleDescriptionOutputResponse: Equatable {
    /// <p>A structure that contains details about the modified role.</p>
    public let role: Role?

    public init (
        role: Role? = nil
    )
    {
        self.role = role
    }
}

struct UpdateRoleDescriptionOutputResponseBody: Equatable {
    public let role: Role?
}

extension UpdateRoleDescriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case role = "Role"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateRoleDescriptionResult"))
        let roleDecoded = try containerValues.decodeIfPresent(Role.self, forKey: .role)
        role = roleDecoded
    }
}

public struct UpdateRoleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleInput>
    public typealias MOutput = OperationOutput<UpdateRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleOutputError>
}

extension UpdateRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoleInput(description: \(String(describing: description)), maxSessionDuration: \(String(describing: maxSessionDuration)), roleName: \(String(describing: roleName)))"}
}

extension UpdateRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: Key("MaxSessionDuration"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: Key("RoleName"))
        }
        try container.encode("UpdateRole", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateRoleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleInput>
    public typealias MOutput = OperationOutput<UpdateRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleOutputError>
}

public struct UpdateRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleInput>
    public typealias MOutput = OperationOutput<UpdateRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleOutputError>
}

public struct UpdateRoleInput: Equatable {
    /// <p>The new description that you want to apply to the specified role.</p>
    public let description: String?
    /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
    ///             If you do not specify a value for this setting, the default maximum of one hour is
    ///             applied. This setting can have a value from 1 hour to 12 hours.</p>
    ///         <p>Anyone who assumes the role from the AWS CLI or API can use the
    ///                 <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
    ///             parameter to request a longer session. The <code>MaxSessionDuration</code> setting
    ///             determines the maximum duration that can be requested using the
    ///                 <code>DurationSeconds</code> parameter. If users don't specify a value for the
    ///                 <code>DurationSeconds</code> parameter, their security credentials are valid for one
    ///             hour by default. This applies when you use the <code>AssumeRole*</code> API operations
    ///             or the <code>assume-role*</code> CLI operations but does not apply when you use those
    ///             operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
    ///                 roles</a> in the <i>IAM User Guide</i>.</p>
    public let maxSessionDuration: Int?
    /// <p>The name of the role that you want to modify.</p>
    public let roleName: String?

    public init (
        description: String? = nil,
        maxSessionDuration: Int? = nil,
        roleName: String? = nil
    )
    {
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.roleName = roleName
    }
}

extension UpdateRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntityException" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoleOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoleOutputResponse()"}
}

extension UpdateRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoleOutputResponse: Equatable {

    public init() {}
}

struct UpdateRoleOutputResponseBody: Equatable {
}

extension UpdateRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSAMLProviderInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSAMLProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSAMLProviderInput>
    public typealias MOutput = OperationOutput<UpdateSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSAMLProviderOutputError>
}

extension UpdateSAMLProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSAMLProviderInput(sAMLMetadataDocument: \(String(describing: sAMLMetadataDocument)), sAMLProviderArn: \(String(describing: sAMLProviderArn)))"}
}

extension UpdateSAMLProviderInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sAMLMetadataDocument = sAMLMetadataDocument {
            try container.encode(sAMLMetadataDocument, forKey: Key("SAMLMetadataDocument"))
        }
        if let sAMLProviderArn = sAMLProviderArn {
            try container.encode(sAMLProviderArn, forKey: Key("SAMLProviderArn"))
        }
        try container.encode("UpdateSAMLProvider", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateSAMLProviderInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSAMLProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSAMLProviderInput>
    public typealias MOutput = OperationOutput<UpdateSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSAMLProviderOutputError>
}

public struct UpdateSAMLProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSAMLProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSAMLProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSAMLProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSAMLProviderInput>
    public typealias MOutput = OperationOutput<UpdateSAMLProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSAMLProviderOutputError>
}

public struct UpdateSAMLProviderInput: Equatable {
    /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
    ///             document includes the issuer's name, expiration information, and keys that can be used
    ///             to validate the SAML authentication response (assertions) that are received from the
    ///             IdP. You must generate the metadata document using the identity management software that
    ///             is used as your organization's IdP.</p>
    public let sAMLMetadataDocument: String?
    /// <p>The Amazon Resource Name (ARN) of the SAML provider to update.</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let sAMLProviderArn: String?

    public init (
        sAMLMetadataDocument: String? = nil,
        sAMLProviderArn: String? = nil
    )
    {
        self.sAMLMetadataDocument = sAMLMetadataDocument
        self.sAMLProviderArn = sAMLProviderArn
    }
}

extension UpdateSAMLProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateSAMLProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSAMLProviderOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSAMLProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSAMLProviderOutputResponse(sAMLProviderArn: \(String(describing: sAMLProviderArn)))"}
}

extension UpdateSAMLProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSAMLProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sAMLProviderArn = output.sAMLProviderArn
        } else {
            self.sAMLProviderArn = nil
        }
    }
}

/// <p>Contains the response to a successful <a>UpdateSAMLProvider</a> request.
///     </p>
public struct UpdateSAMLProviderOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the SAML provider that was updated.</p>
    public let sAMLProviderArn: String?

    public init (
        sAMLProviderArn: String? = nil
    )
    {
        self.sAMLProviderArn = sAMLProviderArn
    }
}

struct UpdateSAMLProviderOutputResponseBody: Equatable {
    public let sAMLProviderArn: String?
}

extension UpdateSAMLProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sAMLProviderArn = "SAMLProviderArn"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateSAMLProviderResult"))
        let sAMLProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sAMLProviderArn)
        sAMLProviderArn = sAMLProviderArnDecoded
    }
}

public struct UpdateSSHPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSSHPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<UpdateSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSSHPublicKeyOutputError>
}

extension UpdateSSHPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSSHPublicKeyInput(sSHPublicKeyId: \(String(describing: sSHPublicKeyId)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

extension UpdateSSHPublicKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sSHPublicKeyId = sSHPublicKeyId {
            try container.encode(sSHPublicKeyId, forKey: Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UpdateSSHPublicKey", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateSSHPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSSHPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<UpdateSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSSHPublicKeyOutputError>
}

public struct UpdateSSHPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSSHPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<UpdateSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSSHPublicKeyOutputError>
}

public struct UpdateSSHPublicKeyInput: Equatable {
    /// <p>The unique identifier for the SSH public key.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let sSHPublicKeyId: String?
    /// <p>The status to assign to the SSH public key. <code>Active</code> means that the key can
    ///             be used for authentication with an AWS CodeCommit repository. <code>Inactive</code> means that
    ///             the key cannot be used.</p>
    public let status: StatusType?
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        sSHPublicKeyId: String? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.sSHPublicKeyId = sSHPublicKeyId
        self.status = status
        self.userName = userName
    }
}

extension UpdateSSHPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateSSHPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSSHPublicKeyOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSSHPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSSHPublicKeyOutputResponse()"}
}

extension UpdateSSHPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSSHPublicKeyOutputResponse: Equatable {

    public init() {}
}

struct UpdateSSHPublicKeyOutputResponseBody: Equatable {
}

extension UpdateSSHPublicKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateServerCertificateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServerCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerCertificateInput>
    public typealias MOutput = OperationOutput<UpdateServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerCertificateOutputError>
}

extension UpdateServerCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerCertificateInput(newPath: \(String(describing: newPath)), newServerCertificateName: \(String(describing: newServerCertificateName)), serverCertificateName: \(String(describing: serverCertificateName)))"}
}

extension UpdateServerCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: Key("NewPath"))
        }
        if let newServerCertificateName = newServerCertificateName {
            try container.encode(newServerCertificateName, forKey: Key("NewServerCertificateName"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        try container.encode("UpdateServerCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateServerCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServerCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerCertificateInput>
    public typealias MOutput = OperationOutput<UpdateServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerCertificateOutputError>
}

public struct UpdateServerCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServerCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerCertificateInput>
    public typealias MOutput = OperationOutput<UpdateServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerCertificateOutputError>
}

public struct UpdateServerCertificateInput: Equatable {
    /// <p>The new path for the server certificate. Include this only if you are updating the
    ///             server certificate's path.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let newPath: String?
    /// <p>The new name for the server certificate. Include this only if you are updating the
    ///             server certificate's name. The name of the certificate cannot contain any spaces.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let newServerCertificateName: String?
    /// <p>The name of the server certificate that you want to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let serverCertificateName: String?

    public init (
        newPath: String? = nil,
        newServerCertificateName: String? = nil,
        serverCertificateName: String? = nil
    )
    {
        self.newPath = newPath
        self.newServerCertificateName = newServerCertificateName
        self.serverCertificateName = serverCertificateName
    }
}

extension UpdateServerCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateServerCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerCertificateOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerCertificateOutputResponse()"}
}

extension UpdateServerCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServerCertificateOutputResponse: Equatable {

    public init() {}
}

struct UpdateServerCertificateOutputResponseBody: Equatable {
}

extension UpdateServerCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateServiceSpecificCredentialInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceSpecificCredentialInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<UpdateServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSpecificCredentialOutputError>
}

extension UpdateServiceSpecificCredentialInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceSpecificCredentialInput(serviceSpecificCredentialId: \(String(describing: serviceSpecificCredentialId)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

extension UpdateServiceSpecificCredentialInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: Key("ServiceSpecificCredentialId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UpdateServiceSpecificCredential", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateServiceSpecificCredentialInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceSpecificCredentialInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<UpdateServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSpecificCredentialOutputError>
}

public struct UpdateServiceSpecificCredentialInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceSpecificCredentialInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSpecificCredentialInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSpecificCredentialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSpecificCredentialInput>
    public typealias MOutput = OperationOutput<UpdateServiceSpecificCredentialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSpecificCredentialOutputError>
}

public struct UpdateServiceSpecificCredentialInput: Equatable {
    /// <p>The unique identifier of the service-specific credential.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let serviceSpecificCredentialId: String?
    /// <p>The status to be assigned to the service-specific credential.</p>
    public let status: StatusType?
    /// <p>The name of the IAM user associated with the service-specific credential. If you do
    ///             not specify this value, then the operation assumes the user whose credentials are used
    ///             to call the operation.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        serviceSpecificCredentialId: String? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.status = status
        self.userName = userName
    }
}

extension UpdateServiceSpecificCredentialOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateServiceSpecificCredentialOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceSpecificCredentialOutputError: Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSpecificCredentialOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceSpecificCredentialOutputResponse()"}
}

extension UpdateServiceSpecificCredentialOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServiceSpecificCredentialOutputResponse: Equatable {

    public init() {}
}

struct UpdateServiceSpecificCredentialOutputResponseBody: Equatable {
}

extension UpdateServiceSpecificCredentialOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSigningCertificateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSigningCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSigningCertificateInput>
    public typealias MOutput = OperationOutput<UpdateSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSigningCertificateOutputError>
}

extension UpdateSigningCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSigningCertificateInput(certificateId: \(String(describing: certificateId)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

extension UpdateSigningCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UpdateSigningCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateSigningCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSigningCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSigningCertificateInput>
    public typealias MOutput = OperationOutput<UpdateSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSigningCertificateOutputError>
}

public struct UpdateSigningCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSigningCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSigningCertificateInput>
    public typealias MOutput = OperationOutput<UpdateSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSigningCertificateOutputError>
}

public struct UpdateSigningCertificateInput: Equatable {
    /// <p>The ID of the signing certificate you want to update.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    ///     consist of any upper or lowercased letter or digit.</p>
    public let certificateId: String?
    /// <p> The status you want to assign to the certificate. <code>Active</code> means that the
    ///             certificate can be used for programmatic calls to AWS <code>Inactive</code> means that
    ///             the certificate cannot be used.</p>
    public let status: StatusType?
    /// <p>The name of the IAM user the signing certificate belongs to.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        certificateId: String? = nil,
        status: StatusType? = nil,
        userName: String? = nil
    )
    {
        self.certificateId = certificateId
        self.status = status
        self.userName = userName
    }
}

extension UpdateSigningCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateSigningCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSigningCertificateOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSigningCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSigningCertificateOutputResponse()"}
}

extension UpdateSigningCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSigningCertificateOutputResponse: Equatable {

    public init() {}
}

struct UpdateSigningCertificateOutputResponseBody: Equatable {
}

extension UpdateSigningCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserInput(newPath: \(String(describing: newPath)), newUserName: \(String(describing: newUserName)), userName: \(String(describing: userName)))"}
}

extension UpdateUserInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: Key("NewPath"))
        }
        if let newUserName = newUserName {
            try container.encode(newUserName, forKey: Key("NewUserName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UpdateUser", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UpdateUserInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInput: Equatable {
    /// <p>New path for the IAM user. Include this parameter only if you're changing the user's
    ///             path.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    public let newPath: String?
    /// <p>New name for the user. Include this parameter only if you're changing the user's
    ///             name.</p>
    ///         <p>IAM user, group, role, and policy names must be unique within the account. Names are
    ///             not distinguished by case. For example, you cannot create resources named both
    ///             "MyResource" and "myresource".</p>
    public let newUserName: String?
    /// <p>Name of the user to update. If you're changing the name of the user, this is the
    ///             original user name.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        newPath: String? = nil,
        newUserName: String? = nil,
        userName: String? = nil
    )
    {
        self.newPath = newPath
        self.newUserName = newUserName
        self.userName = userName
    }
}

extension UpdateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityTemporarilyUnmodifiableException" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserOutputResponse()"}
}

extension UpdateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserOutputResponseBody: Equatable {
}

extension UpdateUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UploadSSHPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "UploadSSHPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<UploadSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadSSHPublicKeyOutputError>
}

extension UploadSSHPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadSSHPublicKeyInput(sSHPublicKeyBody: \(String(describing: sSHPublicKeyBody)), userName: \(String(describing: userName)))"}
}

extension UploadSSHPublicKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sSHPublicKeyBody = sSHPublicKeyBody {
            try container.encode(sSHPublicKeyBody, forKey: Key("SSHPublicKeyBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UploadSSHPublicKey", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UploadSSHPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "UploadSSHPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<UploadSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadSSHPublicKeyOutputError>
}

public struct UploadSSHPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadSSHPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<UploadSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadSSHPublicKeyOutputError>
}

public struct UploadSSHPublicKeyInput: Equatable {
    /// <p>The SSH public key. The public key must be encoded in ssh-rsa format or PEM format.
    ///             The minimum bit-length of the public key is 2048 bits. For example, you can generate a
    ///             2048-bit key, and the resulting PEM file is 1679 bytes long.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let sSHPublicKeyBody: String?
    /// <p>The name of the IAM user to associate the SSH public key with.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        sSHPublicKeyBody: String? = nil,
        userName: String? = nil
    )
    {
        self.sSHPublicKeyBody = sSHPublicKeyBody
        self.userName = userName
    }
}

extension UploadSSHPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadSSHPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateSSHPublicKeyException" : self = .duplicateSSHPublicKeyException(try DuplicateSSHPublicKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPublicKeyException" : self = .invalidPublicKeyException(try InvalidPublicKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnrecognizedPublicKeyEncodingException" : self = .unrecognizedPublicKeyEncodingException(try UnrecognizedPublicKeyEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadSSHPublicKeyOutputError: Equatable {
    case duplicateSSHPublicKeyException(DuplicateSSHPublicKeyException)
    case invalidPublicKeyException(InvalidPublicKeyException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case unrecognizedPublicKeyEncodingException(UnrecognizedPublicKeyEncodingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadSSHPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadSSHPublicKeyOutputResponse(sSHPublicKey: \(String(describing: sSHPublicKey)))"}
}

extension UploadSSHPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadSSHPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sSHPublicKey = output.sSHPublicKey
        } else {
            self.sSHPublicKey = nil
        }
    }
}

/// <p>Contains the response to a successful <a>UploadSSHPublicKey</a>
///       request.</p>
public struct UploadSSHPublicKeyOutputResponse: Equatable {
    /// <p>Contains information about the SSH public key.</p>
    public let sSHPublicKey: SSHPublicKey?

    public init (
        sSHPublicKey: SSHPublicKey? = nil
    )
    {
        self.sSHPublicKey = sSHPublicKey
    }
}

struct UploadSSHPublicKeyOutputResponseBody: Equatable {
    public let sSHPublicKey: SSHPublicKey?
}

extension UploadSSHPublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sSHPublicKey = "SSHPublicKey"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UploadSSHPublicKeyResult"))
        let sSHPublicKeyDecoded = try containerValues.decodeIfPresent(SSHPublicKey.self, forKey: .sSHPublicKey)
        sSHPublicKey = sSHPublicKeyDecoded
    }
}

public struct UploadServerCertificateInputBodyMiddleware: Middleware {
    public let id: String = "UploadServerCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadServerCertificateInput>
    public typealias MOutput = OperationOutput<UploadServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadServerCertificateOutputError>
}

extension UploadServerCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadServerCertificateInput(certificateBody: \(String(describing: certificateBody)), certificateChain: \(String(describing: certificateChain)), path: \(String(describing: path)), privateKey: \(String(describing: privateKey)), serverCertificateName: \(String(describing: serverCertificateName)), tags: \(String(describing: tags)))"}
}

extension UploadServerCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: Key("CertificateChain"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let privateKey = privateKey {
            try container.encode(privateKey, forKey: Key("PrivateKey"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: Key("ServerCertificateName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UploadServerCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UploadServerCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UploadServerCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadServerCertificateInput>
    public typealias MOutput = OperationOutput<UploadServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadServerCertificateOutputError>
}

public struct UploadServerCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadServerCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadServerCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadServerCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadServerCertificateInput>
    public typealias MOutput = OperationOutput<UploadServerCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadServerCertificateOutputError>
}

public struct UploadServerCertificateInput: Equatable {
    /// <p>The contents of the public key certificate in PEM-encoded format.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let certificateBody: String?
    /// <p>The contents of the certificate chain. This is typically a concatenation of the
    ///             PEM-encoded public key certificates of the chain.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let certificateChain: String?
    /// <p>The path for the server certificate. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///                 identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///         <p>This parameter is optional. If it is not included, it defaults to a slash (/).
    ///             This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    ///     of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    ///     In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    ///     most punctuation characters, digits, and upper and lowercased letters.</p>
    ///         <note>
    ///             <p> If you are uploading a server certificate specifically for use with Amazon
    ///                 CloudFront distributions, you must specify a path using the <code>path</code>
    ///                 parameter. The path must begin with <code>/cloudfront</code> and must include a
    ///                 trailing slash (for example, <code>/cloudfront/test/</code>).</p>
    ///         </note>
    public let path: String?
    /// <p>The contents of the private key in PEM-encoded format.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let privateKey: String?
    /// <p>The name for the server certificate. Do not include the path in this value. The name
    ///             of the certificate cannot contain any spaces.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let serverCertificateName: String?
    /// <p>A list of tags that you want to attach to the new IAM server certificate resource.
    ///       Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    ///    fails and the resource is not created.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        certificateBody: String? = nil,
        certificateChain: String? = nil,
        path: String? = nil,
        privateKey: String? = nil,
        serverCertificateName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.path = path
        self.privateKey = privateKey
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

extension UploadServerCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadServerCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyPairMismatchException" : self = .keyPairMismatchException(try KeyPairMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCertificateException" : self = .malformedCertificateException(try MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadServerCertificateOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case keyPairMismatchException(KeyPairMismatchException)
    case limitExceededException(LimitExceededException)
    case malformedCertificateException(MalformedCertificateException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadServerCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadServerCertificateOutputResponse(serverCertificateMetadata: \(String(describing: serverCertificateMetadata)), tags: \(String(describing: tags)))"}
}

extension UploadServerCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadServerCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverCertificateMetadata = output.serverCertificateMetadata
            self.tags = output.tags
        } else {
            self.serverCertificateMetadata = nil
            self.tags = nil
        }
    }
}

/// <p>Contains the response to a successful <a>UploadServerCertificate</a>
///       request. </p>
public struct UploadServerCertificateOutputResponse: Equatable {
    /// <p>The meta information of the uploaded server certificate without its certificate body,
    ///             certificate chain, and private key.</p>
    public let serverCertificateMetadata: ServerCertificateMetadata?
    /// <p>A list of tags that are attached to the new IAM server certificate. The returned list of tags is sorted by tag key.
    ///       For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        serverCertificateMetadata: ServerCertificateMetadata? = nil,
        tags: [Tag]? = nil
    )
    {
        self.serverCertificateMetadata = serverCertificateMetadata
        self.tags = tags
    }
}

struct UploadServerCertificateOutputResponseBody: Equatable {
    public let serverCertificateMetadata: ServerCertificateMetadata?
    public let tags: [Tag]?
}

extension UploadServerCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverCertificateMetadata = "ServerCertificateMetadata"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UploadServerCertificateResult"))
        let serverCertificateMetadataDecoded = try containerValues.decodeIfPresent(ServerCertificateMetadata.self, forKey: .serverCertificateMetadata)
        serverCertificateMetadata = serverCertificateMetadataDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

public struct UploadSigningCertificateInputBodyMiddleware: Middleware {
    public let id: String = "UploadSigningCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadSigningCertificateInput>
    public typealias MOutput = OperationOutput<UploadSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadSigningCertificateOutputError>
}

extension UploadSigningCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadSigningCertificateInput(certificateBody: \(String(describing: certificateBody)), userName: \(String(describing: userName)))"}
}

extension UploadSigningCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: Key("CertificateBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        try container.encode("UploadSigningCertificate", forKey:Key("Action"))
        try container.encode("2010-05-08", forKey:Key("Version"))
    }
}

public struct UploadSigningCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UploadSigningCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadSigningCertificateInput>
    public typealias MOutput = OperationOutput<UploadSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadSigningCertificateOutputError>
}

public struct UploadSigningCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadSigningCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadSigningCertificateInput>
    public typealias MOutput = OperationOutput<UploadSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadSigningCertificateOutputError>
}

public struct UploadSigningCertificateInput: Equatable {
    /// <p>The contents of the signing certificate.</p>
    ///         <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    ///     used to validate this parameter is a string of characters consisting of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any printable ASCII
    ///     character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    ///             </li>
    ///             <li>
    ///                <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    ///     (through <code>\u00FF</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    ///     carriage return (<code>\u000D</code>)</p>
    ///             </li>
    ///          </ul>
    public let certificateBody: String?
    /// <p>The name of the user the signing certificate is for.</p>
    ///         <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    ///     characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    public let userName: String?

    public init (
        certificateBody: String? = nil,
        userName: String? = nil
    )
    {
        self.certificateBody = certificateBody
        self.userName = userName
    }
}

extension UploadSigningCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadSigningCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateCertificateException" : self = .duplicateCertificateException(try DuplicateCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateException" : self = .invalidCertificateException(try InvalidCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCertificateException" : self = .malformedCertificateException(try MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadSigningCertificateOutputError: Equatable {
    case duplicateCertificateException(DuplicateCertificateException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidCertificateException(InvalidCertificateException)
    case limitExceededException(LimitExceededException)
    case malformedCertificateException(MalformedCertificateException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadSigningCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadSigningCertificateOutputResponse(certificate: \(String(describing: certificate)))"}
}

extension UploadSigningCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadSigningCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

/// <p>Contains the response to a successful <a>UploadSigningCertificate</a>
///       request. </p>
public struct UploadSigningCertificateOutputResponse: Equatable {
    /// <p>Information about the certificate.</p>
    public let certificate: SigningCertificate?

    public init (
        certificate: SigningCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct UploadSigningCertificateOutputResponseBody: Equatable {
    public let certificate: SigningCertificate?
}

extension UploadSigningCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UploadSigningCertificateResult"))
        let certificateDecoded = try containerValues.decodeIfPresent(SigningCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case passwordLastUsed = "PasswordLastUsed"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let passwordLastUsed = passwordLastUsed {
            try container.encode(TimestampWrapper(passwordLastUsed, format: .dateTime), forKey: Key("passwordLastUsed"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let passwordLastUsedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .passwordLastUsed)
        var passwordLastUsedBuffer:Date? = nil
        if let passwordLastUsedDecoded = passwordLastUsedDecoded {
            passwordLastUsedBuffer = try TimestampWrapperDecoder.parseDateStringValue(passwordLastUsedDecoded, format: .dateTime)
        }
        passwordLastUsed = passwordLastUsedBuffer
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), passwordLastUsed: \(String(describing: passwordLastUsed)), path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), tags: \(String(describing: tags)), userId: \(String(describing: userId)), userName: \(String(describing: userName)))"}
}

/// <p>Contains information about an IAM user entity.</p>
///          <p>This data type is used as a response element in the following operations:</p>
///          <ul>
///             <li>
///                <p>
///                   <a>CreateUser</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>GetUser</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListUsers</a>
///                </p>
///             </li>
///          </ul>
public struct User: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs
    ///          and how to use ARNs in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM Identifiers</a> in the
    ///             <i>IAM User Guide</i>. </p>
    public let arn: String?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the user was created.</p>
    public let createDate: Date?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the user's password was last used to sign in to an AWS website. For
    ///          a list of AWS websites that capture a user's last sign-in time, see the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html">Credential
    ///             reports</a> topic in the <i>IAM User Guide</i>. If a password is
    ///          used more than once in a five-minute span, only the first use is returned in this field. If
    ///          the field is null (no value), then it indicates that they never signed in with a password.
    ///          This can be because:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The user never had a password.</p>
    ///             </li>
    ///             <li>
    ///                <p>A password exists but has not been used since IAM started tracking this
    ///                information on October 20, 2014.</p>
    ///             </li>
    ///          </ul>
    ///          <p>A null value does not mean that the user <i>never</i> had a password.
    ///          Also, if the user does not currently have a password but had one in the past, then this
    ///          field contains the date and time the most recent password was used.</p>
    ///          <p>This value is returned only in the <a>GetUser</a> and <a>ListUsers</a> operations. </p>
    public let passwordLastUsed: Date?
    /// <p>The path to the user. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>The ARN of the policy used to set the permissions boundary for the user.</p>
    public let path: String?
    /// <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///             identities </a> in the <i>IAM User Guide</i>.</p>
    public let permissionsBoundary: AttachedPermissionsBoundary?
    /// <p>A list of tags that are associated with the user. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The stable and unique string identifying the user. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>.</p>
    public let userId: String?
    /// <p>The friendly name identifying the user.</p>
    public let userName: String?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        passwordLastUsed: Date? = nil,
        path: String? = nil,
        permissionsBoundary: AttachedPermissionsBoundary? = nil,
        tags: [Tag]? = nil,
        userId: String? = nil,
        userName: String? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.passwordLastUsed = passwordLastUsed
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.tags = tags
        self.userId = userId
        self.userName = userName
    }
}

extension UserDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupList = "GroupList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
        case userPolicyList = "UserPolicyList"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttachedManagedPolicies"))
            for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("createDate"))
        }
        if let groupList = groupList {
            var groupListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("GroupList"))
            for (index0, groupnametype0) in groupList.enumerated() {
                try groupListContainer.encode(groupnametype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: Key("PermissionsBoundary"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
        if let userPolicyList = userPolicyList {
            var userPolicyListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("UserPolicyList"))
            for (index0, policydetail0) in userPolicyList.enumerated() {
                try userPolicyListContainer.encode(policydetail0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        if containerValues.contains(.userPolicyList) {
            struct KeyVal0{struct member{}}
            let userPolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userPolicyList)
            if let userPolicyListWrappedContainer = userPolicyListWrappedContainer {
                let userPolicyListContainer = try userPolicyListWrappedContainer.decodeIfPresent([PolicyDetail].self, forKey: .member)
                var userPolicyListBuffer:[PolicyDetail]? = nil
                if let userPolicyListContainer = userPolicyListContainer {
                    userPolicyListBuffer = [PolicyDetail]()
                    for structureContainer0 in userPolicyListContainer {
                        userPolicyListBuffer?.append(structureContainer0)
                    }
                }
                userPolicyList = userPolicyListBuffer
            } else {
                userPolicyList = []
            }
        } else {
            userPolicyList = nil
        }
        if containerValues.contains(.groupList) {
            struct KeyVal0{struct member{}}
            let groupListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupList)
            if let groupListWrappedContainer = groupListWrappedContainer {
                let groupListContainer = try groupListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var groupListBuffer:[String]? = nil
                if let groupListContainer = groupListContainer {
                    groupListBuffer = [String]()
                    for stringContainer0 in groupListContainer {
                        groupListBuffer?.append(stringContainer0)
                    }
                }
                groupList = groupListBuffer
            } else {
                groupList = []
            }
        } else {
            groupList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension UserDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserDetail(arn: \(String(describing: arn)), attachedManagedPolicies: \(String(describing: attachedManagedPolicies)), createDate: \(String(describing: createDate)), groupList: \(String(describing: groupList)), path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), tags: \(String(describing: tags)), userId: \(String(describing: userId)), userName: \(String(describing: userName)), userPolicyList: \(String(describing: userPolicyList)))"}
}

/// <p>Contains information about an IAM user, including all the user's policies and all the
///          IAM groups the user is in.</p>
///          <p>This data type is used as a response element in the <a>GetAccountAuthorizationDetails</a> operation.</p>
public struct UserDetail: Equatable {
    /// <p>The Amazon Resource Name (ARN). ARNs are unique identifiers for AWS resources.</p>
    ///          <p>For more information about ARNs, go to <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in
    ///          the <i>AWS General Reference</i>. </p>
    public let arn: String?
    /// <p>A list of the managed policies attached to the user.</p>
    public let attachedManagedPolicies: [AttachedPolicy]?
    /// <p>The date and time, in <a href="http://www.iso.org/iso/iso8601">ISO 8601 date-time
    ///             format</a>, when the user was created.</p>
    public let createDate: Date?
    /// <p>A list of IAM groups that the user is in.</p>
    public let groupList: [String]?
    /// <p>The path to the user. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let path: String?
    /// <p>The ARN of the policy used to set the permissions boundary for the user.</p>
    ///          <p>For more information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    ///             identities </a> in the <i>IAM User Guide</i>.</p>
    public let permissionsBoundary: AttachedPermissionsBoundary?
    /// <p>A list of tags that are associated with the user. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The stable and unique string identifying the user. For more information about IDs, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    ///             identifiers</a> in the <i>IAM User Guide</i>.</p>
    public let userId: String?
    /// <p>The friendly name identifying the user.</p>
    public let userName: String?
    /// <p>A list of the inline policies embedded in the user.</p>
    public let userPolicyList: [PolicyDetail]?

    public init (
        arn: String? = nil,
        attachedManagedPolicies: [AttachedPolicy]? = nil,
        createDate: Date? = nil,
        groupList: [String]? = nil,
        path: String? = nil,
        permissionsBoundary: AttachedPermissionsBoundary? = nil,
        tags: [Tag]? = nil,
        userId: String? = nil,
        userName: String? = nil,
        userPolicyList: [PolicyDetail]? = nil
    )
    {
        self.arn = arn
        self.attachedManagedPolicies = attachedManagedPolicies
        self.createDate = createDate
        self.groupList = groupList
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.tags = tags
        self.userId = userId
        self.userName = userName
        self.userPolicyList = userPolicyList
    }
}

extension VirtualMFADevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case base32StringSeed = "Base32StringSeed"
        case enableDate = "EnableDate"
        case qRCodePNG = "QRCodePNG"
        case serialNumber = "SerialNumber"
        case tags = "Tags"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let base32StringSeed = base32StringSeed {
            try container.encode(base32StringSeed.base64EncodedString(), forKey: Key("Base32StringSeed"))
        }
        if let enableDate = enableDate {
            try container.encode(TimestampWrapper(enableDate, format: .dateTime), forKey: Key("enableDate"))
        }
        if let qRCodePNG = qRCodePNG {
            try container.encode(qRCodePNG.base64EncodedString(), forKey: Key("QRCodePNG"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let user = user {
            try container.encode(user, forKey: Key("User"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        if containerValues.contains(.base32StringSeed) {
            do {
                let base32StringSeedDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .base32StringSeed)
                base32StringSeed = base32StringSeedDecoded
            } catch {
                base32StringSeed = "".data(using: .utf8)
            }
        } else {
            base32StringSeed = nil
        }
        if containerValues.contains(.qRCodePNG) {
            do {
                let qRCodePNGDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .qRCodePNG)
                qRCodePNG = qRCodePNGDecoded
            } catch {
                qRCodePNG = "".data(using: .utf8)
            }
        } else {
            qRCodePNG = nil
        }
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
        let enableDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enableDate)
        var enableDateBuffer:Date? = nil
        if let enableDateDecoded = enableDateDecoded {
            enableDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(enableDateDecoded, format: .dateTime)
        }
        enableDate = enableDateBuffer
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension VirtualMFADevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualMFADevice(base32StringSeed: \(String(describing: base32StringSeed)), enableDate: \(String(describing: enableDate)), qRCodePNG: \(String(describing: qRCodePNG)), serialNumber: \(String(describing: serialNumber)), tags: \(String(describing: tags)), user: \(String(describing: user)))"}
}

/// <p>Contains information about a virtual MFA device.</p>
public struct VirtualMFADevice: Equatable {
    /// <p> The base32 seed defined as specified in <a href="https://tools.ietf.org/html/rfc3548.txt">RFC3548</a>. The <code>Base32StringSeed</code> is base64-encoded. </p>
    public let base32StringSeed: Data?
    /// <p>The date and time on which the virtual MFA device was enabled.</p>
    public let enableDate: Date?
    /// <p> A QR code PNG image that encodes
    ///             <code>otpauth://totp/$virtualMFADeviceName@$AccountName?secret=$Base32String</code>
    ///          where <code>$virtualMFADeviceName</code> is one of the create call arguments.
    ///             <code>AccountName</code> is the user name if set (otherwise, the account ID otherwise),
    ///          and <code>Base32String</code> is the seed in base32 format. The <code>Base32String</code>
    ///          value is base64-encoded. </p>
    public let qRCodePNG: Data?
    /// <p>The serial number associated with <code>VirtualMFADevice</code>.</p>
    public let serialNumber: String?
    /// <p>A list of tags that are attached to the virtual MFA device. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The IAM user associated with this virtual MFA device.</p>
    public let user: User?

    public init (
        base32StringSeed: Data? = nil,
        enableDate: Date? = nil,
        qRCodePNG: Data? = nil,
        serialNumber: String? = nil,
        tags: [Tag]? = nil,
        user: User? = nil
    )
    {
        self.base32StringSeed = base32StringSeed
        self.enableDate = enableDate
        self.qRCodePNG = qRCodePNG
        self.serialNumber = serialNumber
        self.tags = tags
        self.user = user
    }
}
