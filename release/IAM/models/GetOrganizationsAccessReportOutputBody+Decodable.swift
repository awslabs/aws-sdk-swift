// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct GetOrganizationsAccessReportOutputBody: Equatable {
    public let jobStatus: JobStatusType?
    public let jobCreationDate: Date?
    public let jobCompletionDate: Date?
    public let numberOfServicesAccessible: Int?
    public let numberOfServicesNotAccessed: Int?
    public let accessDetails: [AccessDetail]?
    public let isTruncated: Bool
    public let marker: String?
    public let errorDetails: ErrorDetails?
}

extension GetOrganizationsAccessReportOutputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessDetails = "AccessDetails"
        case errorDetails = "ErrorDetails"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case marker = "Marker"
        case numberOfServicesAccessible = "NumberOfServicesAccessible"
        case numberOfServicesNotAccessed = "NumberOfServicesNotAccessed"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetOrganizationsAccessReportResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobCreationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCreationDate)
        var jobCreationDateBuffer:Date? = nil
        if let jobCreationDateDecoded = jobCreationDateDecoded {
            jobCreationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCreationDateDecoded, format: .dateTime)
        }
        jobCreationDate = jobCreationDateBuffer
        let jobCompletionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCompletionDate)
        var jobCompletionDateBuffer:Date? = nil
        if let jobCompletionDateDecoded = jobCompletionDateDecoded {
            jobCompletionDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(jobCompletionDateDecoded, format: .dateTime)
        }
        jobCompletionDate = jobCompletionDateBuffer
        let numberOfServicesAccessibleDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfServicesAccessible)
        numberOfServicesAccessible = numberOfServicesAccessibleDecoded
        let numberOfServicesNotAccessedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfServicesNotAccessed)
        numberOfServicesNotAccessed = numberOfServicesNotAccessedDecoded
        if containerValues.contains(.accessDetails) {
            struct KeyVal0{struct member{}}
            let accessDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessDetails)
            if let accessDetailsWrappedContainer = accessDetailsWrappedContainer {
                let accessDetailsContainer = try accessDetailsWrappedContainer.decodeIfPresent([AccessDetail].self, forKey: .member)
                var accessDetailsBuffer:[AccessDetail]? = nil
                if let accessDetailsContainer = accessDetailsContainer {
                    accessDetailsBuffer = [AccessDetail]()
                    for structureContainer0 in accessDetailsContainer {
                        accessDetailsBuffer?.append(structureContainer0)
                    }
                }
                accessDetails = accessDetailsBuffer
            } else {
                accessDetails = []
            }
        } else {
            accessDetails = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}
