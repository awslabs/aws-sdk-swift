// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You aren't authorized to perform the action. Use the Amazon Resource Name (ARN)
///             of an authorized user or IAM role to perform the operation.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

public struct AnalyzeDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AnalyzeDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AnalyzeDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AnalyzeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AnalyzeDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AnalyzeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AnalyzeDocumentOutputError>
}

extension AnalyzeDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalyzeDocumentInput(document: \(Swift.String(describing: document)), featureTypes: \(Swift.String(describing: featureTypes)), humanLoopConfig: \(Swift.String(describing: humanLoopConfig)))"}
}

extension AnalyzeDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
        case featureTypes = "FeatureTypes"
        case humanLoopConfig = "HumanLoopConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let featureTypes = featureTypes {
            var featureTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featureTypes)
            for featuretypes0 in featureTypes {
                try featureTypesContainer.encode(featuretypes0.rawValue)
            }
        }
        if let humanLoopConfig = humanLoopConfig {
            try encodeContainer.encode(humanLoopConfig, forKey: .humanLoopConfig)
        }
    }
}

public struct AnalyzeDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AnalyzeDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AnalyzeDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AnalyzeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AnalyzeDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AnalyzeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AnalyzeDocumentOutputError>
}

public struct AnalyzeDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AnalyzeDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AnalyzeDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AnalyzeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AnalyzeDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AnalyzeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AnalyzeDocumentOutputError>
}

public struct AnalyzeDocumentInput: Swift.Equatable {
    /// <p>The input document as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
    ///          to call Amazon Textract operations, you can't pass image bytes. The document must be an image
    ///          in JPEG or PNG format.</p>
    ///          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
    ///          image bytes that are passed using the <code>Bytes</code> field. </p>
    public let document: TextractClientTypes.Document?
    /// <p>A list of the types of analysis to perform. Add TABLES to the list to return information
    ///          about the tables that are detected in the input document. Add FORMS to return detected form data.
    ///          To perform both types of analysis, add TABLES and FORMS to
    ///             <code>FeatureTypes</code>. All lines and words detected in the document are included in
    ///          the response (including text that isn't related to the value of <code>FeatureTypes</code>). </p>
    public let featureTypes: [TextractClientTypes.FeatureType]?
    /// <p>Sets the configuration for the human in the loop workflow for analyzing documents.</p>
    public let humanLoopConfig: TextractClientTypes.HumanLoopConfig?

    public init (
        document: TextractClientTypes.Document? = nil,
        featureTypes: [TextractClientTypes.FeatureType]? = nil,
        humanLoopConfig: TextractClientTypes.HumanLoopConfig? = nil
    )
    {
        self.document = document
        self.featureTypes = featureTypes
        self.humanLoopConfig = humanLoopConfig
    }
}

struct AnalyzeDocumentInputBody: Swift.Equatable {
    public let document: TextractClientTypes.Document?
    public let featureTypes: [TextractClientTypes.FeatureType]?
    public let humanLoopConfig: TextractClientTypes.HumanLoopConfig?
}

extension AnalyzeDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
        case featureTypes = "FeatureTypes"
        case humanLoopConfig = "HumanLoopConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(TextractClientTypes.Document.self, forKey: .document)
        document = documentDecoded
        let featureTypesContainer = try containerValues.decodeIfPresent([TextractClientTypes.FeatureType?].self, forKey: .featureTypes)
        var featureTypesDecoded0:[TextractClientTypes.FeatureType]? = nil
        if let featureTypesContainer = featureTypesContainer {
            featureTypesDecoded0 = [TextractClientTypes.FeatureType]()
            for string0 in featureTypesContainer {
                if let string0 = string0 {
                    featureTypesDecoded0?.append(string0)
                }
            }
        }
        featureTypes = featureTypesDecoded0
        let humanLoopConfigDecoded = try containerValues.decodeIfPresent(TextractClientTypes.HumanLoopConfig.self, forKey: .humanLoopConfig)
        humanLoopConfig = humanLoopConfigDecoded
    }
}

extension AnalyzeDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AnalyzeDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HumanLoopQuotaExceededException" : self = .humanLoopQuotaExceededException(try HumanLoopQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AnalyzeDocumentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case humanLoopQuotaExceededException(HumanLoopQuotaExceededException)
    case internalServerError(InternalServerError)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AnalyzeDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalyzeDocumentOutputResponse(analyzeDocumentModelVersion: \(Swift.String(describing: analyzeDocumentModelVersion)), blocks: \(Swift.String(describing: blocks)), documentMetadata: \(Swift.String(describing: documentMetadata)), humanLoopActivationOutput: \(Swift.String(describing: humanLoopActivationOutput)))"}
}

extension AnalyzeDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AnalyzeDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzeDocumentModelVersion = output.analyzeDocumentModelVersion
            self.blocks = output.blocks
            self.documentMetadata = output.documentMetadata
            self.humanLoopActivationOutput = output.humanLoopActivationOutput
        } else {
            self.analyzeDocumentModelVersion = nil
            self.blocks = nil
            self.documentMetadata = nil
            self.humanLoopActivationOutput = nil
        }
    }
}

public struct AnalyzeDocumentOutputResponse: Swift.Equatable {
    /// <p>The version of the model used to analyze the document.</p>
    public let analyzeDocumentModelVersion: Swift.String?
    /// <p>The items that are detected and analyzed by <code>AnalyzeDocument</code>.</p>
    public let blocks: [TextractClientTypes.Block]?
    /// <p>Metadata about the analyzed document. An example is the number of pages.</p>
    public let documentMetadata: TextractClientTypes.DocumentMetadata?
    /// <p>Shows the results of the human in the loop evaluation.</p>
    public let humanLoopActivationOutput: TextractClientTypes.HumanLoopActivationOutput?

    public init (
        analyzeDocumentModelVersion: Swift.String? = nil,
        blocks: [TextractClientTypes.Block]? = nil,
        documentMetadata: TextractClientTypes.DocumentMetadata? = nil,
        humanLoopActivationOutput: TextractClientTypes.HumanLoopActivationOutput? = nil
    )
    {
        self.analyzeDocumentModelVersion = analyzeDocumentModelVersion
        self.blocks = blocks
        self.documentMetadata = documentMetadata
        self.humanLoopActivationOutput = humanLoopActivationOutput
    }
}

struct AnalyzeDocumentOutputResponseBody: Swift.Equatable {
    public let documentMetadata: TextractClientTypes.DocumentMetadata?
    public let blocks: [TextractClientTypes.Block]?
    public let humanLoopActivationOutput: TextractClientTypes.HumanLoopActivationOutput?
    public let analyzeDocumentModelVersion: Swift.String?
}

extension AnalyzeDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzeDocumentModelVersion = "AnalyzeDocumentModelVersion"
        case blocks = "Blocks"
        case documentMetadata = "DocumentMetadata"
        case humanLoopActivationOutput = "HumanLoopActivationOutput"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(TextractClientTypes.DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let blocksContainer = try containerValues.decodeIfPresent([TextractClientTypes.Block?].self, forKey: .blocks)
        var blocksDecoded0:[TextractClientTypes.Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [TextractClientTypes.Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let humanLoopActivationOutputDecoded = try containerValues.decodeIfPresent(TextractClientTypes.HumanLoopActivationOutput.self, forKey: .humanLoopActivationOutput)
        humanLoopActivationOutput = humanLoopActivationOutputDecoded
        let analyzeDocumentModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzeDocumentModelVersion)
        analyzeDocumentModelVersion = analyzeDocumentModelVersionDecoded
    }
}

extension BadDocumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadDocumentException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension BadDocumentException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadDocumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract isn't able to read the document. For more information on the document
///          limits in Amazon Textract, see <a>limits</a>.</p>
public struct BadDocumentException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadDocumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension BadDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TextractClientTypes.Block: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockType = "BlockType"
        case columnIndex = "ColumnIndex"
        case columnSpan = "ColumnSpan"
        case confidence = "Confidence"
        case entityTypes = "EntityTypes"
        case geometry = "Geometry"
        case id = "Id"
        case page = "Page"
        case relationships = "Relationships"
        case rowIndex = "RowIndex"
        case rowSpan = "RowSpan"
        case selectionStatus = "SelectionStatus"
        case text = "Text"
        case textType = "TextType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockType = blockType {
            try encodeContainer.encode(blockType.rawValue, forKey: .blockType)
        }
        if let columnIndex = columnIndex {
            try encodeContainer.encode(columnIndex, forKey: .columnIndex)
        }
        if let columnSpan = columnSpan {
            try encodeContainer.encode(columnSpan, forKey: .columnSpan)
        }
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entitytypes0 in entityTypes {
                try entityTypesContainer.encode(entitytypes0.rawValue)
            }
        }
        if let geometry = geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let page = page {
            try encodeContainer.encode(page, forKey: .page)
        }
        if let relationships = relationships {
            var relationshipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationships)
            for relationshiplist0 in relationships {
                try relationshipsContainer.encode(relationshiplist0)
            }
        }
        if let rowIndex = rowIndex {
            try encodeContainer.encode(rowIndex, forKey: .rowIndex)
        }
        if let rowSpan = rowSpan {
            try encodeContainer.encode(rowSpan, forKey: .rowSpan)
        }
        if let selectionStatus = selectionStatus {
            try encodeContainer.encode(selectionStatus.rawValue, forKey: .selectionStatus)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockTypeDecoded = try containerValues.decodeIfPresent(TextractClientTypes.BlockType.self, forKey: .blockType)
        blockType = blockTypeDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .confidence)
        confidence = confidenceDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(TextractClientTypes.TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let rowIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowIndex)
        rowIndex = rowIndexDecoded
        let columnIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .columnIndex)
        columnIndex = columnIndexDecoded
        let rowSpanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowSpan)
        rowSpan = rowSpanDecoded
        let columnSpanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .columnSpan)
        columnSpan = columnSpanDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(TextractClientTypes.Geometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let relationshipsContainer = try containerValues.decodeIfPresent([TextractClientTypes.Relationship?].self, forKey: .relationships)
        var relationshipsDecoded0:[TextractClientTypes.Relationship]? = nil
        if let relationshipsContainer = relationshipsContainer {
            relationshipsDecoded0 = [TextractClientTypes.Relationship]()
            for structure0 in relationshipsContainer {
                if let structure0 = structure0 {
                    relationshipsDecoded0?.append(structure0)
                }
            }
        }
        relationships = relationshipsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([TextractClientTypes.EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[TextractClientTypes.EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [TextractClientTypes.EntityType]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let selectionStatusDecoded = try containerValues.decodeIfPresent(TextractClientTypes.SelectionStatus.self, forKey: .selectionStatus)
        selectionStatus = selectionStatusDecoded
        let pageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .page)
        page = pageDecoded
    }
}

extension TextractClientTypes.Block: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Block(blockType: \(Swift.String(describing: blockType)), columnIndex: \(Swift.String(describing: columnIndex)), columnSpan: \(Swift.String(describing: columnSpan)), confidence: \(Swift.String(describing: confidence)), entityTypes: \(Swift.String(describing: entityTypes)), geometry: \(Swift.String(describing: geometry)), id: \(Swift.String(describing: id)), page: \(Swift.String(describing: page)), relationships: \(Swift.String(describing: relationships)), rowIndex: \(Swift.String(describing: rowIndex)), rowSpan: \(Swift.String(describing: rowSpan)), selectionStatus: \(Swift.String(describing: selectionStatus)), text: \(Swift.String(describing: text)), textType: \(Swift.String(describing: textType)))"}
}

extension TextractClientTypes {
    /// <p>A <code>Block</code> represents items that are recognized in a document within a group
    ///          of pixels close to each other. The information returned in a <code>Block</code> object
    ///          depends on the type of operation. In text detection for documents (for example <a>DetectDocumentText</a>), you get information about the detected words and lines
    ///          of text. In text analysis (for example <a>AnalyzeDocument</a>), you can also get
    ///          information about the fields, tables, and selection elements that are detected in the
    ///          document.</p>
    ///          <p>An array of <code>Block</code> objects is returned by both synchronous and asynchronous
    ///          operations. In synchronous operations, such as <a>DetectDocumentText</a>, the
    ///          array of <code>Block</code> objects is the entire set of results. In asynchronous
    ///          operations, such as <a>GetDocumentAnalysis</a>, the array is returned over one
    ///          or more responses.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works.html">How Amazon Textract Works</a>.</p>
    public struct Block: Swift.Equatable {
        /// <p>The type of text item that's recognized. In operations for text detection, the following
        ///          types are returned:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <i>PAGE</i> - Contains a list of the LINE <code>Block</code> objects
        ///                that are detected on a document page.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>WORD</i> - A word detected on a document page. A word is one or
        ///                more ISO basic Latin script characters that aren't separated by spaces.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>LINE</i> - A string of tab-delimited, contiguous words that are
        ///                detected on a document page.</p>
        ///             </li>
        ///          </ul>
        ///          <p>In text analysis operations, the following types are returned:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <i>PAGE</i> - Contains a list of child <code>Block</code> objects
        ///                that are detected on a document page.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>KEY_VALUE_SET</i> - Stores the KEY and VALUE <code>Block</code>
        ///                objects for linked text that's detected on a document page. Use the
        ///                   <code>EntityType</code> field to determine if a KEY_VALUE_SET object is a KEY
        ///                   <code>Block</code> object or a VALUE <code>Block</code> object. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>WORD</i> - A word that's detected on a document page. A word is
        ///                one or more ISO basic Latin script characters that aren't separated by spaces.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>LINE</i> - A string of tab-delimited, contiguous words that are
        ///                detected on a document page.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>TABLE</i> - A table that's detected on a document page. A table
        ///                is grid-based information with two or more rows or columns, with a cell span of one
        ///                row and one column each. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>CELL</i> - A cell within a detected table. The cell is the parent
        ///                of the block that contains the text in the cell.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>SELECTION_ELEMENT</i> - A selection element such as an option
        ///                button (radio button) or a check box that's detected on a document page. Use the
        ///                value of <code>SelectionStatus</code> to determine the status of the selection
        ///                element.</p>
        ///             </li>
        ///          </ul>
        public let blockType: TextractClientTypes.BlockType?
        /// <p>The column in which a table cell appears. The first column position is 1.
        ///             <code>ColumnIndex</code> isn't returned by <code>DetectDocumentText</code> and
        ///             <code>GetDocumentTextDetection</code>.</p>
        public let columnIndex: Swift.Int?
        /// <p>The number of columns that a table cell spans. Currently this value is always 1, even
        ///          if the number of columns spanned is greater than 1. <code>ColumnSpan</code> isn't returned by
        ///             <code>DetectDocumentText</code> and <code>GetDocumentTextDetection</code>. </p>
        public let columnSpan: Swift.Int?
        /// <p>The confidence score that Amazon Textract has in the accuracy of the recognized text and
        ///          the accuracy of the geometry points around the recognized text.</p>
        public let confidence: Swift.Float?
        /// <p>The type of entity. The following can be returned:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <i>KEY</i> - An identifier for a field on the document.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>VALUE</i> - The field text.</p>
        ///             </li>
        ///          </ul>
        ///          <p>
        ///             <code>EntityTypes</code> isn't returned by <code>DetectDocumentText</code> and
        ///             <code>GetDocumentTextDetection</code>.</p>
        public let entityTypes: [TextractClientTypes.EntityType]?
        /// <p>The location of the recognized text on the image. It includes an axis-aligned, coarse
        ///          bounding box that surrounds the text, and a finer-grain polygon for more accurate spatial
        ///          information. </p>
        public let geometry: TextractClientTypes.Geometry?
        /// <p>The identifier for the recognized text. The identifier is only unique for a single
        ///          operation. </p>
        public let id: Swift.String?
        /// <p>The page on which a block was detected. <code>Page</code> is returned by asynchronous
        ///          operations. Page values greater than 1 are only returned for multipage documents that are
        ///          in PDF format. A scanned image (JPEG/PNG), even if it contains multiple document pages, is
        ///          considered to be a single-page document. The value of <code>Page</code> is always 1.
        ///          Synchronous operations don't return <code>Page</code> because every input document is
        ///          considered to be a single-page document.</p>
        public let page: Swift.Int?
        /// <p>A list of child blocks of the current block. For example, a LINE object has child blocks
        ///          for each WORD block that's part of the line of text. There aren't Relationship objects in
        ///          the list for relationships that don't exist, such as when the current block has no child
        ///          blocks. The list size can be the following:</p>
        ///          <ul>
        ///             <li>
        ///                <p>0 - The block has no child blocks.</p>
        ///             </li>
        ///             <li>
        ///                <p>1 - The block has child blocks.</p>
        ///             </li>
        ///          </ul>
        public let relationships: [TextractClientTypes.Relationship]?
        /// <p>The row in which a table cell is located. The first row position is 1.
        ///             <code>RowIndex</code> isn't returned by <code>DetectDocumentText</code> and
        ///             <code>GetDocumentTextDetection</code>.</p>
        public let rowIndex: Swift.Int?
        /// <p>The number of rows that a table cell spans. Currently this value is always 1, even
        ///          if the number of rows spanned is greater than 1. <code>RowSpan</code> isn't returned by
        ///             <code>DetectDocumentText</code> and <code>GetDocumentTextDetection</code>.</p>
        public let rowSpan: Swift.Int?
        /// <p>The selection status of a selection element, such as an option button or check box. </p>
        public let selectionStatus: TextractClientTypes.SelectionStatus?
        /// <p>The word or line of text that's recognized by Amazon Textract. </p>
        public let text: Swift.String?
        /// <p>The kind of text that Amazon Textract has detected. Can check for handwritten text and printed text.</p>
        public let textType: TextractClientTypes.TextType?

        public init (
            blockType: TextractClientTypes.BlockType? = nil,
            columnIndex: Swift.Int? = nil,
            columnSpan: Swift.Int? = nil,
            confidence: Swift.Float? = nil,
            entityTypes: [TextractClientTypes.EntityType]? = nil,
            geometry: TextractClientTypes.Geometry? = nil,
            id: Swift.String? = nil,
            page: Swift.Int? = nil,
            relationships: [TextractClientTypes.Relationship]? = nil,
            rowIndex: Swift.Int? = nil,
            rowSpan: Swift.Int? = nil,
            selectionStatus: TextractClientTypes.SelectionStatus? = nil,
            text: Swift.String? = nil,
            textType: TextractClientTypes.TextType? = nil
        )
        {
            self.blockType = blockType
            self.columnIndex = columnIndex
            self.columnSpan = columnSpan
            self.confidence = confidence
            self.entityTypes = entityTypes
            self.geometry = geometry
            self.id = id
            self.page = page
            self.relationships = relationships
            self.rowIndex = rowIndex
            self.rowSpan = rowSpan
            self.selectionStatus = selectionStatus
            self.text = text
            self.textType = textType
        }
    }

}

extension TextractClientTypes {
    public enum BlockType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cell
        case keyValueSet
        case line
        case page
        case selectionElement
        case table
        case word
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockType] {
            return [
                .cell,
                .keyValueSet,
                .line,
                .page,
                .selectionElement,
                .table,
                .word,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cell: return "CELL"
            case .keyValueSet: return "KEY_VALUE_SET"
            case .line: return "LINE"
            case .page: return "PAGE"
            case .selectionElement: return "SELECTION_ELEMENT"
            case .table: return "TABLE"
            case .word: return "WORD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockType(rawValue: rawValue) ?? BlockType.sdkUnknown(rawValue)
        }
    }
}

extension TextractClientTypes.BoundingBox: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height = "Height"
        case `left` = "Left"
        case top = "Top"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if height != 0.0 {
            try encodeContainer.encode(height, forKey: .height)
        }
        if `left` != 0.0 {
            try encodeContainer.encode(`left`, forKey: .`left`)
        }
        if top != 0.0 {
            try encodeContainer.encode(top, forKey: .top)
        }
        if width != 0.0 {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decode(Swift.Float.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decode(Swift.Float.self, forKey: .height)
        height = heightDecoded
        let leftDecoded = try containerValues.decode(Swift.Float.self, forKey: .left)
        `left` = leftDecoded
        let topDecoded = try containerValues.decode(Swift.Float.self, forKey: .top)
        top = topDecoded
    }
}

extension TextractClientTypes.BoundingBox: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BoundingBox(height: \(Swift.String(describing: height)), left: \(Swift.String(describing: `left`)), top: \(Swift.String(describing: top)), width: \(Swift.String(describing: width)))"}
}

extension TextractClientTypes {
    /// <p>The bounding box around the detected page, text, key-value pair, table, table cell, or selection element on a
    ///          document page. The <code>left</code> (x-coordinate) and <code>top</code> (y-coordinate) are
    ///          coordinates that represent the top and left sides of the bounding box. Note that the
    ///          upper-left corner of the image is the origin (0,0). </p>
    ///          <p>The <code>top</code> and <code>left</code> values returned are ratios of the overall
    ///          document page size. For example, if the input image is 700 x 200 pixels, and the top-left
    ///          coordinate of the bounding box is 350 x 50 pixels, the API returns a <code>left</code>
    ///          value of 0.5 (350/700) and a <code>top</code> value of 0.25 (50/200).</p>
    ///          <p>The <code>width</code> and <code>height</code> values represent the dimensions of the
    ///          bounding box as a ratio of the overall document page dimension. For example, if the
    ///          document page size is 700 x 200 pixels, and the bounding box width is 70 pixels, the width
    ///          returned is 0.1. </p>
    public struct BoundingBox: Swift.Equatable {
        /// <p>The left coordinate of the bounding box as a ratio of overall document page
        ///          width.</p>
        public let `left`: Swift.Float
        /// <p>The height of the bounding box as a ratio of the overall document page
        ///          height.</p>
        public let height: Swift.Float
        /// <p>The top coordinate of the bounding box as a ratio of overall document page
        ///          height.</p>
        public let top: Swift.Float
        /// <p>The width of the bounding box as a ratio of the overall document page
        ///          width.</p>
        public let width: Swift.Float

        public init (
            `left`: Swift.Float = 0.0,
            height: Swift.Float = 0.0,
            top: Swift.Float = 0.0,
            width: Swift.Float = 0.0
        )
        {
            self.`left` = `left`
            self.height = height
            self.top = top
            self.width = width
        }
    }

}

extension TextractClientTypes {
    public enum ContentClassifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case freeOfAdultContent
        case freeOfPersonallyIdentifiableInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentClassifier] {
            return [
                .freeOfAdultContent,
                .freeOfPersonallyIdentifiableInformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .freeOfAdultContent: return "FreeOfAdultContent"
            case .freeOfPersonallyIdentifiableInformation: return "FreeOfPersonallyIdentifiableInformation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentClassifier(rawValue: rawValue) ?? ContentClassifier.sdkUnknown(rawValue)
        }
    }
}

public struct DetectDocumentTextInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectDocumentTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectDocumentTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectDocumentTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectDocumentTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectDocumentTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectDocumentTextOutputError>
}

extension DetectDocumentTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectDocumentTextInput(document: \(Swift.String(describing: document)))"}
}

extension DetectDocumentTextInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
    }
}

public struct DetectDocumentTextInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectDocumentTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectDocumentTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectDocumentTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectDocumentTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectDocumentTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectDocumentTextOutputError>
}

public struct DetectDocumentTextInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectDocumentTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectDocumentTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectDocumentTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectDocumentTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectDocumentTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectDocumentTextOutputError>
}

public struct DetectDocumentTextInput: Swift.Equatable {
    /// <p>The input document as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
    ///          to call Amazon Textract operations, you can't pass image bytes. The document must be an image
    ///       in JPEG or PNG format.</p>
    ///          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
    ///          image bytes that are passed using the <code>Bytes</code> field. </p>
    public let document: TextractClientTypes.Document?

    public init (
        document: TextractClientTypes.Document? = nil
    )
    {
        self.document = document
    }
}

struct DetectDocumentTextInputBody: Swift.Equatable {
    public let document: TextractClientTypes.Document?
}

extension DetectDocumentTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(TextractClientTypes.Document.self, forKey: .document)
        document = documentDecoded
    }
}

extension DetectDocumentTextOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectDocumentTextOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectDocumentTextOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case internalServerError(InternalServerError)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectDocumentTextOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectDocumentTextOutputResponse(blocks: \(Swift.String(describing: blocks)), detectDocumentTextModelVersion: \(Swift.String(describing: detectDocumentTextModelVersion)), documentMetadata: \(Swift.String(describing: documentMetadata)))"}
}

extension DetectDocumentTextOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectDocumentTextOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blocks = output.blocks
            self.detectDocumentTextModelVersion = output.detectDocumentTextModelVersion
            self.documentMetadata = output.documentMetadata
        } else {
            self.blocks = nil
            self.detectDocumentTextModelVersion = nil
            self.documentMetadata = nil
        }
    }
}

public struct DetectDocumentTextOutputResponse: Swift.Equatable {
    /// <p>An array of <code>Block</code> objects that contain the text that's detected in the
    ///          document.</p>
    public let blocks: [TextractClientTypes.Block]?
    /// <p></p>
    public let detectDocumentTextModelVersion: Swift.String?
    /// <p>Metadata about the document. It contains the number of pages that are detected in the
    ///          document.</p>
    public let documentMetadata: TextractClientTypes.DocumentMetadata?

    public init (
        blocks: [TextractClientTypes.Block]? = nil,
        detectDocumentTextModelVersion: Swift.String? = nil,
        documentMetadata: TextractClientTypes.DocumentMetadata? = nil
    )
    {
        self.blocks = blocks
        self.detectDocumentTextModelVersion = detectDocumentTextModelVersion
        self.documentMetadata = documentMetadata
    }
}

struct DetectDocumentTextOutputResponseBody: Swift.Equatable {
    public let documentMetadata: TextractClientTypes.DocumentMetadata?
    public let blocks: [TextractClientTypes.Block]?
    public let detectDocumentTextModelVersion: Swift.String?
}

extension DetectDocumentTextOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocks = "Blocks"
        case detectDocumentTextModelVersion = "DetectDocumentTextModelVersion"
        case documentMetadata = "DocumentMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(TextractClientTypes.DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let blocksContainer = try containerValues.decodeIfPresent([TextractClientTypes.Block?].self, forKey: .blocks)
        var blocksDecoded0:[TextractClientTypes.Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [TextractClientTypes.Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let detectDocumentTextModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectDocumentTextModelVersion)
        detectDocumentTextModelVersion = detectDocumentTextModelVersionDecoded
    }
}

extension TextractClientTypes.Document: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes = "Bytes"
        case s3Object = "S3Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytes = bytes {
            try encodeContainer.encode(bytes.base64EncodedString(), forKey: .bytes)
        }
        if let s3Object = s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .bytes)
        bytes = bytesDecoded
        let s3ObjectDecoded = try containerValues.decodeIfPresent(TextractClientTypes.S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension TextractClientTypes.Document: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Document(bytes: \(Swift.String(describing: bytes)), s3Object: \(Swift.String(describing: s3Object)))"}
}

extension TextractClientTypes {
    /// <p>The input document, either as bytes or as an S3 object.</p>
    ///          <p>You pass image bytes to an Amazon Textract API operation by using the <code>Bytes</code>
    ///          property. For example, you would use the <code>Bytes</code> property to pass a document
    ///          loaded from a local file system. Image bytes passed by using the <code>Bytes</code>
    ///          property must be base64 encoded. Your code might not need to encode document file bytes if
    ///          you're using an AWS SDK to call Amazon Textract API operations. </p>
    ///          <p>You pass images stored in an S3 bucket to an Amazon Textract API operation by using the
    ///             <code>S3Object</code> property. Documents stored in an S3 bucket don't need to be base64
    ///          encoded.</p>
    ///          <p>The AWS Region for the S3 bucket that contains the S3 object must match the AWS
    ///          Region that you use for Amazon Textract operations.</p>
    ///          <p>If you use the AWS CLI to call Amazon Textract operations, passing image bytes using
    ///          the Bytes property isn't supported. You must first upload the document to an Amazon S3
    ///          bucket, and then call the operation using the S3Object property.</p>
    ///
    ///          <p>For Amazon Textract to process an S3 object, the user must have permission
    ///          to access the S3 object. </p>
    public struct Document: Swift.Equatable {
        /// <p>A blob of base64-encoded document bytes. The maximum size of a document that's provided
        ///          in a blob of bytes is 5 MB. The document bytes must be in PNG or JPEG format.</p>
        ///          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
        ///          image bytes passed using the <code>Bytes</code> field. </p>
        public let bytes: ClientRuntime.Data?
        /// <p>Identifies an S3 object as the document source. The maximum size of a document that's
        ///          stored in an S3 bucket is 5 MB.</p>
        public let s3Object: TextractClientTypes.S3Object?

        public init (
            bytes: ClientRuntime.Data? = nil,
            s3Object: TextractClientTypes.S3Object? = nil
        )
        {
            self.bytes = bytes
            self.s3Object = s3Object
        }
    }

}

extension TextractClientTypes.DocumentLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Object = "S3Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Object = s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(TextractClientTypes.S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension TextractClientTypes.DocumentLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentLocation(s3Object: \(Swift.String(describing: s3Object)))"}
}

extension TextractClientTypes {
    /// <p>The Amazon S3 bucket that contains the document to be processed. It's used by asynchronous
    ///          operations such as <a>StartDocumentTextDetection</a>.</p>
    ///          <p>The input document can be an image file in JPEG or PNG format. It can also be a file in
    ///          PDF format.</p>
    public struct DocumentLocation: Swift.Equatable {
        /// <p>The Amazon S3 bucket that contains the input document.</p>
        public let s3Object: TextractClientTypes.S3Object?

        public init (
            s3Object: TextractClientTypes.S3Object? = nil
        )
        {
            self.s3Object = s3Object
        }
    }

}

extension TextractClientTypes.DocumentMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pages = "Pages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pages = pages {
            try encodeContainer.encode(pages, forKey: .pages)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pagesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pages)
        pages = pagesDecoded
    }
}

extension TextractClientTypes.DocumentMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentMetadata(pages: \(Swift.String(describing: pages)))"}
}

extension TextractClientTypes {
    /// <p>Information about the input document.</p>
    public struct DocumentMetadata: Swift.Equatable {
        /// <p>The number of pages that are detected in the document.</p>
        public let pages: Swift.Int?

        public init (
            pages: Swift.Int? = nil
        )
        {
            self.pages = pages
        }
    }

}

extension DocumentTooLargeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentTooLargeException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension DocumentTooLargeException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The document can't be processed because it's too large. The maximum document size for
///          synchronous operations 10 MB. The maximum document size for asynchronous operations is 500
///          MB for PDF files.</p>
public struct DocumentTooLargeException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct DocumentTooLargeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension DocumentTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TextractClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case key
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .key,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .key: return "KEY"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension TextractClientTypes {
    public enum FeatureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forms
        case tables
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureType] {
            return [
                .forms,
                .tables,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forms: return "FORMS"
            case .tables: return "TABLES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureType(rawValue: rawValue) ?? FeatureType.sdkUnknown(rawValue)
        }
    }
}

extension TextractClientTypes.Geometry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case boundingBox = "BoundingBox"
        case polygon = "Polygon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let boundingBox = boundingBox {
            try encodeContainer.encode(boundingBox, forKey: .boundingBox)
        }
        if let polygon = polygon {
            var polygonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .polygon)
            for polygon0 in polygon {
                try polygonContainer.encode(polygon0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let boundingBoxDecoded = try containerValues.decodeIfPresent(TextractClientTypes.BoundingBox.self, forKey: .boundingBox)
        boundingBox = boundingBoxDecoded
        let polygonContainer = try containerValues.decodeIfPresent([TextractClientTypes.Point?].self, forKey: .polygon)
        var polygonDecoded0:[TextractClientTypes.Point]? = nil
        if let polygonContainer = polygonContainer {
            polygonDecoded0 = [TextractClientTypes.Point]()
            for structure0 in polygonContainer {
                if let structure0 = structure0 {
                    polygonDecoded0?.append(structure0)
                }
            }
        }
        polygon = polygonDecoded0
    }
}

extension TextractClientTypes.Geometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Geometry(boundingBox: \(Swift.String(describing: boundingBox)), polygon: \(Swift.String(describing: polygon)))"}
}

extension TextractClientTypes {
    /// <p>Information about where the following items are located on a document page: detected
    ///          page, text, key-value pairs, tables, table cells, and selection elements.</p>
    public struct Geometry: Swift.Equatable {
        /// <p>An axis-aligned coarse representation of the location of the recognized item on the
        ///          document page.</p>
        public let boundingBox: TextractClientTypes.BoundingBox?
        /// <p>Within the bounding box, a fine-grained polygon around the recognized item.</p>
        public let polygon: [TextractClientTypes.Point]?

        public init (
            boundingBox: TextractClientTypes.BoundingBox? = nil,
            polygon: [TextractClientTypes.Point]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.polygon = polygon
        }
    }

}

public struct GetDocumentAnalysisInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentAnalysisOutputError>
}

extension GetDocumentAnalysisInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentAnalysisInput(jobId: \(Swift.String(describing: jobId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDocumentAnalysisInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetDocumentAnalysisInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentAnalysisOutputError>
}

public struct GetDocumentAnalysisInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentAnalysisOutputError>
}

public struct GetDocumentAnalysisInput: Swift.Equatable {
    /// <p>A unique identifier for the text-detection job. The <code>JobId</code> is returned from
    ///          <code>StartDocumentAnalysis</code>. A <code>JobId</code> value is only valid for 7 days.</p>
    public let jobId: Swift.String?
    /// <p>The maximum number of results to return per paginated call. The largest value that you
    ///          can specify is 1,000. If you specify a value greater than 1,000, a maximum of 1,000 results
    ///          is returned. The default value is 1,000.</p>
    public let maxResults: Swift.Int?
    /// <p>If the previous response was incomplete (because there are more blocks to retrieve), Amazon Textract returns a pagination
    ///          token in the response. You can use this pagination token to retrieve the next set of blocks.</p>
    public let nextToken: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDocumentAnalysisInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension GetDocumentAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDocumentAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobIdException" : self = .invalidJobIdException(try InvalidJobIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidJobIdException(InvalidJobIdException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentAnalysisOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentAnalysisOutputResponse(analyzeDocumentModelVersion: \(Swift.String(describing: analyzeDocumentModelVersion)), blocks: \(Swift.String(describing: blocks)), documentMetadata: \(Swift.String(describing: documentMetadata)), jobStatus: \(Swift.String(describing: jobStatus)), nextToken: \(Swift.String(describing: nextToken)), statusMessage: \(Swift.String(describing: statusMessage)), warnings: \(Swift.String(describing: warnings)))"}
}

extension GetDocumentAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzeDocumentModelVersion = output.analyzeDocumentModelVersion
            self.blocks = output.blocks
            self.documentMetadata = output.documentMetadata
            self.jobStatus = output.jobStatus
            self.nextToken = output.nextToken
            self.statusMessage = output.statusMessage
            self.warnings = output.warnings
        } else {
            self.analyzeDocumentModelVersion = nil
            self.blocks = nil
            self.documentMetadata = nil
            self.jobStatus = nil
            self.nextToken = nil
            self.statusMessage = nil
            self.warnings = nil
        }
    }
}

public struct GetDocumentAnalysisOutputResponse: Swift.Equatable {
    /// <p></p>
    public let analyzeDocumentModelVersion: Swift.String?
    /// <p>The results of the text-analysis operation.</p>
    public let blocks: [TextractClientTypes.Block]?
    /// <p>Information about a document that Amazon Textract processed. <code>DocumentMetadata</code> is
    ///          returned in every page of paginated responses from an Amazon Textract video operation.</p>
    public let documentMetadata: TextractClientTypes.DocumentMetadata?
    /// <p>The current status of the text detection job.</p>
    public let jobStatus: TextractClientTypes.JobStatus?
    /// <p>If the response is truncated, Amazon Textract returns this token. You can use this token in
    ///          the subsequent request to retrieve the next set of text detection results.</p>
    public let nextToken: Swift.String?
    /// <p>Returns if the detection job could not be completed. Contains explanation for what error occured.</p>
    public let statusMessage: Swift.String?
    /// <p>A list of warnings that occurred during the document-analysis operation.</p>
    public let warnings: [TextractClientTypes.Warning]?

    public init (
        analyzeDocumentModelVersion: Swift.String? = nil,
        blocks: [TextractClientTypes.Block]? = nil,
        documentMetadata: TextractClientTypes.DocumentMetadata? = nil,
        jobStatus: TextractClientTypes.JobStatus? = nil,
        nextToken: Swift.String? = nil,
        statusMessage: Swift.String? = nil,
        warnings: [TextractClientTypes.Warning]? = nil
    )
    {
        self.analyzeDocumentModelVersion = analyzeDocumentModelVersion
        self.blocks = blocks
        self.documentMetadata = documentMetadata
        self.jobStatus = jobStatus
        self.nextToken = nextToken
        self.statusMessage = statusMessage
        self.warnings = warnings
    }
}

struct GetDocumentAnalysisOutputResponseBody: Swift.Equatable {
    public let documentMetadata: TextractClientTypes.DocumentMetadata?
    public let jobStatus: TextractClientTypes.JobStatus?
    public let nextToken: Swift.String?
    public let blocks: [TextractClientTypes.Block]?
    public let warnings: [TextractClientTypes.Warning]?
    public let statusMessage: Swift.String?
    public let analyzeDocumentModelVersion: Swift.String?
}

extension GetDocumentAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzeDocumentModelVersion = "AnalyzeDocumentModelVersion"
        case blocks = "Blocks"
        case documentMetadata = "DocumentMetadata"
        case jobStatus = "JobStatus"
        case nextToken = "NextToken"
        case statusMessage = "StatusMessage"
        case warnings = "Warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(TextractClientTypes.DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(TextractClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let blocksContainer = try containerValues.decodeIfPresent([TextractClientTypes.Block?].self, forKey: .blocks)
        var blocksDecoded0:[TextractClientTypes.Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [TextractClientTypes.Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([TextractClientTypes.Warning?].self, forKey: .warnings)
        var warningsDecoded0:[TextractClientTypes.Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [TextractClientTypes.Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let analyzeDocumentModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzeDocumentModelVersion)
        analyzeDocumentModelVersion = analyzeDocumentModelVersionDecoded
    }
}

public struct GetDocumentTextDetectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentTextDetectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentTextDetectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentTextDetectionOutputError>
}

extension GetDocumentTextDetectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentTextDetectionInput(jobId: \(Swift.String(describing: jobId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDocumentTextDetectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetDocumentTextDetectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentTextDetectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentTextDetectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentTextDetectionOutputError>
}

public struct GetDocumentTextDetectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentTextDetectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentTextDetectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentTextDetectionOutputError>
}

public struct GetDocumentTextDetectionInput: Swift.Equatable {
    /// <p>A unique identifier for the text detection job. The <code>JobId</code> is returned from
    ///          <code>StartDocumentTextDetection</code>. A <code>JobId</code> value is only valid for 7 days.</p>
    public let jobId: Swift.String?
    /// <p>The maximum number of results to return per paginated call. The largest value you can
    ///          specify is 1,000. If you specify a value greater than 1,000, a maximum of 1,000 results is
    ///          returned. The default value is 1,000.</p>
    public let maxResults: Swift.Int?
    /// <p>If the previous response was incomplete (because there are more blocks to retrieve), Amazon Textract returns a pagination
    ///          token in the response. You can use this pagination token to retrieve the next set of blocks.</p>
    public let nextToken: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDocumentTextDetectionInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension GetDocumentTextDetectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDocumentTextDetectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentTextDetectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobIdException" : self = .invalidJobIdException(try InvalidJobIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentTextDetectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidJobIdException(InvalidJobIdException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentTextDetectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentTextDetectionOutputResponse(blocks: \(Swift.String(describing: blocks)), detectDocumentTextModelVersion: \(Swift.String(describing: detectDocumentTextModelVersion)), documentMetadata: \(Swift.String(describing: documentMetadata)), jobStatus: \(Swift.String(describing: jobStatus)), nextToken: \(Swift.String(describing: nextToken)), statusMessage: \(Swift.String(describing: statusMessage)), warnings: \(Swift.String(describing: warnings)))"}
}

extension GetDocumentTextDetectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentTextDetectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blocks = output.blocks
            self.detectDocumentTextModelVersion = output.detectDocumentTextModelVersion
            self.documentMetadata = output.documentMetadata
            self.jobStatus = output.jobStatus
            self.nextToken = output.nextToken
            self.statusMessage = output.statusMessage
            self.warnings = output.warnings
        } else {
            self.blocks = nil
            self.detectDocumentTextModelVersion = nil
            self.documentMetadata = nil
            self.jobStatus = nil
            self.nextToken = nil
            self.statusMessage = nil
            self.warnings = nil
        }
    }
}

public struct GetDocumentTextDetectionOutputResponse: Swift.Equatable {
    /// <p>The results of the text-detection operation.</p>
    public let blocks: [TextractClientTypes.Block]?
    /// <p></p>
    public let detectDocumentTextModelVersion: Swift.String?
    /// <p>Information about a document that Amazon Textract processed. <code>DocumentMetadata</code> is
    ///          returned in every page of paginated responses from an Amazon Textract video operation.</p>
    public let documentMetadata: TextractClientTypes.DocumentMetadata?
    /// <p>The current status of the text detection job.</p>
    public let jobStatus: TextractClientTypes.JobStatus?
    /// <p>If the response is truncated, Amazon Textract returns this token. You can use this token in
    ///          the subsequent request to retrieve the next set of text-detection results.</p>
    public let nextToken: Swift.String?
    /// <p>Returns if the detection job could not be completed. Contains explanation for what error occured. </p>
    public let statusMessage: Swift.String?
    /// <p>A list of warnings that occurred during the text-detection operation for the
    ///          document.</p>
    public let warnings: [TextractClientTypes.Warning]?

    public init (
        blocks: [TextractClientTypes.Block]? = nil,
        detectDocumentTextModelVersion: Swift.String? = nil,
        documentMetadata: TextractClientTypes.DocumentMetadata? = nil,
        jobStatus: TextractClientTypes.JobStatus? = nil,
        nextToken: Swift.String? = nil,
        statusMessage: Swift.String? = nil,
        warnings: [TextractClientTypes.Warning]? = nil
    )
    {
        self.blocks = blocks
        self.detectDocumentTextModelVersion = detectDocumentTextModelVersion
        self.documentMetadata = documentMetadata
        self.jobStatus = jobStatus
        self.nextToken = nextToken
        self.statusMessage = statusMessage
        self.warnings = warnings
    }
}

struct GetDocumentTextDetectionOutputResponseBody: Swift.Equatable {
    public let documentMetadata: TextractClientTypes.DocumentMetadata?
    public let jobStatus: TextractClientTypes.JobStatus?
    public let nextToken: Swift.String?
    public let blocks: [TextractClientTypes.Block]?
    public let warnings: [TextractClientTypes.Warning]?
    public let statusMessage: Swift.String?
    public let detectDocumentTextModelVersion: Swift.String?
}

extension GetDocumentTextDetectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocks = "Blocks"
        case detectDocumentTextModelVersion = "DetectDocumentTextModelVersion"
        case documentMetadata = "DocumentMetadata"
        case jobStatus = "JobStatus"
        case nextToken = "NextToken"
        case statusMessage = "StatusMessage"
        case warnings = "Warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(TextractClientTypes.DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(TextractClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let blocksContainer = try containerValues.decodeIfPresent([TextractClientTypes.Block?].self, forKey: .blocks)
        var blocksDecoded0:[TextractClientTypes.Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [TextractClientTypes.Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([TextractClientTypes.Warning?].self, forKey: .warnings)
        var warningsDecoded0:[TextractClientTypes.Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [TextractClientTypes.Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let detectDocumentTextModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectDocumentTextModelVersion)
        detectDocumentTextModelVersion = detectDocumentTextModelVersionDecoded
    }
}

extension TextractClientTypes.HumanLoopActivationOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopActivationConditionsEvaluationResults = "HumanLoopActivationConditionsEvaluationResults"
        case humanLoopActivationReasons = "HumanLoopActivationReasons"
        case humanLoopArn = "HumanLoopArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let humanLoopActivationConditionsEvaluationResults = humanLoopActivationConditionsEvaluationResults {
            try encodeContainer.encode(humanLoopActivationConditionsEvaluationResults, forKey: .humanLoopActivationConditionsEvaluationResults)
        }
        if let humanLoopActivationReasons = humanLoopActivationReasons {
            var humanLoopActivationReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .humanLoopActivationReasons)
            for humanloopactivationreasons0 in humanLoopActivationReasons {
                try humanLoopActivationReasonsContainer.encode(humanloopactivationreasons0)
            }
        }
        if let humanLoopArn = humanLoopArn {
            try encodeContainer.encode(humanLoopArn, forKey: .humanLoopArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
        let humanLoopActivationReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .humanLoopActivationReasons)
        var humanLoopActivationReasonsDecoded0:[Swift.String]? = nil
        if let humanLoopActivationReasonsContainer = humanLoopActivationReasonsContainer {
            humanLoopActivationReasonsDecoded0 = [Swift.String]()
            for string0 in humanLoopActivationReasonsContainer {
                if let string0 = string0 {
                    humanLoopActivationReasonsDecoded0?.append(string0)
                }
            }
        }
        humanLoopActivationReasons = humanLoopActivationReasonsDecoded0
        let humanLoopActivationConditionsEvaluationResultsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopActivationConditionsEvaluationResults)
        humanLoopActivationConditionsEvaluationResults = humanLoopActivationConditionsEvaluationResultsDecoded
    }
}

extension TextractClientTypes.HumanLoopActivationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopActivationOutput(humanLoopActivationConditionsEvaluationResults: \(Swift.String(describing: humanLoopActivationConditionsEvaluationResults)), humanLoopActivationReasons: \(Swift.String(describing: humanLoopActivationReasons)), humanLoopArn: \(Swift.String(describing: humanLoopArn)))"}
}

extension TextractClientTypes {
    /// <p>Shows the results of the human in the loop evaluation. If there is no HumanLoopArn, the input
    ///          did not trigger human review.</p>
    public struct HumanLoopActivationOutput: Swift.Equatable {
        /// <p>Shows the result of condition evaluations, including those conditions which activated a human review.</p>
        public let humanLoopActivationConditionsEvaluationResults: Swift.String?
        /// <p>Shows if and why human review was needed.</p>
        public let humanLoopActivationReasons: [Swift.String]?
        /// <p>The Amazon Resource Name (ARN) of the HumanLoop created.</p>
        public let humanLoopArn: Swift.String?

        public init (
            humanLoopActivationConditionsEvaluationResults: Swift.String? = nil,
            humanLoopActivationReasons: [Swift.String]? = nil,
            humanLoopArn: Swift.String? = nil
        )
        {
            self.humanLoopActivationConditionsEvaluationResults = humanLoopActivationConditionsEvaluationResults
            self.humanLoopActivationReasons = humanLoopActivationReasons
            self.humanLoopArn = humanLoopArn
        }
    }

}

extension TextractClientTypes.HumanLoopConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAttributes = dataAttributes {
            try encodeContainer.encode(dataAttributes, forKey: .dataAttributes)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let dataAttributesDecoded = try containerValues.decodeIfPresent(TextractClientTypes.HumanLoopDataAttributes.self, forKey: .dataAttributes)
        dataAttributes = dataAttributesDecoded
    }
}

extension TextractClientTypes.HumanLoopConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopConfig(dataAttributes: \(Swift.String(describing: dataAttributes)), flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), humanLoopName: \(Swift.String(describing: humanLoopName)))"}
}

extension TextractClientTypes {
    /// <p>Sets up the human review workflow the document will be sent to if one of the conditions is met. You can also set certain attributes
    ///          of the image before review. </p>
    public struct HumanLoopConfig: Swift.Equatable {
        /// <p>Sets attributes of the input data.</p>
        public let dataAttributes: TextractClientTypes.HumanLoopDataAttributes?
        /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
        public let flowDefinitionArn: Swift.String?
        /// <p>The name of the human workflow used for this image. This should be kept unique within a region.</p>
        public let humanLoopName: Swift.String?

        public init (
            dataAttributes: TextractClientTypes.HumanLoopDataAttributes? = nil,
            flowDefinitionArn: Swift.String? = nil,
            humanLoopName: Swift.String? = nil
        )
        {
            self.dataAttributes = dataAttributes
            self.flowDefinitionArn = flowDefinitionArn
            self.humanLoopName = humanLoopName
        }
    }

}

extension TextractClientTypes.HumanLoopDataAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentClassifiers = "ContentClassifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentClassifiers = contentClassifiers {
            var contentClassifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentClassifiers)
            for contentclassifiers0 in contentClassifiers {
                try contentClassifiersContainer.encode(contentclassifiers0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentClassifiersContainer = try containerValues.decodeIfPresent([TextractClientTypes.ContentClassifier?].self, forKey: .contentClassifiers)
        var contentClassifiersDecoded0:[TextractClientTypes.ContentClassifier]? = nil
        if let contentClassifiersContainer = contentClassifiersContainer {
            contentClassifiersDecoded0 = [TextractClientTypes.ContentClassifier]()
            for string0 in contentClassifiersContainer {
                if let string0 = string0 {
                    contentClassifiersDecoded0?.append(string0)
                }
            }
        }
        contentClassifiers = contentClassifiersDecoded0
    }
}

extension TextractClientTypes.HumanLoopDataAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopDataAttributes(contentClassifiers: \(Swift.String(describing: contentClassifiers)))"}
}

extension TextractClientTypes {
    /// <p>Allows you to set attributes of the image. Currently, you can declare an image as free of
    ///          personally identifiable information and adult content. </p>
    public struct HumanLoopDataAttributes: Swift.Equatable {
        /// <p>Sets whether the input image is free of personally identifiable information or adult content.</p>
        public let contentClassifiers: [TextractClientTypes.ContentClassifier]?

        public init (
            contentClassifiers: [TextractClientTypes.ContentClassifier]? = nil
        )
        {
            self.contentClassifiers = contentClassifiers
        }
    }

}

extension HumanLoopQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanLoopQuotaExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension HumanLoopQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: HumanLoopQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.code = nil
            self.message = nil
            self.quotaCode = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates you have exceeded the maximum number of active human in the loop workflows available</p>
public struct HumanLoopQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// <p>The quota code.</p>
    public var quotaCode: Swift.String?
    /// <p>The resource type.</p>
    public var resourceType: Swift.String?
    /// <p>The service code.</p>
    public var serviceCode: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.quotaCode = quotaCode
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct HumanLoopQuotaExceededExceptionBody: Swift.Equatable {
    public let resourceType: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
    public let message: Swift.String?
    public let code: Swift.String?
}

extension HumanLoopQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension IdempotentParameterMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdempotentParameterMismatchException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at
///          least one of the other input parameters is different from the previous call to the
///          operation. </p>
public struct IdempotentParameterMismatchException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract experienced a service issue. Try your call again.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidJobIdException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidJobIdException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidJobIdException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidJobIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid job identifier was passed to <a>GetDocumentAnalysis</a> or to
///       <a>GetDocumentAnalysis</a>.</p>
public struct InvalidJobIdException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidJobIdExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension InvalidJobIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidKMSKeyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidKMSKeyException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidKMSKeyException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidKMSKeyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Indicates you do not have decrypt permissions with the KMS key entered, or the KMS key
///         was entered incorrectly. </p>
public struct InvalidKMSKeyException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidKMSKeyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension InvalidKMSKeyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An input parameter violated a constraint. For example, in synchronous operations,
///        an <code>InvalidParameterException</code> exception occurs
///       when neither of the <code>S3Object</code> or <code>Bytes</code> values are supplied in the <code>Document</code>
///       request parameter.
///        Validate your parameter before calling the API operation again.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidS3ObjectException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidS3ObjectException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidS3ObjectException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidS3ObjectExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract is unable to access the S3 object that's specified in the request.
///          for more information, <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html">Configure Access to Amazon S3</a>
///          For troubleshooting information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/troubleshooting.html">Troubleshooting Amazon S3</a>
///          </p>
public struct InvalidS3ObjectException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidS3ObjectExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension InvalidS3ObjectExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TextractClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case partialSuccess
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .failed,
                .inProgress,
                .partialSuccess,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Textract service limit was exceeded. For example, if you start too many
///          asynchronous jobs concurrently, calls to start operations
///             (<code>StartDocumentTextDetection</code>, for example) raise a LimitExceededException
///          exception (HTTP status code: 400) until the number of concurrently running jobs is below
///          the Amazon Textract service limit. </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TextractClientTypes.NotificationChannel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case sNSTopicArn = "SNSTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sNSTopicArn = sNSTopicArn {
            try encodeContainer.encode(sNSTopicArn, forKey: .sNSTopicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNSTopicArn)
        sNSTopicArn = sNSTopicArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension TextractClientTypes.NotificationChannel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationChannel(roleArn: \(Swift.String(describing: roleArn)), sNSTopicArn: \(Swift.String(describing: sNSTopicArn)))"}
}

extension TextractClientTypes {
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic to which Amazon Textract publishes the completion status of
    ///          an asynchronous document operation, such as <a>StartDocumentTextDetection</a>. </p>
    public struct NotificationChannel: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of an IAM role that gives Amazon Textract publishing permissions to the Amazon SNS topic. </p>
        public let roleArn: Swift.String?
        /// <p>The Amazon SNS topic that Amazon Textract posts the completion status to.</p>
        public let sNSTopicArn: Swift.String?

        public init (
            roleArn: Swift.String? = nil,
            sNSTopicArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.sNSTopicArn = sNSTopicArn
        }
    }

}

extension TextractClientTypes.OutputConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension TextractClientTypes.OutputConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputConfig(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Prefix: \(Swift.String(describing: s3Prefix)))"}
}

extension TextractClientTypes {
    /// <p>Sets whether or not your output will go to a user created bucket.
    ///          Used to set the name of the bucket, and the prefix on the output
    ///          file.</p>
    public struct OutputConfig: Swift.Equatable {
        /// <p>The name of the bucket your output will go to.</p>
        public let s3Bucket: Swift.String?
        /// <p>The prefix of the object key that the output will be saved to. When
        ///          not enabled, the prefix will be textract_output".</p>
        public let s3Prefix: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }

}

extension TextractClientTypes.Point: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case x = "X"
        case y = "Y"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if x != 0.0 {
            try encodeContainer.encode(x, forKey: .x)
        }
        if y != 0.0 {
            try encodeContainer.encode(y, forKey: .y)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xDecoded = try containerValues.decode(Swift.Float.self, forKey: .x)
        x = xDecoded
        let yDecoded = try containerValues.decode(Swift.Float.self, forKey: .y)
        y = yDecoded
    }
}

extension TextractClientTypes.Point: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Point(x: \(Swift.String(describing: x)), y: \(Swift.String(describing: y)))"}
}

extension TextractClientTypes {
    /// <p>The X and Y coordinates of a point on a document page. The X and Y
    ///          values that are returned are ratios of the overall document page size. For example, if the
    ///          input document is 700 x 200 and the operation returns X=0.5 and Y=0.25, then the point is
    ///          at the (350,50) pixel coordinate on the document page.</p>
    ///
    ///          <p>An array of <code>Point</code> objects, <code>Polygon</code>, is returned
    ///          by <a>DetectDocumentText</a>. <code>Polygon</code> represents a fine-grained
    ///          polygon around detected text. For more information, see Geometry in the Amazon Textract
    ///          Developer Guide. </p>
    public struct Point: Swift.Equatable {
        /// <p>The value of the X coordinate for a point on a <code>Polygon</code>.</p>
        public let x: Swift.Float
        /// <p>The value of the Y coordinate for a point on a <code>Polygon</code>.</p>
        public let y: Swift.Float

        public init (
            x: Swift.Float = 0.0,
            y: Swift.Float = 0.0
        )
        {
            self.x = x
            self.y = y
        }
    }

}

extension ProvisionedThroughputExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedThroughputExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ProvisionedThroughputExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of requests exceeded your throughput limit. If you want to increase this limit,
///          contact Amazon Textract.</p>
public struct ProvisionedThroughputExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ProvisionedThroughputExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension ProvisionedThroughputExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TextractClientTypes.Relationship: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids = "Ids"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for idlist0 in ids {
                try idsContainer.encode(idlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TextractClientTypes.RelationshipType.self, forKey: .type)
        type = typeDecoded
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension TextractClientTypes.Relationship: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Relationship(ids: \(Swift.String(describing: ids)), type: \(Swift.String(describing: type)))"}
}

extension TextractClientTypes {
    /// <p>Information about how blocks are related to each other. A <code>Block</code> object
    ///          contains 0 or more <code>Relation</code> objects in a list, <code>Relationships</code>. For
    ///          more information, see <a>Block</a>.</p>
    ///          <p>The <code>Type</code> element provides the type of the relationship for all blocks in
    ///          the <code>IDs</code> array. </p>
    public struct Relationship: Swift.Equatable {
        /// <p>An
        ///          array of IDs for related blocks. You can get the type of the relationship from the
        ///             <code>Type</code> element.</p>
        public let ids: [Swift.String]?
        /// <p>The type of relationship that the blocks in the IDs array have with the current block.
        ///          The relationship can be <code>VALUE</code> or <code>CHILD</code>. A relationship of type
        ///          VALUE is a list that contains the ID of the VALUE block that's associated with the KEY of a key-value pair.
        ///          A relationship of type CHILD is a list of IDs that identify WORD blocks in the case of lines
        ///          Cell blocks in the case of Tables, and WORD blocks in the case of Selection Elements.</p>
        public let type: TextractClientTypes.RelationshipType?

        public init (
            ids: [Swift.String]? = nil,
            type: TextractClientTypes.RelationshipType? = nil
        )
        {
            self.ids = ids
            self.type = type
        }
    }

}

extension TextractClientTypes {
    public enum RelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case child
        case complexFeatures
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipType] {
            return [
                .child,
                .complexFeatures,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .complexFeatures: return "COMPLEX_FEATURES"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipType(rawValue: rawValue) ?? RelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension TextractClientTypes.S3Object: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension TextractClientTypes.S3Object: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Object(bucket: \(Swift.String(describing: bucket)), name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension TextractClientTypes {
    /// <p>The S3 bucket name and file name that identifies the document.</p>
    ///          <p>The AWS Region for the S3 bucket that contains the document must match the Region that
    ///          you use for Amazon Textract operations.</p>
    ///
    ///          <p>For Amazon Textract to process a file in an S3 bucket, the user must have
    ///          permission to access the S3 bucket and file.
    ///
    ///       </p>
    public struct S3Object: Swift.Equatable {
        /// <p>The name of the S3 bucket.</p>
        public let bucket: Swift.String?
        /// <p>The file name of the input document. Synchronous operations can use image files that are
        ///          in JPEG or PNG format. Asynchronous operations also support PDF format files.</p>
        public let name: Swift.String?
        /// <p>If the bucket has versioning enabled, you can specify the object version. </p>
        public let version: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.name = name
            self.version = version
        }
    }

}

extension TextractClientTypes {
    public enum SelectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notSelected
        case selected
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectionStatus] {
            return [
                .notSelected,
                .selected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notSelected: return "NOT_SELECTED"
            case .selected: return "SELECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SelectionStatus(rawValue: rawValue) ?? SelectionStatus.sdkUnknown(rawValue)
        }
    }
}

public struct StartDocumentAnalysisInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDocumentAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDocumentAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDocumentAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDocumentAnalysisOutputError>
}

extension StartDocumentAnalysisInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDocumentAnalysisInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), documentLocation: \(Swift.String(describing: documentLocation)), featureTypes: \(Swift.String(describing: featureTypes)), jobTag: \(Swift.String(describing: jobTag)), kMSKeyId: \(Swift.String(describing: kMSKeyId)), notificationChannel: \(Swift.String(describing: notificationChannel)), outputConfig: \(Swift.String(describing: outputConfig)))"}
}

extension StartDocumentAnalysisInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case featureTypes = "FeatureTypes"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let documentLocation = documentLocation {
            try encodeContainer.encode(documentLocation, forKey: .documentLocation)
        }
        if let featureTypes = featureTypes {
            var featureTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featureTypes)
            for featuretypes0 in featureTypes {
                try featureTypesContainer.encode(featuretypes0.rawValue)
            }
        }
        if let jobTag = jobTag {
            try encodeContainer.encode(jobTag, forKey: .jobTag)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
        if let notificationChannel = notificationChannel {
            try encodeContainer.encode(notificationChannel, forKey: .notificationChannel)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

public struct StartDocumentAnalysisInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDocumentAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDocumentAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDocumentAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDocumentAnalysisOutputError>
}

public struct StartDocumentAnalysisInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDocumentAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDocumentAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDocumentAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDocumentAnalysisOutputError>
}

public struct StartDocumentAnalysisInput: Swift.Equatable {
    /// <p>The idempotent token that you use to identify the start request. If you use the same
    ///          token with multiple <code>StartDocumentAnalysis</code> requests, the same
    ///             <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same
    ///          job from being accidentally started more than once. For more information, see
    ///          <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a>.</p>
    public let clientRequestToken: Swift.String?
    /// <p>The location of the document to be processed.</p>
    public let documentLocation: TextractClientTypes.DocumentLocation?
    /// <p>A list of the types of analysis to perform. Add TABLES to the list to return information
    ///          about the tables that are detected in the input document. Add FORMS to return detected
    ///          form data. To perform both types of analysis, add TABLES
    ///          and FORMS to <code>FeatureTypes</code>. All lines and words detected in the document are
    ///          included in the response (including text that isn't related to the value of
    ///             <code>FeatureTypes</code>). </p>
    public let featureTypes: [TextractClientTypes.FeatureType]?
    /// <p>An identifier that you specify that's included in the completion notification published
    ///          to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of
    ///          document that the completion notification corresponds to (such as a tax form or a
    ///          receipt).</p>
    public let jobTag: Swift.String?
    /// <p>The KMS key used to encrypt the inference results. This can be
    ///          in either Key ID or Key Alias format. When a KMS key is provided, the
    ///          KMS key will be used for server-side encryption of the objects in the
    ///          customer bucket. When this parameter is not enabled, the result will
    ///          be encrypted server side,using SSE-S3.</p>
    public let kMSKeyId: Swift.String?
    /// <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the
    ///          operation to. </p>
    public let notificationChannel: TextractClientTypes.NotificationChannel?
    /// <p>Sets if the output will go to a customer defined bucket. By default, Amazon Textract will save
    ///          the results internally to be accessed by the GetDocumentAnalysis operation.</p>
    public let outputConfig: TextractClientTypes.OutputConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        documentLocation: TextractClientTypes.DocumentLocation? = nil,
        featureTypes: [TextractClientTypes.FeatureType]? = nil,
        jobTag: Swift.String? = nil,
        kMSKeyId: Swift.String? = nil,
        notificationChannel: TextractClientTypes.NotificationChannel? = nil,
        outputConfig: TextractClientTypes.OutputConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.documentLocation = documentLocation
        self.featureTypes = featureTypes
        self.jobTag = jobTag
        self.kMSKeyId = kMSKeyId
        self.notificationChannel = notificationChannel
        self.outputConfig = outputConfig
    }
}

struct StartDocumentAnalysisInputBody: Swift.Equatable {
    public let documentLocation: TextractClientTypes.DocumentLocation?
    public let featureTypes: [TextractClientTypes.FeatureType]?
    public let clientRequestToken: Swift.String?
    public let jobTag: Swift.String?
    public let notificationChannel: TextractClientTypes.NotificationChannel?
    public let outputConfig: TextractClientTypes.OutputConfig?
    public let kMSKeyId: Swift.String?
}

extension StartDocumentAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case featureTypes = "FeatureTypes"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentLocationDecoded = try containerValues.decodeIfPresent(TextractClientTypes.DocumentLocation.self, forKey: .documentLocation)
        documentLocation = documentLocationDecoded
        let featureTypesContainer = try containerValues.decodeIfPresent([TextractClientTypes.FeatureType?].self, forKey: .featureTypes)
        var featureTypesDecoded0:[TextractClientTypes.FeatureType]? = nil
        if let featureTypesContainer = featureTypesContainer {
            featureTypesDecoded0 = [TextractClientTypes.FeatureType]()
            for string0 in featureTypesContainer {
                if let string0 = string0 {
                    featureTypesDecoded0?.append(string0)
                }
            }
        }
        featureTypes = featureTypesDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let jobTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTag)
        jobTag = jobTagDecoded
        let notificationChannelDecoded = try containerValues.decodeIfPresent(TextractClientTypes.NotificationChannel.self, forKey: .notificationChannel)
        notificationChannel = notificationChannelDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(TextractClientTypes.OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
    }
}

extension StartDocumentAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDocumentAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKMSKeyException" : self = .invalidKMSKeyException(try InvalidKMSKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDocumentAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerError(InternalServerError)
    case invalidKMSKeyException(InvalidKMSKeyException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case limitExceededException(LimitExceededException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDocumentAnalysisOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDocumentAnalysisOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartDocumentAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDocumentAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartDocumentAnalysisOutputResponse: Swift.Equatable {
    /// <p>The identifier for the document text detection job. Use <code>JobId</code> to identify
    ///          the job in a subsequent call to <code>GetDocumentAnalysis</code>. A <code>JobId</code> value
    ///          is only valid for 7 days.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartDocumentAnalysisOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartDocumentAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartDocumentTextDetectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDocumentTextDetectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDocumentTextDetectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDocumentTextDetectionOutputError>
}

extension StartDocumentTextDetectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDocumentTextDetectionInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), documentLocation: \(Swift.String(describing: documentLocation)), jobTag: \(Swift.String(describing: jobTag)), kMSKeyId: \(Swift.String(describing: kMSKeyId)), notificationChannel: \(Swift.String(describing: notificationChannel)), outputConfig: \(Swift.String(describing: outputConfig)))"}
}

extension StartDocumentTextDetectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let documentLocation = documentLocation {
            try encodeContainer.encode(documentLocation, forKey: .documentLocation)
        }
        if let jobTag = jobTag {
            try encodeContainer.encode(jobTag, forKey: .jobTag)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
        if let notificationChannel = notificationChannel {
            try encodeContainer.encode(notificationChannel, forKey: .notificationChannel)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

public struct StartDocumentTextDetectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDocumentTextDetectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDocumentTextDetectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDocumentTextDetectionOutputError>
}

public struct StartDocumentTextDetectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDocumentTextDetectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDocumentTextDetectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDocumentTextDetectionOutputError>
}

public struct StartDocumentTextDetectionInput: Swift.Equatable {
    /// <p>The idempotent token that's used to identify the start request. If you use the same
    ///          token with multiple <code>StartDocumentTextDetection</code> requests, the same
    ///             <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same
    ///          job from being accidentally started more than once. For more information, see
    ///          <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a>.</p>
    public let clientRequestToken: Swift.String?
    /// <p>The location of the document to be processed.</p>
    public let documentLocation: TextractClientTypes.DocumentLocation?
    /// <p>An identifier that you specify that's included in the completion notification published
    ///          to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of
    ///          document that the completion notification corresponds to (such as a tax form or a
    ///          receipt).</p>
    public let jobTag: Swift.String?
    /// <p>The KMS key used to encrypt the inference results. This can be
    ///          in either Key ID or Key Alias format. When a KMS key is provided, the
    ///          KMS key will be used for server-side encryption of the objects in the
    ///          customer bucket. When this parameter is not enabled, the result will
    ///          be encrypted server side,using SSE-S3.</p>
    public let kMSKeyId: Swift.String?
    /// <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the
    ///          operation to. </p>
    public let notificationChannel: TextractClientTypes.NotificationChannel?
    /// <p>Sets if the output will go to a customer defined bucket. By default Amazon Textract will
    ///          save the results internally to be accessed with the GetDocumentTextDetection operation.</p>
    public let outputConfig: TextractClientTypes.OutputConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        documentLocation: TextractClientTypes.DocumentLocation? = nil,
        jobTag: Swift.String? = nil,
        kMSKeyId: Swift.String? = nil,
        notificationChannel: TextractClientTypes.NotificationChannel? = nil,
        outputConfig: TextractClientTypes.OutputConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.documentLocation = documentLocation
        self.jobTag = jobTag
        self.kMSKeyId = kMSKeyId
        self.notificationChannel = notificationChannel
        self.outputConfig = outputConfig
    }
}

struct StartDocumentTextDetectionInputBody: Swift.Equatable {
    public let documentLocation: TextractClientTypes.DocumentLocation?
    public let clientRequestToken: Swift.String?
    public let jobTag: Swift.String?
    public let notificationChannel: TextractClientTypes.NotificationChannel?
    public let outputConfig: TextractClientTypes.OutputConfig?
    public let kMSKeyId: Swift.String?
}

extension StartDocumentTextDetectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentLocationDecoded = try containerValues.decodeIfPresent(TextractClientTypes.DocumentLocation.self, forKey: .documentLocation)
        documentLocation = documentLocationDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let jobTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTag)
        jobTag = jobTagDecoded
        let notificationChannelDecoded = try containerValues.decodeIfPresent(TextractClientTypes.NotificationChannel.self, forKey: .notificationChannel)
        notificationChannel = notificationChannelDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(TextractClientTypes.OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
    }
}

extension StartDocumentTextDetectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDocumentTextDetectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKMSKeyException" : self = .invalidKMSKeyException(try InvalidKMSKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDocumentTextDetectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerError(InternalServerError)
    case invalidKMSKeyException(InvalidKMSKeyException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case limitExceededException(LimitExceededException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDocumentTextDetectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDocumentTextDetectionOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartDocumentTextDetectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDocumentTextDetectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartDocumentTextDetectionOutputResponse: Swift.Equatable {
    /// <p>The identifier of the text detection job for the document. Use <code>JobId</code> to
    ///          identify the job in a subsequent call to <code>GetDocumentTextDetection</code>.
    ///          A <code>JobId</code> value is only valid for 7 days.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartDocumentTextDetectionOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartDocumentTextDetectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension TextractClientTypes {
    public enum TextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case handwriting
        case printed
        case sdkUnknown(Swift.String)

        public static var allCases: [TextType] {
            return [
                .handwriting,
                .printed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .handwriting: return "HANDWRITING"
            case .printed: return "PRINTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TextType(rawValue: rawValue) ?? TextType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract is temporarily unable to process the request. Try your call again.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UnsupportedDocumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedDocumentException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension UnsupportedDocumentException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedDocumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The format of the input document isn't supported. Documents for synchronous operations can be in
///          PNG or JPEG format. Documents for asynchronous operations can also be in PDF format.</p>
public struct UnsupportedDocumentException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnsupportedDocumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension UnsupportedDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TextractClientTypes.Warning: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case pages = "Pages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let pages = pages {
            var pagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pages)
            for pages0 in pages {
                try pagesContainer.encode(pages0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let pagesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .pages)
        var pagesDecoded0:[Swift.Int]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [Swift.Int]()
            for integer0 in pagesContainer {
                if let integer0 = integer0 {
                    pagesDecoded0?.append(integer0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

extension TextractClientTypes.Warning: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Warning(errorCode: \(Swift.String(describing: errorCode)), pages: \(Swift.String(describing: pages)))"}
}

extension TextractClientTypes {
    /// <p>A warning about an issue that occurred during asynchronous text analysis (<a>StartDocumentAnalysis</a>) or asynchronous document text detection (<a>StartDocumentTextDetection</a>). </p>
    public struct Warning: Swift.Equatable {
        /// <p>The error code for the warning.</p>
        public let errorCode: Swift.String?
        /// <p>A list of the pages that the warning applies to.</p>
        public let pages: [Swift.Int]?

        public init (
            errorCode: Swift.String? = nil,
            pages: [Swift.Int]? = nil
        )
        {
            self.errorCode = errorCode
            self.pages = pages
        }
    }

}
