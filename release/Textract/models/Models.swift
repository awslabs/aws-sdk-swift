// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You aren't authorized to perform the action. Use the Amazon Resource Name (ARN)
///             of an authorized user or IAM role to perform the operation.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

public struct AnalyzeDocumentInputBodyMiddleware: Middleware {
    public let id: String = "AnalyzeDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AnalyzeDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<AnalyzeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AnalyzeDocumentInput>
    public typealias MOutput = OperationOutput<AnalyzeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AnalyzeDocumentOutputError>
}

extension AnalyzeDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyzeDocumentInput(document: \(String(describing: document)), featureTypes: \(String(describing: featureTypes)), humanLoopConfig: \(String(describing: humanLoopConfig)))"}
}

extension AnalyzeDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
        case featureTypes = "FeatureTypes"
        case humanLoopConfig = "HumanLoopConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let featureTypes = featureTypes {
            var featureTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featureTypes)
            for featuretypes0 in featureTypes {
                try featureTypesContainer.encode(featuretypes0.rawValue)
            }
        }
        if let humanLoopConfig = humanLoopConfig {
            try encodeContainer.encode(humanLoopConfig, forKey: .humanLoopConfig)
        }
    }
}

public struct AnalyzeDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "AnalyzeDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AnalyzeDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<AnalyzeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AnalyzeDocumentInput>
    public typealias MOutput = OperationOutput<AnalyzeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AnalyzeDocumentOutputError>
}

public struct AnalyzeDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "AnalyzeDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AnalyzeDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<AnalyzeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AnalyzeDocumentInput>
    public typealias MOutput = OperationOutput<AnalyzeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AnalyzeDocumentOutputError>
}

public struct AnalyzeDocumentInput: Equatable {
    /// <p>The input document as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
    ///          to call Amazon Textract operations, you can't pass image bytes. The document must be an image
    ///          in JPEG or PNG format.</p>
    ///          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
    ///          image bytes that are passed using the <code>Bytes</code> field. </p>
    public let document: Document?
    /// <p>A list of the types of analysis to perform. Add TABLES to the list to return information
    ///          about the tables that are detected in the input document. Add FORMS to return detected form data.
    ///          To perform both types of analysis, add TABLES and FORMS to
    ///             <code>FeatureTypes</code>. All lines and words detected in the document are included in
    ///          the response (including text that isn't related to the value of <code>FeatureTypes</code>). </p>
    public let featureTypes: [FeatureType]?
    /// <p>Sets the configuration for the human in the loop workflow for analyzing documents.</p>
    public let humanLoopConfig: HumanLoopConfig?

    public init (
        document: Document? = nil,
        featureTypes: [FeatureType]? = nil,
        humanLoopConfig: HumanLoopConfig? = nil
    )
    {
        self.document = document
        self.featureTypes = featureTypes
        self.humanLoopConfig = humanLoopConfig
    }
}

struct AnalyzeDocumentInputBody: Equatable {
    public let document: Document?
    public let featureTypes: [FeatureType]?
    public let humanLoopConfig: HumanLoopConfig?
}

extension AnalyzeDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
        case featureTypes = "FeatureTypes"
        case humanLoopConfig = "HumanLoopConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Document.self, forKey: .document)
        document = documentDecoded
        let featureTypesContainer = try containerValues.decodeIfPresent([FeatureType?].self, forKey: .featureTypes)
        var featureTypesDecoded0:[FeatureType]? = nil
        if let featureTypesContainer = featureTypesContainer {
            featureTypesDecoded0 = [FeatureType]()
            for string0 in featureTypesContainer {
                if let string0 = string0 {
                    featureTypesDecoded0?.append(string0)
                }
            }
        }
        featureTypes = featureTypesDecoded0
        let humanLoopConfigDecoded = try containerValues.decodeIfPresent(HumanLoopConfig.self, forKey: .humanLoopConfig)
        humanLoopConfig = humanLoopConfigDecoded
    }
}

extension AnalyzeDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AnalyzeDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HumanLoopQuotaExceededException" : self = .humanLoopQuotaExceededException(try HumanLoopQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AnalyzeDocumentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case humanLoopQuotaExceededException(HumanLoopQuotaExceededException)
    case internalServerError(InternalServerError)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AnalyzeDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyzeDocumentOutputResponse(analyzeDocumentModelVersion: \(String(describing: analyzeDocumentModelVersion)), blocks: \(String(describing: blocks)), documentMetadata: \(String(describing: documentMetadata)), humanLoopActivationOutput: \(String(describing: humanLoopActivationOutput)))"}
}

extension AnalyzeDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AnalyzeDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analyzeDocumentModelVersion = output.analyzeDocumentModelVersion
            self.blocks = output.blocks
            self.documentMetadata = output.documentMetadata
            self.humanLoopActivationOutput = output.humanLoopActivationOutput
        } else {
            self.analyzeDocumentModelVersion = nil
            self.blocks = nil
            self.documentMetadata = nil
            self.humanLoopActivationOutput = nil
        }
    }
}

public struct AnalyzeDocumentOutputResponse: Equatable {
    /// <p>The version of the model used to analyze the document.</p>
    public let analyzeDocumentModelVersion: String?
    /// <p>The items that are detected and analyzed by <code>AnalyzeDocument</code>.</p>
    public let blocks: [Block]?
    /// <p>Metadata about the analyzed document. An example is the number of pages.</p>
    public let documentMetadata: DocumentMetadata?
    /// <p>Shows the results of the human in the loop evaluation.</p>
    public let humanLoopActivationOutput: HumanLoopActivationOutput?

    public init (
        analyzeDocumentModelVersion: String? = nil,
        blocks: [Block]? = nil,
        documentMetadata: DocumentMetadata? = nil,
        humanLoopActivationOutput: HumanLoopActivationOutput? = nil
    )
    {
        self.analyzeDocumentModelVersion = analyzeDocumentModelVersion
        self.blocks = blocks
        self.documentMetadata = documentMetadata
        self.humanLoopActivationOutput = humanLoopActivationOutput
    }
}

struct AnalyzeDocumentOutputResponseBody: Equatable {
    public let documentMetadata: DocumentMetadata?
    public let blocks: [Block]?
    public let humanLoopActivationOutput: HumanLoopActivationOutput?
    public let analyzeDocumentModelVersion: String?
}

extension AnalyzeDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzeDocumentModelVersion = "AnalyzeDocumentModelVersion"
        case blocks = "Blocks"
        case documentMetadata = "DocumentMetadata"
        case humanLoopActivationOutput = "HumanLoopActivationOutput"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let blocksContainer = try containerValues.decodeIfPresent([Block?].self, forKey: .blocks)
        var blocksDecoded0:[Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let humanLoopActivationOutputDecoded = try containerValues.decodeIfPresent(HumanLoopActivationOutput.self, forKey: .humanLoopActivationOutput)
        humanLoopActivationOutput = humanLoopActivationOutputDecoded
        let analyzeDocumentModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzeDocumentModelVersion)
        analyzeDocumentModelVersion = analyzeDocumentModelVersionDecoded
    }
}

extension BadDocumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadDocumentException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension BadDocumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadDocumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract isn't able to read the document. For more information on the document
///          limits in Amazon Textract, see <a>limits</a>.</p>
public struct BadDocumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadDocumentExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension BadDocumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension Block: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockType = "BlockType"
        case columnIndex = "ColumnIndex"
        case columnSpan = "ColumnSpan"
        case confidence = "Confidence"
        case entityTypes = "EntityTypes"
        case geometry = "Geometry"
        case id = "Id"
        case page = "Page"
        case relationships = "Relationships"
        case rowIndex = "RowIndex"
        case rowSpan = "RowSpan"
        case selectionStatus = "SelectionStatus"
        case text = "Text"
        case textType = "TextType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockType = blockType {
            try encodeContainer.encode(blockType.rawValue, forKey: .blockType)
        }
        if let columnIndex = columnIndex {
            try encodeContainer.encode(columnIndex, forKey: .columnIndex)
        }
        if let columnSpan = columnSpan {
            try encodeContainer.encode(columnSpan, forKey: .columnSpan)
        }
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entitytypes0 in entityTypes {
                try entityTypesContainer.encode(entitytypes0.rawValue)
            }
        }
        if let geometry = geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let page = page {
            try encodeContainer.encode(page, forKey: .page)
        }
        if let relationships = relationships {
            var relationshipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationships)
            for relationshiplist0 in relationships {
                try relationshipsContainer.encode(relationshiplist0)
            }
        }
        if let rowIndex = rowIndex {
            try encodeContainer.encode(rowIndex, forKey: .rowIndex)
        }
        if let rowSpan = rowSpan {
            try encodeContainer.encode(rowSpan, forKey: .rowSpan)
        }
        if let selectionStatus = selectionStatus {
            try encodeContainer.encode(selectionStatus.rawValue, forKey: .selectionStatus)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockTypeDecoded = try containerValues.decodeIfPresent(BlockType.self, forKey: .blockType)
        blockType = blockTypeDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .confidence)
        confidence = confidenceDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let rowIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rowIndex)
        rowIndex = rowIndexDecoded
        let columnIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .columnIndex)
        columnIndex = columnIndexDecoded
        let rowSpanDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rowSpan)
        rowSpan = rowSpanDecoded
        let columnSpanDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .columnSpan)
        columnSpan = columnSpanDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(Geometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let relationshipsContainer = try containerValues.decodeIfPresent([Relationship?].self, forKey: .relationships)
        var relationshipsDecoded0:[Relationship]? = nil
        if let relationshipsContainer = relationshipsContainer {
            relationshipsDecoded0 = [Relationship]()
            for structure0 in relationshipsContainer {
                if let structure0 = structure0 {
                    relationshipsDecoded0?.append(structure0)
                }
            }
        }
        relationships = relationshipsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [EntityType]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let selectionStatusDecoded = try containerValues.decodeIfPresent(SelectionStatus.self, forKey: .selectionStatus)
        selectionStatus = selectionStatusDecoded
        let pageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .page)
        page = pageDecoded
    }
}

extension Block: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Block(blockType: \(String(describing: blockType)), columnIndex: \(String(describing: columnIndex)), columnSpan: \(String(describing: columnSpan)), confidence: \(String(describing: confidence)), entityTypes: \(String(describing: entityTypes)), geometry: \(String(describing: geometry)), id: \(String(describing: id)), page: \(String(describing: page)), relationships: \(String(describing: relationships)), rowIndex: \(String(describing: rowIndex)), rowSpan: \(String(describing: rowSpan)), selectionStatus: \(String(describing: selectionStatus)), text: \(String(describing: text)), textType: \(String(describing: textType)))"}
}

/// <p>A <code>Block</code> represents items that are recognized in a document within a group
///          of pixels close to each other. The information returned in a <code>Block</code> object
///          depends on the type of operation. In text detection for documents (for example <a>DetectDocumentText</a>), you get information about the detected words and lines
///          of text. In text analysis (for example <a>AnalyzeDocument</a>), you can also get
///          information about the fields, tables, and selection elements that are detected in the
///          document.</p>
///          <p>An array of <code>Block</code> objects is returned by both synchronous and asynchronous
///          operations. In synchronous operations, such as <a>DetectDocumentText</a>, the
///          array of <code>Block</code> objects is the entire set of results. In asynchronous
///          operations, such as <a>GetDocumentAnalysis</a>, the array is returned over one
///          or more responses.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works.html">How Amazon Textract Works</a>.</p>
public struct Block: Equatable {
    /// <p>The type of text item that's recognized. In operations for text detection, the following
    ///          types are returned:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>PAGE</i> - Contains a list of the LINE <code>Block</code> objects
    ///                that are detected on a document page.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>WORD</i> - A word detected on a document page. A word is one or
    ///                more ISO basic Latin script characters that aren't separated by spaces.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>LINE</i> - A string of tab-delimited, contiguous words that are
    ///                detected on a document page.</p>
    ///             </li>
    ///          </ul>
    ///          <p>In text analysis operations, the following types are returned:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>PAGE</i> - Contains a list of child <code>Block</code> objects
    ///                that are detected on a document page.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>KEY_VALUE_SET</i> - Stores the KEY and VALUE <code>Block</code>
    ///                objects for linked text that's detected on a document page. Use the
    ///                   <code>EntityType</code> field to determine if a KEY_VALUE_SET object is a KEY
    ///                   <code>Block</code> object or a VALUE <code>Block</code> object. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>WORD</i> - A word that's detected on a document page. A word is
    ///                one or more ISO basic Latin script characters that aren't separated by spaces.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>LINE</i> - A string of tab-delimited, contiguous words that are
    ///                detected on a document page.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>TABLE</i> - A table that's detected on a document page. A table
    ///                is grid-based information with two or more rows or columns, with a cell span of one
    ///                row and one column each. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>CELL</i> - A cell within a detected table. The cell is the parent
    ///                of the block that contains the text in the cell.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>SELECTION_ELEMENT</i> - A selection element such as an option
    ///                button (radio button) or a check box that's detected on a document page. Use the
    ///                value of <code>SelectionStatus</code> to determine the status of the selection
    ///                element.</p>
    ///             </li>
    ///          </ul>
    public let blockType: BlockType?
    /// <p>The column in which a table cell appears. The first column position is 1.
    ///             <code>ColumnIndex</code> isn't returned by <code>DetectDocumentText</code> and
    ///             <code>GetDocumentTextDetection</code>.</p>
    public let columnIndex: Int?
    /// <p>The number of columns that a table cell spans. Currently this value is always 1, even
    ///          if the number of columns spanned is greater than 1. <code>ColumnSpan</code> isn't returned by
    ///             <code>DetectDocumentText</code> and <code>GetDocumentTextDetection</code>. </p>
    public let columnSpan: Int?
    /// <p>The confidence score that Amazon Textract has in the accuracy of the recognized text and
    ///          the accuracy of the geometry points around the recognized text.</p>
    public let confidence: Float?
    /// <p>The type of entity. The following can be returned:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>KEY</i> - An identifier for a field on the document.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>VALUE</i> - The field text.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>EntityTypes</code> isn't returned by <code>DetectDocumentText</code> and
    ///             <code>GetDocumentTextDetection</code>.</p>
    public let entityTypes: [EntityType]?
    /// <p>The location of the recognized text on the image. It includes an axis-aligned, coarse
    ///          bounding box that surrounds the text, and a finer-grain polygon for more accurate spatial
    ///          information. </p>
    public let geometry: Geometry?
    /// <p>The identifier for the recognized text. The identifier is only unique for a single
    ///          operation. </p>
    public let id: String?
    /// <p>The page on which a block was detected. <code>Page</code> is returned by asynchronous
    ///          operations. Page values greater than 1 are only returned for multipage documents that are
    ///          in PDF format. A scanned image (JPEG/PNG), even if it contains multiple document pages, is
    ///          considered to be a single-page document. The value of <code>Page</code> is always 1.
    ///          Synchronous operations don't return <code>Page</code> because every input document is
    ///          considered to be a single-page document.</p>
    public let page: Int?
    /// <p>A list of child blocks of the current block. For example, a LINE object has child blocks
    ///          for each WORD block that's part of the line of text. There aren't Relationship objects in
    ///          the list for relationships that don't exist, such as when the current block has no child
    ///          blocks. The list size can be the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>0 - The block has no child blocks.</p>
    ///             </li>
    ///             <li>
    ///                <p>1 - The block has child blocks.</p>
    ///             </li>
    ///          </ul>
    public let relationships: [Relationship]?
    /// <p>The row in which a table cell is located. The first row position is 1.
    ///             <code>RowIndex</code> isn't returned by <code>DetectDocumentText</code> and
    ///             <code>GetDocumentTextDetection</code>.</p>
    public let rowIndex: Int?
    /// <p>The number of rows that a table cell spans. Currently this value is always 1, even
    ///          if the number of rows spanned is greater than 1. <code>RowSpan</code> isn't returned by
    ///             <code>DetectDocumentText</code> and <code>GetDocumentTextDetection</code>.</p>
    public let rowSpan: Int?
    /// <p>The selection status of a selection element, such as an option button or check box. </p>
    public let selectionStatus: SelectionStatus?
    /// <p>The word or line of text that's recognized by Amazon Textract. </p>
    public let text: String?
    /// <p>The kind of text that Amazon Textract has detected. Can check for handwritten text and printed text.</p>
    public let textType: TextType?

    public init (
        blockType: BlockType? = nil,
        columnIndex: Int? = nil,
        columnSpan: Int? = nil,
        confidence: Float? = nil,
        entityTypes: [EntityType]? = nil,
        geometry: Geometry? = nil,
        id: String? = nil,
        page: Int? = nil,
        relationships: [Relationship]? = nil,
        rowIndex: Int? = nil,
        rowSpan: Int? = nil,
        selectionStatus: SelectionStatus? = nil,
        text: String? = nil,
        textType: TextType? = nil
    )
    {
        self.blockType = blockType
        self.columnIndex = columnIndex
        self.columnSpan = columnSpan
        self.confidence = confidence
        self.entityTypes = entityTypes
        self.geometry = geometry
        self.id = id
        self.page = page
        self.relationships = relationships
        self.rowIndex = rowIndex
        self.rowSpan = rowSpan
        self.selectionStatus = selectionStatus
        self.text = text
        self.textType = textType
    }
}

public enum BlockType {
    case cell
    case keyValueSet
    case line
    case page
    case selectionElement
    case table
    case word
    case sdkUnknown(String)
}

extension BlockType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BlockType] {
        return [
            .cell,
            .keyValueSet,
            .line,
            .page,
            .selectionElement,
            .table,
            .word,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cell: return "CELL"
        case .keyValueSet: return "KEY_VALUE_SET"
        case .line: return "LINE"
        case .page: return "PAGE"
        case .selectionElement: return "SELECTION_ELEMENT"
        case .table: return "TABLE"
        case .word: return "WORD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BlockType(rawValue: rawValue) ?? BlockType.sdkUnknown(rawValue)
    }
}

extension BoundingBox: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case height = "Height"
        case `left` = "Left"
        case top = "Top"
        case width = "Width"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if height != 0.0 {
            try encodeContainer.encode(height, forKey: .height)
        }
        if `left` != 0.0 {
            try encodeContainer.encode(`left`, forKey: .`left`)
        }
        if top != 0.0 {
            try encodeContainer.encode(top, forKey: .top)
        }
        if width != 0.0 {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decode(Float.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decode(Float.self, forKey: .height)
        height = heightDecoded
        let leftDecoded = try containerValues.decode(Float.self, forKey: .left)
        `left` = leftDecoded
        let topDecoded = try containerValues.decode(Float.self, forKey: .top)
        top = topDecoded
    }
}

extension BoundingBox: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BoundingBox(height: \(String(describing: height)), left: \(String(describing: `left`)), top: \(String(describing: top)), width: \(String(describing: width)))"}
}

/// <p>The bounding box around the detected page, text, key-value pair, table, table cell, or selection element on a
///          document page. The <code>left</code> (x-coordinate) and <code>top</code> (y-coordinate) are
///          coordinates that represent the top and left sides of the bounding box. Note that the
///          upper-left corner of the image is the origin (0,0). </p>
///          <p>The <code>top</code> and <code>left</code> values returned are ratios of the overall
///          document page size. For example, if the input image is 700 x 200 pixels, and the top-left
///          coordinate of the bounding box is 350 x 50 pixels, the API returns a <code>left</code>
///          value of 0.5 (350/700) and a <code>top</code> value of 0.25 (50/200).</p>
///          <p>The <code>width</code> and <code>height</code> values represent the dimensions of the
///          bounding box as a ratio of the overall document page dimension. For example, if the
///          document page size is 700 x 200 pixels, and the bounding box width is 70 pixels, the width
///          returned is 0.1. </p>
public struct BoundingBox: Equatable {
    /// <p>The left coordinate of the bounding box as a ratio of overall document page
    ///          width.</p>
    public let `left`: Float
    /// <p>The height of the bounding box as a ratio of the overall document page
    ///          height.</p>
    public let height: Float
    /// <p>The top coordinate of the bounding box as a ratio of overall document page
    ///          height.</p>
    public let top: Float
    /// <p>The width of the bounding box as a ratio of the overall document page
    ///          width.</p>
    public let width: Float

    public init (
        `left`: Float = 0.0,
        height: Float = 0.0,
        top: Float = 0.0,
        width: Float = 0.0
    )
    {
        self.`left` = `left`
        self.height = height
        self.top = top
        self.width = width
    }
}

public enum ContentClassifier {
    case freeOfAdultContent
    case freeOfPersonallyIdentifiableInformation
    case sdkUnknown(String)
}

extension ContentClassifier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContentClassifier] {
        return [
            .freeOfAdultContent,
            .freeOfPersonallyIdentifiableInformation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .freeOfAdultContent: return "FreeOfAdultContent"
        case .freeOfPersonallyIdentifiableInformation: return "FreeOfPersonallyIdentifiableInformation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContentClassifier(rawValue: rawValue) ?? ContentClassifier.sdkUnknown(rawValue)
    }
}

public struct DetectDocumentTextInputBodyMiddleware: Middleware {
    public let id: String = "DetectDocumentTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectDocumentTextInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectDocumentTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectDocumentTextInput>
    public typealias MOutput = OperationOutput<DetectDocumentTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectDocumentTextOutputError>
}

extension DetectDocumentTextInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectDocumentTextInput(document: \(String(describing: document)))"}
}

extension DetectDocumentTextInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
    }
}

public struct DetectDocumentTextInputHeadersMiddleware: Middleware {
    public let id: String = "DetectDocumentTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectDocumentTextInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectDocumentTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectDocumentTextInput>
    public typealias MOutput = OperationOutput<DetectDocumentTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectDocumentTextOutputError>
}

public struct DetectDocumentTextInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectDocumentTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectDocumentTextInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectDocumentTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectDocumentTextInput>
    public typealias MOutput = OperationOutput<DetectDocumentTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectDocumentTextOutputError>
}

public struct DetectDocumentTextInput: Equatable {
    /// <p>The input document as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
    ///          to call Amazon Textract operations, you can't pass image bytes. The document must be an image
    ///       in JPEG or PNG format.</p>
    ///          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
    ///          image bytes that are passed using the <code>Bytes</code> field. </p>
    public let document: Document?

    public init (
        document: Document? = nil
    )
    {
        self.document = document
    }
}

struct DetectDocumentTextInputBody: Equatable {
    public let document: Document?
}

extension DetectDocumentTextInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Document.self, forKey: .document)
        document = documentDecoded
    }
}

extension DetectDocumentTextOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectDocumentTextOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectDocumentTextOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case internalServerError(InternalServerError)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectDocumentTextOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectDocumentTextOutputResponse(blocks: \(String(describing: blocks)), detectDocumentTextModelVersion: \(String(describing: detectDocumentTextModelVersion)), documentMetadata: \(String(describing: documentMetadata)))"}
}

extension DetectDocumentTextOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectDocumentTextOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blocks = output.blocks
            self.detectDocumentTextModelVersion = output.detectDocumentTextModelVersion
            self.documentMetadata = output.documentMetadata
        } else {
            self.blocks = nil
            self.detectDocumentTextModelVersion = nil
            self.documentMetadata = nil
        }
    }
}

public struct DetectDocumentTextOutputResponse: Equatable {
    /// <p>An array of <code>Block</code> objects that contain the text that's detected in the
    ///          document.</p>
    public let blocks: [Block]?
    /// <p></p>
    public let detectDocumentTextModelVersion: String?
    /// <p>Metadata about the document. It contains the number of pages that are detected in the
    ///          document.</p>
    public let documentMetadata: DocumentMetadata?

    public init (
        blocks: [Block]? = nil,
        detectDocumentTextModelVersion: String? = nil,
        documentMetadata: DocumentMetadata? = nil
    )
    {
        self.blocks = blocks
        self.detectDocumentTextModelVersion = detectDocumentTextModelVersion
        self.documentMetadata = documentMetadata
    }
}

struct DetectDocumentTextOutputResponseBody: Equatable {
    public let documentMetadata: DocumentMetadata?
    public let blocks: [Block]?
    public let detectDocumentTextModelVersion: String?
}

extension DetectDocumentTextOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blocks = "Blocks"
        case detectDocumentTextModelVersion = "DetectDocumentTextModelVersion"
        case documentMetadata = "DocumentMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let blocksContainer = try containerValues.decodeIfPresent([Block?].self, forKey: .blocks)
        var blocksDecoded0:[Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let detectDocumentTextModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectDocumentTextModelVersion)
        detectDocumentTextModelVersion = detectDocumentTextModelVersionDecoded
    }
}

extension Document: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytes = "Bytes"
        case s3Object = "S3Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytes = bytes {
            try encodeContainer.encode(bytes.base64EncodedString(), forKey: .bytes)
        }
        if let s3Object = s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .bytes)
        bytes = bytesDecoded
        let s3ObjectDecoded = try containerValues.decodeIfPresent(S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension Document: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Document(bytes: \(String(describing: bytes)), s3Object: \(String(describing: s3Object)))"}
}

/// <p>The input document, either as bytes or as an S3 object.</p>
///          <p>You pass image bytes to an Amazon Textract API operation by using the <code>Bytes</code>
///          property. For example, you would use the <code>Bytes</code> property to pass a document
///          loaded from a local file system. Image bytes passed by using the <code>Bytes</code>
///          property must be base64 encoded. Your code might not need to encode document file bytes if
///          you're using an AWS SDK to call Amazon Textract API operations. </p>
///          <p>You pass images stored in an S3 bucket to an Amazon Textract API operation by using the
///             <code>S3Object</code> property. Documents stored in an S3 bucket don't need to be base64
///          encoded.</p>
///          <p>The AWS Region for the S3 bucket that contains the S3 object must match the AWS
///          Region that you use for Amazon Textract operations.</p>
///          <p>If you use the AWS CLI to call Amazon Textract operations, passing image bytes using
///          the Bytes property isn't supported. You must first upload the document to an Amazon S3
///          bucket, and then call the operation using the S3Object property.</p>
///
///          <p>For Amazon Textract to process an S3 object, the user must have permission
///          to access the S3 object. </p>
public struct Document: Equatable {
    /// <p>A blob of base64-encoded document bytes. The maximum size of a document that's provided
    ///          in a blob of bytes is 5 MB. The document bytes must be in PNG or JPEG format.</p>
    ///          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
    ///          image bytes passed using the <code>Bytes</code> field. </p>
    public let bytes: Data?
    /// <p>Identifies an S3 object as the document source. The maximum size of a document that's
    ///          stored in an S3 bucket is 5 MB.</p>
    public let s3Object: S3Object?

    public init (
        bytes: Data? = nil,
        s3Object: S3Object? = nil
    )
    {
        self.bytes = bytes
        self.s3Object = s3Object
    }
}

extension DocumentLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Object = "S3Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Object = s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension DocumentLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentLocation(s3Object: \(String(describing: s3Object)))"}
}

/// <p>The Amazon S3 bucket that contains the document to be processed. It's used by asynchronous
///          operations such as <a>StartDocumentTextDetection</a>.</p>
///          <p>The input document can be an image file in JPEG or PNG format. It can also be a file in
///          PDF format.</p>
public struct DocumentLocation: Equatable {
    /// <p>The Amazon S3 bucket that contains the input document.</p>
    public let s3Object: S3Object?

    public init (
        s3Object: S3Object? = nil
    )
    {
        self.s3Object = s3Object
    }
}

extension DocumentMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pages = "Pages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pages = pages {
            try encodeContainer.encode(pages, forKey: .pages)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pagesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pages)
        pages = pagesDecoded
    }
}

extension DocumentMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentMetadata(pages: \(String(describing: pages)))"}
}

/// <p>Information about the input document.</p>
public struct DocumentMetadata: Equatable {
    /// <p>The number of pages that are detected in the document.</p>
    public let pages: Int?

    public init (
        pages: Int? = nil
    )
    {
        self.pages = pages
    }
}

extension DocumentTooLargeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentTooLargeException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension DocumentTooLargeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DocumentTooLargeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The document can't be processed because it's too large. The maximum document size for
///          synchronous operations 10 MB. The maximum document size for asynchronous operations is 500
///          MB for PDF files.</p>
public struct DocumentTooLargeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct DocumentTooLargeExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension DocumentTooLargeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

public enum EntityType {
    case key
    case value
    case sdkUnknown(String)
}

extension EntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityType] {
        return [
            .key,
            .value,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .key: return "KEY"
        case .value: return "VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
    }
}

public enum FeatureType {
    case forms
    case tables
    case sdkUnknown(String)
}

extension FeatureType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FeatureType] {
        return [
            .forms,
            .tables,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .forms: return "FORMS"
        case .tables: return "TABLES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FeatureType(rawValue: rawValue) ?? FeatureType.sdkUnknown(rawValue)
    }
}

extension Geometry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case boundingBox = "BoundingBox"
        case polygon = "Polygon"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let boundingBox = boundingBox {
            try encodeContainer.encode(boundingBox, forKey: .boundingBox)
        }
        if let polygon = polygon {
            var polygonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .polygon)
            for polygon0 in polygon {
                try polygonContainer.encode(polygon0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let boundingBoxDecoded = try containerValues.decodeIfPresent(BoundingBox.self, forKey: .boundingBox)
        boundingBox = boundingBoxDecoded
        let polygonContainer = try containerValues.decodeIfPresent([Point?].self, forKey: .polygon)
        var polygonDecoded0:[Point]? = nil
        if let polygonContainer = polygonContainer {
            polygonDecoded0 = [Point]()
            for structure0 in polygonContainer {
                if let structure0 = structure0 {
                    polygonDecoded0?.append(structure0)
                }
            }
        }
        polygon = polygonDecoded0
    }
}

extension Geometry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Geometry(boundingBox: \(String(describing: boundingBox)), polygon: \(String(describing: polygon)))"}
}

/// <p>Information about where the following items are located on a document page: detected
///          page, text, key-value pairs, tables, table cells, and selection elements.</p>
public struct Geometry: Equatable {
    /// <p>An axis-aligned coarse representation of the location of the recognized item on the
    ///          document page.</p>
    public let boundingBox: BoundingBox?
    /// <p>Within the bounding box, a fine-grained polygon around the recognized item.</p>
    public let polygon: [Point]?

    public init (
        boundingBox: BoundingBox? = nil,
        polygon: [Point]? = nil
    )
    {
        self.boundingBox = boundingBox
        self.polygon = polygon
    }
}

public struct GetDocumentAnalysisInputBodyMiddleware: Middleware {
    public let id: String = "GetDocumentAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentAnalysisInput>
    public typealias MOutput = OperationOutput<GetDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentAnalysisOutputError>
}

extension GetDocumentAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentAnalysisInput(jobId: \(String(describing: jobId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDocumentAnalysisInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetDocumentAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentAnalysisInput>
    public typealias MOutput = OperationOutput<GetDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentAnalysisOutputError>
}

public struct GetDocumentAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentAnalysisInput>
    public typealias MOutput = OperationOutput<GetDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentAnalysisOutputError>
}

public struct GetDocumentAnalysisInput: Equatable {
    /// <p>A unique identifier for the text-detection job. The <code>JobId</code> is returned from
    ///          <code>StartDocumentAnalysis</code>. A <code>JobId</code> value is only valid for 7 days.</p>
    public let jobId: String?
    /// <p>The maximum number of results to return per paginated call. The largest value that you
    ///          can specify is 1,000. If you specify a value greater than 1,000, a maximum of 1,000 results
    ///          is returned. The default value is 1,000.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there are more blocks to retrieve), Amazon Textract returns a pagination
    ///          token in the response. You can use this pagination token to retrieve the next set of blocks.</p>
    public let nextToken: String?

    public init (
        jobId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDocumentAnalysisInputBody: Equatable {
    public let jobId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetDocumentAnalysisInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDocumentAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobIdException" : self = .invalidJobIdException(try InvalidJobIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentAnalysisOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidJobIdException(InvalidJobIdException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentAnalysisOutputResponse(analyzeDocumentModelVersion: \(String(describing: analyzeDocumentModelVersion)), blocks: \(String(describing: blocks)), documentMetadata: \(String(describing: documentMetadata)), jobStatus: \(String(describing: jobStatus)), nextToken: \(String(describing: nextToken)), statusMessage: \(String(describing: statusMessage)), warnings: \(String(describing: warnings)))"}
}

extension GetDocumentAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analyzeDocumentModelVersion = output.analyzeDocumentModelVersion
            self.blocks = output.blocks
            self.documentMetadata = output.documentMetadata
            self.jobStatus = output.jobStatus
            self.nextToken = output.nextToken
            self.statusMessage = output.statusMessage
            self.warnings = output.warnings
        } else {
            self.analyzeDocumentModelVersion = nil
            self.blocks = nil
            self.documentMetadata = nil
            self.jobStatus = nil
            self.nextToken = nil
            self.statusMessage = nil
            self.warnings = nil
        }
    }
}

public struct GetDocumentAnalysisOutputResponse: Equatable {
    /// <p></p>
    public let analyzeDocumentModelVersion: String?
    /// <p>The results of the text-analysis operation.</p>
    public let blocks: [Block]?
    /// <p>Information about a document that Amazon Textract processed. <code>DocumentMetadata</code> is
    ///          returned in every page of paginated responses from an Amazon Textract video operation.</p>
    public let documentMetadata: DocumentMetadata?
    /// <p>The current status of the text detection job.</p>
    public let jobStatus: JobStatus?
    /// <p>If the response is truncated, Amazon Textract returns this token. You can use this token in
    ///          the subsequent request to retrieve the next set of text detection results.</p>
    public let nextToken: String?
    /// <p>Returns if the detection job could not be completed. Contains explanation for what error occured.</p>
    public let statusMessage: String?
    /// <p>A list of warnings that occurred during the document-analysis operation.</p>
    public let warnings: [Warning]?

    public init (
        analyzeDocumentModelVersion: String? = nil,
        blocks: [Block]? = nil,
        documentMetadata: DocumentMetadata? = nil,
        jobStatus: JobStatus? = nil,
        nextToken: String? = nil,
        statusMessage: String? = nil,
        warnings: [Warning]? = nil
    )
    {
        self.analyzeDocumentModelVersion = analyzeDocumentModelVersion
        self.blocks = blocks
        self.documentMetadata = documentMetadata
        self.jobStatus = jobStatus
        self.nextToken = nextToken
        self.statusMessage = statusMessage
        self.warnings = warnings
    }
}

struct GetDocumentAnalysisOutputResponseBody: Equatable {
    public let documentMetadata: DocumentMetadata?
    public let jobStatus: JobStatus?
    public let nextToken: String?
    public let blocks: [Block]?
    public let warnings: [Warning]?
    public let statusMessage: String?
    public let analyzeDocumentModelVersion: String?
}

extension GetDocumentAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzeDocumentModelVersion = "AnalyzeDocumentModelVersion"
        case blocks = "Blocks"
        case documentMetadata = "DocumentMetadata"
        case jobStatus = "JobStatus"
        case nextToken = "NextToken"
        case statusMessage = "StatusMessage"
        case warnings = "Warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let blocksContainer = try containerValues.decodeIfPresent([Block?].self, forKey: .blocks)
        var blocksDecoded0:[Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([Warning?].self, forKey: .warnings)
        var warningsDecoded0:[Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let analyzeDocumentModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzeDocumentModelVersion)
        analyzeDocumentModelVersion = analyzeDocumentModelVersionDecoded
    }
}

public struct GetDocumentTextDetectionInputBodyMiddleware: Middleware {
    public let id: String = "GetDocumentTextDetectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentTextDetectionInput>
    public typealias MOutput = OperationOutput<GetDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentTextDetectionOutputError>
}

extension GetDocumentTextDetectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentTextDetectionInput(jobId: \(String(describing: jobId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDocumentTextDetectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetDocumentTextDetectionInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentTextDetectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentTextDetectionInput>
    public typealias MOutput = OperationOutput<GetDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentTextDetectionOutputError>
}

public struct GetDocumentTextDetectionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentTextDetectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentTextDetectionInput>
    public typealias MOutput = OperationOutput<GetDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentTextDetectionOutputError>
}

public struct GetDocumentTextDetectionInput: Equatable {
    /// <p>A unique identifier for the text detection job. The <code>JobId</code> is returned from
    ///          <code>StartDocumentTextDetection</code>. A <code>JobId</code> value is only valid for 7 days.</p>
    public let jobId: String?
    /// <p>The maximum number of results to return per paginated call. The largest value you can
    ///          specify is 1,000. If you specify a value greater than 1,000, a maximum of 1,000 results is
    ///          returned. The default value is 1,000.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there are more blocks to retrieve), Amazon Textract returns a pagination
    ///          token in the response. You can use this pagination token to retrieve the next set of blocks.</p>
    public let nextToken: String?

    public init (
        jobId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDocumentTextDetectionInputBody: Equatable {
    public let jobId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetDocumentTextDetectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDocumentTextDetectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentTextDetectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobIdException" : self = .invalidJobIdException(try InvalidJobIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentTextDetectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidJobIdException(InvalidJobIdException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentTextDetectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentTextDetectionOutputResponse(blocks: \(String(describing: blocks)), detectDocumentTextModelVersion: \(String(describing: detectDocumentTextModelVersion)), documentMetadata: \(String(describing: documentMetadata)), jobStatus: \(String(describing: jobStatus)), nextToken: \(String(describing: nextToken)), statusMessage: \(String(describing: statusMessage)), warnings: \(String(describing: warnings)))"}
}

extension GetDocumentTextDetectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentTextDetectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blocks = output.blocks
            self.detectDocumentTextModelVersion = output.detectDocumentTextModelVersion
            self.documentMetadata = output.documentMetadata
            self.jobStatus = output.jobStatus
            self.nextToken = output.nextToken
            self.statusMessage = output.statusMessage
            self.warnings = output.warnings
        } else {
            self.blocks = nil
            self.detectDocumentTextModelVersion = nil
            self.documentMetadata = nil
            self.jobStatus = nil
            self.nextToken = nil
            self.statusMessage = nil
            self.warnings = nil
        }
    }
}

public struct GetDocumentTextDetectionOutputResponse: Equatable {
    /// <p>The results of the text-detection operation.</p>
    public let blocks: [Block]?
    /// <p></p>
    public let detectDocumentTextModelVersion: String?
    /// <p>Information about a document that Amazon Textract processed. <code>DocumentMetadata</code> is
    ///          returned in every page of paginated responses from an Amazon Textract video operation.</p>
    public let documentMetadata: DocumentMetadata?
    /// <p>The current status of the text detection job.</p>
    public let jobStatus: JobStatus?
    /// <p>If the response is truncated, Amazon Textract returns this token. You can use this token in
    ///          the subsequent request to retrieve the next set of text-detection results.</p>
    public let nextToken: String?
    /// <p>Returns if the detection job could not be completed. Contains explanation for what error occured. </p>
    public let statusMessage: String?
    /// <p>A list of warnings that occurred during the text-detection operation for the
    ///          document.</p>
    public let warnings: [Warning]?

    public init (
        blocks: [Block]? = nil,
        detectDocumentTextModelVersion: String? = nil,
        documentMetadata: DocumentMetadata? = nil,
        jobStatus: JobStatus? = nil,
        nextToken: String? = nil,
        statusMessage: String? = nil,
        warnings: [Warning]? = nil
    )
    {
        self.blocks = blocks
        self.detectDocumentTextModelVersion = detectDocumentTextModelVersion
        self.documentMetadata = documentMetadata
        self.jobStatus = jobStatus
        self.nextToken = nextToken
        self.statusMessage = statusMessage
        self.warnings = warnings
    }
}

struct GetDocumentTextDetectionOutputResponseBody: Equatable {
    public let documentMetadata: DocumentMetadata?
    public let jobStatus: JobStatus?
    public let nextToken: String?
    public let blocks: [Block]?
    public let warnings: [Warning]?
    public let statusMessage: String?
    public let detectDocumentTextModelVersion: String?
}

extension GetDocumentTextDetectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blocks = "Blocks"
        case detectDocumentTextModelVersion = "DetectDocumentTextModelVersion"
        case documentMetadata = "DocumentMetadata"
        case jobStatus = "JobStatus"
        case nextToken = "NextToken"
        case statusMessage = "StatusMessage"
        case warnings = "Warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentMetadataDecoded = try containerValues.decodeIfPresent(DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let blocksContainer = try containerValues.decodeIfPresent([Block?].self, forKey: .blocks)
        var blocksDecoded0:[Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([Warning?].self, forKey: .warnings)
        var warningsDecoded0:[Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let detectDocumentTextModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectDocumentTextModelVersion)
        detectDocumentTextModelVersion = detectDocumentTextModelVersionDecoded
    }
}

extension HumanLoopActivationOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case humanLoopActivationConditionsEvaluationResults = "HumanLoopActivationConditionsEvaluationResults"
        case humanLoopActivationReasons = "HumanLoopActivationReasons"
        case humanLoopArn = "HumanLoopArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let humanLoopActivationConditionsEvaluationResults = humanLoopActivationConditionsEvaluationResults {
            try encodeContainer.encode(humanLoopActivationConditionsEvaluationResults, forKey: .humanLoopActivationConditionsEvaluationResults)
        }
        if let humanLoopActivationReasons = humanLoopActivationReasons {
            var humanLoopActivationReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .humanLoopActivationReasons)
            for humanloopactivationreasons0 in humanLoopActivationReasons {
                try humanLoopActivationReasonsContainer.encode(humanloopactivationreasons0)
            }
        }
        if let humanLoopArn = humanLoopArn {
            try encodeContainer.encode(humanLoopArn, forKey: .humanLoopArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
        let humanLoopActivationReasonsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .humanLoopActivationReasons)
        var humanLoopActivationReasonsDecoded0:[String]? = nil
        if let humanLoopActivationReasonsContainer = humanLoopActivationReasonsContainer {
            humanLoopActivationReasonsDecoded0 = [String]()
            for string0 in humanLoopActivationReasonsContainer {
                if let string0 = string0 {
                    humanLoopActivationReasonsDecoded0?.append(string0)
                }
            }
        }
        humanLoopActivationReasons = humanLoopActivationReasonsDecoded0
        let humanLoopActivationConditionsEvaluationResultsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopActivationConditionsEvaluationResults)
        humanLoopActivationConditionsEvaluationResults = humanLoopActivationConditionsEvaluationResultsDecoded
    }
}

extension HumanLoopActivationOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopActivationOutput(humanLoopActivationConditionsEvaluationResults: \(String(describing: humanLoopActivationConditionsEvaluationResults)), humanLoopActivationReasons: \(String(describing: humanLoopActivationReasons)), humanLoopArn: \(String(describing: humanLoopArn)))"}
}

/// <p>Shows the results of the human in the loop evaluation. If there is no HumanLoopArn, the input
///          did not trigger human review.</p>
public struct HumanLoopActivationOutput: Equatable {
    /// <p>Shows the result of condition evaluations, including those conditions which activated a human review.</p>
    public let humanLoopActivationConditionsEvaluationResults: String?
    /// <p>Shows if and why human review was needed.</p>
    public let humanLoopActivationReasons: [String]?
    /// <p>The Amazon Resource Name (ARN) of the HumanLoop created.</p>
    public let humanLoopArn: String?

    public init (
        humanLoopActivationConditionsEvaluationResults: String? = nil,
        humanLoopActivationReasons: [String]? = nil,
        humanLoopArn: String? = nil
    )
    {
        self.humanLoopActivationConditionsEvaluationResults = humanLoopActivationConditionsEvaluationResults
        self.humanLoopActivationReasons = humanLoopActivationReasons
        self.humanLoopArn = humanLoopArn
    }
}

extension HumanLoopConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAttributes = dataAttributes {
            try encodeContainer.encode(dataAttributes, forKey: .dataAttributes)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let dataAttributesDecoded = try containerValues.decodeIfPresent(HumanLoopDataAttributes.self, forKey: .dataAttributes)
        dataAttributes = dataAttributesDecoded
    }
}

extension HumanLoopConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopConfig(dataAttributes: \(String(describing: dataAttributes)), flowDefinitionArn: \(String(describing: flowDefinitionArn)), humanLoopName: \(String(describing: humanLoopName)))"}
}

/// <p>Sets up the human review workflow the document will be sent to if one of the conditions is met. You can also set certain attributes
///          of the image before review. </p>
public struct HumanLoopConfig: Equatable {
    /// <p>Sets attributes of the input data.</p>
    public let dataAttributes: HumanLoopDataAttributes?
    /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
    public let flowDefinitionArn: String?
    /// <p>The name of the human workflow used for this image. This should be kept unique within a region.</p>
    public let humanLoopName: String?

    public init (
        dataAttributes: HumanLoopDataAttributes? = nil,
        flowDefinitionArn: String? = nil,
        humanLoopName: String? = nil
    )
    {
        self.dataAttributes = dataAttributes
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopName = humanLoopName
    }
}

extension HumanLoopDataAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentClassifiers = "ContentClassifiers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentClassifiers = contentClassifiers {
            var contentClassifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentClassifiers)
            for contentclassifiers0 in contentClassifiers {
                try contentClassifiersContainer.encode(contentclassifiers0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentClassifiersContainer = try containerValues.decodeIfPresent([ContentClassifier?].self, forKey: .contentClassifiers)
        var contentClassifiersDecoded0:[ContentClassifier]? = nil
        if let contentClassifiersContainer = contentClassifiersContainer {
            contentClassifiersDecoded0 = [ContentClassifier]()
            for string0 in contentClassifiersContainer {
                if let string0 = string0 {
                    contentClassifiersDecoded0?.append(string0)
                }
            }
        }
        contentClassifiers = contentClassifiersDecoded0
    }
}

extension HumanLoopDataAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopDataAttributes(contentClassifiers: \(String(describing: contentClassifiers)))"}
}

/// <p>Allows you to set attributes of the image. Currently, you can declare an image as free of
///          personally identifiable information and adult content. </p>
public struct HumanLoopDataAttributes: Equatable {
    /// <p>Sets whether the input image is free of personally identifiable information or adult content.</p>
    public let contentClassifiers: [ContentClassifier]?

    public init (
        contentClassifiers: [ContentClassifier]? = nil
    )
    {
        self.contentClassifiers = contentClassifiers
    }
}

extension HumanLoopQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopQuotaExceededException(code: \(String(describing: code)), message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension HumanLoopQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: HumanLoopQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.code = nil
            self.message = nil
            self.quotaCode = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates you have exceeded the maximum number of active human in the loop workflows available</p>
public struct HumanLoopQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?
    /// <p>The quota code.</p>
    public var quotaCode: String?
    /// <p>The resource type.</p>
    public var resourceType: String?
    /// <p>The service code.</p>
    public var serviceCode: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        quotaCode: String? = nil,
        resourceType: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.quotaCode = quotaCode
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct HumanLoopQuotaExceededExceptionBody: Equatable {
    public let resourceType: String?
    public let quotaCode: String?
    public let serviceCode: String?
    public let message: String?
    public let code: String?
}

extension HumanLoopQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension IdempotentParameterMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotentParameterMismatchException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension IdempotentParameterMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at
///          least one of the other input parameters is different from the previous call to the
///          operation. </p>
public struct IdempotentParameterMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension IdempotentParameterMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract experienced a service issue. Try your call again.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidJobIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidJobIdException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidJobIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidJobIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid job identifier was passed to <a>GetDocumentAnalysis</a> or to
///       <a>GetDocumentAnalysis</a>.</p>
public struct InvalidJobIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidJobIdExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InvalidJobIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidKMSKeyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidKMSKeyException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidKMSKeyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidKMSKeyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Indicates you do not have decrypt permissions with the KMS key entered, or the KMS key
///         was entered incorrectly. </p>
public struct InvalidKMSKeyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidKMSKeyExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InvalidKMSKeyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An input parameter violated a constraint. For example, in synchronous operations,
///        an <code>InvalidParameterException</code> exception occurs
///       when neither of the <code>S3Object</code> or <code>Bytes</code> values are supplied in the <code>Document</code>
///       request parameter.
///        Validate your parameter before calling the API operation again.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidS3ObjectException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3ObjectException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidS3ObjectException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidS3ObjectExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract is unable to access the S3 object that's specified in the request.
///          for more information, <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html">Configure Access to Amazon S3</a>
///          For troubleshooting information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/troubleshooting.html">Troubleshooting Amazon S3</a>
///          </p>
public struct InvalidS3ObjectException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidS3ObjectExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InvalidS3ObjectExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

public enum JobStatus {
    case failed
    case inProgress
    case partialSuccess
    case succeeded
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .failed,
            .inProgress,
            .partialSuccess,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .partialSuccess: return "PARTIAL_SUCCESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Textract service limit was exceeded. For example, if you start too many
///          asynchronous jobs concurrently, calls to start operations
///             (<code>StartDocumentTextDetection</code>, for example) raise a LimitExceededException
///          exception (HTTP status code: 400) until the number of concurrently running jobs is below
///          the Amazon Textract service limit. </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NotificationChannel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case sNSTopicArn = "SNSTopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sNSTopicArn = sNSTopicArn {
            try encodeContainer.encode(sNSTopicArn, forKey: .sNSTopicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNSTopicArn)
        sNSTopicArn = sNSTopicArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension NotificationChannel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationChannel(roleArn: \(String(describing: roleArn)), sNSTopicArn: \(String(describing: sNSTopicArn)))"}
}

/// <p>The Amazon Simple Notification Service (Amazon SNS) topic to which Amazon Textract publishes the completion status of
///          an asynchronous document operation, such as <a>StartDocumentTextDetection</a>. </p>
public struct NotificationChannel: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an IAM role that gives Amazon Textract publishing permissions to the Amazon SNS topic. </p>
    public let roleArn: String?
    /// <p>The Amazon SNS topic that Amazon Textract posts the completion status to.</p>
    public let sNSTopicArn: String?

    public init (
        roleArn: String? = nil,
        sNSTopicArn: String? = nil
    )
    {
        self.roleArn = roleArn
        self.sNSTopicArn = sNSTopicArn
    }
}

extension OutputConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension OutputConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputConfig(s3Bucket: \(String(describing: s3Bucket)), s3Prefix: \(String(describing: s3Prefix)))"}
}

/// <p>Sets whether or not your output will go to a user created bucket.
///          Used to set the name of the bucket, and the prefix on the output
///          file.</p>
public struct OutputConfig: Equatable {
    /// <p>The name of the bucket your output will go to.</p>
    public let s3Bucket: String?
    /// <p>The prefix of the object key that the output will be saved to. When
    ///          not enabled, the prefix will be “textract_output".</p>
    public let s3Prefix: String?

    public init (
        s3Bucket: String? = nil,
        s3Prefix: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }
}

extension Point: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case x = "X"
        case y = "Y"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if x != 0.0 {
            try encodeContainer.encode(x, forKey: .x)
        }
        if y != 0.0 {
            try encodeContainer.encode(y, forKey: .y)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xDecoded = try containerValues.decode(Float.self, forKey: .x)
        x = xDecoded
        let yDecoded = try containerValues.decode(Float.self, forKey: .y)
        y = yDecoded
    }
}

extension Point: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Point(x: \(String(describing: x)), y: \(String(describing: y)))"}
}

/// <p>The X and Y coordinates of a point on a document page. The X and Y
///          values that are returned are ratios of the overall document page size. For example, if the
///          input document is 700 x 200 and the operation returns X=0.5 and Y=0.25, then the point is
///          at the (350,50) pixel coordinate on the document page.</p>
///
///          <p>An array of <code>Point</code> objects, <code>Polygon</code>, is returned
///          by <a>DetectDocumentText</a>. <code>Polygon</code> represents a fine-grained
///          polygon around detected text. For more information, see Geometry in the Amazon Textract
///          Developer Guide. </p>
public struct Point: Equatable {
    /// <p>The value of the X coordinate for a point on a <code>Polygon</code>.</p>
    public let x: Float
    /// <p>The value of the Y coordinate for a point on a <code>Polygon</code>.</p>
    public let y: Float

    public init (
        x: Float = 0.0,
        y: Float = 0.0
    )
    {
        self.x = x
        self.y = y
    }
}

extension ProvisionedThroughputExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedThroughputExceededException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ProvisionedThroughputExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of requests exceeded your throughput limit. If you want to increase this limit,
///          contact Amazon Textract.</p>
public struct ProvisionedThroughputExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ProvisionedThroughputExceededExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ProvisionedThroughputExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension Relationship: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ids = "Ids"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for idlist0 in ids {
                try idsContainer.encode(idlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(RelationshipType.self, forKey: .type)
        type = typeDecoded
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension Relationship: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Relationship(ids: \(String(describing: ids)), type: \(String(describing: type)))"}
}

/// <p>Information about how blocks are related to each other. A <code>Block</code> object
///          contains 0 or more <code>Relation</code> objects in a list, <code>Relationships</code>. For
///          more information, see <a>Block</a>.</p>
///          <p>The <code>Type</code> element provides the type of the relationship for all blocks in
///          the <code>IDs</code> array. </p>
public struct Relationship: Equatable {
    /// <p>An
    ///          array of IDs for related blocks. You can get the type of the relationship from the
    ///             <code>Type</code> element.</p>
    public let ids: [String]?
    /// <p>The type of relationship that the blocks in the IDs array have with the current block.
    ///          The relationship can be <code>VALUE</code> or <code>CHILD</code>. A relationship of type
    ///          VALUE is a list that contains the ID of the VALUE block that's associated with the KEY of a key-value pair.
    ///          A relationship of type CHILD is a list of IDs that identify WORD blocks in the case of lines
    ///          Cell blocks in the case of Tables, and WORD blocks in the case of Selection Elements.</p>
    public let type: RelationshipType?

    public init (
        ids: [String]? = nil,
        type: RelationshipType? = nil
    )
    {
        self.ids = ids
        self.type = type
    }
}

public enum RelationshipType {
    case child
    case complexFeatures
    case value
    case sdkUnknown(String)
}

extension RelationshipType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RelationshipType] {
        return [
            .child,
            .complexFeatures,
            .value,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .child: return "CHILD"
        case .complexFeatures: return "COMPLEX_FEATURES"
        case .value: return "VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RelationshipType(rawValue: rawValue) ?? RelationshipType.sdkUnknown(rawValue)
    }
}

extension S3Object: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension S3Object: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Object(bucket: \(String(describing: bucket)), name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>The S3 bucket name and file name that identifies the document.</p>
///          <p>The AWS Region for the S3 bucket that contains the document must match the Region that
///          you use for Amazon Textract operations.</p>
///
///          <p>For Amazon Textract to process a file in an S3 bucket, the user must have
///          permission to access the S3 bucket and file.
///
///       </p>
public struct S3Object: Equatable {
    /// <p>The name of the S3 bucket.</p>
    public let bucket: String?
    /// <p>The file name of the input document. Synchronous operations can use image files that are
    ///          in JPEG or PNG format. Asynchronous operations also support PDF format files.</p>
    public let name: String?
    /// <p>If the bucket has versioning enabled, you can specify the object version. </p>
    public let version: String?

    public init (
        bucket: String? = nil,
        name: String? = nil,
        version: String? = nil
    )
    {
        self.bucket = bucket
        self.name = name
        self.version = version
    }
}

public enum SelectionStatus {
    case notSelected
    case selected
    case sdkUnknown(String)
}

extension SelectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SelectionStatus] {
        return [
            .notSelected,
            .selected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notSelected: return "NOT_SELECTED"
        case .selected: return "SELECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SelectionStatus(rawValue: rawValue) ?? SelectionStatus.sdkUnknown(rawValue)
    }
}

public struct StartDocumentAnalysisInputBodyMiddleware: Middleware {
    public let id: String = "StartDocumentAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentAnalysisInput>
    public typealias MOutput = OperationOutput<StartDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentAnalysisOutputError>
}

extension StartDocumentAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDocumentAnalysisInput(clientRequestToken: \(String(describing: clientRequestToken)), documentLocation: \(String(describing: documentLocation)), featureTypes: \(String(describing: featureTypes)), jobTag: \(String(describing: jobTag)), kMSKeyId: \(String(describing: kMSKeyId)), notificationChannel: \(String(describing: notificationChannel)), outputConfig: \(String(describing: outputConfig)))"}
}

extension StartDocumentAnalysisInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case featureTypes = "FeatureTypes"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let documentLocation = documentLocation {
            try encodeContainer.encode(documentLocation, forKey: .documentLocation)
        }
        if let featureTypes = featureTypes {
            var featureTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featureTypes)
            for featuretypes0 in featureTypes {
                try featureTypesContainer.encode(featuretypes0.rawValue)
            }
        }
        if let jobTag = jobTag {
            try encodeContainer.encode(jobTag, forKey: .jobTag)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
        if let notificationChannel = notificationChannel {
            try encodeContainer.encode(notificationChannel, forKey: .notificationChannel)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

public struct StartDocumentAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "StartDocumentAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentAnalysisInput>
    public typealias MOutput = OperationOutput<StartDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentAnalysisOutputError>
}

public struct StartDocumentAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDocumentAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentAnalysisInput>
    public typealias MOutput = OperationOutput<StartDocumentAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentAnalysisOutputError>
}

public struct StartDocumentAnalysisInput: Equatable {
    /// <p>The idempotent token that you use to identify the start request. If you use the same
    ///          token with multiple <code>StartDocumentAnalysis</code> requests, the same
    ///             <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same
    ///          job from being accidentally started more than once. For more information, see
    ///          <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a>.</p>
    public let clientRequestToken: String?
    /// <p>The location of the document to be processed.</p>
    public let documentLocation: DocumentLocation?
    /// <p>A list of the types of analysis to perform. Add TABLES to the list to return information
    ///          about the tables that are detected in the input document. Add FORMS to return detected
    ///          form data. To perform both types of analysis, add TABLES
    ///          and FORMS to <code>FeatureTypes</code>. All lines and words detected in the document are
    ///          included in the response (including text that isn't related to the value of
    ///             <code>FeatureTypes</code>). </p>
    public let featureTypes: [FeatureType]?
    /// <p>An identifier that you specify that's included in the completion notification published
    ///          to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of
    ///          document that the completion notification corresponds to (such as a tax form or a
    ///          receipt).</p>
    public let jobTag: String?
    /// <p>The KMS key used to encrypt the inference results. This can be
    ///          in either Key ID or Key Alias format. When a KMS key is provided, the
    ///          KMS key will be used for server-side encryption of the objects in the
    ///          customer bucket. When this parameter is not enabled, the result will
    ///          be encrypted server side,using SSE-S3.</p>
    public let kMSKeyId: String?
    /// <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the
    ///          operation to. </p>
    public let notificationChannel: NotificationChannel?
    /// <p>Sets if the output will go to a customer defined bucket. By default, Amazon Textract will save
    ///          the results internally to be accessed by the GetDocumentAnalysis operation.</p>
    public let outputConfig: OutputConfig?

    public init (
        clientRequestToken: String? = nil,
        documentLocation: DocumentLocation? = nil,
        featureTypes: [FeatureType]? = nil,
        jobTag: String? = nil,
        kMSKeyId: String? = nil,
        notificationChannel: NotificationChannel? = nil,
        outputConfig: OutputConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.documentLocation = documentLocation
        self.featureTypes = featureTypes
        self.jobTag = jobTag
        self.kMSKeyId = kMSKeyId
        self.notificationChannel = notificationChannel
        self.outputConfig = outputConfig
    }
}

struct StartDocumentAnalysisInputBody: Equatable {
    public let documentLocation: DocumentLocation?
    public let featureTypes: [FeatureType]?
    public let clientRequestToken: String?
    public let jobTag: String?
    public let notificationChannel: NotificationChannel?
    public let outputConfig: OutputConfig?
    public let kMSKeyId: String?
}

extension StartDocumentAnalysisInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case featureTypes = "FeatureTypes"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentLocationDecoded = try containerValues.decodeIfPresent(DocumentLocation.self, forKey: .documentLocation)
        documentLocation = documentLocationDecoded
        let featureTypesContainer = try containerValues.decodeIfPresent([FeatureType?].self, forKey: .featureTypes)
        var featureTypesDecoded0:[FeatureType]? = nil
        if let featureTypesContainer = featureTypesContainer {
            featureTypesDecoded0 = [FeatureType]()
            for string0 in featureTypesContainer {
                if let string0 = string0 {
                    featureTypesDecoded0?.append(string0)
                }
            }
        }
        featureTypes = featureTypesDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let jobTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTag)
        jobTag = jobTagDecoded
        let notificationChannelDecoded = try containerValues.decodeIfPresent(NotificationChannel.self, forKey: .notificationChannel)
        notificationChannel = notificationChannelDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
    }
}

extension StartDocumentAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDocumentAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKMSKeyException" : self = .invalidKMSKeyException(try InvalidKMSKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDocumentAnalysisOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerError(InternalServerError)
    case invalidKMSKeyException(InvalidKMSKeyException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case limitExceededException(LimitExceededException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDocumentAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDocumentAnalysisOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartDocumentAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDocumentAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartDocumentAnalysisOutputResponse: Equatable {
    /// <p>The identifier for the document text detection job. Use <code>JobId</code> to identify
    ///          the job in a subsequent call to <code>GetDocumentAnalysis</code>. A <code>JobId</code> value
    ///          is only valid for 7 days.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartDocumentAnalysisOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartDocumentAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartDocumentTextDetectionInputBodyMiddleware: Middleware {
    public let id: String = "StartDocumentTextDetectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentTextDetectionInput>
    public typealias MOutput = OperationOutput<StartDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentTextDetectionOutputError>
}

extension StartDocumentTextDetectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDocumentTextDetectionInput(clientRequestToken: \(String(describing: clientRequestToken)), documentLocation: \(String(describing: documentLocation)), jobTag: \(String(describing: jobTag)), kMSKeyId: \(String(describing: kMSKeyId)), notificationChannel: \(String(describing: notificationChannel)), outputConfig: \(String(describing: outputConfig)))"}
}

extension StartDocumentTextDetectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let documentLocation = documentLocation {
            try encodeContainer.encode(documentLocation, forKey: .documentLocation)
        }
        if let jobTag = jobTag {
            try encodeContainer.encode(jobTag, forKey: .jobTag)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
        if let notificationChannel = notificationChannel {
            try encodeContainer.encode(notificationChannel, forKey: .notificationChannel)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

public struct StartDocumentTextDetectionInputHeadersMiddleware: Middleware {
    public let id: String = "StartDocumentTextDetectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentTextDetectionInput>
    public typealias MOutput = OperationOutput<StartDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentTextDetectionOutputError>
}

public struct StartDocumentTextDetectionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDocumentTextDetectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentTextDetectionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentTextDetectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentTextDetectionInput>
    public typealias MOutput = OperationOutput<StartDocumentTextDetectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentTextDetectionOutputError>
}

public struct StartDocumentTextDetectionInput: Equatable {
    /// <p>The idempotent token that's used to identify the start request. If you use the same
    ///          token with multiple <code>StartDocumentTextDetection</code> requests, the same
    ///             <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same
    ///          job from being accidentally started more than once. For more information, see
    ///          <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a>.</p>
    public let clientRequestToken: String?
    /// <p>The location of the document to be processed.</p>
    public let documentLocation: DocumentLocation?
    /// <p>An identifier that you specify that's included in the completion notification published
    ///          to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of
    ///          document that the completion notification corresponds to (such as a tax form or a
    ///          receipt).</p>
    public let jobTag: String?
    /// <p>The KMS key used to encrypt the inference results. This can be
    ///          in either Key ID or Key Alias format. When a KMS key is provided, the
    ///          KMS key will be used for server-side encryption of the objects in the
    ///          customer bucket. When this parameter is not enabled, the result will
    ///          be encrypted server side,using SSE-S3.</p>
    public let kMSKeyId: String?
    /// <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the
    ///          operation to. </p>
    public let notificationChannel: NotificationChannel?
    /// <p>Sets if the output will go to a customer defined bucket. By default Amazon Textract will
    ///          save the results internally to be accessed with the GetDocumentTextDetection operation.</p>
    public let outputConfig: OutputConfig?

    public init (
        clientRequestToken: String? = nil,
        documentLocation: DocumentLocation? = nil,
        jobTag: String? = nil,
        kMSKeyId: String? = nil,
        notificationChannel: NotificationChannel? = nil,
        outputConfig: OutputConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.documentLocation = documentLocation
        self.jobTag = jobTag
        self.kMSKeyId = kMSKeyId
        self.notificationChannel = notificationChannel
        self.outputConfig = outputConfig
    }
}

struct StartDocumentTextDetectionInputBody: Equatable {
    public let documentLocation: DocumentLocation?
    public let clientRequestToken: String?
    public let jobTag: String?
    public let notificationChannel: NotificationChannel?
    public let outputConfig: OutputConfig?
    public let kMSKeyId: String?
}

extension StartDocumentTextDetectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case documentLocation = "DocumentLocation"
        case jobTag = "JobTag"
        case kMSKeyId = "KMSKeyId"
        case notificationChannel = "NotificationChannel"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentLocationDecoded = try containerValues.decodeIfPresent(DocumentLocation.self, forKey: .documentLocation)
        documentLocation = documentLocationDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let jobTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTag)
        jobTag = jobTagDecoded
        let notificationChannelDecoded = try containerValues.decodeIfPresent(NotificationChannel.self, forKey: .notificationChannel)
        notificationChannel = notificationChannelDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
    }
}

extension StartDocumentTextDetectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDocumentTextDetectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadDocumentException" : self = .badDocumentException(try BadDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentTooLargeException" : self = .documentTooLargeException(try DocumentTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKMSKeyException" : self = .invalidKMSKeyException(try InvalidKMSKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ObjectException" : self = .invalidS3ObjectException(try InvalidS3ObjectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentException" : self = .unsupportedDocumentException(try UnsupportedDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDocumentTextDetectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badDocumentException(BadDocumentException)
    case documentTooLargeException(DocumentTooLargeException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerError(InternalServerError)
    case invalidKMSKeyException(InvalidKMSKeyException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3ObjectException(InvalidS3ObjectException)
    case limitExceededException(LimitExceededException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case throttlingException(ThrottlingException)
    case unsupportedDocumentException(UnsupportedDocumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDocumentTextDetectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDocumentTextDetectionOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartDocumentTextDetectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDocumentTextDetectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartDocumentTextDetectionOutputResponse: Equatable {
    /// <p>The identifier of the text detection job for the document. Use <code>JobId</code> to
    ///          identify the job in a subsequent call to <code>GetDocumentTextDetection</code>.
    ///          A <code>JobId</code> value is only valid for 7 days.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartDocumentTextDetectionOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartDocumentTextDetectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public enum TextType {
    case handwriting
    case printed
    case sdkUnknown(String)
}

extension TextType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TextType] {
        return [
            .handwriting,
            .printed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .handwriting: return "HANDWRITING"
        case .printed: return "PRINTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TextType(rawValue: rawValue) ?? TextType.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Textract is temporarily unable to process the request. Try your call again.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UnsupportedDocumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedDocumentException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension UnsupportedDocumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedDocumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The format of the input document isn't supported. Documents for synchronous operations can be in
///          PNG or JPEG format. Documents for asynchronous operations can also be in PDF format.</p>
public struct UnsupportedDocumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnsupportedDocumentExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension UnsupportedDocumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension Warning: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case pages = "Pages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let pages = pages {
            var pagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pages)
            for pages0 in pages {
                try pagesContainer.encode(pages0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let pagesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .pages)
        var pagesDecoded0:[Int]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [Int]()
            for integer0 in pagesContainer {
                if let integer0 = integer0 {
                    pagesDecoded0?.append(integer0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

extension Warning: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Warning(errorCode: \(String(describing: errorCode)), pages: \(String(describing: pages)))"}
}

/// <p>A warning about an issue that occurred during asynchronous text analysis (<a>StartDocumentAnalysis</a>) or asynchronous document text detection (<a>StartDocumentTextDetection</a>). </p>
public struct Warning: Equatable {
    /// <p>The error code for the warning.</p>
    public let errorCode: String?
    /// <p>A list of the pages that the warning applies to.</p>
    public let pages: [Int]?

    public init (
        errorCode: String? = nil,
        pages: [Int]? = nil
    )
    {
        self.errorCode = errorCode
        self.pages = pages
    }
}
