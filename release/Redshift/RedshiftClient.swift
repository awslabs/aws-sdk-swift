// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class RedshiftClient {
    let client: ClientRuntime.SdkHttpClient
    let config: AWSClientRuntime.AWSClientConfiguration
    let serviceName = "Redshift"
    let encoder: ClientRuntime.RequestEncoder
    let decoder: ClientRuntime.ResponseDecoder

    public init(config: AWSClientRuntime.AWSClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = ClientRuntime.FormURLEncoder()
        self.encoder = config.encoder ?? encoder
        let decoder = ClientRuntime.XMLDecoder()
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: Swift.String? = nil) throws {
        let unwrappedRegion = region ?? "us-east-1"
        let config = try RedshiftClientConfiguration(region: unwrappedRegion)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class RedshiftClientConfiguration: AWSClientRuntime.AWSClientConfiguration {

        public var clientLogMode: ClientRuntime.ClientLogMode
        public var decoder: ClientRuntime.ResponseDecoder?
        public var encoder: ClientRuntime.RequestEncoder?
        public var httpClientConfiguration: ClientRuntime.HttpClientConfiguration
        public var httpClientEngine: ClientRuntime.HttpClientEngine
        public var idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator
        public var logger: ClientRuntime.LogAgent
        public var retrier: ClientRuntime.Retrier

        public var credentialsProvider: AWSClientRuntime.AWSCredentialsProvider
        public var endpointResolver: AWSClientRuntime.EndpointResolver
        public var region: Swift.String
        public var signingRegion: Swift.String

        public init(
            credentialsProvider: AWSClientRuntime.AWSCredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String,
            signingRegion: Swift.String? = nil,
            runtimeConfig: ClientRuntime.SDKRuntimeConfiguration
        ) throws {
            self.region = region
            self.signingRegion = signingRegion ?? region
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = credProvider
            } else {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retrier = runtimeConfig.retrier
        }

        public convenience init(
            credentialsProvider: AWSClientRuntime.AWSCredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String,
            signingRegion: Swift.String? = nil
        ) throws {
            let defaultRuntimeConfig = try ClientRuntime.DefaultSDKRuntimeConfiguration("RedshiftClient")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct RedshiftClientLogHandlerFactory: ClientRuntime.SDKLogHandlerFactory {
    public var label = "RedshiftClient"
    let logLevel: ClientRuntime.SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: ClientRuntime.SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension RedshiftClient: RedshiftClientProtocol {
    /// <p>Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the
    ///             configuration (term, payment type, or number of nodes) and no additional costs.
    ///         </p>
    public func acceptReservedNodeExchange(input: AcceptReservedNodeExchangeInput, completion: @escaping (ClientRuntime.SdkResult<AcceptReservedNodeExchangeOutputResponse, AcceptReservedNodeExchangeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "acceptReservedNodeExchange")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AcceptReservedNodeExchangeInput, AcceptReservedNodeExchangeOutputResponse, AcceptReservedNodeExchangeOutputError>(id: "acceptReservedNodeExchange")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AcceptReservedNodeExchangeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AcceptReservedNodeExchangeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AcceptReservedNodeExchangeInput, AcceptReservedNodeExchangeOutputResponse, AcceptReservedNodeExchangeOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: AcceptReservedNodeExchangeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a partner integration to a cluster.
    ///             This operation authorizes a partner to push status updates for the specified database.
    ///             To complete the integration, you also set up the integration on the partner website.</p>
    public func addPartner(input: AddPartnerInput, completion: @escaping (ClientRuntime.SdkResult<AddPartnerOutputResponse, AddPartnerOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addPartner")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddPartnerInput, AddPartnerOutputResponse, AddPartnerOutputError>(id: "addPartner")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddPartnerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddPartnerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddPartnerInput, AddPartnerOutputResponse, AddPartnerOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: AddPartnerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether
    ///             the application accessing your cluster is running on the Internet or an Amazon EC2
    ///             instance, you can authorize inbound access to either a Classless Interdomain Routing
    ///             (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as
    ///             many as 20 ingress rules to an Amazon Redshift security group.</p>
    ///         <p>If you authorize access to an Amazon EC2 security group, specify
    ///                 <i>EC2SecurityGroupName</i> and
    ///                 <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and
    ///             Amazon Redshift cluster must be in the same AWS Region. </p>
    ///         <p>If you authorize access to a CIDR/IP address range, specify
    ///                 <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia
    ///             article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p>
    ///         <p>You must also associate the security group with a cluster so that clients running
    ///             on these IP addresses or the EC2 instance are authorized to connect to the cluster. For
    ///             information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security
    ///                 Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func authorizeClusterSecurityGroupIngress(input: AuthorizeClusterSecurityGroupIngressInput, completion: @escaping (ClientRuntime.SdkResult<AuthorizeClusterSecurityGroupIngressOutputResponse, AuthorizeClusterSecurityGroupIngressOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "authorizeClusterSecurityGroupIngress")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AuthorizeClusterSecurityGroupIngressInput, AuthorizeClusterSecurityGroupIngressOutputResponse, AuthorizeClusterSecurityGroupIngressOutputError>(id: "authorizeClusterSecurityGroupIngress")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeClusterSecurityGroupIngressInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeClusterSecurityGroupIngressInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AuthorizeClusterSecurityGroupIngressInput, AuthorizeClusterSecurityGroupIngressOutputResponse, AuthorizeClusterSecurityGroupIngressOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeClusterSecurityGroupIngressInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Grants access to a cluster.</p>
    public func authorizeEndpointAccess(input: AuthorizeEndpointAccessInput, completion: @escaping (ClientRuntime.SdkResult<AuthorizeEndpointAccessOutputResponse, AuthorizeEndpointAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "authorizeEndpointAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AuthorizeEndpointAccessInput, AuthorizeEndpointAccessOutputResponse, AuthorizeEndpointAccessOutputError>(id: "authorizeEndpointAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeEndpointAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeEndpointAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AuthorizeEndpointAccessInput, AuthorizeEndpointAccessOutputResponse, AuthorizeEndpointAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeEndpointAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Authorizes the specified AWS customer account to restore the specified
    ///             snapshot.</p>
    ///         <p>
    /// For more information about working with snapshots, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func authorizeSnapshotAccess(input: AuthorizeSnapshotAccessInput, completion: @escaping (ClientRuntime.SdkResult<AuthorizeSnapshotAccessOutputResponse, AuthorizeSnapshotAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "authorizeSnapshotAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AuthorizeSnapshotAccessInput, AuthorizeSnapshotAccessOutputResponse, AuthorizeSnapshotAccessOutputError>(id: "authorizeSnapshotAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeSnapshotAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeSnapshotAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AuthorizeSnapshotAccessInput, AuthorizeSnapshotAccessOutputResponse, AuthorizeSnapshotAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: AuthorizeSnapshotAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a set of cluster snapshots.</p>
    public func batchDeleteClusterSnapshots(input: BatchDeleteClusterSnapshotsInput, completion: @escaping (ClientRuntime.SdkResult<BatchDeleteClusterSnapshotsOutputResponse, BatchDeleteClusterSnapshotsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchDeleteClusterSnapshots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchDeleteClusterSnapshotsInput, BatchDeleteClusterSnapshotsOutputResponse, BatchDeleteClusterSnapshotsOutputError>(id: "batchDeleteClusterSnapshots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteClusterSnapshotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteClusterSnapshotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchDeleteClusterSnapshotsInput, BatchDeleteClusterSnapshotsOutputResponse, BatchDeleteClusterSnapshotsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteClusterSnapshotsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the settings for a set of cluster snapshots.</p>
    public func batchModifyClusterSnapshots(input: BatchModifyClusterSnapshotsInput, completion: @escaping (ClientRuntime.SdkResult<BatchModifyClusterSnapshotsOutputResponse, BatchModifyClusterSnapshotsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchModifyClusterSnapshots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchModifyClusterSnapshotsInput, BatchModifyClusterSnapshotsOutputResponse, BatchModifyClusterSnapshotsOutputError>(id: "batchModifyClusterSnapshots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchModifyClusterSnapshotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchModifyClusterSnapshotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchModifyClusterSnapshotsInput, BatchModifyClusterSnapshotsOutputResponse, BatchModifyClusterSnapshotsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: BatchModifyClusterSnapshotsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels a resize operation for a cluster.</p>
    public func cancelResize(input: CancelResizeInput, completion: @escaping (ClientRuntime.SdkResult<CancelResizeOutputResponse, CancelResizeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelResize")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelResizeInput, CancelResizeOutputResponse, CancelResizeOutputError>(id: "cancelResize")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelResizeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelResizeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelResizeInput, CancelResizeOutputResponse, CancelResizeOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CancelResizeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot.
    ///             The source must be an automated snapshot and it must be in the available
    ///             state.</p>
    ///         <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the
    ///             cluster. Also, when the retention period of the snapshot expires, Amazon Redshift
    ///             automatically deletes it. If you want to keep an automated snapshot for a longer period,
    ///             you can make a manual copy of the snapshot. Manual snapshots are retained until you
    ///             delete them.</p>
    ///         <p>
    /// For more information about working with snapshots, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func copyClusterSnapshot(input: CopyClusterSnapshotInput, completion: @escaping (ClientRuntime.SdkResult<CopyClusterSnapshotOutputResponse, CopyClusterSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "copyClusterSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CopyClusterSnapshotInput, CopyClusterSnapshotOutputResponse, CopyClusterSnapshotOutputError>(id: "copyClusterSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CopyClusterSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CopyClusterSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CopyClusterSnapshotInput, CopyClusterSnapshotOutputResponse, CopyClusterSnapshotOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CopyClusterSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new cluster with the specified parameters.</p>
    ///         <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster
    ///             subnet group name. The cluster subnet group identifies the subnets of your VPC that
    ///             Amazon Redshift uses when creating the cluster.
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func createCluster(input: CreateClusterInput, completion: @escaping (ClientRuntime.SdkResult<CreateClusterOutputResponse, CreateClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterInput, CreateClusterOutputResponse, CreateClusterOutputError>(id: "createCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterInput, CreateClusterOutputResponse, CreateClusterOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an Amazon Redshift parameter group.</p>
    ///         <p>Creating parameter groups is independent of creating clusters. You can associate a
    ///             cluster with a parameter group when you create the cluster. You can also associate an
    ///             existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p>
    ///         <p>Parameters in the parameter group define specific behavior that applies to the
    ///             databases you create on the cluster.
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func createClusterParameterGroup(input: CreateClusterParameterGroupInput, completion: @escaping (ClientRuntime.SdkResult<CreateClusterParameterGroupOutputResponse, CreateClusterParameterGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createClusterParameterGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterParameterGroupInput, CreateClusterParameterGroupOutputResponse, CreateClusterParameterGroupOutputError>(id: "createClusterParameterGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterParameterGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterParameterGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterParameterGroupInput, CreateClusterParameterGroupOutputResponse, CreateClusterParameterGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterParameterGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new Amazon Redshift security group. You use security groups to control access
    ///             to non-VPC clusters.</p>
    ///         <p>
    /// For information about managing security groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
    /// <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func createClusterSecurityGroup(input: CreateClusterSecurityGroupInput, completion: @escaping (ClientRuntime.SdkResult<CreateClusterSecurityGroupOutputResponse, CreateClusterSecurityGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createClusterSecurityGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterSecurityGroupInput, CreateClusterSecurityGroupOutputResponse, CreateClusterSecurityGroupOutputError>(id: "createClusterSecurityGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSecurityGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSecurityGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterSecurityGroupInput, CreateClusterSecurityGroupOutputResponse, CreateClusterSecurityGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSecurityGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a manual snapshot of the specified cluster. The cluster must be in the
    ///                 <code>available</code> state. </p>
    ///         <p>
    /// For more information about working with snapshots, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func createClusterSnapshot(input: CreateClusterSnapshotInput, completion: @escaping (ClientRuntime.SdkResult<CreateClusterSnapshotOutputResponse, CreateClusterSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createClusterSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterSnapshotInput, CreateClusterSnapshotOutputResponse, CreateClusterSnapshotOutputError>(id: "createClusterSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterSnapshotInput, CreateClusterSnapshotOutputResponse, CreateClusterSnapshotOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more
    ///             subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating
    ///             Amazon Redshift subnet group.</p>
    ///         <p>
    /// For information about subnet groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the
    /// <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func createClusterSubnetGroup(input: CreateClusterSubnetGroupInput, completion: @escaping (ClientRuntime.SdkResult<CreateClusterSubnetGroupOutputResponse, CreateClusterSubnetGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createClusterSubnetGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterSubnetGroupInput, CreateClusterSubnetGroupOutputResponse, CreateClusterSubnetGroupOutputError>(id: "createClusterSubnetGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSubnetGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSubnetGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterSubnetGroupInput, CreateClusterSubnetGroupOutputResponse, CreateClusterSubnetGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterSubnetGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a Redshift-managed VPC endpoint.</p>
    public func createEndpointAccess(input: CreateEndpointAccessInput, completion: @escaping (ClientRuntime.SdkResult<CreateEndpointAccessOutputResponse, CreateEndpointAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createEndpointAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateEndpointAccessInput, CreateEndpointAccessOutputResponse, CreateEndpointAccessOutputError>(id: "createEndpointAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateEndpointAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateEndpointAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateEndpointAccessInput, CreateEndpointAccessOutputResponse, CreateEndpointAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateEndpointAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN
    ///             (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console,
    ///             the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you
    ///             must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in
    ///             the SNS console.</p>
    ///         <p>You can specify the source type, and lists of Amazon Redshift source IDs, event
    ///             categories, and event severities. Notifications will be sent for all events you want
    ///             that match those criteria. For example, you can specify source type = cluster, source ID
    ///             = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity =
    ///             ERROR. The subscription will only send notifications for those ERROR events in the
    ///             Availability and Backup categories for the specified clusters.</p>
    ///         <p>If you specify both the source type and source IDs, such as source type = cluster
    ///             and source identifier = my-cluster-1, notifications will be sent for all the cluster
    ///             events for my-cluster-1. If you specify a source type but do not specify a source
    ///             identifier, you will receive notice of the events for the objects of that type in your
    ///             AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you
    ///             will be notified of events generated from all Amazon Redshift sources belonging to your AWS
    ///             account. You must specify a source type if you specify a source ID.</p>
    public func createEventSubscription(input: CreateEventSubscriptionInput, completion: @escaping (ClientRuntime.SdkResult<CreateEventSubscriptionOutputResponse, CreateEventSubscriptionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createEventSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateEventSubscriptionInput, CreateEventSubscriptionOutputResponse, CreateEventSubscriptionOutputError>(id: "createEventSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateEventSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateEventSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateEventSubscriptionInput, CreateEventSubscriptionOutputResponse, CreateEventSubscriptionOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateEventSubscriptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to
    ///             the client's HSM in order to store and retrieve the keys used to encrypt the cluster
    ///             databases.</p>
    ///         <p>The command returns a public key, which you must store in the HSM. In addition to
    ///             creating the HSM certificate, you must create an Amazon Redshift HSM configuration that
    ///             provides a cluster the information needed to store and use encryption keys in the HSM.
    ///             For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM">Hardware Security Modules</a>
    ///             in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func createHsmClientCertificate(input: CreateHsmClientCertificateInput, completion: @escaping (ClientRuntime.SdkResult<CreateHsmClientCertificateOutputResponse, CreateHsmClientCertificateOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createHsmClientCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateHsmClientCertificateInput, CreateHsmClientCertificateOutputResponse, CreateHsmClientCertificateOutputError>(id: "createHsmClientCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateHsmClientCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateHsmClientCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateHsmClientCertificateInput, CreateHsmClientCertificateOutputResponse, CreateHsmClientCertificateOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateHsmClientCertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an HSM configuration that contains the information required by an Amazon Redshift
    ///             cluster to store and use database encryption keys in a Hardware Security Module (HSM).
    ///             After creating the HSM configuration, you can specify it as a parameter when creating a
    ///             cluster. The cluster will then store its encryption keys in the HSM.</p>
    ///         <p>In addition to creating an HSM configuration, you must also create an HSM client
    ///             certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a>
    ///             in the Amazon Redshift Cluster Management Guide.</p>
    public func createHsmConfiguration(input: CreateHsmConfigurationInput, completion: @escaping (ClientRuntime.SdkResult<CreateHsmConfigurationOutputResponse, CreateHsmConfigurationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createHsmConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateHsmConfigurationInput, CreateHsmConfigurationOutputResponse, CreateHsmConfigurationOutputError>(id: "createHsmConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateHsmConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateHsmConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateHsmConfigurationInput, CreateHsmConfigurationOutputResponse, CreateHsmConfigurationOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateHsmConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action.
    ///             For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation.
    ///         </p>
    public func createScheduledAction(input: CreateScheduledActionInput, completion: @escaping (ClientRuntime.SdkResult<CreateScheduledActionOutputResponse, CreateScheduledActionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createScheduledAction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateScheduledActionInput, CreateScheduledActionOutputResponse, CreateScheduledActionOutputError>(id: "createScheduledAction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateScheduledActionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateScheduledActionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateScheduledActionInput, CreateScheduledActionOutputResponse, CreateScheduledActionOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateScheduledActionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key
    ///             (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a
    ///             destination region.</p>
    ///         <p>
    /// For more information about managing snapshot copy grants, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public func createSnapshotCopyGrant(input: CreateSnapshotCopyGrantInput, completion: @escaping (ClientRuntime.SdkResult<CreateSnapshotCopyGrantOutputResponse, CreateSnapshotCopyGrantOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSnapshotCopyGrant")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSnapshotCopyGrantInput, CreateSnapshotCopyGrantOutputResponse, CreateSnapshotCopyGrantOutputError>(id: "createSnapshotCopyGrant")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotCopyGrantInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotCopyGrantInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSnapshotCopyGrantInput, CreateSnapshotCopyGrantOutputResponse, CreateSnapshotCopyGrantOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotCopyGrantInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. </p>
    public func createSnapshotSchedule(input: CreateSnapshotScheduleInput, completion: @escaping (ClientRuntime.SdkResult<CreateSnapshotScheduleOutputResponse, CreateSnapshotScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSnapshotSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSnapshotScheduleInput, CreateSnapshotScheduleOutputResponse, CreateSnapshotScheduleOutputError>(id: "createSnapshotSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSnapshotScheduleInput, CreateSnapshotScheduleOutputResponse, CreateSnapshotScheduleOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds tags to a cluster.</p>
    ///         <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a
    ///             resource, you will receive an error and the attempt will fail.</p>
    ///         <p>If you specify a key that already exists for the resource, the value for that key
    ///             will be updated with the new value.</p>
    public func createTags(input: CreateTagsInput, completion: @escaping (ClientRuntime.SdkResult<CreateTagsOutputResponse, CreateTagsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTagsInput, CreateTagsOutputResponse, CreateTagsOutputError>(id: "createTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTagsInput, CreateTagsOutputResponse, CreateTagsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a usage limit for a specified Amazon Redshift feature on a cluster.
    ///             The usage limit is identified by the returned usage limit identifier.</p>
    public func createUsageLimit(input: CreateUsageLimitInput, completion: @escaping (ClientRuntime.SdkResult<CreateUsageLimitOutputResponse, CreateUsageLimitOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUsageLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUsageLimitInput, CreateUsageLimitOutputResponse, CreateUsageLimitOutputError>(id: "createUsageLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUsageLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUsageLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUsageLimitInput, CreateUsageLimitOutputResponse, CreateUsageLimitOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUsageLimitInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web
    ///             service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete
    ///             operation cannot be canceled or reverted once submitted.
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///         <p>If you want to shut down the cluster and retain it for future use, set
    ///                 <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a
    ///             name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this
    ///             snapshot to resume using the cluster. If a final cluster snapshot is requested, the
    ///             status of the cluster will be "final-snapshot" while the snapshot is being taken, then
    ///             it's "deleting" once Amazon Redshift begins deleting the cluster. </p>
    ///         <p>
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func deleteCluster(input: DeleteClusterInput, completion: @escaping (ClientRuntime.SdkResult<DeleteClusterOutputResponse, DeleteClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClusterInput, DeleteClusterOutputResponse, DeleteClusterOutputError>(id: "deleteCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteClusterInput, DeleteClusterOutputResponse, DeleteClusterOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specified Amazon Redshift parameter group.</p>
    ///         <note>
    ///             <p>You cannot delete a parameter group if it is associated with a
    ///                 cluster.</p>
    ///         </note>
    public func deleteClusterParameterGroup(input: DeleteClusterParameterGroupInput, completion: @escaping (ClientRuntime.SdkResult<DeleteClusterParameterGroupOutputResponse, DeleteClusterParameterGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteClusterParameterGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClusterParameterGroupInput, DeleteClusterParameterGroupOutputResponse, DeleteClusterParameterGroupOutputError>(id: "deleteClusterParameterGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterParameterGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterParameterGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteClusterParameterGroupInput, DeleteClusterParameterGroupOutputResponse, DeleteClusterParameterGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterParameterGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an Amazon Redshift security group.</p>
    ///         <note>
    ///             <p>You cannot delete a security group that is associated with any clusters. You
    ///                 cannot delete the default security group.</p>
    ///         </note>
    ///         <p>
    /// For information about managing security groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
    /// <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func deleteClusterSecurityGroup(input: DeleteClusterSecurityGroupInput, completion: @escaping (ClientRuntime.SdkResult<DeleteClusterSecurityGroupOutputResponse, DeleteClusterSecurityGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteClusterSecurityGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClusterSecurityGroupInput, DeleteClusterSecurityGroupOutputResponse, DeleteClusterSecurityGroupOutputError>(id: "deleteClusterSecurityGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSecurityGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSecurityGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteClusterSecurityGroupInput, DeleteClusterSecurityGroupOutputResponse, DeleteClusterSecurityGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSecurityGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified manual snapshot. The snapshot must be in the
    ///                 <code>available</code> state, with no other users authorized to access the snapshot. </p>
    ///         <p>Unlike automated snapshots, manual snapshots are retained even after you delete
    ///             your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual
    ///             snapshot explicitly to avoid getting charged. If other accounts are authorized to access
    ///             the snapshot, you must revoke all of the authorizations before you can delete the
    ///             snapshot.</p>
    public func deleteClusterSnapshot(input: DeleteClusterSnapshotInput, completion: @escaping (ClientRuntime.SdkResult<DeleteClusterSnapshotOutputResponse, DeleteClusterSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteClusterSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClusterSnapshotInput, DeleteClusterSnapshotOutputResponse, DeleteClusterSnapshotOutputError>(id: "deleteClusterSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteClusterSnapshotInput, DeleteClusterSnapshotOutputResponse, DeleteClusterSnapshotOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified cluster subnet group.</p>
    public func deleteClusterSubnetGroup(input: DeleteClusterSubnetGroupInput, completion: @escaping (ClientRuntime.SdkResult<DeleteClusterSubnetGroupOutputResponse, DeleteClusterSubnetGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteClusterSubnetGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClusterSubnetGroupInput, DeleteClusterSubnetGroupOutputResponse, DeleteClusterSubnetGroupOutputError>(id: "deleteClusterSubnetGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSubnetGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSubnetGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteClusterSubnetGroupInput, DeleteClusterSubnetGroupOutputResponse, DeleteClusterSubnetGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterSubnetGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a Redshift-managed VPC endpoint.</p>
    public func deleteEndpointAccess(input: DeleteEndpointAccessInput, completion: @escaping (ClientRuntime.SdkResult<DeleteEndpointAccessOutputResponse, DeleteEndpointAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteEndpointAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteEndpointAccessInput, DeleteEndpointAccessOutputResponse, DeleteEndpointAccessOutputError>(id: "deleteEndpointAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteEndpointAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteEndpointAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteEndpointAccessInput, DeleteEndpointAccessOutputResponse, DeleteEndpointAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteEndpointAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an Amazon Redshift event notification subscription.</p>
    public func deleteEventSubscription(input: DeleteEventSubscriptionInput, completion: @escaping (ClientRuntime.SdkResult<DeleteEventSubscriptionOutputResponse, DeleteEventSubscriptionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteEventSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteEventSubscriptionInput, DeleteEventSubscriptionOutputResponse, DeleteEventSubscriptionOutputError>(id: "deleteEventSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteEventSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteEventSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteEventSubscriptionInput, DeleteEventSubscriptionOutputResponse, DeleteEventSubscriptionOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteEventSubscriptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified HSM client certificate.</p>
    public func deleteHsmClientCertificate(input: DeleteHsmClientCertificateInput, completion: @escaping (ClientRuntime.SdkResult<DeleteHsmClientCertificateOutputResponse, DeleteHsmClientCertificateOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteHsmClientCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteHsmClientCertificateInput, DeleteHsmClientCertificateOutputResponse, DeleteHsmClientCertificateOutputError>(id: "deleteHsmClientCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteHsmClientCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteHsmClientCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteHsmClientCertificateInput, DeleteHsmClientCertificateOutputResponse, DeleteHsmClientCertificateOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteHsmClientCertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified Amazon Redshift HSM configuration.</p>
    public func deleteHsmConfiguration(input: DeleteHsmConfigurationInput, completion: @escaping (ClientRuntime.SdkResult<DeleteHsmConfigurationOutputResponse, DeleteHsmConfigurationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteHsmConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteHsmConfigurationInput, DeleteHsmConfigurationOutputResponse, DeleteHsmConfigurationOutputError>(id: "deleteHsmConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteHsmConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteHsmConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteHsmConfigurationInput, DeleteHsmConfigurationOutputResponse, DeleteHsmConfigurationOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteHsmConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner's website.</p>
    public func deletePartner(input: DeletePartnerInput, completion: @escaping (ClientRuntime.SdkResult<DeletePartnerOutputResponse, DeletePartnerOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePartner")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePartnerInput, DeletePartnerOutputResponse, DeletePartnerOutputError>(id: "deletePartner")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePartnerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePartnerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePartnerInput, DeletePartnerOutputResponse, DeletePartnerOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeletePartnerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a scheduled action.
    ///              </p>
    public func deleteScheduledAction(input: DeleteScheduledActionInput, completion: @escaping (ClientRuntime.SdkResult<DeleteScheduledActionOutputResponse, DeleteScheduledActionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteScheduledAction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteScheduledActionInput, DeleteScheduledActionOutputResponse, DeleteScheduledActionOutputError>(id: "deleteScheduledAction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteScheduledActionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteScheduledActionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteScheduledActionInput, DeleteScheduledActionOutputResponse, DeleteScheduledActionOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteScheduledActionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified snapshot copy grant.</p>
    public func deleteSnapshotCopyGrant(input: DeleteSnapshotCopyGrantInput, completion: @escaping (ClientRuntime.SdkResult<DeleteSnapshotCopyGrantOutputResponse, DeleteSnapshotCopyGrantOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSnapshotCopyGrant")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSnapshotCopyGrantInput, DeleteSnapshotCopyGrantOutputResponse, DeleteSnapshotCopyGrantOutputError>(id: "deleteSnapshotCopyGrant")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotCopyGrantInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotCopyGrantInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSnapshotCopyGrantInput, DeleteSnapshotCopyGrantOutputResponse, DeleteSnapshotCopyGrantOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotCopyGrantInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a snapshot schedule.</p>
    public func deleteSnapshotSchedule(input: DeleteSnapshotScheduleInput, completion: @escaping (ClientRuntime.SdkResult<DeleteSnapshotScheduleOutputResponse, DeleteSnapshotScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSnapshotSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSnapshotScheduleInput, DeleteSnapshotScheduleOutputResponse, DeleteSnapshotScheduleOutputError>(id: "deleteSnapshotSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSnapshotScheduleInput, DeleteSnapshotScheduleOutputResponse, DeleteSnapshotScheduleOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes tags from a resource. You must provide the ARN of the resource
    ///             from which you want to delete the tag or tags.</p>
    public func deleteTags(input: DeleteTagsInput, completion: @escaping (ClientRuntime.SdkResult<DeleteTagsOutputResponse, DeleteTagsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTagsInput, DeleteTagsOutputResponse, DeleteTagsOutputError>(id: "deleteTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTagsInput, DeleteTagsOutputResponse, DeleteTagsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a usage limit from a cluster.</p>
    public func deleteUsageLimit(input: DeleteUsageLimitInput, completion: @escaping (ClientRuntime.SdkResult<DeleteUsageLimitOutputResponse, DeleteUsageLimitOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUsageLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUsageLimitInput, DeleteUsageLimitOutputResponse, DeleteUsageLimitOutputError>(id: "deleteUsageLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUsageLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUsageLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUsageLimitInput, DeleteUsageLimitOutputResponse, DeleteUsageLimitOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteUsageLimitInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of attributes attached to an account</p>
    public func describeAccountAttributes(input: DescribeAccountAttributesInput, completion: @escaping (ClientRuntime.SdkResult<DescribeAccountAttributesOutputResponse, DescribeAccountAttributesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAccountAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAccountAttributesInput, DescribeAccountAttributesOutputResponse, DescribeAccountAttributesOutputError>(id: "describeAccountAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAccountAttributesInput, DescribeAccountAttributesOutputResponse, DescribeAccountAttributesOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an array of <code>ClusterDbRevision</code> objects.</p>
    public func describeClusterDbRevisions(input: DescribeClusterDbRevisionsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterDbRevisionsOutputResponse, DescribeClusterDbRevisionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterDbRevisions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterDbRevisionsInput, DescribeClusterDbRevisionsOutputResponse, DescribeClusterDbRevisionsOutputError>(id: "describeClusterDbRevisions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterDbRevisionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterDbRevisionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterDbRevisionsInput, DescribeClusterDbRevisionsOutputResponse, DescribeClusterDbRevisionsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterDbRevisionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you
    ///             created and the default parameter group. For each parameter group, the response includes
    ///             the parameter group name, description, and parameter group family name. You can
    ///             optionally specify a name to retrieve the description of a specific parameter
    ///             group.</p>
    ///         <p>
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all parameter groups that match any combination of the specified keys and values. For
    ///             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
    ///                 <code>admin</code> and <code>test</code> for tag values, all parameter groups that
    ///             have any combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, parameter groups are
    ///             returned regardless of whether they have tag keys or values associated with
    ///             them.</p>
    public func describeClusterParameterGroups(input: DescribeClusterParameterGroupsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterParameterGroupsOutputResponse, DescribeClusterParameterGroupsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterParameterGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterParameterGroupsInput, DescribeClusterParameterGroupsOutputResponse, DescribeClusterParameterGroupsOutputError>(id: "describeClusterParameterGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterParameterGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterParameterGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterParameterGroupsInput, DescribeClusterParameterGroupsOutputResponse, DescribeClusterParameterGroupsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterParameterGroupsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a detailed list of parameters contained within the specified Amazon Redshift
    ///             parameter group. For each parameter the response includes information such as parameter
    ///             name, description, data type, value, whether the parameter value is modifiable, and so
    ///             on.</p>
    ///         <p>You can specify <i>source</i> filter to retrieve parameters of only
    ///             specific type. For example, to retrieve parameters that were modified by a user action
    ///             such as from <a>ModifyClusterParameterGroup</a>, you can specify
    ///                 <i>source</i> equal to <i>user</i>.</p>
    ///         <p>
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func describeClusterParameters(input: DescribeClusterParametersInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterParametersOutputResponse, DescribeClusterParametersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterParameters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterParametersInput, DescribeClusterParametersOutputResponse, DescribeClusterParametersOutputError>(id: "describeClusterParameters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterParametersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterParametersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterParametersInput, DescribeClusterParametersOutputResponse, DescribeClusterParametersOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterParametersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about Amazon Redshift security groups. If the name of a security
    ///             group is specified, the response will contain only information about only that security
    ///             group.</p>
    ///         <p>
    /// For information about managing security groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
    /// <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all security groups that match any combination of the specified keys and values. For
    ///             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
    ///                 <code>admin</code> and <code>test</code> for tag values, all security groups that
    ///             have any combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, security groups are
    ///             returned regardless of whether they have tag keys or values associated with
    ///             them.</p>
    public func describeClusterSecurityGroups(input: DescribeClusterSecurityGroupsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterSecurityGroupsOutputResponse, DescribeClusterSecurityGroupsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterSecurityGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterSecurityGroupsInput, DescribeClusterSecurityGroupsOutputResponse, DescribeClusterSecurityGroupsOutputError>(id: "describeClusterSecurityGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSecurityGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSecurityGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterSecurityGroupsInput, DescribeClusterSecurityGroupsOutputResponse, DescribeClusterSecurityGroupsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSecurityGroupsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns one or more snapshot objects, which contain metadata about your cluster
    ///             snapshots. By default, this operation returns information about all snapshots of all
    ///             clusters that are owned by you AWS customer account. No information is returned for
    ///             snapshots owned by inactive AWS customer accounts.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all snapshots that match any combination of the specified keys and values. For example,
    ///             if you have <code>owner</code> and <code>environment</code> for tag keys, and
    ///                 <code>admin</code> and <code>test</code> for tag values, all snapshots that have any
    ///             combination of those values are returned. Only snapshots that you own are returned in
    ///             the response; shared snapshots are not returned with the tag key and tag value request
    ///             parameters.</p>
    ///         <p>If both tag keys and values are omitted from the request, snapshots are returned
    ///             regardless of whether they have tag keys or values associated with them.</p>
    public func describeClusterSnapshots(input: DescribeClusterSnapshotsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterSnapshotsOutputResponse, DescribeClusterSnapshotsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterSnapshots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterSnapshotsInput, DescribeClusterSnapshotsOutputResponse, DescribeClusterSnapshotsOutputError>(id: "describeClusterSnapshots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSnapshotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSnapshotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterSnapshotsInput, DescribeClusterSnapshotsOutputResponse, DescribeClusterSnapshotsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSnapshotsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns one or more cluster subnet group objects, which contain metadata about your
    ///             cluster subnet groups. By default, this operation returns information about all cluster
    ///             subnet groups that are defined in you AWS account.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all subnet groups that match any combination of the specified keys and values. For
    ///             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
    ///                 <code>admin</code> and <code>test</code> for tag values, all subnet groups that have
    ///             any combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, subnet groups are
    ///             returned regardless of whether they have tag keys or values associated with
    ///             them.</p>
    public func describeClusterSubnetGroups(input: DescribeClusterSubnetGroupsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterSubnetGroupsOutputResponse, DescribeClusterSubnetGroupsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterSubnetGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterSubnetGroupsInput, DescribeClusterSubnetGroupsOutputResponse, DescribeClusterSubnetGroupsOutputError>(id: "describeClusterSubnetGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSubnetGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSubnetGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterSubnetGroupsInput, DescribeClusterSubnetGroupsOutputResponse, DescribeClusterSubnetGroupsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterSubnetGroupsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of all the available maintenance tracks.</p>
    public func describeClusterTracks(input: DescribeClusterTracksInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterTracksOutputResponse, DescribeClusterTracksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterTracks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterTracksInput, DescribeClusterTracksOutputResponse, DescribeClusterTracksOutputError>(id: "describeClusterTracks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterTracksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterTracksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterTracksInput, DescribeClusterTracksOutputResponse, DescribeClusterTracksOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterTracksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns descriptions of the available Amazon Redshift cluster versions. You can call this
    ///             operation even before creating any clusters to learn more about the Amazon Redshift versions.
    ///
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func describeClusterVersions(input: DescribeClusterVersionsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClusterVersionsOutputResponse, DescribeClusterVersionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusterVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterVersionsInput, DescribeClusterVersionsOutputResponse, DescribeClusterVersionsOutputError>(id: "describeClusterVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterVersionsInput, DescribeClusterVersionsOutputResponse, DescribeClusterVersionsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterVersionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns properties of provisioned clusters including general cluster properties,
    ///             cluster database properties, maintenance and backup properties, and security and access
    ///             properties. This operation supports pagination.
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all clusters that match any combination of the specified keys and values. For example,
    ///             if you have <code>owner</code> and <code>environment</code> for tag keys, and
    ///                 <code>admin</code> and <code>test</code> for tag values, all clusters that have any
    ///             combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, clusters are returned
    ///             regardless of whether they have tag keys or values associated with them.</p>
    public func describeClusters(input: DescribeClustersInput, completion: @escaping (ClientRuntime.SdkResult<DescribeClustersOutputResponse, DescribeClustersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClustersInput, DescribeClustersOutputResponse, DescribeClustersOutputError>(id: "describeClusters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClustersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClustersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClustersInput, DescribeClustersOutputResponse, DescribeClustersOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClustersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of parameter settings for the specified parameter group
    ///             family.</p>
    ///         <p>
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func describeDefaultClusterParameters(input: DescribeDefaultClusterParametersInput, completion: @escaping (ClientRuntime.SdkResult<DescribeDefaultClusterParametersOutputResponse, DescribeDefaultClusterParametersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDefaultClusterParameters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDefaultClusterParametersInput, DescribeDefaultClusterParametersOutputResponse, DescribeDefaultClusterParametersOutputError>(id: "describeDefaultClusterParameters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDefaultClusterParametersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDefaultClusterParametersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDefaultClusterParametersInput, DescribeDefaultClusterParametersOutputResponse, DescribeDefaultClusterParametersOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeDefaultClusterParametersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a Redshift-managed VPC endpoint.</p>
    public func describeEndpointAccess(input: DescribeEndpointAccessInput, completion: @escaping (ClientRuntime.SdkResult<DescribeEndpointAccessOutputResponse, DescribeEndpointAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeEndpointAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeEndpointAccessInput, DescribeEndpointAccessOutputResponse, DescribeEndpointAccessOutputError>(id: "describeEndpointAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeEndpointAccessInput, DescribeEndpointAccessOutputResponse, DescribeEndpointAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an endpoint authorization.</p>
    public func describeEndpointAuthorization(input: DescribeEndpointAuthorizationInput, completion: @escaping (ClientRuntime.SdkResult<DescribeEndpointAuthorizationOutputResponse, DescribeEndpointAuthorizationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeEndpointAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeEndpointAuthorizationInput, DescribeEndpointAuthorizationOutputResponse, DescribeEndpointAuthorizationOutputError>(id: "describeEndpointAuthorization")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeEndpointAuthorizationInput, DescribeEndpointAuthorizationOutputResponse, DescribeEndpointAuthorizationOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointAuthorizationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Displays a list of event categories for all event source types, or for a specified
    ///             source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event
    ///                 Notifications</a>.</p>
    public func describeEventCategories(input: DescribeEventCategoriesInput, completion: @escaping (ClientRuntime.SdkResult<DescribeEventCategoriesOutputResponse, DescribeEventCategoriesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeEventCategories")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeEventCategoriesInput, DescribeEventCategoriesOutputResponse, DescribeEventCategoriesOutputError>(id: "describeEventCategories")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventCategoriesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventCategoriesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeEventCategoriesInput, DescribeEventCategoriesOutputResponse, DescribeEventCategoriesOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventCategoriesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a
    ///             customer account. If you specify a subscription name, lists the description for that
    ///             subscription.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all event notification subscriptions that match any combination of the specified keys
    ///             and values. For example, if you have <code>owner</code> and <code>environment</code> for
    ///             tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions
    ///             that have any combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, subscriptions are
    ///             returned regardless of whether they have tag keys or values associated with
    ///             them.</p>
    public func describeEventSubscriptions(input: DescribeEventSubscriptionsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeEventSubscriptionsOutputResponse, DescribeEventSubscriptionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeEventSubscriptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse, DescribeEventSubscriptionsOutputError>(id: "describeEventSubscriptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventSubscriptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventSubscriptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse, DescribeEventSubscriptionsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventSubscriptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns events related to clusters, security groups, snapshots, and parameter
    ///             groups for the past 14 days. Events specific to a particular cluster, security group,
    ///             snapshot or parameter group can be obtained by providing the name as a parameter. By
    ///             default, the past hour of events are returned.</p>
    public func describeEvents(input: DescribeEventsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeEventsOutputResponse, DescribeEventsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeEvents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeEventsInput, DescribeEventsOutputResponse, DescribeEventsOutputError>(id: "describeEvents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeEventsInput, DescribeEventsOutputResponse, DescribeEventsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the specified HSM client certificate. If no certificate
    ///             ID is specified, returns information about all the HSM certificates owned by your AWS
    ///             customer account.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all HSM client certificates that match any combination of the specified keys and values.
    ///             For example, if you have <code>owner</code> and <code>environment</code> for tag keys,
    ///             and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates
    ///             that have any combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, HSM client certificates
    ///             are returned regardless of whether they have tag keys or values associated with
    ///             them.</p>
    public func describeHsmClientCertificates(input: DescribeHsmClientCertificatesInput, completion: @escaping (ClientRuntime.SdkResult<DescribeHsmClientCertificatesOutputResponse, DescribeHsmClientCertificatesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeHsmClientCertificates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeHsmClientCertificatesInput, DescribeHsmClientCertificatesOutputResponse, DescribeHsmClientCertificatesOutputError>(id: "describeHsmClientCertificates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeHsmClientCertificatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeHsmClientCertificatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeHsmClientCertificatesInput, DescribeHsmClientCertificatesOutputResponse, DescribeHsmClientCertificatesOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeHsmClientCertificatesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the specified Amazon Redshift HSM configuration. If no
    ///             configuration ID is specified, returns information about all the HSM configurations
    ///             owned by your AWS customer account.</p>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all HSM connections that match any combination of the specified keys and values. For
    ///             example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
    ///                 <code>admin</code> and <code>test</code> for tag values, all HSM connections that
    ///             have any combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, HSM connections are
    ///             returned regardless of whether they have tag keys or values associated with
    ///             them.</p>
    public func describeHsmConfigurations(input: DescribeHsmConfigurationsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeHsmConfigurationsOutputResponse, DescribeHsmConfigurationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeHsmConfigurations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeHsmConfigurationsInput, DescribeHsmConfigurationsOutputResponse, DescribeHsmConfigurationsOutputError>(id: "describeHsmConfigurations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeHsmConfigurationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeHsmConfigurationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeHsmConfigurationsInput, DescribeHsmConfigurationsOutputResponse, DescribeHsmConfigurationsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeHsmConfigurationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes whether information, such as queries and connection attempts, is being
    ///             logged for the specified Amazon Redshift cluster.</p>
    public func describeLoggingStatus(input: DescribeLoggingStatusInput, completion: @escaping (ClientRuntime.SdkResult<DescribeLoggingStatusOutputResponse, DescribeLoggingStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeLoggingStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeLoggingStatusInput, DescribeLoggingStatusOutputResponse, DescribeLoggingStatusOutputError>(id: "describeLoggingStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeLoggingStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeLoggingStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeLoggingStatusInput, DescribeLoggingStatusOutputResponse, DescribeLoggingStatusOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeLoggingStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns properties of possible node configurations such as node type, number of nodes, and
    ///             disk usage for the specified action type.</p>
    public func describeNodeConfigurationOptions(input: DescribeNodeConfigurationOptionsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeNodeConfigurationOptionsOutputResponse, DescribeNodeConfigurationOptionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeNodeConfigurationOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeNodeConfigurationOptionsInput, DescribeNodeConfigurationOptionsOutputResponse, DescribeNodeConfigurationOptionsOutputError>(id: "describeNodeConfigurationOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeNodeConfigurationOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeNodeConfigurationOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeNodeConfigurationOptionsInput, DescribeNodeConfigurationOptionsOutputResponse, DescribeNodeConfigurationOptionsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeNodeConfigurationOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of orderable cluster options. Before you create a new cluster you
    ///             can use this operation to find what options are available, such as the EC2 Availability
    ///             Zones (AZ) in the specific AWS Region that you can specify, and the node types you can
    ///             request. The node types differ by available storage, memory, CPU and price. With the
    ///             cost involved you might want to obtain a list of cluster options in the specific region
    ///             and specify values when creating a cluster.
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func describeOrderableClusterOptions(input: DescribeOrderableClusterOptionsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeOrderableClusterOptionsOutputResponse, DescribeOrderableClusterOptionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeOrderableClusterOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeOrderableClusterOptionsInput, DescribeOrderableClusterOptionsOutputResponse, DescribeOrderableClusterOptionsOutputError>(id: "describeOrderableClusterOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrderableClusterOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrderableClusterOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeOrderableClusterOptionsInput, DescribeOrderableClusterOptionsOutputResponse, DescribeOrderableClusterOptionsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrderableClusterOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the partner integrations defined for a cluster.</p>
    public func describePartners(input: DescribePartnersInput, completion: @escaping (ClientRuntime.SdkResult<DescribePartnersOutputResponse, DescribePartnersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describePartners")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribePartnersInput, DescribePartnersOutputResponse, DescribePartnersOutputError>(id: "describePartners")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribePartnersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribePartnersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribePartnersInput, DescribePartnersOutputResponse, DescribePartnersOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribePartnersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of the available reserved node offerings by Amazon Redshift with their
    ///             descriptions including the node type, the fixed and recurring costs of reserving the
    ///             node and duration the node will be reserved for you. These descriptions help you
    ///             determine which reserve node offering you want to purchase. You then use the unique
    ///             offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one
    ///             or more nodes for your Amazon Redshift cluster. </p>
    ///         <p>
    /// For more information about reserved node offerings, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func describeReservedNodeOfferings(input: DescribeReservedNodeOfferingsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeReservedNodeOfferingsOutputResponse, DescribeReservedNodeOfferingsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeReservedNodeOfferings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeReservedNodeOfferingsInput, DescribeReservedNodeOfferingsOutputResponse, DescribeReservedNodeOfferingsOutputError>(id: "describeReservedNodeOfferings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedNodeOfferingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedNodeOfferingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeReservedNodeOfferingsInput, DescribeReservedNodeOfferingsOutputResponse, DescribeReservedNodeOfferingsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedNodeOfferingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the descriptions of the reserved nodes.</p>
    public func describeReservedNodes(input: DescribeReservedNodesInput, completion: @escaping (ClientRuntime.SdkResult<DescribeReservedNodesOutputResponse, DescribeReservedNodesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeReservedNodes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeReservedNodesInput, DescribeReservedNodesOutputResponse, DescribeReservedNodesOutputError>(id: "describeReservedNodes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedNodesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedNodesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeReservedNodesInput, DescribeReservedNodesOutputResponse, DescribeReservedNodesOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedNodesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the last resize operation for the specified cluster. If
    ///             no resize operation has ever been initiated for the specified cluster, a <code>HTTP
    ///                 404</code> error is returned. If a resize operation was initiated and completed, the
    ///             status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p>
    ///         <p>A resize operation can be requested using <a>ModifyCluster</a> and
    ///             specifying a different number or type of nodes for the cluster. </p>
    public func describeResize(input: DescribeResizeInput, completion: @escaping (ClientRuntime.SdkResult<DescribeResizeOutputResponse, DescribeResizeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeResize")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeResizeInput, DescribeResizeOutputResponse, DescribeResizeOutputError>(id: "describeResize")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeResizeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeResizeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeResizeInput, DescribeResizeOutputResponse, DescribeResizeOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeResizeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes properties of scheduled actions.
    ///              </p>
    public func describeScheduledActions(input: DescribeScheduledActionsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeScheduledActionsOutputResponse, DescribeScheduledActionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeScheduledActions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeScheduledActionsInput, DescribeScheduledActionsOutputResponse, DescribeScheduledActionsOutputError>(id: "describeScheduledActions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeScheduledActionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeScheduledActionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeScheduledActionsInput, DescribeScheduledActionsOutputResponse, DescribeScheduledActionsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeScheduledActionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of snapshot copy grants owned by the AWS account in the destination
    ///             region.</p>
    ///         <p>
    /// For more information about managing snapshot copy grants, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public func describeSnapshotCopyGrants(input: DescribeSnapshotCopyGrantsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeSnapshotCopyGrantsOutputResponse, DescribeSnapshotCopyGrantsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSnapshotCopyGrants")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSnapshotCopyGrantsInput, DescribeSnapshotCopyGrantsOutputResponse, DescribeSnapshotCopyGrantsOutputError>(id: "describeSnapshotCopyGrants")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotCopyGrantsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotCopyGrantsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSnapshotCopyGrantsInput, DescribeSnapshotCopyGrantsOutputResponse, DescribeSnapshotCopyGrantsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotCopyGrantsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of snapshot schedules. </p>
    public func describeSnapshotSchedules(input: DescribeSnapshotSchedulesInput, completion: @escaping (ClientRuntime.SdkResult<DescribeSnapshotSchedulesOutputResponse, DescribeSnapshotSchedulesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSnapshotSchedules")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSnapshotSchedulesInput, DescribeSnapshotSchedulesOutputResponse, DescribeSnapshotSchedulesOutputError>(id: "describeSnapshotSchedules")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotSchedulesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotSchedulesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSnapshotSchedulesInput, DescribeSnapshotSchedulesOutputResponse, DescribeSnapshotSchedulesOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotSchedulesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns account level backups storage size and provisional storage.</p>
    public func describeStorage(input: DescribeStorageInput, completion: @escaping (ClientRuntime.SdkResult<DescribeStorageOutputResponse, DescribeStorageOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeStorage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeStorageInput, DescribeStorageOutputResponse, DescribeStorageOutputError>(id: "describeStorage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeStorageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeStorageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeStorageInput, DescribeStorageOutputResponse, DescribeStorageOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value
    ///             for the <code>TableRestoreRequestId</code> parameter, then
    ///                 <code>DescribeTableRestoreStatus</code> returns the status of all table restore
    ///             requests ordered by the date and time of the request in ascending order. Otherwise
    ///                 <code>DescribeTableRestoreStatus</code> returns the status of the table specified by
    ///                 <code>TableRestoreRequestId</code>.</p>
    public func describeTableRestoreStatus(input: DescribeTableRestoreStatusInput, completion: @escaping (ClientRuntime.SdkResult<DescribeTableRestoreStatusOutputResponse, DescribeTableRestoreStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTableRestoreStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTableRestoreStatusInput, DescribeTableRestoreStatusOutputResponse, DescribeTableRestoreStatusOutputError>(id: "describeTableRestoreStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableRestoreStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableRestoreStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTableRestoreStatusInput, DescribeTableRestoreStatusOutputResponse, DescribeTableRestoreStatusOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableRestoreStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of tags. You can return tags from a specific resource by specifying
    ///             an ARN, or you can return all tags for a given type of resource, such as clusters,
    ///             snapshots, and so on.</p>
    ///         <p>The following are limitations for <code>DescribeTags</code>: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>You cannot specify an ARN and a resource-type value together in the same
    ///                     request.</p>
    ///             </li>
    ///             <li>
    ///                 <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code>
    ///                     parameters together with the ARN parameter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results
    ///                     to return in a request.</p>
    ///             </li>
    ///          </ul>
    ///         <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
    ///             all resources that match any combination of the specified keys and values. For example,
    ///             if you have <code>owner</code> and <code>environment</code> for tag keys, and
    ///                 <code>admin</code> and <code>test</code> for tag values, all resources that have any
    ///             combination of those values are returned.</p>
    ///         <p>If both tag keys and values are omitted from the request, resources are returned
    ///             regardless of whether they have tag keys or values associated with them.</p>
    public func describeTags(input: DescribeTagsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeTagsOutputResponse, DescribeTagsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTagsInput, DescribeTagsOutputResponse, DescribeTagsOutputError>(id: "describeTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTagsInput, DescribeTagsOutputResponse, DescribeTagsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Shows usage limits on a cluster.
    ///             Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If usage limit identifier, cluster identifier, and feature type are not provided,
    ///                 then all usage limit objects for the current account in the current region are returned.</p>
    ///             </li>
    ///             <li>
    ///                <p>If usage limit identifier is provided,
    ///                 then the corresponding usage limit object is returned.</p>
    ///             </li>
    ///             <li>
    ///                <p>If cluster identifier is provided,
    ///                 then all usage limit objects for the specified cluster are returned.</p>
    ///             </li>
    ///             <li>
    ///                <p>If cluster identifier and feature type are provided,
    ///                 then all usage limit objects for the combination of cluster and feature are returned.</p>
    ///             </li>
    ///          </ul>
    public func describeUsageLimits(input: DescribeUsageLimitsInput, completion: @escaping (ClientRuntime.SdkResult<DescribeUsageLimitsOutputResponse, DescribeUsageLimitsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUsageLimits")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUsageLimitsInput, DescribeUsageLimitsOutputResponse, DescribeUsageLimitsOutputError>(id: "describeUsageLimits")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUsageLimitsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUsageLimitsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUsageLimitsInput, DescribeUsageLimitsOutputResponse, DescribeUsageLimitsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeUsageLimitsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Stops logging information, such as queries and connection attempts, for the
    ///             specified Amazon Redshift cluster.</p>
    public func disableLogging(input: DisableLoggingInput, completion: @escaping (ClientRuntime.SdkResult<DisableLoggingOutputResponse, DisableLoggingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disableLogging")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisableLoggingInput, DisableLoggingOutputResponse, DisableLoggingOutputError>(id: "disableLogging")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisableLoggingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisableLoggingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisableLoggingInput, DisableLoggingOutputResponse, DisableLoggingOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DisableLoggingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disables the automatic copying of snapshots from one region to another region for a
    ///             specified cluster.</p>
    ///         <p>If your cluster and its snapshots are encrypted using a customer master key (CMK)
    ///             from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that
    ///             grants Amazon Redshift permission to the CMK in the destination region. </p>
    public func disableSnapshotCopy(input: DisableSnapshotCopyInput, completion: @escaping (ClientRuntime.SdkResult<DisableSnapshotCopyOutputResponse, DisableSnapshotCopyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disableSnapshotCopy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisableSnapshotCopyInput, DisableSnapshotCopyOutputResponse, DisableSnapshotCopyOutputError>(id: "disableSnapshotCopy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisableSnapshotCopyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisableSnapshotCopyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisableSnapshotCopyInput, DisableSnapshotCopyOutputResponse, DisableSnapshotCopyOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: DisableSnapshotCopyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts logging information, such as queries and connection attempts, for the
    ///             specified Amazon Redshift cluster.</p>
    public func enableLogging(input: EnableLoggingInput, completion: @escaping (ClientRuntime.SdkResult<EnableLoggingOutputResponse, EnableLoggingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "enableLogging")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<EnableLoggingInput, EnableLoggingOutputResponse, EnableLoggingOutputError>(id: "enableLogging")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: EnableLoggingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: EnableLoggingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<EnableLoggingInput, EnableLoggingOutputResponse, EnableLoggingOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: EnableLoggingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enables the automatic copy of snapshots from one region to another region for a
    ///             specified cluster.</p>
    public func enableSnapshotCopy(input: EnableSnapshotCopyInput, completion: @escaping (ClientRuntime.SdkResult<EnableSnapshotCopyOutputResponse, EnableSnapshotCopyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "enableSnapshotCopy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<EnableSnapshotCopyInput, EnableSnapshotCopyOutputResponse, EnableSnapshotCopyOutputError>(id: "enableSnapshotCopy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: EnableSnapshotCopyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: EnableSnapshotCopyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<EnableSnapshotCopyInput, EnableSnapshotCopyOutputResponse, EnableSnapshotCopyOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: EnableSnapshotCopyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a database user name and temporary password with temporary authorization to
    ///             log on to an Amazon Redshift database. The action returns the database user name
    ///             prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or
    ///                 <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can
    ///             optionally specify one or more database user groups that the user will join at log on.
    ///             By default, the temporary credentials expire in 900 seconds. You can optionally specify
    ///             a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more
    ///             information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication
    ///                 to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>The AWS Identity and Access Management (IAM)user or role that executes
    ///             GetClusterCredentials must have an IAM policy attached that allows access to all
    ///             necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the
    ///             Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the
    ///                 <code>redshift:JoinGroup</code> action with access to the listed
    ///                 <code>dbgroups</code>. </p>
    ///         <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>,
    ///             then the policy must include the <code>redshift:CreateClusterUser</code>
    ///             privilege.</p>
    ///         <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access
    ///             to the resource <code>dbname</code> for the specified database name. </p>
    public func getClusterCredentials(input: GetClusterCredentialsInput, completion: @escaping (ClientRuntime.SdkResult<GetClusterCredentialsOutputResponse, GetClusterCredentialsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getClusterCredentials")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetClusterCredentialsInput, GetClusterCredentialsOutputResponse, GetClusterCredentialsOutputError>(id: "getClusterCredentials")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetClusterCredentialsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetClusterCredentialsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetClusterCredentialsInput, GetClusterCredentialsOutputResponse, GetClusterCredentialsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: GetClusterCredentialsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term,
    ///             and usage price of the given DC1 reserved node.</p>
    public func getReservedNodeExchangeOfferings(input: GetReservedNodeExchangeOfferingsInput, completion: @escaping (ClientRuntime.SdkResult<GetReservedNodeExchangeOfferingsOutputResponse, GetReservedNodeExchangeOfferingsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getReservedNodeExchangeOfferings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetReservedNodeExchangeOfferingsInput, GetReservedNodeExchangeOfferingsOutputResponse, GetReservedNodeExchangeOfferingsOutputError>(id: "getReservedNodeExchangeOfferings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetReservedNodeExchangeOfferingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetReservedNodeExchangeOfferingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetReservedNodeExchangeOfferingsInput, GetReservedNodeExchangeOfferingsOutputResponse, GetReservedNodeExchangeOfferingsOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: GetReservedNodeExchangeOfferingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies whether a cluster can use AQUA (Advanced Query Accelerator). </p>
    public func modifyAquaConfiguration(input: ModifyAquaConfigurationInput, completion: @escaping (ClientRuntime.SdkResult<ModifyAquaConfigurationOutputResponse, ModifyAquaConfigurationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyAquaConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyAquaConfigurationInput, ModifyAquaConfigurationOutputResponse, ModifyAquaConfigurationOutputError>(id: "modifyAquaConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyAquaConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyAquaConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyAquaConfigurationInput, ModifyAquaConfigurationOutputResponse, ModifyAquaConfigurationOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyAquaConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the settings for a cluster.</p>
    ///         <p>You can also change node type and the number of nodes to scale up or down the
    ///             cluster. When resizing a cluster, you must specify both the number of nodes and the node
    ///             type even if one of the parameters does not change.</p>
    /// 		       <p>You can add another security or
    ///             parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect.
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func modifyCluster(input: ModifyClusterInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterOutputResponse, ModifyClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterInput, ModifyClusterOutputResponse, ModifyClusterOutputError>(id: "modifyCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterInput, ModifyClusterOutputResponse, ModifyClusterOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the database revision of a cluster. The database revision is a unique
    ///             revision of the database running in a cluster.</p>
    public func modifyClusterDbRevision(input: ModifyClusterDbRevisionInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterDbRevisionOutputResponse, ModifyClusterDbRevisionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyClusterDbRevision")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterDbRevisionInput, ModifyClusterDbRevisionOutputResponse, ModifyClusterDbRevisionOutputError>(id: "modifyClusterDbRevision")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterDbRevisionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterDbRevisionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterDbRevisionInput, ModifyClusterDbRevisionOutputResponse, ModifyClusterDbRevisionOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterDbRevisionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be
    ///             used by the cluster to access other AWS services.</p>
    ///         <p>A cluster can have up to 10 IAM roles associated at any time.</p>
    public func modifyClusterIamRoles(input: ModifyClusterIamRolesInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterIamRolesOutputResponse, ModifyClusterIamRolesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyClusterIamRoles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterIamRolesInput, ModifyClusterIamRolesOutputResponse, ModifyClusterIamRolesOutputError>(id: "modifyClusterIamRoles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterIamRolesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterIamRolesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterIamRolesInput, ModifyClusterIamRolesOutputResponse, ModifyClusterIamRolesOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterIamRolesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the maintenance settings of a cluster.</p>
    public func modifyClusterMaintenance(input: ModifyClusterMaintenanceInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterMaintenanceOutputResponse, ModifyClusterMaintenanceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyClusterMaintenance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterMaintenanceInput, ModifyClusterMaintenanceOutputResponse, ModifyClusterMaintenanceOutputError>(id: "modifyClusterMaintenance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterMaintenanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterMaintenanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterMaintenanceInput, ModifyClusterMaintenanceOutputResponse, ModifyClusterMaintenanceOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterMaintenanceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the parameters of a parameter group.</p>
    ///         <p>
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func modifyClusterParameterGroup(input: ModifyClusterParameterGroupInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterParameterGroupOutputResponse, ModifyClusterParameterGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyClusterParameterGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterParameterGroupInput, ModifyClusterParameterGroupOutputResponse, ModifyClusterParameterGroupOutputError>(id: "modifyClusterParameterGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterParameterGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterParameterGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterParameterGroupInput, ModifyClusterParameterGroupOutputResponse, ModifyClusterParameterGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterParameterGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the settings for a snapshot.</p>
    /// 		       <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
    public func modifyClusterSnapshot(input: ModifyClusterSnapshotInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterSnapshotOutputResponse, ModifyClusterSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyClusterSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterSnapshotInput, ModifyClusterSnapshotOutputResponse, ModifyClusterSnapshotOutputError>(id: "modifyClusterSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterSnapshotInput, ModifyClusterSnapshotOutputResponse, ModifyClusterSnapshotOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies a snapshot schedule for a cluster.</p>
    public func modifyClusterSnapshotSchedule(input: ModifyClusterSnapshotScheduleInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterSnapshotScheduleOutputResponse, ModifyClusterSnapshotScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyClusterSnapshotSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterSnapshotScheduleInput, ModifyClusterSnapshotScheduleOutputResponse, ModifyClusterSnapshotScheduleOutputError>(id: "modifyClusterSnapshotSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSnapshotScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSnapshotScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterSnapshotScheduleInput, ModifyClusterSnapshotScheduleOutputResponse, ModifyClusterSnapshotScheduleOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSnapshotScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies a cluster subnet group to include the specified list of VPC subnets. The
    ///             operation replaces the existing list of subnets with the new list of subnets.</p>
    public func modifyClusterSubnetGroup(input: ModifyClusterSubnetGroupInput, completion: @escaping (ClientRuntime.SdkResult<ModifyClusterSubnetGroupOutputResponse, ModifyClusterSubnetGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyClusterSubnetGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyClusterSubnetGroupInput, ModifyClusterSubnetGroupOutputResponse, ModifyClusterSubnetGroupOutputError>(id: "modifyClusterSubnetGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSubnetGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSubnetGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyClusterSubnetGroupInput, ModifyClusterSubnetGroupOutputResponse, ModifyClusterSubnetGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyClusterSubnetGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies a Redshift-managed VPC endpoint.</p>
    public func modifyEndpointAccess(input: ModifyEndpointAccessInput, completion: @escaping (ClientRuntime.SdkResult<ModifyEndpointAccessOutputResponse, ModifyEndpointAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyEndpointAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyEndpointAccessInput, ModifyEndpointAccessOutputResponse, ModifyEndpointAccessOutputError>(id: "modifyEndpointAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyEndpointAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyEndpointAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyEndpointAccessInput, ModifyEndpointAccessOutputResponse, ModifyEndpointAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyEndpointAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies an existing Amazon Redshift event notification subscription.</p>
    public func modifyEventSubscription(input: ModifyEventSubscriptionInput, completion: @escaping (ClientRuntime.SdkResult<ModifyEventSubscriptionOutputResponse, ModifyEventSubscriptionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyEventSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyEventSubscriptionInput, ModifyEventSubscriptionOutputResponse, ModifyEventSubscriptionOutputError>(id: "modifyEventSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyEventSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyEventSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyEventSubscriptionInput, ModifyEventSubscriptionOutputResponse, ModifyEventSubscriptionOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyEventSubscriptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies a scheduled action.
    ///             </p>
    public func modifyScheduledAction(input: ModifyScheduledActionInput, completion: @escaping (ClientRuntime.SdkResult<ModifyScheduledActionOutputResponse, ModifyScheduledActionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyScheduledAction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyScheduledActionInput, ModifyScheduledActionOutputResponse, ModifyScheduledActionOutputError>(id: "modifyScheduledAction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyScheduledActionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyScheduledActionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyScheduledActionInput, ModifyScheduledActionOutputResponse, ModifyScheduledActionOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyScheduledActionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the number of days to retain snapshots in the destination AWS Region after
    ///             they are copied from the source AWS Region. By default, this operation only changes the
    ///             retention period of copied automated snapshots. The retention periods for both new and
    ///             existing copied automated snapshots are updated with the new retention period. You can
    ///             set the manual option to change only the retention periods of copied manual snapshots.
    ///             If you set this option, only newly copied manual snapshots have the new retention
    ///             period. </p>
    public func modifySnapshotCopyRetentionPeriod(input: ModifySnapshotCopyRetentionPeriodInput, completion: @escaping (ClientRuntime.SdkResult<ModifySnapshotCopyRetentionPeriodOutputResponse, ModifySnapshotCopyRetentionPeriodOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifySnapshotCopyRetentionPeriod")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifySnapshotCopyRetentionPeriodInput, ModifySnapshotCopyRetentionPeriodOutputResponse, ModifySnapshotCopyRetentionPeriodOutputError>(id: "modifySnapshotCopyRetentionPeriod")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifySnapshotCopyRetentionPeriodInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifySnapshotCopyRetentionPeriodInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifySnapshotCopyRetentionPeriodInput, ModifySnapshotCopyRetentionPeriodOutputResponse, ModifySnapshotCopyRetentionPeriodOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifySnapshotCopyRetentionPeriodInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies a snapshot schedule. Any schedule associated with a cluster is modified
    ///             asynchronously.</p>
    public func modifySnapshotSchedule(input: ModifySnapshotScheduleInput, completion: @escaping (ClientRuntime.SdkResult<ModifySnapshotScheduleOutputResponse, ModifySnapshotScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifySnapshotSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifySnapshotScheduleInput, ModifySnapshotScheduleOutputResponse, ModifySnapshotScheduleOutputError>(id: "modifySnapshotSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifySnapshotScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifySnapshotScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifySnapshotScheduleInput, ModifySnapshotScheduleOutputResponse, ModifySnapshotScheduleOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifySnapshotScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies a usage limit in a cluster.
    ///             You can't modify the feature type or period of a usage limit.</p>
    public func modifyUsageLimit(input: ModifyUsageLimitInput, completion: @escaping (ClientRuntime.SdkResult<ModifyUsageLimitOutputResponse, ModifyUsageLimitOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyUsageLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyUsageLimitInput, ModifyUsageLimitOutputResponse, ModifyUsageLimitOutputError>(id: "modifyUsageLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyUsageLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyUsageLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyUsageLimitInput, ModifyUsageLimitOutputResponse, ModifyUsageLimitOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyUsageLimitInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Pauses a cluster.</p>
    public func pauseCluster(input: PauseClusterInput, completion: @escaping (ClientRuntime.SdkResult<PauseClusterOutputResponse, PauseClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "pauseCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PauseClusterInput, PauseClusterOutputResponse, PauseClusterOutputError>(id: "pauseCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PauseClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PauseClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PauseClusterInput, PauseClusterOutputResponse, PauseClusterOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: PauseClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of
    ///             reserved node offerings. You can purchase one or more of the offerings. You can call the
    ///                 <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved
    ///             node offerings. You can call this API by providing a specific reserved node offering and
    ///             the number of nodes you want to reserve. </p>
    ///         <p>
    /// For more information about reserved node offerings, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func purchaseReservedNodeOffering(input: PurchaseReservedNodeOfferingInput, completion: @escaping (ClientRuntime.SdkResult<PurchaseReservedNodeOfferingOutputResponse, PurchaseReservedNodeOfferingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "purchaseReservedNodeOffering")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PurchaseReservedNodeOfferingInput, PurchaseReservedNodeOfferingOutputResponse, PurchaseReservedNodeOfferingOutputError>(id: "purchaseReservedNodeOffering")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PurchaseReservedNodeOfferingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PurchaseReservedNodeOfferingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PurchaseReservedNodeOfferingInput, PurchaseReservedNodeOfferingOutputResponse, PurchaseReservedNodeOfferingOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: PurchaseReservedNodeOfferingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Reboots a cluster. This action is taken as soon as possible. It results in a
    ///             momentary outage to the cluster, during which the cluster status is set to
    ///                 <code>rebooting</code>. A cluster event is created when the reboot is completed. Any
    ///             pending cluster modifications (see <a>ModifyCluster</a>) are applied at this
    ///             reboot.
    /// For more information about managing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    public func rebootCluster(input: RebootClusterInput, completion: @escaping (ClientRuntime.SdkResult<RebootClusterOutputResponse, RebootClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "rebootCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RebootClusterInput, RebootClusterOutputResponse, RebootClusterOutputError>(id: "rebootCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RebootClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RebootClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RebootClusterInput, RebootClusterOutputResponse, RebootClusterOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: RebootClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets one or more parameters of the specified parameter group to their default
    ///             values and sets the source values of the parameters to "engine-default". To reset the
    ///             entire parameter group specify the <i>ResetAllParameters</i> parameter.
    ///             For parameter changes to take effect you must reboot any associated clusters. </p>
    public func resetClusterParameterGroup(input: ResetClusterParameterGroupInput, completion: @escaping (ClientRuntime.SdkResult<ResetClusterParameterGroupOutputResponse, ResetClusterParameterGroupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resetClusterParameterGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResetClusterParameterGroupInput, ResetClusterParameterGroupOutputResponse, ResetClusterParameterGroupOutputError>(id: "resetClusterParameterGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResetClusterParameterGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResetClusterParameterGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResetClusterParameterGroupInput, ResetClusterParameterGroupOutputResponse, ResetClusterParameterGroupOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ResetClusterParameterGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Changes the size of the cluster. You can change the cluster's type, or change the
    ///             number or type of nodes. The default behavior is to use the elastic resize method. With
    ///             an elastic resize, your cluster is available for read and write operations more quickly
    ///             than with the classic resize method. </p>
    ///         <p>Elastic resize operations have the following restrictions:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>You can only resize clusters of the following types:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>dc1.large (if your cluster is in a VPC)</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>dc1.8xlarge (if your cluster is in a VPC)</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>dc2.large</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>dc2.8xlarge</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>ds2.xlarge</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>ds2.8xlarge</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>ra3.xlplus</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>ra3.4xlarge</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>ra3.16xlarge</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>The type of nodes that you add must match the node type for the
    ///                     cluster.</p>
    ///             </li>
    ///          </ul>
    public func resizeCluster(input: ResizeClusterInput, completion: @escaping (ClientRuntime.SdkResult<ResizeClusterOutputResponse, ResizeClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resizeCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResizeClusterInput, ResizeClusterOutputResponse, ResizeClusterOutputError>(id: "resizeCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResizeClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResizeClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResizeClusterInput, ResizeClusterOutputResponse, ResizeClusterOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ResizeClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting
    ///             cluster with the same configuration as the original cluster from which the snapshot was
    ///             created, except that the new cluster is created with the default cluster security and
    ///             parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different
    ///             parameter group with the restored cluster. If you are using a DS node type, you can also
    ///             choose to change to another DS node type of the same size during restore.</p>
    ///         <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where
    ///             you want the cluster restored.</p>
    ///         <p>
    /// For more information about working with snapshots, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func restoreFromClusterSnapshot(input: RestoreFromClusterSnapshotInput, completion: @escaping (ClientRuntime.SdkResult<RestoreFromClusterSnapshotOutputResponse, RestoreFromClusterSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "restoreFromClusterSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RestoreFromClusterSnapshotInput, RestoreFromClusterSnapshotOutputResponse, RestoreFromClusterSnapshotOutputError>(id: "restoreFromClusterSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RestoreFromClusterSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RestoreFromClusterSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RestoreFromClusterSnapshotInput, RestoreFromClusterSnapshotOutputResponse, RestoreFromClusterSnapshotOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: RestoreFromClusterSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must
    ///             create the new table within the Amazon Redshift cluster that the snapshot was taken
    ///             from.</p>
    ///         <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with
    ///             the same name as an existing table in an Amazon Redshift cluster. That is, you cannot
    ///             overwrite an existing table in a cluster with a restored table. If you want to replace
    ///             your original table with a new, restored table, then rename or drop your original table
    ///             before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your
    ///             original table, then you can pass the original name of the table as the
    ///                 <code>NewTableName</code> parameter value in the call to
    ///                 <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original
    ///             table with the table created from the snapshot.</p>
    public func restoreTableFromClusterSnapshot(input: RestoreTableFromClusterSnapshotInput, completion: @escaping (ClientRuntime.SdkResult<RestoreTableFromClusterSnapshotOutputResponse, RestoreTableFromClusterSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "restoreTableFromClusterSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RestoreTableFromClusterSnapshotInput, RestoreTableFromClusterSnapshotOutputResponse, RestoreTableFromClusterSnapshotOutputError>(id: "restoreTableFromClusterSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RestoreTableFromClusterSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RestoreTableFromClusterSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RestoreTableFromClusterSnapshotInput, RestoreTableFromClusterSnapshotOutputResponse, RestoreTableFromClusterSnapshotOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: RestoreTableFromClusterSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Resumes a paused cluster.</p>
    public func resumeCluster(input: ResumeClusterInput, completion: @escaping (ClientRuntime.SdkResult<ResumeClusterOutputResponse, ResumeClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resumeCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResumeClusterInput, ResumeClusterOutputResponse, ResumeClusterOutputError>(id: "resumeCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResumeClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResumeClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResumeClusterInput, ResumeClusterOutputResponse, ResumeClusterOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: ResumeClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Revokes an ingress rule in an Amazon Redshift security group for a previously authorized
    ///             IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>.
    /// For information about managing security groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
    /// <i>Amazon Redshift Cluster Management Guide</i>. </p>
    public func revokeClusterSecurityGroupIngress(input: RevokeClusterSecurityGroupIngressInput, completion: @escaping (ClientRuntime.SdkResult<RevokeClusterSecurityGroupIngressOutputResponse, RevokeClusterSecurityGroupIngressOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "revokeClusterSecurityGroupIngress")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RevokeClusterSecurityGroupIngressInput, RevokeClusterSecurityGroupIngressOutputResponse, RevokeClusterSecurityGroupIngressOutputError>(id: "revokeClusterSecurityGroupIngress")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RevokeClusterSecurityGroupIngressInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RevokeClusterSecurityGroupIngressInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RevokeClusterSecurityGroupIngressInput, RevokeClusterSecurityGroupIngressOutputResponse, RevokeClusterSecurityGroupIngressOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: RevokeClusterSecurityGroupIngressInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Revokes access to a cluster.</p>
    public func revokeEndpointAccess(input: RevokeEndpointAccessInput, completion: @escaping (ClientRuntime.SdkResult<RevokeEndpointAccessOutputResponse, RevokeEndpointAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "revokeEndpointAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RevokeEndpointAccessInput, RevokeEndpointAccessOutputResponse, RevokeEndpointAccessOutputError>(id: "revokeEndpointAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RevokeEndpointAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RevokeEndpointAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RevokeEndpointAccessInput, RevokeEndpointAccessOutputResponse, RevokeEndpointAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: RevokeEndpointAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the ability of the specified AWS customer account to restore the specified
    ///             snapshot. If the account is currently restoring the snapshot, the restore will run to
    ///             completion.</p>
    ///         <p>
    /// For more information about working with snapshots, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public func revokeSnapshotAccess(input: RevokeSnapshotAccessInput, completion: @escaping (ClientRuntime.SdkResult<RevokeSnapshotAccessOutputResponse, RevokeSnapshotAccessOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "revokeSnapshotAccess")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RevokeSnapshotAccessInput, RevokeSnapshotAccessOutputResponse, RevokeSnapshotAccessOutputError>(id: "revokeSnapshotAccess")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RevokeSnapshotAccessInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RevokeSnapshotAccessInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RevokeSnapshotAccessInput, RevokeSnapshotAccessOutputResponse, RevokeSnapshotAccessOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: RevokeSnapshotAccessInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Rotates the encryption keys for a cluster.</p>
    public func rotateEncryptionKey(input: RotateEncryptionKeyInput, completion: @escaping (ClientRuntime.SdkResult<RotateEncryptionKeyOutputResponse, RotateEncryptionKeyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "rotateEncryptionKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RotateEncryptionKeyInput, RotateEncryptionKeyOutputResponse, RotateEncryptionKeyOutputError>(id: "rotateEncryptionKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RotateEncryptionKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RotateEncryptionKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RotateEncryptionKeyInput, RotateEncryptionKeyOutputResponse, RotateEncryptionKeyOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: RotateEncryptionKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the status of a partner integration.</p>
    public func updatePartnerStatus(input: UpdatePartnerStatusInput, completion: @escaping (ClientRuntime.SdkResult<UpdatePartnerStatusOutputResponse, UpdatePartnerStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updatePartnerStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdatePartnerStatusInput, UpdatePartnerStatusOutputResponse, UpdatePartnerStatusOutputError>(id: "updatePartnerStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdatePartnerStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdatePartnerStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdatePartnerStatusInput, UpdatePartnerStatusOutputResponse, UpdatePartnerStatusOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .before, middleware: UpdatePartnerStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
