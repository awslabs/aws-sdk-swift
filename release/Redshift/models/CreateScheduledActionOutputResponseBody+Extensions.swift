// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct CreateScheduledActionOutputResponseBody: Equatable {
    public let scheduledActionName: String?
    public let targetAction: ScheduledActionType?
    public let schedule: String?
    public let iamRole: String?
    public let scheduledActionDescription: String?
    public let state: ScheduledActionState?
    public let nextInvocations: [Date]?
    public let startTime: Date?
    public let endTime: Date?
}

extension CreateScheduledActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateScheduledActionResult"))
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        var startTimeBuffer:Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        var endTimeBuffer:Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}
