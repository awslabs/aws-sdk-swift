// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct DescribeResizeOutputBody: Equatable {
    public let targetNodeType: String?
    public let targetNumberOfNodes: Int?
    public let targetClusterType: String?
    public let status: String?
    public let importTablesCompleted: [String]?
    public let importTablesInProgress: [String]?
    public let importTablesNotStarted: [String]?
    public let avgResizeRateInMegaBytesPerSecond: Double?
    public let totalResizeDataInMegaBytes: Int?
    public let progressInMegaBytes: Int?
    public let elapsedTimeInSeconds: Int?
    public let estimatedTimeToCompletionInSeconds: Int?
    public let resizeType: String?
    public let message: String?
    public let targetEncryptionType: String?
    public let dataTransferProgressPercent: Double?
}

extension DescribeResizeOutputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case avgResizeRateInMegaBytesPerSecond = "AvgResizeRateInMegaBytesPerSecond"
        case dataTransferProgressPercent = "DataTransferProgressPercent"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case importTablesCompleted = "ImportTablesCompleted"
        case importTablesInProgress = "ImportTablesInProgress"
        case importTablesNotStarted = "ImportTablesNotStarted"
        case message = "Message"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case resizeType = "ResizeType"
        case status = "Status"
        case targetClusterType = "TargetClusterType"
        case targetEncryptionType = "TargetEncryptionType"
        case targetNodeType = "TargetNodeType"
        case targetNumberOfNodes = "TargetNumberOfNodes"
        case totalResizeDataInMegaBytes = "TotalResizeDataInMegaBytes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeResizeResult"))
        let targetNodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetNodeType)
        targetNodeType = targetNodeTypeDecoded
        let targetNumberOfNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .targetNumberOfNodes)
        targetNumberOfNodes = targetNumberOfNodesDecoded
        let targetClusterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetClusterType)
        targetClusterType = targetClusterTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.importTablesCompleted) {
            struct KeyVal0{struct member{}}
            let importTablesCompletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesCompleted)
            if let importTablesCompletedWrappedContainer = importTablesCompletedWrappedContainer {
                let importTablesCompletedContainer = try importTablesCompletedWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesCompletedBuffer:[String]? = nil
                if let importTablesCompletedContainer = importTablesCompletedContainer {
                    importTablesCompletedBuffer = [String]()
                    for stringContainer0 in importTablesCompletedContainer {
                        importTablesCompletedBuffer?.append(stringContainer0)
                    }
                }
                importTablesCompleted = importTablesCompletedBuffer
            } else {
                importTablesCompleted = []
            }
        } else {
            importTablesCompleted = nil
        }
        if containerValues.contains(.importTablesInProgress) {
            struct KeyVal0{struct member{}}
            let importTablesInProgressWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesInProgress)
            if let importTablesInProgressWrappedContainer = importTablesInProgressWrappedContainer {
                let importTablesInProgressContainer = try importTablesInProgressWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesInProgressBuffer:[String]? = nil
                if let importTablesInProgressContainer = importTablesInProgressContainer {
                    importTablesInProgressBuffer = [String]()
                    for stringContainer0 in importTablesInProgressContainer {
                        importTablesInProgressBuffer?.append(stringContainer0)
                    }
                }
                importTablesInProgress = importTablesInProgressBuffer
            } else {
                importTablesInProgress = []
            }
        } else {
            importTablesInProgress = nil
        }
        if containerValues.contains(.importTablesNotStarted) {
            struct KeyVal0{struct member{}}
            let importTablesNotStartedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesNotStarted)
            if let importTablesNotStartedWrappedContainer = importTablesNotStartedWrappedContainer {
                let importTablesNotStartedContainer = try importTablesNotStartedWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesNotStartedBuffer:[String]? = nil
                if let importTablesNotStartedContainer = importTablesNotStartedContainer {
                    importTablesNotStartedBuffer = [String]()
                    for stringContainer0 in importTablesNotStartedContainer {
                        importTablesNotStartedBuffer?.append(stringContainer0)
                    }
                }
                importTablesNotStarted = importTablesNotStartedBuffer
            } else {
                importTablesNotStarted = []
            }
        } else {
            importTablesNotStarted = nil
        }
        let avgResizeRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .avgResizeRateInMegaBytesPerSecond)
        avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecondDecoded
        let totalResizeDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalResizeDataInMegaBytes)
        totalResizeDataInMegaBytes = totalResizeDataInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let targetEncryptionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetEncryptionType)
        targetEncryptionType = targetEncryptionTypeDecoded
        let dataTransferProgressPercentDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .dataTransferProgressPercent)
        dataTransferProgressPercent = dataTransferProgressPercentDecoded
    }
}
