// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ScheduledAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let iamRole = iamRole {
            try container.encode(iamRole, forKey: Key("IamRole"))
        }
        if let nextInvocations = nextInvocations {
            var nextInvocationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NextInvocations"))
            for (index0, tstamp0) in nextInvocations.enumerated() {
                try nextInvocationsContainer.encode(TimestampWrapper(tstamp0, format: .dateTime), forKey: Key("ScheduledActionTime.\(index0.advanced(by: 1))"))
            }
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: Key("Schedule"))
        }
        if let scheduledActionDescription = scheduledActionDescription {
            try container.encode(scheduledActionDescription, forKey: Key("ScheduledActionDescription"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let targetAction = targetAction {
            try container.encode(targetAction, forKey: Key("TargetAction"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        var startTimeBuffer:Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        var endTimeBuffer:Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}
