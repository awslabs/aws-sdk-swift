// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Snapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountsWithRestoreAccess = "AccountsWithRestoreAccess"
        case actualIncrementalBackupSizeInMegaBytes = "ActualIncrementalBackupSizeInMegaBytes"
        case availabilityZone = "AvailabilityZone"
        case backupProgressInMegaBytes = "BackupProgressInMegaBytes"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterVersion = "ClusterVersion"
        case currentBackupRateInMegaBytesPerSecond = "CurrentBackupRateInMegaBytesPerSecond"
        case dBName = "DBName"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case encrypted = "Encrypted"
        case encryptedWithHSM = "EncryptedWithHSM"
        case engineFullVersion = "EngineFullVersion"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case estimatedSecondsToCompletion = "EstimatedSecondsToCompletion"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRemainingDays = "ManualSnapshotRemainingDays"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case ownerAccount = "OwnerAccount"
        case port = "Port"
        case restorableNodeTypes = "RestorableNodeTypes"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotIdentifier = "SnapshotIdentifier"
        case snapshotRetentionStartTime = "SnapshotRetentionStartTime"
        case snapshotType = "SnapshotType"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case tags = "Tags"
        case totalBackupSizeInMegaBytes = "TotalBackupSizeInMegaBytes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountsWithRestoreAccess = accountsWithRestoreAccess {
            var accountsWithRestoreAccessContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AccountsWithRestoreAccess"))
            for (index0, accountwithrestoreaccess0) in accountsWithRestoreAccess.enumerated() {
                try accountsWithRestoreAccessContainer.encode(accountwithrestoreaccess0, forKey: Key("AccountWithRestoreAccess.\(index0.advanced(by: 1))"))
            }
        }
        if actualIncrementalBackupSizeInMegaBytes != 0.0 {
            try container.encode(actualIncrementalBackupSizeInMegaBytes, forKey: Key("ActualIncrementalBackupSizeInMegaBytes"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if backupProgressInMegaBytes != 0.0 {
            try container.encode(backupProgressInMegaBytes, forKey: Key("BackupProgressInMegaBytes"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if currentBackupRateInMegaBytesPerSecond != 0.0 {
            try container.encode(currentBackupRateInMegaBytesPerSecond, forKey: Key("CurrentBackupRateInMegaBytesPerSecond"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if elapsedTimeInSeconds != 0 {
            try container.encode(elapsedTimeInSeconds, forKey: Key("ElapsedTimeInSeconds"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: Key("Encrypted"))
        }
        if encryptedWithHSM != false {
            try container.encode(encryptedWithHSM, forKey: Key("EncryptedWithHSM"))
        }
        if let engineFullVersion = engineFullVersion {
            try container.encode(engineFullVersion, forKey: Key("EngineFullVersion"))
        }
        if enhancedVpcRouting != false {
            try container.encode(enhancedVpcRouting, forKey: Key("EnhancedVpcRouting"))
        }
        if estimatedSecondsToCompletion != 0 {
            try container.encode(estimatedSecondsToCompletion, forKey: Key("EstimatedSecondsToCompletion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRemainingDays = manualSnapshotRemainingDays {
            try container.encode(manualSnapshotRemainingDays, forKey: Key("ManualSnapshotRemainingDays"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: Key("OwnerAccount"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let restorableNodeTypes = restorableNodeTypes {
            var restorableNodeTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RestorableNodeTypes"))
            for (index0, string0) in restorableNodeTypes.enumerated() {
                try restorableNodeTypesContainer.encode(string0, forKey: Key("NodeType.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: Key("snapshotCreateTime"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let snapshotRetentionStartTime = snapshotRetentionStartTime {
            try container.encode(TimestampWrapper(snapshotRetentionStartTime, format: .dateTime), forKey: Key("snapshotRetentionStartTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        if let sourceRegion = sourceRegion {
            try container.encode(sourceRegion, forKey: Key("SourceRegion"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if totalBackupSizeInMegaBytes != 0.0 {
            try container.encode(totalBackupSizeInMegaBytes, forKey: Key("TotalBackupSizeInMegaBytes"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let engineFullVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineFullVersion)
        engineFullVersion = engineFullVersionDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedWithHSMDecoded = try containerValues.decode(Bool.self, forKey: .encryptedWithHSM)
        encryptedWithHSM = encryptedWithHSMDecoded
        if containerValues.contains(.accountsWithRestoreAccess) {
            struct KeyVal0{struct AccountWithRestoreAccess{}}
            let accountsWithRestoreAccessWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountWithRestoreAccess>.CodingKeys.self, forKey: .accountsWithRestoreAccess)
            if let accountsWithRestoreAccessWrappedContainer = accountsWithRestoreAccessWrappedContainer {
                let accountsWithRestoreAccessContainer = try accountsWithRestoreAccessWrappedContainer.decodeIfPresent([AccountWithRestoreAccess].self, forKey: .member)
                var accountsWithRestoreAccessBuffer:[AccountWithRestoreAccess]? = nil
                if let accountsWithRestoreAccessContainer = accountsWithRestoreAccessContainer {
                    accountsWithRestoreAccessBuffer = [AccountWithRestoreAccess]()
                    for structureContainer0 in accountsWithRestoreAccessContainer {
                        accountsWithRestoreAccessBuffer?.append(structureContainer0)
                    }
                }
                accountsWithRestoreAccess = accountsWithRestoreAccessBuffer
            } else {
                accountsWithRestoreAccess = []
            }
        } else {
            accountsWithRestoreAccess = nil
        }
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let actualIncrementalBackupSizeInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .actualIncrementalBackupSizeInMegaBytes)
        actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytesDecoded
        let backupProgressInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .backupProgressInMegaBytes)
        backupProgressInMegaBytes = backupProgressInMegaBytesDecoded
        let currentBackupRateInMegaBytesPerSecondDecoded = try containerValues.decode(Double.self, forKey: .currentBackupRateInMegaBytesPerSecond)
        currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecondDecoded
        let estimatedSecondsToCompletionDecoded = try containerValues.decode(Int.self, forKey: .estimatedSecondsToCompletion)
        estimatedSecondsToCompletion = estimatedSecondsToCompletionDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.restorableNodeTypes) {
            struct KeyVal0{struct NodeType{}}
            let restorableNodeTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeType>.CodingKeys.self, forKey: .restorableNodeTypes)
            if let restorableNodeTypesWrappedContainer = restorableNodeTypesWrappedContainer {
                let restorableNodeTypesContainer = try restorableNodeTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var restorableNodeTypesBuffer:[String]? = nil
                if let restorableNodeTypesContainer = restorableNodeTypesContainer {
                    restorableNodeTypesBuffer = [String]()
                    for stringContainer0 in restorableNodeTypesContainer {
                        restorableNodeTypesBuffer?.append(stringContainer0)
                    }
                }
                restorableNodeTypes = restorableNodeTypesBuffer
            } else {
                restorableNodeTypes = []
            }
        } else {
            restorableNodeTypes = nil
        }
        let enhancedVpcRoutingDecoded = try containerValues.decode(Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let manualSnapshotRemainingDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .manualSnapshotRemainingDays)
        manualSnapshotRemainingDays = manualSnapshotRemainingDaysDecoded
        let snapshotRetentionStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotRetentionStartTime)
        var snapshotRetentionStartTimeBuffer:Date? = nil
        if let snapshotRetentionStartTimeDecoded = snapshotRetentionStartTimeDecoded {
            snapshotRetentionStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotRetentionStartTimeDecoded, format: .dateTime)
        }
        snapshotRetentionStartTime = snapshotRetentionStartTimeBuffer
    }
}
