// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptReservedNodeExchangeInputBodyMiddleware: Middleware {
    public let id: String = "AcceptReservedNodeExchangeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptReservedNodeExchangeInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptReservedNodeExchangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptReservedNodeExchangeInput>
    public typealias MOutput = OperationOutput<AcceptReservedNodeExchangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptReservedNodeExchangeOutputError>
}

extension AcceptReservedNodeExchangeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptReservedNodeExchangeInput(reservedNodeId: \(String(describing: reservedNodeId)), targetReservedNodeOfferingId: \(String(describing: targetReservedNodeOfferingId)))"}
}

extension AcceptReservedNodeExchangeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: Key("ReservedNodeId"))
        }
        if let targetReservedNodeOfferingId = targetReservedNodeOfferingId {
            try container.encode(targetReservedNodeOfferingId, forKey: Key("TargetReservedNodeOfferingId"))
        }
        try container.encode("AcceptReservedNodeExchange", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct AcceptReservedNodeExchangeInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptReservedNodeExchangeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptReservedNodeExchangeInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptReservedNodeExchangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptReservedNodeExchangeInput>
    public typealias MOutput = OperationOutput<AcceptReservedNodeExchangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptReservedNodeExchangeOutputError>
}

public struct AcceptReservedNodeExchangeInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptReservedNodeExchangeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptReservedNodeExchangeInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptReservedNodeExchangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptReservedNodeExchangeInput>
    public typealias MOutput = OperationOutput<AcceptReservedNodeExchangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptReservedNodeExchangeOutputError>
}

public struct AcceptReservedNodeExchangeInput: Equatable {
    /// <p>A string representing the node identifier of the DC1 Reserved Node to be
    ///             exchanged.</p>
    public let reservedNodeId: String?
    /// <p>The unique identifier of the DC2 Reserved Node offering to be used for the exchange.
    ///             You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a>
    ///          </p>
    public let targetReservedNodeOfferingId: String?

    public init (
        reservedNodeId: String? = nil,
        targetReservedNodeOfferingId: String? = nil
    )
    {
        self.reservedNodeId = reservedNodeId
        self.targetReservedNodeOfferingId = targetReservedNodeOfferingId
    }
}

extension AcceptReservedNodeExchangeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AcceptReservedNodeExchangeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReservedNodeStateFault" : self = .invalidReservedNodeStateFault(try InvalidReservedNodeStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeAlreadyExistsFault" : self = .reservedNodeAlreadyExistsFault(try ReservedNodeAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeAlreadyMigratedFault" : self = .reservedNodeAlreadyMigratedFault(try ReservedNodeAlreadyMigratedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeNotFoundFault" : self = .reservedNodeNotFoundFault(try ReservedNodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptReservedNodeExchangeOutputError: Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case invalidReservedNodeStateFault(InvalidReservedNodeStateFault)
    case reservedNodeAlreadyExistsFault(ReservedNodeAlreadyExistsFault)
    case reservedNodeAlreadyMigratedFault(ReservedNodeAlreadyMigratedFault)
    case reservedNodeNotFoundFault(ReservedNodeNotFoundFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptReservedNodeExchangeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptReservedNodeExchangeOutputResponse(exchangedReservedNode: \(String(describing: exchangedReservedNode)))"}
}

extension AcceptReservedNodeExchangeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AcceptReservedNodeExchangeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exchangedReservedNode = output.exchangedReservedNode
        } else {
            self.exchangedReservedNode = nil
        }
    }
}

public struct AcceptReservedNodeExchangeOutputResponse: Equatable {
    /// <p></p>
    public let exchangedReservedNode: ReservedNode?

    public init (
        exchangedReservedNode: ReservedNode? = nil
    )
    {
        self.exchangedReservedNode = exchangedReservedNode
    }
}

struct AcceptReservedNodeExchangeOutputResponseBody: Equatable {
    public let exchangedReservedNode: ReservedNode?
}

extension AcceptReservedNodeExchangeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exchangedReservedNode = "ExchangedReservedNode"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AcceptReservedNodeExchangeResult"))
        let exchangedReservedNodeDecoded = try containerValues.decodeIfPresent(ReservedNode.self, forKey: .exchangedReservedNode)
        exchangedReservedNode = exchangedReservedNodeDecoded
    }
}

extension AccessToClusterDeniedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessToClusterDeniedFault(message: \(String(describing: message)))"}
}

extension AccessToClusterDeniedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AccessToClusterDeniedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to access the cluster.</p>
public struct AccessToClusterDeniedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessToClusterDeniedFaultBody: Equatable {
    public let message: String?
}

extension AccessToClusterDeniedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessToSnapshotDeniedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessToSnapshotDeniedFault(message: \(String(describing: message)))"}
}

extension AccessToSnapshotDeniedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AccessToSnapshotDeniedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The owner of the specified snapshot has not authorized your account to access the
///             snapshot.</p>
public struct AccessToSnapshotDeniedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessToSnapshotDeniedFaultBody: Equatable {
    public let message: String?
}

extension AccessToSnapshotDeniedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttributeValues"))
            for (index0, attributevaluetarget0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(attributevaluetarget0, forKey: Key("AttributeValueTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValueTarget{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValueTarget>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([AttributeValueTarget].self, forKey: .member)
                var attributeValuesBuffer:[AttributeValueTarget]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [AttributeValueTarget]()
                    for structureContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(structureContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension AccountAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountAttribute(attributeName: \(String(describing: attributeName)), attributeValues: \(String(describing: attributeValues)))"}
}

/// <p>A name value pair that describes an aspect of an account. </p>
public struct AccountAttribute: Equatable {
    /// <p>The name of the attribute.</p>
    public let attributeName: String?
    /// <p>A list of attribute values.</p>
    public let attributeValues: [AttributeValueTarget]?

    public init (
        attributeName: String? = nil,
        attributeValues: [AttributeValueTarget]? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValues = attributeValues
    }
}

extension AccountWithRestoreAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountAlias = "AccountAlias"
        case accountId = "AccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: Key("AccountAlias"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: Key("AccountId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let accountAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension AccountWithRestoreAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountWithRestoreAccess(accountAlias: \(String(describing: accountAlias)), accountId: \(String(describing: accountId)))"}
}

/// <p>Describes an AWS customer account authorized to restore a snapshot.</p>
public struct AccountWithRestoreAccess: Equatable {
    /// <p>The identifier of an AWS support account authorized to restore a snapshot. For AWS
    ///             support, the identifier is <code>amazon-redshift-support</code>. </p>
    public let accountAlias: String?
    /// <p>The identifier of an AWS customer account authorized to restore a
    ///             snapshot.</p>
    public let accountId: String?

    public init (
        accountAlias: String? = nil,
        accountId: String? = nil
    )
    {
        self.accountAlias = accountAlias
        self.accountId = accountId
    }
}

public enum ActionType {
    case recommendNodeConfig
    case resizeCluster
    case restoreCluster
    case sdkUnknown(String)
}

extension ActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionType] {
        return [
            .recommendNodeConfig,
            .resizeCluster,
            .restoreCluster,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .recommendNodeConfig: return "recommend-node-config"
        case .resizeCluster: return "resize-cluster"
        case .restoreCluster: return "restore-cluster"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
    }
}

public struct AddPartnerInputBodyMiddleware: Middleware {
    public let id: String = "AddPartnerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPartnerInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPartnerInput>
    public typealias MOutput = OperationOutput<AddPartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPartnerOutputError>
}

extension AddPartnerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddPartnerInput(accountId: \(String(describing: accountId)), clusterIdentifier: \(String(describing: clusterIdentifier)), databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)))"}
}

extension AddPartnerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: Key("PartnerName"))
        }
        try container.encode("AddPartner", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct AddPartnerInputHeadersMiddleware: Middleware {
    public let id: String = "AddPartnerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPartnerInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPartnerInput>
    public typealias MOutput = OperationOutput<AddPartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPartnerOutputError>
}

public struct AddPartnerInputQueryItemMiddleware: Middleware {
    public let id: String = "AddPartnerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPartnerInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPartnerInput>
    public typealias MOutput = OperationOutput<AddPartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPartnerOutputError>
}

public struct AddPartnerInput: Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: String?
    /// <p>The cluster identifier of the cluster that receives data from the partner.</p>
    public let clusterIdentifier: String?
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: String?

    public init (
        accountId: String? = nil,
        clusterIdentifier: String? = nil,
        databaseName: String? = nil,
        partnerName: String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

extension AddPartnerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddPartnerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PartnerNotFoundFault" : self = .partnerNotFoundFault(try PartnerNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPartnerOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case partnerNotFoundFault(PartnerNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPartnerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddPartnerOutputResponse(databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)))"}
}

extension AddPartnerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddPartnerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.databaseName = output.databaseName
            self.partnerName = output.partnerName
        } else {
            self.databaseName = nil
            self.partnerName = nil
        }
    }
}

public struct AddPartnerOutputResponse: Equatable {
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: String?

    public init (
        databaseName: String? = nil,
        partnerName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

struct AddPartnerOutputResponseBody: Equatable {
    public let databaseName: String?
    public let partnerName: String?
}

extension AddPartnerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AddPartnerResult"))
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
    }
}

extension AquaConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aquaConfigurationStatus = "AquaConfigurationStatus"
        case aquaStatus = "AquaStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: Key("AquaConfigurationStatus"))
        }
        if let aquaStatus = aquaStatus {
            try container.encode(aquaStatus, forKey: Key("AquaStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aquaStatusDecoded = try containerValues.decodeIfPresent(AquaStatus.self, forKey: .aquaStatus)
        aquaStatus = aquaStatusDecoded
        let aquaConfigurationStatusDecoded = try containerValues.decodeIfPresent(AquaConfigurationStatus.self, forKey: .aquaConfigurationStatus)
        aquaConfigurationStatus = aquaConfigurationStatusDecoded
    }
}

extension AquaConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AquaConfiguration(aquaConfigurationStatus: \(String(describing: aquaConfigurationStatus)), aquaStatus: \(String(describing: aquaStatus)))"}
}

/// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
public struct AquaConfiguration: Equatable {
    /// <p>The value represents how the cluster is configured to use AQUA. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - Don't use AQUA. </p>
    ///             </li>
    ///             <li>
    ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    ///             </li>
    ///          </ul>
    public let aquaConfigurationStatus: AquaConfigurationStatus?
    /// <p>The value indicates the status of AQUA on the cluster. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - AQUA is enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - AQUA is not enabled. </p>
    ///             </li>
    ///             <li>
    ///                <p>applying - AQUA status is being applied. </p>
    ///             </li>
    ///          </ul>
    public let aquaStatus: AquaStatus?

    public init (
        aquaConfigurationStatus: AquaConfigurationStatus? = nil,
        aquaStatus: AquaStatus? = nil
    )
    {
        self.aquaConfigurationStatus = aquaConfigurationStatus
        self.aquaStatus = aquaStatus
    }
}

public enum AquaConfigurationStatus {
    case auto
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension AquaConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AquaConfigurationStatus] {
        return [
            .auto,
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auto: return "auto"
        case .disabled: return "disabled"
        case .enabled: return "enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AquaConfigurationStatus(rawValue: rawValue) ?? AquaConfigurationStatus.sdkUnknown(rawValue)
    }
}

public enum AquaStatus {
    case applying
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension AquaStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AquaStatus] {
        return [
            .applying,
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .applying: return "applying"
        case .disabled: return "disabled"
        case .enabled: return "enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AquaStatus(rawValue: rawValue) ?? AquaStatus.sdkUnknown(rawValue)
    }
}

extension AttributeValueTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: Key("AttributeValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension AttributeValueTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeValueTarget(attributeValue: \(String(describing: attributeValue)))"}
}

/// <p>Describes an attribute value.</p>
public struct AttributeValueTarget: Equatable {
    /// <p>The value of the attribute.</p>
    public let attributeValue: String?

    public init (
        attributeValue: String? = nil
    )
    {
        self.attributeValue = attributeValue
    }
}

extension AuthorizationAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension AuthorizationAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CIDR block or EC2 security group is already authorized for the
///             specified cluster security group.</p>
public struct AuthorizationAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension AuthorizationAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationNotFoundFault(message: \(String(describing: message)))"}
}

extension AuthorizationNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CIDR IP range or EC2 security group is not authorized for the
///             specified cluster security group.</p>
public struct AuthorizationNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationNotFoundFaultBody: Equatable {
    public let message: String?
}

extension AuthorizationNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationQuotaExceededFault(message: \(String(describing: message)))"}
}

extension AuthorizationQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The authorization quota for the cluster security group has been reached.</p>
public struct AuthorizationQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension AuthorizationQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AuthorizationStatus {
    case authorized
    case revoking
    case sdkUnknown(String)
}

extension AuthorizationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthorizationStatus] {
        return [
            .authorized,
            .revoking,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authorized: return "Authorized"
        case .revoking: return "Revoking"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthorizationStatus(rawValue: rawValue) ?? AuthorizationStatus.sdkUnknown(rawValue)
    }
}

public struct AuthorizeClusterSecurityGroupIngressInputBodyMiddleware: Middleware {
    public let id: String = "AuthorizeClusterSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeClusterSecurityGroupIngressOutputError>
}

extension AuthorizeClusterSecurityGroupIngressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeClusterSecurityGroupIngressInput(cIDRIP: \(String(describing: cIDRIP)), clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)), eC2SecurityGroupName: \(String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(String(describing: eC2SecurityGroupOwnerId)))"}
}

extension AuthorizeClusterSecurityGroupIngressInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: Key("CIDRIP"))
        }
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: Key("ClusterSecurityGroupName"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("AuthorizeClusterSecurityGroupIngress", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct AuthorizeClusterSecurityGroupIngressInputHeadersMiddleware: Middleware {
    public let id: String = "AuthorizeClusterSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeClusterSecurityGroupIngressOutputError>
}

public struct AuthorizeClusterSecurityGroupIngressInputQueryItemMiddleware: Middleware {
    public let id: String = "AuthorizeClusterSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeClusterSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<AuthorizeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeClusterSecurityGroupIngressOutputError>
}

/// <p></p>
public struct AuthorizeClusterSecurityGroupIngressInput: Equatable {
    /// <p>The IP range to be added the Amazon Redshift security group.</p>
    public let cIDRIP: String?
    /// <p>The name of the security group to which the ingress rule is added.</p>
    public let clusterSecurityGroupName: String?
    /// <p>The EC2 security group to be added the Amazon Redshift security group.</p>
    public let eC2SecurityGroupName: String?
    /// <p>The AWS account number of the owner of the security group specified by the
    ///                 <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an
    ///             acceptable value. </p>
    ///         <p>Example: <code>111122223333</code>
    ///         </p>
    public let eC2SecurityGroupOwnerId: String?

    public init (
        cIDRIP: String? = nil,
        clusterSecurityGroupName: String? = nil,
        eC2SecurityGroupName: String? = nil,
        eC2SecurityGroupOwnerId: String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension AuthorizeClusterSecurityGroupIngressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeClusterSecurityGroupIngressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationAlreadyExistsFault" : self = .authorizationAlreadyExistsFault(try AuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationQuotaExceededFault" : self = .authorizationQuotaExceededFault(try AuthorizationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeClusterSecurityGroupIngressOutputError: Equatable {
    case authorizationAlreadyExistsFault(AuthorizationAlreadyExistsFault)
    case authorizationQuotaExceededFault(AuthorizationQuotaExceededFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeClusterSecurityGroupIngressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeClusterSecurityGroupIngressOutputResponse(clusterSecurityGroup: \(String(describing: clusterSecurityGroup)))"}
}

extension AuthorizeClusterSecurityGroupIngressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorizeClusterSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterSecurityGroup = output.clusterSecurityGroup
        } else {
            self.clusterSecurityGroup = nil
        }
    }
}

public struct AuthorizeClusterSecurityGroupIngressOutputResponse: Equatable {
    /// <p>Describes a security group.</p>
    public let clusterSecurityGroup: ClusterSecurityGroup?

    public init (
        clusterSecurityGroup: ClusterSecurityGroup? = nil
    )
    {
        self.clusterSecurityGroup = clusterSecurityGroup
    }
}

struct AuthorizeClusterSecurityGroupIngressOutputResponseBody: Equatable {
    public let clusterSecurityGroup: ClusterSecurityGroup?
}

extension AuthorizeClusterSecurityGroupIngressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterSecurityGroup = "ClusterSecurityGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AuthorizeClusterSecurityGroupIngressResult"))
        let clusterSecurityGroupDecoded = try containerValues.decodeIfPresent(ClusterSecurityGroup.self, forKey: .clusterSecurityGroup)
        clusterSecurityGroup = clusterSecurityGroupDecoded
    }
}

public struct AuthorizeEndpointAccessInputBodyMiddleware: Middleware {
    public let id: String = "AuthorizeEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeEndpointAccessInput>
    public typealias MOutput = OperationOutput<AuthorizeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeEndpointAccessOutputError>
}

extension AuthorizeEndpointAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeEndpointAccessInput(account: \(String(describing: account)), clusterIdentifier: \(String(describing: clusterIdentifier)), vpcIds: \(String(describing: vpcIds)))"}
}

extension AuthorizeEndpointAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let account = account {
            try container.encode(account, forKey: Key("Account"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let vpcIds = vpcIds {
            var vpcIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcIds"))
            for (index0, string0) in vpcIds.enumerated() {
                try vpcIdsContainer.encode(string0, forKey: Key("VpcIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AuthorizeEndpointAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct AuthorizeEndpointAccessInputHeadersMiddleware: Middleware {
    public let id: String = "AuthorizeEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeEndpointAccessInput>
    public typealias MOutput = OperationOutput<AuthorizeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeEndpointAccessOutputError>
}

public struct AuthorizeEndpointAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "AuthorizeEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeEndpointAccessInput>
    public typealias MOutput = OperationOutput<AuthorizeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeEndpointAccessOutputError>
}

public struct AuthorizeEndpointAccessInput: Equatable {
    /// <p>The AWS account ID to grant access to.</p>
    public let account: String?
    /// <p>The cluster identifier of the cluster to grant access to.</p>
    public let clusterIdentifier: String?
    /// <p>The virtual private cloud (VPC) identifiers to grant access to.</p>
    public let vpcIds: [String]?

    public init (
        account: String? = nil,
        clusterIdentifier: String? = nil,
        vpcIds: [String]? = nil
    )
    {
        self.account = account
        self.clusterIdentifier = clusterIdentifier
        self.vpcIds = vpcIds
    }
}

extension AuthorizeEndpointAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeEndpointAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAuthorizationAlreadyExistsFault" : self = .endpointAuthorizationAlreadyExistsFault(try EndpointAuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAuthorizationsPerClusterLimitExceededFault" : self = .endpointAuthorizationsPerClusterLimitExceededFault(try EndpointAuthorizationsPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthorizationStateFault" : self = .invalidAuthorizationStateFault(try InvalidAuthorizationStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeEndpointAccessOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointAuthorizationAlreadyExistsFault(EndpointAuthorizationAlreadyExistsFault)
    case endpointAuthorizationsPerClusterLimitExceededFault(EndpointAuthorizationsPerClusterLimitExceededFault)
    case invalidAuthorizationStateFault(InvalidAuthorizationStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeEndpointAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeEndpointAccessOutputResponse(allowedAllVPCs: \(String(describing: allowedAllVPCs)), allowedVPCs: \(String(describing: allowedVPCs)), authorizeTime: \(String(describing: authorizeTime)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterStatus: \(String(describing: clusterStatus)), endpointCount: \(String(describing: endpointCount)), grantee: \(String(describing: grantee)), grantor: \(String(describing: grantor)), status: \(String(describing: status)))"}
}

extension AuthorizeEndpointAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorizeEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowedAllVPCs = output.allowedAllVPCs
            self.allowedVPCs = output.allowedVPCs
            self.authorizeTime = output.authorizeTime
            self.clusterIdentifier = output.clusterIdentifier
            self.clusterStatus = output.clusterStatus
            self.endpointCount = output.endpointCount
            self.grantee = output.grantee
            self.grantor = output.grantor
            self.status = output.status
        } else {
            self.allowedAllVPCs = false
            self.allowedVPCs = nil
            self.authorizeTime = nil
            self.clusterIdentifier = nil
            self.clusterStatus = nil
            self.endpointCount = 0
            self.grantee = nil
            self.grantor = nil
            self.status = nil
        }
    }
}

/// <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across AWS accounts.</p>
public struct AuthorizeEndpointAccessOutputResponse: Equatable {
    /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
    public let allowedAllVPCs: Bool
    /// <p>The VPCs allowed access to the cluster.</p>
    public let allowedVPCs: [String]?
    /// <p>The time (UTC) when the authorization was created.</p>
    public let authorizeTime: Date?
    /// <p>The cluster identifier.</p>
    public let clusterIdentifier: String?
    /// <p>The status of the cluster.</p>
    public let clusterStatus: String?
    /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
    public let endpointCount: Int
    /// <p>The AWS account ID of the grantee of the cluster.</p>
    public let grantee: String?
    /// <p>The AWS account ID of the cluster owner.</p>
    public let grantor: String?
    /// <p>The status of the authorization action.</p>
    public let status: AuthorizationStatus?

    public init (
        allowedAllVPCs: Bool = false,
        allowedVPCs: [String]? = nil,
        authorizeTime: Date? = nil,
        clusterIdentifier: String? = nil,
        clusterStatus: String? = nil,
        endpointCount: Int = 0,
        grantee: String? = nil,
        grantor: String? = nil,
        status: AuthorizationStatus? = nil
    )
    {
        self.allowedAllVPCs = allowedAllVPCs
        self.allowedVPCs = allowedVPCs
        self.authorizeTime = authorizeTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterStatus = clusterStatus
        self.endpointCount = endpointCount
        self.grantee = grantee
        self.grantor = grantor
        self.status = status
    }
}

struct AuthorizeEndpointAccessOutputResponseBody: Equatable {
    public let grantor: String?
    public let grantee: String?
    public let clusterIdentifier: String?
    public let authorizeTime: Date?
    public let clusterStatus: String?
    public let status: AuthorizationStatus?
    public let allowedAllVPCs: Bool
    public let allowedVPCs: [String]?
    public let endpointCount: Int
}

extension AuthorizeEndpointAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowedAllVPCs = "AllowedAllVPCs"
        case allowedVPCs = "AllowedVPCs"
        case authorizeTime = "AuthorizeTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterStatus = "ClusterStatus"
        case endpointCount = "EndpointCount"
        case grantee = "Grantee"
        case grantor = "Grantor"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AuthorizeEndpointAccessResult"))
        let grantorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantor)
        grantor = grantorDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantee)
        grantee = granteeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let authorizeTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizeTime)
        var authorizeTimeBuffer:Date? = nil
        if let authorizeTimeDecoded = authorizeTimeDecoded {
            authorizeTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(authorizeTimeDecoded, format: .dateTime)
        }
        authorizeTime = authorizeTimeBuffer
        let clusterStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let allowedAllVPCsDecoded = try containerValues.decode(Bool.self, forKey: .allowedAllVPCs)
        allowedAllVPCs = allowedAllVPCsDecoded
        if containerValues.contains(.allowedVPCs) {
            struct KeyVal0{struct VpcIdentifier{}}
            let allowedVPCsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcIdentifier>.CodingKeys.self, forKey: .allowedVPCs)
            if let allowedVPCsWrappedContainer = allowedVPCsWrappedContainer {
                let allowedVPCsContainer = try allowedVPCsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var allowedVPCsBuffer:[String]? = nil
                if let allowedVPCsContainer = allowedVPCsContainer {
                    allowedVPCsBuffer = [String]()
                    for stringContainer0 in allowedVPCsContainer {
                        allowedVPCsBuffer?.append(stringContainer0)
                    }
                }
                allowedVPCs = allowedVPCsBuffer
            } else {
                allowedVPCs = []
            }
        } else {
            allowedVPCs = nil
        }
        let endpointCountDecoded = try containerValues.decode(Int.self, forKey: .endpointCount)
        endpointCount = endpointCountDecoded
    }
}

public struct AuthorizeSnapshotAccessInputBodyMiddleware: Middleware {
    public let id: String = "AuthorizeSnapshotAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeSnapshotAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeSnapshotAccessInput>
    public typealias MOutput = OperationOutput<AuthorizeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeSnapshotAccessOutputError>
}

extension AuthorizeSnapshotAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeSnapshotAccessInput(accountWithRestoreAccess: \(String(describing: accountWithRestoreAccess)), snapshotClusterIdentifier: \(String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(String(describing: snapshotIdentifier)))"}
}

extension AuthorizeSnapshotAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountWithRestoreAccess = accountWithRestoreAccess {
            try container.encode(accountWithRestoreAccess, forKey: Key("AccountWithRestoreAccess"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        try container.encode("AuthorizeSnapshotAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct AuthorizeSnapshotAccessInputHeadersMiddleware: Middleware {
    public let id: String = "AuthorizeSnapshotAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeSnapshotAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeSnapshotAccessInput>
    public typealias MOutput = OperationOutput<AuthorizeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeSnapshotAccessOutputError>
}

public struct AuthorizeSnapshotAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "AuthorizeSnapshotAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeSnapshotAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeSnapshotAccessInput>
    public typealias MOutput = OperationOutput<AuthorizeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeSnapshotAccessOutputError>
}

/// <p></p>
public struct AuthorizeSnapshotAccessInput: Equatable {
    /// <p>The identifier of the AWS customer account authorized to restore the specified
    ///             snapshot.</p>
    ///         <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
    public let accountWithRestoreAccess: String?
    /// <p>The identifier of the cluster the snapshot was created from. This parameter is
    ///             required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    public let snapshotClusterIdentifier: String?
    /// <p>The identifier of the snapshot the account is authorized to restore.</p>
    public let snapshotIdentifier: String?

    public init (
        accountWithRestoreAccess: String? = nil,
        snapshotClusterIdentifier: String? = nil,
        snapshotIdentifier: String? = nil
    )
    {
        self.accountWithRestoreAccess = accountWithRestoreAccess
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension AuthorizeSnapshotAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeSnapshotAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationAlreadyExistsFault" : self = .authorizationAlreadyExistsFault(try AuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationQuotaExceededFault" : self = .authorizationQuotaExceededFault(try AuthorizationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeSnapshotAccessOutputError: Equatable {
    case authorizationAlreadyExistsFault(AuthorizationAlreadyExistsFault)
    case authorizationQuotaExceededFault(AuthorizationQuotaExceededFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case limitExceededFault(LimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeSnapshotAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeSnapshotAccessOutputResponse(snapshot: \(String(describing: snapshot)))"}
}

extension AuthorizeSnapshotAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorizeSnapshotAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct AuthorizeSnapshotAccessOutputResponse: Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: Snapshot?

    public init (
        snapshot: Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct AuthorizeSnapshotAccessOutputResponseBody: Equatable {
    public let snapshot: Snapshot?
}

extension AuthorizeSnapshotAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AuthorizeSnapshotAccessResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension AvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case supportedPlatforms = "SupportedPlatforms"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let supportedPlatforms = supportedPlatforms {
            var supportedPlatformsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedPlatforms"))
            for (index0, supportedplatform0) in supportedPlatforms.enumerated() {
                try supportedPlatformsContainer.encode(supportedplatform0, forKey: Key("SupportedPlatform.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.supportedPlatforms) {
            struct KeyVal0{struct SupportedPlatform{}}
            let supportedPlatformsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SupportedPlatform>.CodingKeys.self, forKey: .supportedPlatforms)
            if let supportedPlatformsWrappedContainer = supportedPlatformsWrappedContainer {
                let supportedPlatformsContainer = try supportedPlatformsWrappedContainer.decodeIfPresent([SupportedPlatform].self, forKey: .member)
                var supportedPlatformsBuffer:[SupportedPlatform]? = nil
                if let supportedPlatformsContainer = supportedPlatformsContainer {
                    supportedPlatformsBuffer = [SupportedPlatform]()
                    for structureContainer0 in supportedPlatformsContainer {
                        supportedPlatformsBuffer?.append(structureContainer0)
                    }
                }
                supportedPlatforms = supportedPlatformsBuffer
            } else {
                supportedPlatforms = []
            }
        } else {
            supportedPlatforms = nil
        }
    }
}

extension AvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZone(name: \(String(describing: name)), supportedPlatforms: \(String(describing: supportedPlatforms)))"}
}

/// <p>Describes an availability zone.</p>
public struct AvailabilityZone: Equatable {
    /// <p>The name of the availability zone.</p>
    public let name: String?
    /// <p></p>
    public let supportedPlatforms: [SupportedPlatform]?

    public init (
        name: String? = nil,
        supportedPlatforms: [SupportedPlatform]? = nil
    )
    {
        self.name = name
        self.supportedPlatforms = supportedPlatforms
    }
}

public struct BatchDeleteClusterSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteClusterSnapshotsOutputError>
}

extension BatchDeleteClusterSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteClusterSnapshotsInput(identifiers: \(String(describing: identifiers)))"}
}

extension BatchDeleteClusterSnapshotsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identifiers = identifiers {
            var identifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Identifiers"))
            for (index0, deleteclustersnapshotmessage0) in identifiers.enumerated() {
                try identifiersContainer.encode(deleteclustersnapshotmessage0, forKey: Key("DeleteClusterSnapshotMessage.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("BatchDeleteClusterSnapshots", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct BatchDeleteClusterSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteClusterSnapshotsOutputError>
}

public struct BatchDeleteClusterSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<BatchDeleteClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteClusterSnapshotsOutputError>
}

public struct BatchDeleteClusterSnapshotsInput: Equatable {
    /// <p>A list of identifiers for the snapshots that you want to delete.</p>
    public let identifiers: [DeleteClusterSnapshotMessage]?

    public init (
        identifiers: [DeleteClusterSnapshotMessage]? = nil
    )
    {
        self.identifiers = identifiers
    }
}

extension BatchDeleteClusterSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BatchDeleteClusterSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BatchDeleteRequestSizeExceededFault" : self = .batchDeleteRequestSizeExceededFault(try BatchDeleteRequestSizeExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteClusterSnapshotsOutputError: Equatable {
    case batchDeleteRequestSizeExceededFault(BatchDeleteRequestSizeExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteClusterSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteClusterSnapshotsOutputResponse(errors: \(String(describing: errors)), resources: \(String(describing: resources)))"}
}

extension BatchDeleteClusterSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.resources = output.resources
        } else {
            self.errors = nil
            self.resources = nil
        }
    }
}

public struct BatchDeleteClusterSnapshotsOutputResponse: Equatable {
    /// <p>A list of any errors returned.</p>
    public let errors: [SnapshotErrorMessage]?
    /// <p>A list of the snapshot identifiers that were deleted. </p>
    public let resources: [String]?

    public init (
        errors: [SnapshotErrorMessage]? = nil,
        resources: [String]? = nil
    )
    {
        self.errors = errors
        self.resources = resources
    }
}

struct BatchDeleteClusterSnapshotsOutputResponseBody: Equatable {
    public let resources: [String]?
    public let errors: [SnapshotErrorMessage]?
}

extension BatchDeleteClusterSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
        case resources = "Resources"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("BatchDeleteClusterSnapshotsResult"))
        if containerValues.contains(.resources) {
            struct KeyVal0{struct String{}}
            let resourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.String>.CodingKeys.self, forKey: .resources)
            if let resourcesWrappedContainer = resourcesWrappedContainer {
                let resourcesContainer = try resourcesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var resourcesBuffer:[String]? = nil
                if let resourcesContainer = resourcesContainer {
                    resourcesBuffer = [String]()
                    for stringContainer0 in resourcesContainer {
                        resourcesBuffer?.append(stringContainer0)
                    }
                }
                resources = resourcesBuffer
            } else {
                resources = []
            }
        } else {
            resources = nil
        }
        if containerValues.contains(.errors) {
            struct KeyVal0{struct SnapshotErrorMessage{}}
            let errorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotErrorMessage>.CodingKeys.self, forKey: .errors)
            if let errorsWrappedContainer = errorsWrappedContainer {
                let errorsContainer = try errorsWrappedContainer.decodeIfPresent([SnapshotErrorMessage].self, forKey: .member)
                var errorsBuffer:[SnapshotErrorMessage]? = nil
                if let errorsContainer = errorsContainer {
                    errorsBuffer = [SnapshotErrorMessage]()
                    for structureContainer0 in errorsContainer {
                        errorsBuffer?.append(structureContainer0)
                    }
                }
                errors = errorsBuffer
            } else {
                errors = []
            }
        } else {
            errors = nil
        }
    }
}

extension BatchDeleteRequestSizeExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteRequestSizeExceededFault(message: \(String(describing: message)))"}
}

extension BatchDeleteRequestSizeExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<BatchDeleteRequestSizeExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number for a batch delete of snapshots has been reached. The limit is
///             100. </p>
public struct BatchDeleteRequestSizeExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BatchDeleteRequestSizeExceededFaultBody: Equatable {
    public let message: String?
}

extension BatchDeleteRequestSizeExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchModifyClusterSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "BatchModifyClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchModifyClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchModifyClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchModifyClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<BatchModifyClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchModifyClusterSnapshotsOutputError>
}

extension BatchModifyClusterSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchModifyClusterSnapshotsInput(force: \(String(describing: force)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), snapshotIdentifierList: \(String(describing: snapshotIdentifierList)))"}
}

extension BatchModifyClusterSnapshotsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if force != false {
            try container.encode(force, forKey: Key("Force"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let snapshotIdentifierList = snapshotIdentifierList {
            var snapshotIdentifierListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SnapshotIdentifierList"))
            for (index0, string0) in snapshotIdentifierList.enumerated() {
                try snapshotIdentifierListContainer.encode(string0, forKey: Key("String.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("BatchModifyClusterSnapshots", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct BatchModifyClusterSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchModifyClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchModifyClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchModifyClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchModifyClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<BatchModifyClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchModifyClusterSnapshotsOutputError>
}

public struct BatchModifyClusterSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchModifyClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchModifyClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchModifyClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchModifyClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<BatchModifyClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchModifyClusterSnapshotsOutputError>
}

public struct BatchModifyClusterSnapshotsInput: Equatable {
    /// <p>A boolean value indicating whether to override an exception if the retention period
    ///             has passed. </p>
    public let force: Bool
    /// <p>The number of days that a manual snapshot is retained. If you specify the value -1,
    ///             the manual snapshot is retained indefinitely.</p>
    ///         <p>The number must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>If you decrease the manual snapshot retention period from its current value, existing
    ///             manual snapshots that fall outside of the new retention period will return an error. If
    ///             you want to suppress the errors and delete the snapshots, use the force option. </p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>A list of snapshot identifiers you want to modify.</p>
    public let snapshotIdentifierList: [String]?

    public init (
        force: Bool = false,
        manualSnapshotRetentionPeriod: Int? = nil,
        snapshotIdentifierList: [String]? = nil
    )
    {
        self.force = force
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.snapshotIdentifierList = snapshotIdentifierList
    }
}

extension BatchModifyClusterSnapshotsLimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchModifyClusterSnapshotsLimitExceededFault(message: \(String(describing: message)))"}
}

extension BatchModifyClusterSnapshotsLimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<BatchModifyClusterSnapshotsLimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number for snapshot identifiers has been reached. The limit is 100.
///         </p>
public struct BatchModifyClusterSnapshotsLimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BatchModifyClusterSnapshotsLimitExceededFaultBody: Equatable {
    public let message: String?
}

extension BatchModifyClusterSnapshotsLimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchModifyClusterSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BatchModifyClusterSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BatchModifyClusterSnapshotsLimitExceededFault" : self = .batchModifyClusterSnapshotsLimitExceededFault(try BatchModifyClusterSnapshotsLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchModifyClusterSnapshotsOutputError: Equatable {
    case batchModifyClusterSnapshotsLimitExceededFault(BatchModifyClusterSnapshotsLimitExceededFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchModifyClusterSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchModifyClusterSnapshotsOutputResponse(errors: \(String(describing: errors)), resources: \(String(describing: resources)))"}
}

extension BatchModifyClusterSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchModifyClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.resources = output.resources
        } else {
            self.errors = nil
            self.resources = nil
        }
    }
}

public struct BatchModifyClusterSnapshotsOutputResponse: Equatable {
    /// <p>A list of any errors returned.</p>
    public let errors: [SnapshotErrorMessage]?
    /// <p>A list of the snapshots that were modified.</p>
    public let resources: [String]?

    public init (
        errors: [SnapshotErrorMessage]? = nil,
        resources: [String]? = nil
    )
    {
        self.errors = errors
        self.resources = resources
    }
}

struct BatchModifyClusterSnapshotsOutputResponseBody: Equatable {
    public let resources: [String]?
    public let errors: [SnapshotErrorMessage]?
}

extension BatchModifyClusterSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
        case resources = "Resources"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("BatchModifyClusterSnapshotsResult"))
        if containerValues.contains(.resources) {
            struct KeyVal0{struct String{}}
            let resourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.String>.CodingKeys.self, forKey: .resources)
            if let resourcesWrappedContainer = resourcesWrappedContainer {
                let resourcesContainer = try resourcesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var resourcesBuffer:[String]? = nil
                if let resourcesContainer = resourcesContainer {
                    resourcesBuffer = [String]()
                    for stringContainer0 in resourcesContainer {
                        resourcesBuffer?.append(stringContainer0)
                    }
                }
                resources = resourcesBuffer
            } else {
                resources = []
            }
        } else {
            resources = nil
        }
        if containerValues.contains(.errors) {
            struct KeyVal0{struct SnapshotErrorMessage{}}
            let errorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotErrorMessage>.CodingKeys.self, forKey: .errors)
            if let errorsWrappedContainer = errorsWrappedContainer {
                let errorsContainer = try errorsWrappedContainer.decodeIfPresent([SnapshotErrorMessage].self, forKey: .member)
                var errorsBuffer:[SnapshotErrorMessage]? = nil
                if let errorsContainer = errorsContainer {
                    errorsBuffer = [SnapshotErrorMessage]()
                    for structureContainer0 in errorsContainer {
                        errorsBuffer?.append(structureContainer0)
                    }
                }
                errors = errorsBuffer
            } else {
                errors = []
            }
        } else {
            errors = nil
        }
    }
}

extension BucketNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketNotFoundFault(message: \(String(describing: message)))"}
}

extension BucketNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<BucketNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Could not find the specified S3 bucket.</p>
public struct BucketNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BucketNotFoundFaultBody: Equatable {
    public let message: String?
}

extension BucketNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelResizeInputBodyMiddleware: Middleware {
    public let id: String = "CancelResizeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelResizeInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelResizeInput>
    public typealias MOutput = OperationOutput<CancelResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelResizeOutputError>
}

extension CancelResizeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelResizeInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension CancelResizeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("CancelResize", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CancelResizeInputHeadersMiddleware: Middleware {
    public let id: String = "CancelResizeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelResizeInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelResizeInput>
    public typealias MOutput = OperationOutput<CancelResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelResizeOutputError>
}

public struct CancelResizeInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelResizeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelResizeInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelResizeInput>
    public typealias MOutput = OperationOutput<CancelResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelResizeOutputError>
}

public struct CancelResizeInput: Equatable {
    /// <p>The unique identifier for the cluster that you want to cancel a resize operation
    ///             for.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension CancelResizeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CancelResizeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResizeNotFoundFault" : self = .resizeNotFoundFault(try ResizeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelResizeOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case resizeNotFoundFault(ResizeNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelResizeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelResizeOutputResponse(avgResizeRateInMegaBytesPerSecond: \(String(describing: avgResizeRateInMegaBytesPerSecond)), dataTransferProgressPercent: \(String(describing: dataTransferProgressPercent)), elapsedTimeInSeconds: \(String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(String(describing: estimatedTimeToCompletionInSeconds)), importTablesCompleted: \(String(describing: importTablesCompleted)), importTablesInProgress: \(String(describing: importTablesInProgress)), importTablesNotStarted: \(String(describing: importTablesNotStarted)), message: \(String(describing: message)), progressInMegaBytes: \(String(describing: progressInMegaBytes)), resizeType: \(String(describing: resizeType)), status: \(String(describing: status)), targetClusterType: \(String(describing: targetClusterType)), targetEncryptionType: \(String(describing: targetEncryptionType)), targetNodeType: \(String(describing: targetNodeType)), targetNumberOfNodes: \(String(describing: targetNumberOfNodes)), totalResizeDataInMegaBytes: \(String(describing: totalResizeDataInMegaBytes)))"}
}

extension CancelResizeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelResizeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.avgResizeRateInMegaBytesPerSecond = output.avgResizeRateInMegaBytesPerSecond
            self.dataTransferProgressPercent = output.dataTransferProgressPercent
            self.elapsedTimeInSeconds = output.elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = output.estimatedTimeToCompletionInSeconds
            self.importTablesCompleted = output.importTablesCompleted
            self.importTablesInProgress = output.importTablesInProgress
            self.importTablesNotStarted = output.importTablesNotStarted
            self.message = output.message
            self.progressInMegaBytes = output.progressInMegaBytes
            self.resizeType = output.resizeType
            self.status = output.status
            self.targetClusterType = output.targetClusterType
            self.targetEncryptionType = output.targetEncryptionType
            self.targetNodeType = output.targetNodeType
            self.targetNumberOfNodes = output.targetNumberOfNodes
            self.totalResizeDataInMegaBytes = output.totalResizeDataInMegaBytes
        } else {
            self.avgResizeRateInMegaBytesPerSecond = nil
            self.dataTransferProgressPercent = nil
            self.elapsedTimeInSeconds = nil
            self.estimatedTimeToCompletionInSeconds = nil
            self.importTablesCompleted = nil
            self.importTablesInProgress = nil
            self.importTablesNotStarted = nil
            self.message = nil
            self.progressInMegaBytes = nil
            self.resizeType = nil
            self.status = nil
            self.targetClusterType = nil
            self.targetEncryptionType = nil
            self.targetNodeType = nil
            self.targetNumberOfNodes = nil
            self.totalResizeDataInMegaBytes = nil
        }
    }
}

/// <p>Describes the result of a cluster resize operation.</p>
public struct CancelResizeOutputResponse: Equatable {
    /// <p>The average rate of the resize operation over the last few minutes, measured in
    ///             megabytes per second. After the resize operation completes, this value shows the average
    ///             rate of the entire resize operation.</p>
    public let avgResizeRateInMegaBytesPerSecond: Double?
    /// <p>The percent of data transferred from source cluster to target cluster.</p>
    public let dataTransferProgressPercent: Double?
    /// <p>The amount of seconds that have elapsed since the resize operation began. After the
    ///             resize operation completes, this value shows the total actual time, in seconds, for the
    ///             resize operation.</p>
    public let elapsedTimeInSeconds: Int?
    /// <p>The estimated time remaining, in seconds, until the resize operation is complete.
    ///             This value is calculated based on the average resize rate and the estimated amount of
    ///             data remaining to be processed. Once the resize operation is complete, this value will
    ///             be 0.</p>
    public let estimatedTimeToCompletionInSeconds: Int?
    /// <p>The names of tables that have been completely imported .</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesCompleted: [String]?
    /// <p>The names of tables that are being currently imported.</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesInProgress: [String]?
    /// <p>The names of tables that have not been yet imported.</p>
    ///         <p>Valid Values: List of table names</p>
    public let importTablesNotStarted: [String]?
    /// <p>An optional string to provide additional details about the resize action.</p>
    public let message: String?
    /// <p>While the resize operation is in progress, this value shows the current amount of
    ///             data, in megabytes, that has been processed so far. When the resize operation is
    ///             complete, this value shows the total amount of data, in megabytes, on the cluster, which
    ///             may be more or less than TotalResizeDataInMegaBytes (the estimated total amount of data
    ///             before resize).</p>
    public let progressInMegaBytes: Int?
    /// <p>An enum with possible values of <code>ClassicResize</code> and
    ///                 <code>ElasticResize</code>. These values describe the type of resize operation being
    ///             performed. </p>
    public let resizeType: String?
    /// <p>The status of the resize operation.</p>
    ///         <p>Valid Values: <code>NONE</code> | <code>IN_PROGRESS</code> | <code>FAILED</code> |
    ///                 <code>SUCCEEDED</code> | <code>CANCELLING</code>
    ///         </p>
    public let status: String?
    /// <p>The cluster type after the resize operation is complete.</p>
    ///         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
    ///         </p>
    public let targetClusterType: String?
    /// <p>The type of encryption for the cluster after the resize is complete.</p>
    ///         <p>Possible values are <code>KMS</code> and <code>None</code>. </p>
    public let targetEncryptionType: String?
    /// <p>The node type that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNodeType: String?
    /// <p>The number of nodes that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNumberOfNodes: Int?
    /// <p>The estimated total amount of data, in megabytes, on the cluster before the resize
    ///             operation began.</p>
    public let totalResizeDataInMegaBytes: Int?

    public init (
        avgResizeRateInMegaBytesPerSecond: Double? = nil,
        dataTransferProgressPercent: Double? = nil,
        elapsedTimeInSeconds: Int? = nil,
        estimatedTimeToCompletionInSeconds: Int? = nil,
        importTablesCompleted: [String]? = nil,
        importTablesInProgress: [String]? = nil,
        importTablesNotStarted: [String]? = nil,
        message: String? = nil,
        progressInMegaBytes: Int? = nil,
        resizeType: String? = nil,
        status: String? = nil,
        targetClusterType: String? = nil,
        targetEncryptionType: String? = nil,
        targetNodeType: String? = nil,
        targetNumberOfNodes: Int? = nil,
        totalResizeDataInMegaBytes: Int? = nil
    )
    {
        self.avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecond
        self.dataTransferProgressPercent = dataTransferProgressPercent
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
        self.importTablesCompleted = importTablesCompleted
        self.importTablesInProgress = importTablesInProgress
        self.importTablesNotStarted = importTablesNotStarted
        self.message = message
        self.progressInMegaBytes = progressInMegaBytes
        self.resizeType = resizeType
        self.status = status
        self.targetClusterType = targetClusterType
        self.targetEncryptionType = targetEncryptionType
        self.targetNodeType = targetNodeType
        self.targetNumberOfNodes = targetNumberOfNodes
        self.totalResizeDataInMegaBytes = totalResizeDataInMegaBytes
    }
}

struct CancelResizeOutputResponseBody: Equatable {
    public let targetNodeType: String?
    public let targetNumberOfNodes: Int?
    public let targetClusterType: String?
    public let status: String?
    public let importTablesCompleted: [String]?
    public let importTablesInProgress: [String]?
    public let importTablesNotStarted: [String]?
    public let avgResizeRateInMegaBytesPerSecond: Double?
    public let totalResizeDataInMegaBytes: Int?
    public let progressInMegaBytes: Int?
    public let elapsedTimeInSeconds: Int?
    public let estimatedTimeToCompletionInSeconds: Int?
    public let resizeType: String?
    public let message: String?
    public let targetEncryptionType: String?
    public let dataTransferProgressPercent: Double?
}

extension CancelResizeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case avgResizeRateInMegaBytesPerSecond = "AvgResizeRateInMegaBytesPerSecond"
        case dataTransferProgressPercent = "DataTransferProgressPercent"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case importTablesCompleted = "ImportTablesCompleted"
        case importTablesInProgress = "ImportTablesInProgress"
        case importTablesNotStarted = "ImportTablesNotStarted"
        case message = "Message"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case resizeType = "ResizeType"
        case status = "Status"
        case targetClusterType = "TargetClusterType"
        case targetEncryptionType = "TargetEncryptionType"
        case targetNodeType = "TargetNodeType"
        case targetNumberOfNodes = "TargetNumberOfNodes"
        case totalResizeDataInMegaBytes = "TotalResizeDataInMegaBytes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CancelResizeResult"))
        let targetNodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetNodeType)
        targetNodeType = targetNodeTypeDecoded
        let targetNumberOfNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .targetNumberOfNodes)
        targetNumberOfNodes = targetNumberOfNodesDecoded
        let targetClusterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetClusterType)
        targetClusterType = targetClusterTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.importTablesCompleted) {
            struct KeyVal0{struct member{}}
            let importTablesCompletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesCompleted)
            if let importTablesCompletedWrappedContainer = importTablesCompletedWrappedContainer {
                let importTablesCompletedContainer = try importTablesCompletedWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesCompletedBuffer:[String]? = nil
                if let importTablesCompletedContainer = importTablesCompletedContainer {
                    importTablesCompletedBuffer = [String]()
                    for stringContainer0 in importTablesCompletedContainer {
                        importTablesCompletedBuffer?.append(stringContainer0)
                    }
                }
                importTablesCompleted = importTablesCompletedBuffer
            } else {
                importTablesCompleted = []
            }
        } else {
            importTablesCompleted = nil
        }
        if containerValues.contains(.importTablesInProgress) {
            struct KeyVal0{struct member{}}
            let importTablesInProgressWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesInProgress)
            if let importTablesInProgressWrappedContainer = importTablesInProgressWrappedContainer {
                let importTablesInProgressContainer = try importTablesInProgressWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesInProgressBuffer:[String]? = nil
                if let importTablesInProgressContainer = importTablesInProgressContainer {
                    importTablesInProgressBuffer = [String]()
                    for stringContainer0 in importTablesInProgressContainer {
                        importTablesInProgressBuffer?.append(stringContainer0)
                    }
                }
                importTablesInProgress = importTablesInProgressBuffer
            } else {
                importTablesInProgress = []
            }
        } else {
            importTablesInProgress = nil
        }
        if containerValues.contains(.importTablesNotStarted) {
            struct KeyVal0{struct member{}}
            let importTablesNotStartedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesNotStarted)
            if let importTablesNotStartedWrappedContainer = importTablesNotStartedWrappedContainer {
                let importTablesNotStartedContainer = try importTablesNotStartedWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesNotStartedBuffer:[String]? = nil
                if let importTablesNotStartedContainer = importTablesNotStartedContainer {
                    importTablesNotStartedBuffer = [String]()
                    for stringContainer0 in importTablesNotStartedContainer {
                        importTablesNotStartedBuffer?.append(stringContainer0)
                    }
                }
                importTablesNotStarted = importTablesNotStartedBuffer
            } else {
                importTablesNotStarted = []
            }
        } else {
            importTablesNotStarted = nil
        }
        let avgResizeRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .avgResizeRateInMegaBytesPerSecond)
        avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecondDecoded
        let totalResizeDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalResizeDataInMegaBytes)
        totalResizeDataInMegaBytes = totalResizeDataInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let targetEncryptionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetEncryptionType)
        targetEncryptionType = targetEncryptionTypeDecoded
        let dataTransferProgressPercentDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .dataTransferProgressPercent)
        dataTransferProgressPercent = dataTransferProgressPercentDecoded
    }
}

extension Cluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowVersionUpgrade = "AllowVersionUpgrade"
        case aquaConfiguration = "AquaConfiguration"
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneRelocationStatus = "AvailabilityZoneRelocationStatus"
        case clusterAvailabilityStatus = "ClusterAvailabilityStatus"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterNamespaceArn = "ClusterNamespaceArn"
        case clusterNodes = "ClusterNodes"
        case clusterParameterGroups = "ClusterParameterGroups"
        case clusterPublicKey = "ClusterPublicKey"
        case clusterRevisionNumber = "ClusterRevisionNumber"
        case clusterSecurityGroups = "ClusterSecurityGroups"
        case clusterSnapshotCopyStatus = "ClusterSnapshotCopyStatus"
        case clusterStatus = "ClusterStatus"
        case clusterSubnetGroupName = "ClusterSubnetGroupName"
        case clusterVersion = "ClusterVersion"
        case dBName = "DBName"
        case dataTransferProgress = "DataTransferProgress"
        case deferredMaintenanceWindows = "DeferredMaintenanceWindows"
        case elasticIpStatus = "ElasticIpStatus"
        case elasticResizeNumberOfNodeOptions = "ElasticResizeNumberOfNodeOptions"
        case encrypted = "Encrypted"
        case endpoint = "Endpoint"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case expectedNextSnapshotScheduleTime = "ExpectedNextSnapshotScheduleTime"
        case expectedNextSnapshotScheduleTimeStatus = "ExpectedNextSnapshotScheduleTimeStatus"
        case hsmStatus = "HsmStatus"
        case iamRoles = "IamRoles"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case modifyStatus = "ModifyStatus"
        case nextMaintenanceWindowStartTime = "NextMaintenanceWindowStartTime"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case pendingActions = "PendingActions"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case resizeInfo = "ResizeInfo"
        case restoreStatus = "RestoreStatus"
        case snapshotScheduleIdentifier = "SnapshotScheduleIdentifier"
        case snapshotScheduleState = "SnapshotScheduleState"
        case tags = "Tags"
        case totalStorageCapacityInMegaBytes = "TotalStorageCapacityInMegaBytes"
        case vpcId = "VpcId"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowVersionUpgrade != false {
            try container.encode(allowVersionUpgrade, forKey: Key("AllowVersionUpgrade"))
        }
        if let aquaConfiguration = aquaConfiguration {
            try container.encode(aquaConfiguration, forKey: Key("AquaConfiguration"))
        }
        if automatedSnapshotRetentionPeriod != 0 {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocationStatus = availabilityZoneRelocationStatus {
            try container.encode(availabilityZoneRelocationStatus, forKey: Key("AvailabilityZoneRelocationStatus"))
        }
        if let clusterAvailabilityStatus = clusterAvailabilityStatus {
            try container.encode(clusterAvailabilityStatus, forKey: Key("ClusterAvailabilityStatus"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterNamespaceArn = clusterNamespaceArn {
            try container.encode(clusterNamespaceArn, forKey: Key("ClusterNamespaceArn"))
        }
        if let clusterNodes = clusterNodes {
            var clusterNodesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClusterNodes"))
            for (index0, clusternode0) in clusterNodes.enumerated() {
                try clusterNodesContainer.encode(clusternode0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterParameterGroups = clusterParameterGroups {
            var clusterParameterGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClusterParameterGroups"))
            for (index0, clusterparametergroupstatus0) in clusterParameterGroups.enumerated() {
                try clusterParameterGroupsContainer.encode(clusterparametergroupstatus0, forKey: Key("ClusterParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterPublicKey = clusterPublicKey {
            try container.encode(clusterPublicKey, forKey: Key("ClusterPublicKey"))
        }
        if let clusterRevisionNumber = clusterRevisionNumber {
            try container.encode(clusterRevisionNumber, forKey: Key("ClusterRevisionNumber"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClusterSecurityGroups"))
            for (index0, clustersecuritygroupmembership0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(clustersecuritygroupmembership0, forKey: Key("ClusterSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterSnapshotCopyStatus = clusterSnapshotCopyStatus {
            try container.encode(clusterSnapshotCopyStatus, forKey: Key("ClusterSnapshotCopyStatus"))
        }
        if let clusterStatus = clusterStatus {
            try container.encode(clusterStatus, forKey: Key("ClusterStatus"))
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dataTransferProgress = dataTransferProgress {
            try container.encode(dataTransferProgress, forKey: Key("DataTransferProgress"))
        }
        if let deferredMaintenanceWindows = deferredMaintenanceWindows {
            var deferredMaintenanceWindowsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DeferredMaintenanceWindows"))
            for (index0, deferredmaintenancewindow0) in deferredMaintenanceWindows.enumerated() {
                try deferredMaintenanceWindowsContainer.encode(deferredmaintenancewindow0, forKey: Key("DeferredMaintenanceWindow.\(index0.advanced(by: 1))"))
            }
        }
        if let elasticIpStatus = elasticIpStatus {
            try container.encode(elasticIpStatus, forKey: Key("ElasticIpStatus"))
        }
        if let elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions {
            try container.encode(elasticResizeNumberOfNodeOptions, forKey: Key("ElasticResizeNumberOfNodeOptions"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: Key("Encrypted"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if enhancedVpcRouting != false {
            try container.encode(enhancedVpcRouting, forKey: Key("EnhancedVpcRouting"))
        }
        if let expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime {
            try container.encode(TimestampWrapper(expectedNextSnapshotScheduleTime, format: .dateTime), forKey: Key("expectedNextSnapshotScheduleTime"))
        }
        if let expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus {
            try container.encode(expectedNextSnapshotScheduleTimeStatus, forKey: Key("ExpectedNextSnapshotScheduleTimeStatus"))
        }
        if let hsmStatus = hsmStatus {
            try container.encode(hsmStatus, forKey: Key("HsmStatus"))
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("IamRoles"))
            for (index0, clusteriamrole0) in iamRoles.enumerated() {
                try iamRolesContainer.encode(clusteriamrole0, forKey: Key("ClusterIamRole.\(index0.advanced(by: 1))"))
            }
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if manualSnapshotRetentionPeriod != 0 {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let modifyStatus = modifyStatus {
            try container.encode(modifyStatus, forKey: Key("ModifyStatus"))
        }
        if let nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime {
            try container.encode(TimestampWrapper(nextMaintenanceWindowStartTime, format: .dateTime), forKey: Key("nextMaintenanceWindowStartTime"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        if let pendingActions = pendingActions {
            var pendingActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PendingActions"))
            for (index0, string0) in pendingActions.enumerated() {
                try pendingActionsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: Key("PendingModifiedValues"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let resizeInfo = resizeInfo {
            try container.encode(resizeInfo, forKey: Key("ResizeInfo"))
        }
        if let restoreStatus = restoreStatus {
            try container.encode(restoreStatus, forKey: Key("RestoreStatus"))
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try container.encode(snapshotScheduleIdentifier, forKey: Key("SnapshotScheduleIdentifier"))
        }
        if let snapshotScheduleState = snapshotScheduleState {
            try container.encode(snapshotScheduleState, forKey: Key("SnapshotScheduleState"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytes {
            try container.encode(totalStorageCapacityInMegaBytes, forKey: Key("TotalStorageCapacityInMegaBytes"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let clusterAvailabilityStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterAvailabilityStatus)
        clusterAvailabilityStatus = clusterAvailabilityStatusDecoded
        let modifyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modifyStatus)
        modifyStatus = modifyStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .automatedSnapshotRetentionPeriod)
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        if containerValues.contains(.clusterSecurityGroups) {
            struct KeyVal0{struct ClusterSecurityGroup{}}
            let clusterSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterSecurityGroup>.CodingKeys.self, forKey: .clusterSecurityGroups)
            if let clusterSecurityGroupsWrappedContainer = clusterSecurityGroupsWrappedContainer {
                let clusterSecurityGroupsContainer = try clusterSecurityGroupsWrappedContainer.decodeIfPresent([ClusterSecurityGroupMembership].self, forKey: .member)
                var clusterSecurityGroupsBuffer:[ClusterSecurityGroupMembership]? = nil
                if let clusterSecurityGroupsContainer = clusterSecurityGroupsContainer {
                    clusterSecurityGroupsBuffer = [ClusterSecurityGroupMembership]()
                    for structureContainer0 in clusterSecurityGroupsContainer {
                        clusterSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterSecurityGroups = clusterSecurityGroupsBuffer
            } else {
                clusterSecurityGroups = []
            }
        } else {
            clusterSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.clusterParameterGroups) {
            struct KeyVal0{struct ClusterParameterGroup{}}
            let clusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterParameterGroup>.CodingKeys.self, forKey: .clusterParameterGroups)
            if let clusterParameterGroupsWrappedContainer = clusterParameterGroupsWrappedContainer {
                let clusterParameterGroupsContainer = try clusterParameterGroupsWrappedContainer.decodeIfPresent([ClusterParameterGroupStatus].self, forKey: .member)
                var clusterParameterGroupsBuffer:[ClusterParameterGroupStatus]? = nil
                if let clusterParameterGroupsContainer = clusterParameterGroupsContainer {
                    clusterParameterGroupsBuffer = [ClusterParameterGroupStatus]()
                    for structureContainer0 in clusterParameterGroupsContainer {
                        clusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterParameterGroups = clusterParameterGroupsBuffer
            } else {
                clusterParameterGroups = []
            }
        } else {
            clusterParameterGroups = nil
        }
        let clusterSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterSubnetGroupName)
        clusterSubnetGroupName = clusterSubnetGroupNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let allowVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .allowVersionUpgrade)
        allowVersionUpgrade = allowVersionUpgradeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let restoreStatusDecoded = try containerValues.decodeIfPresent(RestoreStatus.self, forKey: .restoreStatus)
        restoreStatus = restoreStatusDecoded
        let dataTransferProgressDecoded = try containerValues.decodeIfPresent(DataTransferProgress.self, forKey: .dataTransferProgress)
        dataTransferProgress = dataTransferProgressDecoded
        let hsmStatusDecoded = try containerValues.decodeIfPresent(HsmStatus.self, forKey: .hsmStatus)
        hsmStatus = hsmStatusDecoded
        let clusterSnapshotCopyStatusDecoded = try containerValues.decodeIfPresent(ClusterSnapshotCopyStatus.self, forKey: .clusterSnapshotCopyStatus)
        clusterSnapshotCopyStatus = clusterSnapshotCopyStatusDecoded
        let clusterPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterPublicKey)
        clusterPublicKey = clusterPublicKeyDecoded
        if containerValues.contains(.clusterNodes) {
            struct KeyVal0{struct member{}}
            let clusterNodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clusterNodes)
            if let clusterNodesWrappedContainer = clusterNodesWrappedContainer {
                let clusterNodesContainer = try clusterNodesWrappedContainer.decodeIfPresent([ClusterNode].self, forKey: .member)
                var clusterNodesBuffer:[ClusterNode]? = nil
                if let clusterNodesContainer = clusterNodesContainer {
                    clusterNodesBuffer = [ClusterNode]()
                    for structureContainer0 in clusterNodesContainer {
                        clusterNodesBuffer?.append(structureContainer0)
                    }
                }
                clusterNodes = clusterNodesBuffer
            } else {
                clusterNodes = []
            }
        } else {
            clusterNodes = nil
        }
        let elasticIpStatusDecoded = try containerValues.decodeIfPresent(ElasticIpStatus.self, forKey: .elasticIpStatus)
        elasticIpStatus = elasticIpStatusDecoded
        let clusterRevisionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterRevisionNumber)
        clusterRevisionNumber = clusterRevisionNumberDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decode(Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        if containerValues.contains(.iamRoles) {
            struct KeyVal0{struct ClusterIamRole{}}
            let iamRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterIamRole>.CodingKeys.self, forKey: .iamRoles)
            if let iamRolesWrappedContainer = iamRolesWrappedContainer {
                let iamRolesContainer = try iamRolesWrappedContainer.decodeIfPresent([ClusterIamRole].self, forKey: .member)
                var iamRolesBuffer:[ClusterIamRole]? = nil
                if let iamRolesContainer = iamRolesContainer {
                    iamRolesBuffer = [ClusterIamRole]()
                    for structureContainer0 in iamRolesContainer {
                        iamRolesBuffer?.append(structureContainer0)
                    }
                }
                iamRoles = iamRolesBuffer
            } else {
                iamRoles = []
            }
        } else {
            iamRoles = nil
        }
        if containerValues.contains(.pendingActions) {
            struct KeyVal0{struct member{}}
            let pendingActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .pendingActions)
            if let pendingActionsWrappedContainer = pendingActionsWrappedContainer {
                let pendingActionsContainer = try pendingActionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var pendingActionsBuffer:[String]? = nil
                if let pendingActionsContainer = pendingActionsContainer {
                    pendingActionsBuffer = [String]()
                    for stringContainer0 in pendingActionsContainer {
                        pendingActionsBuffer?.append(stringContainer0)
                    }
                }
                pendingActions = pendingActionsBuffer
            } else {
                pendingActions = []
            }
        } else {
            pendingActions = nil
        }
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let elasticResizeNumberOfNodeOptionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticResizeNumberOfNodeOptions)
        elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptionsDecoded
        if containerValues.contains(.deferredMaintenanceWindows) {
            struct KeyVal0{struct DeferredMaintenanceWindow{}}
            let deferredMaintenanceWindowsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DeferredMaintenanceWindow>.CodingKeys.self, forKey: .deferredMaintenanceWindows)
            if let deferredMaintenanceWindowsWrappedContainer = deferredMaintenanceWindowsWrappedContainer {
                let deferredMaintenanceWindowsContainer = try deferredMaintenanceWindowsWrappedContainer.decodeIfPresent([DeferredMaintenanceWindow].self, forKey: .member)
                var deferredMaintenanceWindowsBuffer:[DeferredMaintenanceWindow]? = nil
                if let deferredMaintenanceWindowsContainer = deferredMaintenanceWindowsContainer {
                    deferredMaintenanceWindowsBuffer = [DeferredMaintenanceWindow]()
                    for structureContainer0 in deferredMaintenanceWindowsContainer {
                        deferredMaintenanceWindowsBuffer?.append(structureContainer0)
                    }
                }
                deferredMaintenanceWindows = deferredMaintenanceWindowsBuffer
            } else {
                deferredMaintenanceWindows = []
            }
        } else {
            deferredMaintenanceWindows = nil
        }
        let snapshotScheduleIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotScheduleIdentifier)
        snapshotScheduleIdentifier = snapshotScheduleIdentifierDecoded
        let snapshotScheduleStateDecoded = try containerValues.decodeIfPresent(ScheduleState.self, forKey: .snapshotScheduleState)
        snapshotScheduleState = snapshotScheduleStateDecoded
        let expectedNextSnapshotScheduleTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedNextSnapshotScheduleTime)
        var expectedNextSnapshotScheduleTimeBuffer:Date? = nil
        if let expectedNextSnapshotScheduleTimeDecoded = expectedNextSnapshotScheduleTimeDecoded {
            expectedNextSnapshotScheduleTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(expectedNextSnapshotScheduleTimeDecoded, format: .dateTime)
        }
        expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTimeBuffer
        let expectedNextSnapshotScheduleTimeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedNextSnapshotScheduleTimeStatus)
        expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatusDecoded
        let nextMaintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMaintenanceWindowStartTime)
        var nextMaintenanceWindowStartTimeBuffer:Date? = nil
        if let nextMaintenanceWindowStartTimeDecoded = nextMaintenanceWindowStartTimeDecoded {
            nextMaintenanceWindowStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(nextMaintenanceWindowStartTimeDecoded, format: .dateTime)
        }
        nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTimeBuffer
        let resizeInfoDecoded = try containerValues.decodeIfPresent(ResizeInfo.self, forKey: .resizeInfo)
        resizeInfo = resizeInfoDecoded
        let availabilityZoneRelocationStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneRelocationStatus)
        availabilityZoneRelocationStatus = availabilityZoneRelocationStatusDecoded
        let clusterNamespaceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterNamespaceArn)
        clusterNamespaceArn = clusterNamespaceArnDecoded
        let totalStorageCapacityInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalStorageCapacityInMegaBytes)
        totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytesDecoded
        let aquaConfigurationDecoded = try containerValues.decodeIfPresent(AquaConfiguration.self, forKey: .aquaConfiguration)
        aquaConfiguration = aquaConfigurationDecoded
    }
}

extension Cluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cluster(allowVersionUpgrade: \(String(describing: allowVersionUpgrade)), aquaConfiguration: \(String(describing: aquaConfiguration)), automatedSnapshotRetentionPeriod: \(String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(String(describing: availabilityZone)), availabilityZoneRelocationStatus: \(String(describing: availabilityZoneRelocationStatus)), clusterAvailabilityStatus: \(String(describing: clusterAvailabilityStatus)), clusterCreateTime: \(String(describing: clusterCreateTime)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterNamespaceArn: \(String(describing: clusterNamespaceArn)), clusterNodes: \(String(describing: clusterNodes)), clusterParameterGroups: \(String(describing: clusterParameterGroups)), clusterPublicKey: \(String(describing: clusterPublicKey)), clusterRevisionNumber: \(String(describing: clusterRevisionNumber)), clusterSecurityGroups: \(String(describing: clusterSecurityGroups)), clusterSnapshotCopyStatus: \(String(describing: clusterSnapshotCopyStatus)), clusterStatus: \(String(describing: clusterStatus)), clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), clusterVersion: \(String(describing: clusterVersion)), dBName: \(String(describing: dBName)), dataTransferProgress: \(String(describing: dataTransferProgress)), deferredMaintenanceWindows: \(String(describing: deferredMaintenanceWindows)), elasticIpStatus: \(String(describing: elasticIpStatus)), elasticResizeNumberOfNodeOptions: \(String(describing: elasticResizeNumberOfNodeOptions)), encrypted: \(String(describing: encrypted)), endpoint: \(String(describing: endpoint)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), expectedNextSnapshotScheduleTime: \(String(describing: expectedNextSnapshotScheduleTime)), expectedNextSnapshotScheduleTimeStatus: \(String(describing: expectedNextSnapshotScheduleTimeStatus)), hsmStatus: \(String(describing: hsmStatus)), iamRoles: \(String(describing: iamRoles)), kmsKeyId: \(String(describing: kmsKeyId)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), masterUsername: \(String(describing: masterUsername)), modifyStatus: \(String(describing: modifyStatus)), nextMaintenanceWindowStartTime: \(String(describing: nextMaintenanceWindowStartTime)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), pendingActions: \(String(describing: pendingActions)), pendingModifiedValues: \(String(describing: pendingModifiedValues)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(String(describing: publiclyAccessible)), resizeInfo: \(String(describing: resizeInfo)), restoreStatus: \(String(describing: restoreStatus)), snapshotScheduleIdentifier: \(String(describing: snapshotScheduleIdentifier)), snapshotScheduleState: \(String(describing: snapshotScheduleState)), tags: \(String(describing: tags)), totalStorageCapacityInMegaBytes: \(String(describing: totalStorageCapacityInMegaBytes)), vpcId: \(String(describing: vpcId)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Describes a cluster.</p>
public struct Cluster: Equatable {
    /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades
    ///             will be applied automatically to the cluster during the maintenance window. </p>
    public let allowVersionUpgrade: Bool
    /// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
    public let aquaConfiguration: AquaConfiguration?
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    public let automatedSnapshotRetentionPeriod: Int
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    public let availabilityZone: String?
    /// <p>Describes the status of the Availability Zone relocation operation.</p>
    public let availabilityZoneRelocationStatus: String?
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Available - The cluster is available for queries. </p>
    ///             </li>
    ///             <li>
    ///                <p>Unavailable - The cluster is not available for queries.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p>
    ///             </li>
    ///             <li>
    ///                <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>Failed - The cluster failed and is not available for queries.</p>
    ///             </li>
    ///          </ul>
    public let clusterAvailabilityStatus: String?
    /// <p>The date and time that the cluster was created.</p>
    public let clusterCreateTime: Date?
    /// <p>The unique identifier of the cluster.</p>
    public let clusterIdentifier: String?
    /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterNamespaceArn: String?
    /// <p>The nodes in the cluster.</p>
    public let clusterNodes: [ClusterNode]?
    /// <p>The list of cluster parameter groups that are associated with this cluster. Each
    ///             parameter group in the list is returned with its status.</p>
    public let clusterParameterGroups: [ClusterParameterGroupStatus]?
    /// <p>The public key for the cluster.</p>
    public let clusterPublicKey: String?
    /// <p>The specific revision number of the database in the cluster.</p>
    public let clusterRevisionNumber: String?
    /// <p>A list of cluster security group that are associated with the cluster. Each
    ///             security group is represented by an element that contains
    ///                 <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code>
    ///             subelements. </p>
    ///         <p>Cluster security groups are used when the cluster is not created in an Amazon
    ///             Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups,
    ///             which are listed by the <b>VpcSecurityGroups</b> parameter.
    ///         </p>
    public let clusterSecurityGroups: [ClusterSecurityGroupMembership]?
    /// <p>A value that returns the destination region and retention period that are
    ///             configured for cross-region snapshot copy.</p>
    public let clusterSnapshotCopyStatus: ClusterSnapshotCopyStatus?
    /// <p> The current state of the cluster. Possible values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>available</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>available, prep-for-resize</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>available, resize-cleanup</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>cancelling-resize</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>creating</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>deleting</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>final-snapshot</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>hardware-failure</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>incompatible-hsm</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>incompatible-network</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>incompatible-parameters</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>incompatible-restore</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>modifying</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>paused</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>rebooting</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>renaming</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>resizing</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>rotating-keys</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>storage-full</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>updating-hsm</code>
    ///                 </p>
    ///             </li>
    ///          </ul>
    public let clusterStatus: String?
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is
    ///             valid only when the cluster is in a VPC.</p>
    public let clusterSubnetGroupName: String?
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    public let clusterVersion: String?
    /// <p>The name of the initial database that was created when the cluster was created.
    ///             This same name is returned for the life of the cluster. If an initial database was not
    ///             specified, a database named <code>dev</code>dev was created by default. </p>
    public let dBName: String?
    /// <p></p>
    public let dataTransferProgress: DataTransferProgress?
    /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
    public let deferredMaintenanceWindows: [DeferredMaintenanceWindow]?
    /// <p>The status of the elastic IP (EIP) address.</p>
    public let elasticIpStatus: ElasticIpStatus?
    /// <p>The number of nodes that you can resize the cluster to with the elastic resize method.
    ///         </p>
    public let elasticResizeNumberOfNodeOptions: String?
    /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is
    ///             encrypted at rest.</p>
    public let encrypted: Bool
    /// <p>The connection endpoint.</p>
    public let endpoint: Endpoint?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Bool
    /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
    public let expectedNextSnapshotScheduleTime: Date?
    /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled.  Possible values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>OnTrack - The next snapshot is expected to be taken on time. </p>
    ///             </li>
    ///             <li>
    ///                <p>Pending - The next snapshot is pending to be taken. </p>
    ///             </li>
    ///          </ul>
    public let expectedNextSnapshotScheduleTimeStatus: String?
    /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any
    ///             hardware security module (HSM) settings changes specified in a modify cluster
    ///             command.</p>
    ///         <p>Values: active, applying</p>
    public let hsmStatus: HsmStatus?
    /// <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the
    ///             cluster to access other AWS services.</p>
    public let iamRoles: [ClusterIamRole]?
    /// <p>The AWS Key Management Service (AWS KMS) key ID of the encryption key used to
    ///             encrypt data in the cluster.</p>
    public let kmsKeyId: String?
    /// <p>The name of the maintenance track for the cluster.</p>
    public let maintenanceTrackName: String?
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
    ///             snapshot is retained indefinitely. This setting doesn't change the retention period
    ///             of existing snapshots.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Int
    /// <p>The master user name for the cluster. This name is used to connect to the database
    ///             that is specified in the <b>DBName</b> parameter. </p>
    public let masterUsername: String?
    /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
    public let modifyStatus: String?
    /// <p>The date and time in UTC when system maintenance can begin.</p>
    public let nextMaintenanceWindowStartTime: Date?
    /// <p>The node type for the nodes in the cluster.</p>
    public let nodeType: String?
    /// <p>The number of compute nodes in the cluster.</p>
    public let numberOfNodes: Int
    /// <p>Cluster operations that are waiting to be started.</p>
    public let pendingActions: [String]?
    /// <p>A value that, if present, indicates that changes to the cluster are pending.
    ///             Specific pending changes are identified by subelements.</p>
    public let pendingModifiedValues: PendingModifiedValues?
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system
    ///             maintenance can occur.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be
    ///             accessed from a public network.</p>
    public let publiclyAccessible: Bool
    /// <p>Returns the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>AllowCancelResize: a boolean value indicating if the resize operation can be
    ///                     cancelled.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ResizeType: Returns ClassicResize</p>
    ///             </li>
    ///          </ul>
    public let resizeInfo: ResizeInfo?
    /// <p>A value that describes the status of a cluster restore action. This parameter
    ///             returns null if the cluster was not created by restoring a snapshot.</p>
    public let restoreStatus: RestoreStatus?
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    public let snapshotScheduleIdentifier: String?
    /// <p>The current state of the cluster snapshot schedule.</p>
    public let snapshotScheduleState: ScheduleState?
    /// <p>The list of tags for the cluster.</p>
    public let tags: [Tag]?
    /// <p>The total storage capacity of the cluster in megabytes. </p>
    public let totalStorageCapacityInMegaBytes: Int?
    /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
    public let vpcId: String?
    /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are
    ///             associated with the cluster. This parameter is returned only if the cluster is in a
    ///             VPC.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        allowVersionUpgrade: Bool = false,
        aquaConfiguration: AquaConfiguration? = nil,
        automatedSnapshotRetentionPeriod: Int = 0,
        availabilityZone: String? = nil,
        availabilityZoneRelocationStatus: String? = nil,
        clusterAvailabilityStatus: String? = nil,
        clusterCreateTime: Date? = nil,
        clusterIdentifier: String? = nil,
        clusterNamespaceArn: String? = nil,
        clusterNodes: [ClusterNode]? = nil,
        clusterParameterGroups: [ClusterParameterGroupStatus]? = nil,
        clusterPublicKey: String? = nil,
        clusterRevisionNumber: String? = nil,
        clusterSecurityGroups: [ClusterSecurityGroupMembership]? = nil,
        clusterSnapshotCopyStatus: ClusterSnapshotCopyStatus? = nil,
        clusterStatus: String? = nil,
        clusterSubnetGroupName: String? = nil,
        clusterVersion: String? = nil,
        dBName: String? = nil,
        dataTransferProgress: DataTransferProgress? = nil,
        deferredMaintenanceWindows: [DeferredMaintenanceWindow]? = nil,
        elasticIpStatus: ElasticIpStatus? = nil,
        elasticResizeNumberOfNodeOptions: String? = nil,
        encrypted: Bool = false,
        endpoint: Endpoint? = nil,
        enhancedVpcRouting: Bool = false,
        expectedNextSnapshotScheduleTime: Date? = nil,
        expectedNextSnapshotScheduleTimeStatus: String? = nil,
        hsmStatus: HsmStatus? = nil,
        iamRoles: [ClusterIamRole]? = nil,
        kmsKeyId: String? = nil,
        maintenanceTrackName: String? = nil,
        manualSnapshotRetentionPeriod: Int = 0,
        masterUsername: String? = nil,
        modifyStatus: String? = nil,
        nextMaintenanceWindowStartTime: Date? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int = 0,
        pendingActions: [String]? = nil,
        pendingModifiedValues: PendingModifiedValues? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool = false,
        resizeInfo: ResizeInfo? = nil,
        restoreStatus: RestoreStatus? = nil,
        snapshotScheduleIdentifier: String? = nil,
        snapshotScheduleState: ScheduleState? = nil,
        tags: [Tag]? = nil,
        totalStorageCapacityInMegaBytes: Int? = nil,
        vpcId: String? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.allowVersionUpgrade = allowVersionUpgrade
        self.aquaConfiguration = aquaConfiguration
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.availabilityZoneRelocationStatus = availabilityZoneRelocationStatus
        self.clusterAvailabilityStatus = clusterAvailabilityStatus
        self.clusterCreateTime = clusterCreateTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterNamespaceArn = clusterNamespaceArn
        self.clusterNodes = clusterNodes
        self.clusterParameterGroups = clusterParameterGroups
        self.clusterPublicKey = clusterPublicKey
        self.clusterRevisionNumber = clusterRevisionNumber
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterSnapshotCopyStatus = clusterSnapshotCopyStatus
        self.clusterStatus = clusterStatus
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.clusterVersion = clusterVersion
        self.dBName = dBName
        self.dataTransferProgress = dataTransferProgress
        self.deferredMaintenanceWindows = deferredMaintenanceWindows
        self.elasticIpStatus = elasticIpStatus
        self.elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions
        self.encrypted = encrypted
        self.endpoint = endpoint
        self.enhancedVpcRouting = enhancedVpcRouting
        self.expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime
        self.expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus
        self.hsmStatus = hsmStatus
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.masterUsername = masterUsername
        self.modifyStatus = modifyStatus
        self.nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.pendingActions = pendingActions
        self.pendingModifiedValues = pendingModifiedValues
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.resizeInfo = resizeInfo
        self.restoreStatus = restoreStatus
        self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
        self.snapshotScheduleState = snapshotScheduleState
        self.tags = tags
        self.totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytes
        self.vpcId = vpcId
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension ClusterAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ClusterAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The account already has a cluster with the given identifier.</p>
public struct ClusterAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ClusterAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterAssociatedToSchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case scheduleAssociationState = "ScheduleAssociationState"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let scheduleAssociationState = scheduleAssociationState {
            try container.encode(scheduleAssociationState, forKey: Key("ScheduleAssociationState"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let scheduleAssociationStateDecoded = try containerValues.decodeIfPresent(ScheduleState.self, forKey: .scheduleAssociationState)
        scheduleAssociationState = scheduleAssociationStateDecoded
    }
}

extension ClusterAssociatedToSchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterAssociatedToSchedule(clusterIdentifier: \(String(describing: clusterIdentifier)), scheduleAssociationState: \(String(describing: scheduleAssociationState)))"}
}

/// <p></p>
public struct ClusterAssociatedToSchedule: Equatable {
    /// <p></p>
    public let clusterIdentifier: String?
    /// <p></p>
    public let scheduleAssociationState: ScheduleState?

    public init (
        clusterIdentifier: String? = nil,
        scheduleAssociationState: ScheduleState? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.scheduleAssociationState = scheduleAssociationState
    }
}

extension ClusterDbRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case currentDatabaseRevision = "CurrentDatabaseRevision"
        case databaseRevisionReleaseDate = "DatabaseRevisionReleaseDate"
        case revisionTargets = "RevisionTargets"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let currentDatabaseRevision = currentDatabaseRevision {
            try container.encode(currentDatabaseRevision, forKey: Key("CurrentDatabaseRevision"))
        }
        if let databaseRevisionReleaseDate = databaseRevisionReleaseDate {
            try container.encode(TimestampWrapper(databaseRevisionReleaseDate, format: .dateTime), forKey: Key("databaseRevisionReleaseDate"))
        }
        if let revisionTargets = revisionTargets {
            var revisionTargetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RevisionTargets"))
            for (index0, revisiontarget0) in revisionTargets.enumerated() {
                try revisionTargetsContainer.encode(revisiontarget0, forKey: Key("RevisionTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let currentDatabaseRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentDatabaseRevision)
        currentDatabaseRevision = currentDatabaseRevisionDecoded
        let databaseRevisionReleaseDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseRevisionReleaseDate)
        var databaseRevisionReleaseDateBuffer:Date? = nil
        if let databaseRevisionReleaseDateDecoded = databaseRevisionReleaseDateDecoded {
            databaseRevisionReleaseDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(databaseRevisionReleaseDateDecoded, format: .dateTime)
        }
        databaseRevisionReleaseDate = databaseRevisionReleaseDateBuffer
        if containerValues.contains(.revisionTargets) {
            struct KeyVal0{struct RevisionTarget{}}
            let revisionTargetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RevisionTarget>.CodingKeys.self, forKey: .revisionTargets)
            if let revisionTargetsWrappedContainer = revisionTargetsWrappedContainer {
                let revisionTargetsContainer = try revisionTargetsWrappedContainer.decodeIfPresent([RevisionTarget].self, forKey: .member)
                var revisionTargetsBuffer:[RevisionTarget]? = nil
                if let revisionTargetsContainer = revisionTargetsContainer {
                    revisionTargetsBuffer = [RevisionTarget]()
                    for structureContainer0 in revisionTargetsContainer {
                        revisionTargetsBuffer?.append(structureContainer0)
                    }
                }
                revisionTargets = revisionTargetsBuffer
            } else {
                revisionTargets = []
            }
        } else {
            revisionTargets = nil
        }
    }
}

extension ClusterDbRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterDbRevision(clusterIdentifier: \(String(describing: clusterIdentifier)), currentDatabaseRevision: \(String(describing: currentDatabaseRevision)), databaseRevisionReleaseDate: \(String(describing: databaseRevisionReleaseDate)), revisionTargets: \(String(describing: revisionTargets)))"}
}

/// <p>Describes a <code>ClusterDbRevision</code>.</p>
public struct ClusterDbRevision: Equatable {
    /// <p>The unique identifier of the cluster.</p>
    public let clusterIdentifier: String?
    /// <p>A string representing the current cluster version.</p>
    public let currentDatabaseRevision: String?
    /// <p>The date on which the database revision was released.</p>
    public let databaseRevisionReleaseDate: Date?
    /// <p>A list of <code>RevisionTarget</code> objects, where each object describes the
    ///             database revision that a cluster can be updated to.</p>
    public let revisionTargets: [RevisionTarget]?

    public init (
        clusterIdentifier: String? = nil,
        currentDatabaseRevision: String? = nil,
        databaseRevisionReleaseDate: Date? = nil,
        revisionTargets: [RevisionTarget]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.currentDatabaseRevision = currentDatabaseRevision
        self.databaseRevisionReleaseDate = databaseRevisionReleaseDate
        self.revisionTargets = revisionTargets
    }
}

extension ClusterIamRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyStatus = "ApplyStatus"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applyStatus = applyStatus {
            try container.encode(applyStatus, forKey: Key("ApplyStatus"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: Key("IamRoleArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let applyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applyStatus)
        applyStatus = applyStatusDecoded
    }
}

extension ClusterIamRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterIamRole(applyStatus: \(String(describing: applyStatus)), iamRoleArn: \(String(describing: iamRoleArn)))"}
}

/// <p>An AWS Identity and Access Management (IAM) role that can be used by the associated
///             Amazon Redshift cluster to access other AWS services.</p>
public struct ClusterIamRole: Equatable {
    /// <p>A value that describes the status of the IAM role's association with an Amazon
    ///             Redshift cluster.</p>
    ///         <p>The following are possible statuses and descriptions.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>in-sync</code>: The role is available for use by the cluster.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>adding</code>: The role is in the process of being associated with the
    ///                     cluster.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>removing</code>: The role is in the process of being disassociated with
    ///                     the cluster.</p>
    ///             </li>
    ///          </ul>
    public let applyStatus: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role, for example,
    ///                 <code>arn:aws:iam::123456789012:role/RedshiftCopyUnload</code>. </p>
    public let iamRoleArn: String?

    public init (
        applyStatus: String? = nil,
        iamRoleArn: String? = nil
    )
    {
        self.applyStatus = applyStatus
        self.iamRoleArn = iamRoleArn
    }
}

extension ClusterNode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nodeRole = "NodeRole"
        case privateIPAddress = "PrivateIPAddress"
        case publicIPAddress = "PublicIPAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nodeRole = nodeRole {
            try container.encode(nodeRole, forKey: Key("NodeRole"))
        }
        if let privateIPAddress = privateIPAddress {
            try container.encode(privateIPAddress, forKey: Key("PrivateIPAddress"))
        }
        if let publicIPAddress = publicIPAddress {
            try container.encode(publicIPAddress, forKey: Key("PublicIPAddress"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeRole)
        nodeRole = nodeRoleDecoded
        let privateIPAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIPAddress)
        privateIPAddress = privateIPAddressDecoded
        let publicIPAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIPAddress)
        publicIPAddress = publicIPAddressDecoded
    }
}

extension ClusterNode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterNode(nodeRole: \(String(describing: nodeRole)), privateIPAddress: \(String(describing: privateIPAddress)), publicIPAddress: \(String(describing: publicIPAddress)))"}
}

/// <p>The identifier of a node in a cluster.</p>
public struct ClusterNode: Equatable {
    /// <p>Whether the node is a leader node or a compute node.</p>
    public let nodeRole: String?
    /// <p>The private IP address of a node within a cluster.</p>
    public let privateIPAddress: String?
    /// <p>The public IP address of a node within a cluster.</p>
    public let publicIPAddress: String?

    public init (
        nodeRole: String? = nil,
        privateIPAddress: String? = nil,
        publicIPAddress: String? = nil
    )
    {
        self.nodeRole = nodeRole
        self.privateIPAddress = privateIPAddress
        self.publicIPAddress = publicIPAddress
    }
}

extension ClusterNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterNotFoundFault(message: \(String(describing: message)))"}
}

extension ClusterNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster.
///         </p>
public struct ClusterNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ClusterNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterOnLatestRevisionFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterOnLatestRevisionFault(message: \(String(describing: message)))"}
}

extension ClusterOnLatestRevisionFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterOnLatestRevisionFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cluster is already on the latest database revision.</p>
public struct ClusterOnLatestRevisionFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterOnLatestRevisionFaultBody: Equatable {
    public let message: String?
}

extension ClusterOnLatestRevisionFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case parameterGroupFamily = "ParameterGroupFamily"
        case parameterGroupName = "ParameterGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: Key("ParameterGroupFamily"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupFamily)
        parameterGroupFamily = parameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ClusterParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterParameterGroup(description: \(String(describing: description)), parameterGroupFamily: \(String(describing: parameterGroupFamily)), parameterGroupName: \(String(describing: parameterGroupName)), tags: \(String(describing: tags)))"}
}

/// <p>Describes a parameter group.</p>
public struct ClusterParameterGroup: Equatable {
    /// <p>The description of the parameter group.</p>
    public let description: String?
    /// <p>The name of the cluster parameter group family that this cluster parameter group is
    ///             compatible with.</p>
    public let parameterGroupFamily: String?
    /// <p>The name of the cluster parameter group.</p>
    public let parameterGroupName: String?
    /// <p>The list of tags for the cluster parameter group.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        parameterGroupFamily: String? = nil,
        parameterGroupName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.parameterGroupFamily = parameterGroupFamily
        self.parameterGroupName = parameterGroupName
        self.tags = tags
    }
}

extension ClusterParameterGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterParameterGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ClusterParameterGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterParameterGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A cluster parameter group with the same name already exists.</p>
public struct ClusterParameterGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterParameterGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ClusterParameterGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterParameterGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterParameterGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension ClusterParameterGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter group name does not refer to an existing parameter group.</p>
public struct ClusterParameterGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterParameterGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ClusterParameterGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterParameterGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterParameterGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ClusterParameterGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterParameterGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster
///             parameter groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterParameterGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterParameterGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ClusterParameterGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterParameterGroupStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterParameterStatusList = "ClusterParameterStatusList"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterParameterStatusList = clusterParameterStatusList {
            var clusterParameterStatusListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClusterParameterStatusList"))
            for (index0, clusterparameterstatus0) in clusterParameterStatusList.enumerated() {
                try clusterParameterStatusListContainer.encode(clusterparameterstatus0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: Key("ParameterApplyStatus"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        if containerValues.contains(.clusterParameterStatusList) {
            struct KeyVal0{struct member{}}
            let clusterParameterStatusListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clusterParameterStatusList)
            if let clusterParameterStatusListWrappedContainer = clusterParameterStatusListWrappedContainer {
                let clusterParameterStatusListContainer = try clusterParameterStatusListWrappedContainer.decodeIfPresent([ClusterParameterStatus].self, forKey: .member)
                var clusterParameterStatusListBuffer:[ClusterParameterStatus]? = nil
                if let clusterParameterStatusListContainer = clusterParameterStatusListContainer {
                    clusterParameterStatusListBuffer = [ClusterParameterStatus]()
                    for structureContainer0 in clusterParameterStatusListContainer {
                        clusterParameterStatusListBuffer?.append(structureContainer0)
                    }
                }
                clusterParameterStatusList = clusterParameterStatusListBuffer
            } else {
                clusterParameterStatusList = []
            }
        } else {
            clusterParameterStatusList = nil
        }
    }
}

extension ClusterParameterGroupStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterParameterGroupStatus(clusterParameterStatusList: \(String(describing: clusterParameterStatusList)), parameterApplyStatus: \(String(describing: parameterApplyStatus)), parameterGroupName: \(String(describing: parameterGroupName)))"}
}

/// <p>Describes the status of a parameter group.</p>
public struct ClusterParameterGroupStatus: Equatable {
    /// <p>The list of parameter statuses.</p>
    ///         <p>
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public let clusterParameterStatusList: [ClusterParameterStatus]?
    /// <p>The status of parameter updates.</p>
    public let parameterApplyStatus: String?
    /// <p>The name of the cluster parameter group.</p>
    public let parameterGroupName: String?

    public init (
        clusterParameterStatusList: [ClusterParameterStatus]? = nil,
        parameterApplyStatus: String? = nil,
        parameterGroupName: String? = nil
    )
    {
        self.clusterParameterStatusList = clusterParameterStatusList
        self.parameterApplyStatus = parameterApplyStatus
        self.parameterGroupName = parameterGroupName
    }
}

extension ClusterParameterStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterApplyErrorDescription = "ParameterApplyErrorDescription"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterName = "ParameterName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let parameterApplyErrorDescription = parameterApplyErrorDescription {
            try container.encode(parameterApplyErrorDescription, forKey: Key("ParameterApplyErrorDescription"))
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: Key("ParameterApplyStatus"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: Key("ParameterName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let parameterApplyErrorDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyErrorDescription)
        parameterApplyErrorDescription = parameterApplyErrorDescriptionDecoded
    }
}

extension ClusterParameterStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterParameterStatus(parameterApplyErrorDescription: \(String(describing: parameterApplyErrorDescription)), parameterApplyStatus: \(String(describing: parameterApplyStatus)), parameterName: \(String(describing: parameterName)))"}
}

/// <p>Describes the status of a parameter group.</p>
public struct ClusterParameterStatus: Equatable {
    /// <p>The error that prevented the parameter from being applied to the
    ///             database.</p>
    public let parameterApplyErrorDescription: String?
    /// <p>The status of the parameter that indicates whether the parameter is in sync with
    ///             the database, waiting for a cluster reboot, or encountered an error when being
    ///             applied.</p>
    ///         <p>The following are possible statuses and descriptions.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>in-sync</code>: The parameter value is in sync with the
    ///                     database.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>pending-reboot</code>: The parameter value will be applied after the
    ///                     cluster reboots.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>applying</code>: The parameter value is being applied to the
    ///                     database.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>invalid-parameter</code>: Cannot apply the parameter value because it has
    ///                     an invalid value or syntax.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>apply-deferred</code>: The parameter contains static property changes. The
    ///                     changes are deferred until the cluster reboots.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>apply-error</code>: Cannot connect to the cluster. The parameter change
    ///                     will be applied after the cluster reboots.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>unknown-error</code>: Cannot apply the parameter change right now. The
    ///                     change will be applied after the cluster reboots.</p>
    ///             </li>
    ///          </ul>
    public let parameterApplyStatus: String?
    /// <p>The name of the parameter.</p>
    public let parameterName: String?

    public init (
        parameterApplyErrorDescription: String? = nil,
        parameterApplyStatus: String? = nil,
        parameterName: String? = nil
    )
    {
        self.parameterApplyErrorDescription = parameterApplyErrorDescription
        self.parameterApplyStatus = parameterApplyStatus
        self.parameterName = parameterName
    }
}

extension ClusterQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ClusterQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would exceed the allowed number of cluster instances for this account.
///
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ClusterQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterSecurityGroupName = "ClusterSecurityGroupName"
        case description = "Description"
        case eC2SecurityGroups = "EC2SecurityGroups"
        case iPRanges = "IPRanges"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: Key("ClusterSecurityGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let eC2SecurityGroups = eC2SecurityGroups {
            var eC2SecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EC2SecurityGroups"))
            for (index0, ec2securitygroup0) in eC2SecurityGroups.enumerated() {
                try eC2SecurityGroupsContainer.encode(ec2securitygroup0, forKey: Key("EC2SecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let iPRanges = iPRanges {
            var iPRangesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("IPRanges"))
            for (index0, iprange0) in iPRanges.enumerated() {
                try iPRangesContainer.encode(iprange0, forKey: Key("IPRange.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterSecurityGroupName)
        clusterSecurityGroupName = clusterSecurityGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.eC2SecurityGroups) {
            struct KeyVal0{struct EC2SecurityGroup{}}
            let eC2SecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EC2SecurityGroup>.CodingKeys.self, forKey: .eC2SecurityGroups)
            if let eC2SecurityGroupsWrappedContainer = eC2SecurityGroupsWrappedContainer {
                let eC2SecurityGroupsContainer = try eC2SecurityGroupsWrappedContainer.decodeIfPresent([EC2SecurityGroup].self, forKey: .member)
                var eC2SecurityGroupsBuffer:[EC2SecurityGroup]? = nil
                if let eC2SecurityGroupsContainer = eC2SecurityGroupsContainer {
                    eC2SecurityGroupsBuffer = [EC2SecurityGroup]()
                    for structureContainer0 in eC2SecurityGroupsContainer {
                        eC2SecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                eC2SecurityGroups = eC2SecurityGroupsBuffer
            } else {
                eC2SecurityGroups = []
            }
        } else {
            eC2SecurityGroups = nil
        }
        if containerValues.contains(.iPRanges) {
            struct KeyVal0{struct IPRange{}}
            let iPRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.IPRange>.CodingKeys.self, forKey: .iPRanges)
            if let iPRangesWrappedContainer = iPRangesWrappedContainer {
                let iPRangesContainer = try iPRangesWrappedContainer.decodeIfPresent([IPRange].self, forKey: .member)
                var iPRangesBuffer:[IPRange]? = nil
                if let iPRangesContainer = iPRangesContainer {
                    iPRangesBuffer = [IPRange]()
                    for structureContainer0 in iPRangesContainer {
                        iPRangesBuffer?.append(structureContainer0)
                    }
                }
                iPRanges = iPRangesBuffer
            } else {
                iPRanges = []
            }
        } else {
            iPRanges = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ClusterSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSecurityGroup(clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)), description: \(String(describing: description)), eC2SecurityGroups: \(String(describing: eC2SecurityGroups)), iPRanges: \(String(describing: iPRanges)), tags: \(String(describing: tags)))"}
}

/// <p>Describes a security group.</p>
public struct ClusterSecurityGroup: Equatable {
    /// <p>The name of the cluster security group to which the operation was
    ///             applied.</p>
    public let clusterSecurityGroupName: String?
    /// <p>A description of the security group.</p>
    public let description: String?
    /// <p>A list of EC2 security groups that are permitted to access clusters associated with
    ///             this cluster security group.</p>
    public let eC2SecurityGroups: [EC2SecurityGroup]?
    /// <p>A list of IP ranges (CIDR blocks) that are permitted to access clusters associated
    ///             with this cluster security group.</p>
    public let iPRanges: [IPRange]?
    /// <p>The list of tags for the cluster security group.</p>
    public let tags: [Tag]?

    public init (
        clusterSecurityGroupName: String? = nil,
        description: String? = nil,
        eC2SecurityGroups: [EC2SecurityGroup]? = nil,
        iPRanges: [IPRange]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.description = description
        self.eC2SecurityGroups = eC2SecurityGroups
        self.iPRanges = iPRanges
        self.tags = tags
    }
}

extension ClusterSecurityGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSecurityGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ClusterSecurityGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSecurityGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A cluster security group with the same name already exists.</p>
public struct ClusterSecurityGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSecurityGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ClusterSecurityGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterSecurityGroupName = "ClusterSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: Key("ClusterSecurityGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterSecurityGroupName)
        clusterSecurityGroupName = clusterSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ClusterSecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSecurityGroupMembership(clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)), status: \(String(describing: status)))"}
}

/// <p>Describes a cluster security group.</p>
public struct ClusterSecurityGroupMembership: Equatable {
    /// <p>The name of the cluster security group.</p>
    public let clusterSecurityGroupName: String?
    /// <p>The status of the cluster security group.</p>
    public let status: String?

    public init (
        clusterSecurityGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.status = status
    }
}

extension ClusterSecurityGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSecurityGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension ClusterSecurityGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSecurityGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster security group name does not refer to an existing cluster security
///             group.</p>
public struct ClusterSecurityGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSecurityGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ClusterSecurityGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSecurityGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSecurityGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ClusterSecurityGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSecurityGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster
///             security groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterSecurityGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSecurityGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ClusterSecurityGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSnapshotAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSnapshotAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ClusterSnapshotAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified as a snapshot identifier is already used by an existing
///             snapshot.</p>
public struct ClusterSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSnapshotAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ClusterSnapshotAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSnapshotCopyStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationRegion = "DestinationRegion"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case retentionPeriod = "RetentionPeriod"
        case snapshotCopyGrantName = "SnapshotCopyGrantName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let destinationRegion = destinationRegion {
            try container.encode(destinationRegion, forKey: Key("DestinationRegion"))
        }
        if manualSnapshotRetentionPeriod != 0 {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if retentionPeriod != 0 {
            try container.encode(retentionPeriod, forKey: Key("RetentionPeriod"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: Key("SnapshotCopyGrantName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let retentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let snapshotCopyGrantNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCopyGrantName)
        snapshotCopyGrantName = snapshotCopyGrantNameDecoded
    }
}

extension ClusterSnapshotCopyStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSnapshotCopyStatus(destinationRegion: \(String(describing: destinationRegion)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), retentionPeriod: \(String(describing: retentionPeriod)), snapshotCopyGrantName: \(String(describing: snapshotCopyGrantName)))"}
}

/// <p>Returns the destination region and retention period that are configured for
///             cross-region snapshot copy.</p>
public struct ClusterSnapshotCopyStatus: Equatable {
    /// <p>The destination region that snapshots are automatically copied to when cross-region
    ///             snapshot copy is enabled.</p>
    public let destinationRegion: String?
    /// <p>The number of days that automated snapshots are retained in the destination region
    ///             after they are copied from a source region. If the value is -1, the manual snapshot is
    ///             retained indefinitely. </p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Int
    /// <p>The number of days that automated snapshots are retained in the destination region
    ///             after they are copied from a source region.</p>
    public let retentionPeriod: Int
    /// <p>The name of the snapshot copy grant.</p>
    public let snapshotCopyGrantName: String?

    public init (
        destinationRegion: String? = nil,
        manualSnapshotRetentionPeriod: Int = 0,
        retentionPeriod: Int = 0,
        snapshotCopyGrantName: String? = nil
    )
    {
        self.destinationRegion = destinationRegion
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.retentionPeriod = retentionPeriod
        self.snapshotCopyGrantName = snapshotCopyGrantName
    }
}

extension ClusterSnapshotNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSnapshotNotFoundFault(message: \(String(describing: message)))"}
}

extension ClusterSnapshotNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
public struct ClusterSnapshotNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSnapshotNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ClusterSnapshotNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSnapshotQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSnapshotQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ClusterSnapshotQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster
///             snapshots.</p>
public struct ClusterSnapshotQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSnapshotQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ClusterSnapshotQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSubnetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterSubnetGroupName = "ClusterSubnetGroupName"
        case description = "Description"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try container.encode(subnetGroupStatus, forKey: Key("SubnetGroupStatus"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnet0) in subnets.enumerated() {
                try subnetsContainer.encode(subnet0, forKey: Key("Subnet.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterSubnetGroupName)
        clusterSubnetGroupName = clusterSubnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct Subnet{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Subnet>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Subnet].self, forKey: .member)
                var subnetsBuffer:[Subnet]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Subnet]()
                    for structureContainer0 in subnetsContainer {
                        subnetsBuffer?.append(structureContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ClusterSubnetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSubnetGroup(clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), description: \(String(describing: description)), subnetGroupStatus: \(String(describing: subnetGroupStatus)), subnets: \(String(describing: subnets)), tags: \(String(describing: tags)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Describes a subnet group.</p>
public struct ClusterSubnetGroup: Equatable {
    /// <p>The name of the cluster subnet group.</p>
    public let clusterSubnetGroupName: String?
    /// <p>The description of the cluster subnet group.</p>
    public let description: String?
    /// <p>The status of the cluster subnet group. Possible values are <code>Complete</code>,
    ///                 <code>Incomplete</code> and <code>Invalid</code>. </p>
    public let subnetGroupStatus: String?
    /// <p>A list of the VPC <a>Subnet</a> elements. </p>
    public let subnets: [Subnet]?
    /// <p>The list of tags for the cluster subnet group.</p>
    public let tags: [Tag]?
    /// <p>The VPC ID of the cluster subnet group.</p>
    public let vpcId: String?

    public init (
        clusterSubnetGroupName: String? = nil,
        description: String? = nil,
        subnetGroupStatus: String? = nil,
        subnets: [Subnet]? = nil,
        tags: [Tag]? = nil,
        vpcId: String? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.description = description
        self.subnetGroupStatus = subnetGroupStatus
        self.subnets = subnets
        self.tags = tags
        self.vpcId = vpcId
    }
}

extension ClusterSubnetGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSubnetGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ClusterSubnetGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSubnetGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A <i>ClusterSubnetGroupName</i> is already used by an existing
///             cluster subnet group. </p>
public struct ClusterSubnetGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ClusterSubnetGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSubnetGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSubnetGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension ClusterSubnetGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSubnetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster subnet group name does not refer to an existing cluster subnet
///             group.</p>
public struct ClusterSubnetGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ClusterSubnetGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSubnetGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSubnetGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ClusterSubnetGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSubnetGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in user exceeding the allowed number of cluster subnet
///             groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterSubnetGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ClusterSubnetGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterSubnetQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterSubnetQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ClusterSubnetQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ClusterSubnetQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in user exceeding the allowed number of subnets in a
///             cluster subnet groups.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ClusterSubnetQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterSubnetQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ClusterSubnetQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterParameterGroupFamily = "ClusterParameterGroupFamily"
        case clusterVersion = "ClusterVersion"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterParameterGroupFamily = clusterParameterGroupFamily {
            try container.encode(clusterParameterGroupFamily, forKey: Key("ClusterParameterGroupFamily"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let clusterParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterParameterGroupFamily)
        clusterParameterGroupFamily = clusterParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ClusterVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterVersion(clusterParameterGroupFamily: \(String(describing: clusterParameterGroupFamily)), clusterVersion: \(String(describing: clusterVersion)), description: \(String(describing: description)))"}
}

/// <p>Describes a cluster version, including the parameter group family and description
///             of the version.</p>
public struct ClusterVersion: Equatable {
    /// <p>The name of the cluster parameter group family for the cluster.</p>
    public let clusterParameterGroupFamily: String?
    /// <p>The version number used by the cluster.</p>
    public let clusterVersion: String?
    /// <p>The description of the cluster version.</p>
    public let description: String?

    public init (
        clusterParameterGroupFamily: String? = nil,
        clusterVersion: String? = nil,
        description: String? = nil
    )
    {
        self.clusterParameterGroupFamily = clusterParameterGroupFamily
        self.clusterVersion = clusterVersion
        self.description = description
    }
}

public struct CopyClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CopyClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyClusterSnapshotOutputError>
}

extension CopyClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyClusterSnapshotInput(manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), sourceSnapshotClusterIdentifier: \(String(describing: sourceSnapshotClusterIdentifier)), sourceSnapshotIdentifier: \(String(describing: sourceSnapshotIdentifier)), targetSnapshotIdentifier: \(String(describing: targetSnapshotIdentifier)))"}
}

extension CopyClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let sourceSnapshotClusterIdentifier = sourceSnapshotClusterIdentifier {
            try container.encode(sourceSnapshotClusterIdentifier, forKey: Key("SourceSnapshotClusterIdentifier"))
        }
        if let sourceSnapshotIdentifier = sourceSnapshotIdentifier {
            try container.encode(sourceSnapshotIdentifier, forKey: Key("SourceSnapshotIdentifier"))
        }
        if let targetSnapshotIdentifier = targetSnapshotIdentifier {
            try container.encode(targetSnapshotIdentifier, forKey: Key("TargetSnapshotIdentifier"))
        }
        try container.encode("CopyClusterSnapshot", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CopyClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CopyClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyClusterSnapshotOutputError>
}

public struct CopyClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyClusterSnapshotOutputError>
}

/// <p></p>
public struct CopyClusterSnapshotInput: Equatable {
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely. </p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>The default value is -1.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>The identifier of the cluster the source snapshot was created from. This parameter
    ///             is required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be the identifier for a valid cluster.</p>
    ///             </li>
    ///          </ul>
    public let sourceSnapshotClusterIdentifier: String?
    /// <p>The identifier for the source snapshot.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be the identifier for a valid automated snapshot whose state is
    ///                         <code>available</code>.</p>
    ///             </li>
    ///          </ul>
    public let sourceSnapshotIdentifier: String?
    /// <p>The identifier given to the new manual snapshot.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot be null, empty, or blank.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique for the AWS account that is making the request.</p>
    ///             </li>
    ///          </ul>
    public let targetSnapshotIdentifier: String?

    public init (
        manualSnapshotRetentionPeriod: Int? = nil,
        sourceSnapshotClusterIdentifier: String? = nil,
        sourceSnapshotIdentifier: String? = nil,
        targetSnapshotIdentifier: String? = nil
    )
    {
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.sourceSnapshotClusterIdentifier = sourceSnapshotClusterIdentifier
        self.sourceSnapshotIdentifier = sourceSnapshotIdentifier
        self.targetSnapshotIdentifier = targetSnapshotIdentifier
    }
}

extension CopyClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSnapshotAlreadyExistsFault" : self = .clusterSnapshotAlreadyExistsFault(try ClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotQuotaExceededFault" : self = .clusterSnapshotQuotaExceededFault(try ClusterSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyClusterSnapshotOutputError: Equatable {
    case clusterSnapshotAlreadyExistsFault(ClusterSnapshotAlreadyExistsFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case clusterSnapshotQuotaExceededFault(ClusterSnapshotQuotaExceededFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyClusterSnapshotOutputResponse(snapshot: \(String(describing: snapshot)))"}
}

extension CopyClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CopyClusterSnapshotOutputResponse: Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: Snapshot?

    public init (
        snapshot: Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CopyClusterSnapshotOutputResponseBody: Equatable {
    public let snapshot: Snapshot?
}

extension CopyClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension CopyToRegionDisabledFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyToRegionDisabledFault(message: \(String(describing: message)))"}
}

extension CopyToRegionDisabledFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CopyToRegionDisabledFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cross-region snapshot copy was temporarily disabled. Try your request
///             again.</p>
public struct CopyToRegionDisabledFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CopyToRegionDisabledFaultBody: Equatable {
    public let message: String?
}

extension CopyToRegionDisabledFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterInput(additionalInfo: \(String(describing: additionalInfo)), allowVersionUpgrade: \(String(describing: allowVersionUpgrade)), aquaConfigurationStatus: \(String(describing: aquaConfigurationStatus)), automatedSnapshotRetentionPeriod: \(String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(String(describing: availabilityZone)), availabilityZoneRelocation: \(String(describing: availabilityZoneRelocation)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterParameterGroupName: \(String(describing: clusterParameterGroupName)), clusterSecurityGroups: \(String(describing: clusterSecurityGroups)), clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), clusterType: \(String(describing: clusterType)), clusterVersion: \(String(describing: clusterVersion)), dBName: \(String(describing: dBName)), elasticIp: \(String(describing: elasticIp)), encrypted: \(String(describing: encrypted)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), iamRoles: \(String(describing: iamRoles)), kmsKeyId: \(String(describing: kmsKeyId)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), masterUserPassword: \(String(describing: masterUserPassword)), masterUsername: \(String(describing: masterUsername)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), port: \(String(describing: port)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(String(describing: publiclyAccessible)), snapshotScheduleIdentifier: \(String(describing: snapshotScheduleIdentifier)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let additionalInfo = additionalInfo {
            try container.encode(additionalInfo, forKey: Key("AdditionalInfo"))
        }
        if let allowVersionUpgrade = allowVersionUpgrade {
            try container.encode(allowVersionUpgrade, forKey: Key("AllowVersionUpgrade"))
        }
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: Key("AquaConfigurationStatus"))
        }
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocation = availabilityZoneRelocation {
            try container.encode(availabilityZoneRelocation, forKey: Key("AvailabilityZoneRelocation"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterParameterGroupName = clusterParameterGroupName {
            try container.encode(clusterParameterGroupName, forKey: Key("ClusterParameterGroupName"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClusterSecurityGroups"))
            for (index0, string0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(string0, forKey: Key("ClusterSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: Key("ElasticIp"))
        }
        if let encrypted = encrypted {
            try container.encode(encrypted, forKey: Key("Encrypted"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: Key("EnhancedVpcRouting"))
        }
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("IamRoles"))
            for (index0, string0) in iamRoles.enumerated() {
                try iamRolesContainer.encode(string0, forKey: Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try container.encode(snapshotScheduleIdentifier, forKey: Key("SnapshotScheduleIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateCluster", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

/// <p></p>
public struct CreateClusterInput: Equatable {
    /// <p>Reserved.</p>
    public let additionalInfo: String?
    /// <p>If <code>true</code>, major version upgrades can be applied during the maintenance
    ///             window to the Amazon Redshift engine that is running on the cluster.</p>
    ///         <p>When a new major version of the Amazon Redshift engine is released, you can request that
    ///             the service automatically apply upgrades during the maintenance window to the Amazon Redshift
    ///             engine that is running on your cluster.</p>
    ///         <p>Default: <code>true</code>
    ///         </p>
    public let allowVersionUpgrade: Bool?
    /// <p>The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) when it is created. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - Don't use AQUA. </p>
    ///             </li>
    ///             <li>
    ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    ///             </li>
    ///          </ul>
    public let aquaConfigurationStatus: AquaConfigurationStatus?
    /// <p>The number of days that automated snapshots are retained. If the value is 0,
    ///             automated snapshots are disabled. Even if automated snapshots are disabled, you can
    ///             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
    ///
    ///         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
    ///         <p>Default: <code>1</code>
    ///         </p>
    ///         <p>Constraints: Must be a value from 0 to 35.</p>
    public let automatedSnapshotRetentionPeriod: Int?
    /// <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the
    ///             cluster. For example, if you have several EC2 instances running in a specific
    ///             Availability Zone, then you might want the cluster to be provisioned in the same zone in
    ///             order to decrease network latency.</p>
    ///         <p>Default: A random, system-chosen Availability Zone in the region that is specified
    ///             by the endpoint.</p>
    ///         <p>Example: <code>us-east-2d</code>
    ///         </p>
    ///         <p>Constraint: The specified Availability Zone must be in the same region as the
    ///             current endpoint.</p>
    public let availabilityZone: String?
    /// <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is created.</p>
    public let availabilityZoneRelocation: Bool?
    /// <p>A unique identifier for the cluster. You use this identifier to refer to the
    ///             cluster for any subsequent cluster operations such as deleting or modifying. The
    ///             identifier also appears in the Amazon Redshift console.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    ///
    ///             <p>Example: <code>myexamplecluster</code>
    ///         </p>
    public let clusterIdentifier: String?
    /// <p>The name of the parameter group to be associated with this cluster.</p>
    ///         <p>Default: The default Amazon Redshift cluster parameter group. For information about the
    ///             default parameter group, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon
    ///                 Redshift Parameter Groups</a>
    ///         </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterParameterGroupName: String?
    /// <p>A list of security groups to be associated with this cluster.</p>
    ///         <p>Default: The default cluster security group for Amazon Redshift.</p>
    public let clusterSecurityGroups: [String]?
    /// <p>The name of a cluster subnet group to be associated with this cluster.</p>
    ///         <p>If this parameter is not provided the resulting cluster will be deployed outside
    ///             virtual private cloud (VPC).</p>
    public let clusterSubnetGroupName: String?
    /// <p>The type of the cluster. When cluster type is specified as</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>single-node</code>, the <b>NumberOfNodes</b>
    ///                     parameter is not required.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>multi-node</code>, the <b>NumberOfNodes</b>
    ///                     parameter is required.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
    ///         </p>
    ///         <p>Default: <code>multi-node</code>
    ///         </p>
    public let clusterType: String?
    /// <p>The version of the Amazon Redshift engine software that you want to deploy on the
    ///             cluster.</p>
    ///         <p>The version selected runs on all the nodes in the cluster.</p>
    ///         <p>Constraints: Only version 1.0 is currently available.</p>
    ///         <p>Example: <code>1.0</code>
    ///         </p>
    public let clusterVersion: String?
    /// <p>The name of the first database to be created when the cluster is created.</p>
    ///         <p>To create additional databases after the cluster is created, connect to the cluster
    ///             with a SQL client and use SQL commands to create a database. For more information, go to
    ///                 <a href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create
    ///                 a Database</a> in the Amazon Redshift Database Developer Guide. </p>
    ///         <p>Default: <code>dev</code>
    ///         </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain 1 to 64 alphanumeric characters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a word that is reserved by the service. A list of reserved words
    ///                     can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the
    ///                     Amazon Redshift Database Developer Guide. </p>
    ///             </li>
    ///          </ul>
    public let dBName: String?
    /// <p>The Elastic IP (EIP) address for the cluster.</p>
    ///         <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible
    ///             through an Internet gateway. For more information about provisioning clusters in
    ///             EC2-VPC, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported
    ///                 Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
    public let elasticIp: String?
    /// <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p>
    ///         <p>Default: false</p>
    public let encrypted: Bool?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Bool?
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    ///             retrieve the data encryption keys stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>Specifies the name of the HSM configuration that contains the information the
    ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the
    ///             cluster to access other AWS services. You must supply the IAM roles in their Amazon
    ///             Resource Name (ARN) format. You can supply up to 10 IAM roles in a single
    ///             request.</p>
    ///         <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
    public let iamRoles: [String]?
    /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that you want to
    ///             use to encrypt data in the cluster.</p>
    public let kmsKeyId: String?
    /// <p>An optional parameter for the name of the maintenance track for the cluster. If you
    ///             don't provide a maintenance track name, the cluster is assigned to the
    ///                 <code>current</code> track.</p>
    public let maintenanceTrackName: String?
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
    ///             snapshot is retained indefinitely. This setting doesn't change the retention period
    ///             of existing snapshots.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>The password associated with the master user account for the cluster that is being
    ///             created.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be between 8 and 64 characters in length.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one uppercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one lowercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain one number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can be any printable ASCII character (ASCII code 33 to 126) except '
    ///                     (single quote), " (double quote), \, /, @, or space.</p>
    ///             </li>
    ///          </ul>
    public let masterUserPassword: String?
    /// <p>The user name associated with the master user account for the cluster that is being
    ///             created.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 - 128 alphanumeric characters. The user name can't be
    ///                         <code>PUBLIC</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved
    ///                         Words</a> in the Amazon Redshift Database Developer Guide. </p>
    ///             </li>
    ///          </ul>
    public let masterUsername: String?
    /// <p>The node type to be provisioned for the cluster. For information about node types,
    ///             go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with
    ///                 Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ///         <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> |
    ///                 <code>dc1.large</code> | <code>dc1.8xlarge</code> |
    ///                 <code>dc2.large</code> | <code>dc2.8xlarge</code> |
    ///                 <code>ra3.xlplus</code> |  <code>ra3.4xlarge</code> | <code>ra3.16xlarge</code>
    ///          </p>
    public let nodeType: String?
    /// <p>The number of compute nodes in the cluster. This parameter is required when the
    ///                 <b>ClusterType</b> parameter is specified as
    ///                 <code>multi-node</code>. </p>
    ///         <p>For information about determining how many nodes you need, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with
    ///                 Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ///         <p>If you don't specify this parameter, you get a single-node cluster. When requesting
    ///             a multi-node cluster, you must specify the number of nodes that you want in the
    ///             cluster.</p>
    ///         <p>Default: <code>1</code>
    ///         </p>
    ///         <p>Constraints: Value must be at least 1 and no more than 100.</p>
    public let numberOfNodes: Int?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    ///         <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of
    ///             the connection string requires the port on which the cluster will listen for incoming
    ///             connections.</p>
    ///         <p>Default: <code>5439</code>
    ///         </p>
    ///         <p>Valid Values: <code>1150-65535</code>
    ///         </p>
    public let port: Int?
    /// <p>The weekly time range (in UTC) during which automated cluster maintenance can
    ///             occur.</p>
    ///         <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///         </p>
    ///         <p> Default: A 30-minute window selected at random from an 8-hour block of time per
    ///             region, occurring on a random day of the week. For more information about the time
    ///             blocks for each region, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p>
    ///         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///         <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>If <code>true</code>, the cluster can be accessed from a public network. </p>
    public let publiclyAccessible: Bool?
    /// <p>A unique identifier for the snapshot schedule.</p>
    public let snapshotScheduleIdentifier: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?
    /// <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the
    ///             cluster.</p>
    ///         <p>Default: The default VPC security group is associated with the cluster.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        additionalInfo: String? = nil,
        allowVersionUpgrade: Bool? = nil,
        aquaConfigurationStatus: AquaConfigurationStatus? = nil,
        automatedSnapshotRetentionPeriod: Int? = nil,
        availabilityZone: String? = nil,
        availabilityZoneRelocation: Bool? = nil,
        clusterIdentifier: String? = nil,
        clusterParameterGroupName: String? = nil,
        clusterSecurityGroups: [String]? = nil,
        clusterSubnetGroupName: String? = nil,
        clusterType: String? = nil,
        clusterVersion: String? = nil,
        dBName: String? = nil,
        elasticIp: String? = nil,
        encrypted: Bool? = nil,
        enhancedVpcRouting: Bool? = nil,
        hsmClientCertificateIdentifier: String? = nil,
        hsmConfigurationIdentifier: String? = nil,
        iamRoles: [String]? = nil,
        kmsKeyId: String? = nil,
        maintenanceTrackName: String? = nil,
        manualSnapshotRetentionPeriod: Int? = nil,
        masterUserPassword: String? = nil,
        masterUsername: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int? = nil,
        port: Int? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool? = nil,
        snapshotScheduleIdentifier: String? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.allowVersionUpgrade = allowVersionUpgrade
        self.aquaConfigurationStatus = aquaConfigurationStatus
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.availabilityZoneRelocation = availabilityZoneRelocation
        self.clusterIdentifier = clusterIdentifier
        self.clusterParameterGroupName = clusterParameterGroupName
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.clusterType = clusterType
        self.clusterVersion = clusterVersion
        self.dBName = dBName
        self.elasticIp = elasticIp
        self.encrypted = encrypted
        self.enhancedVpcRouting = enhancedVpcRouting
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.port = port
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaExceededFault" : self = .clusterQuotaExceededFault(try ClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetGroupStateFault" : self = .invalidClusterSubnetGroupStateFault(try InvalidClusterSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidElasticIpFault" : self = .invalidElasticIpFault(try InvalidElasticIpFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case clusterQuotaExceededFault(ClusterQuotaExceededFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterSubnetGroupStateFault(InvalidClusterSubnetGroupStateFault)
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case invalidElasticIpFault(InvalidElasticIpFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case invalidSubnet(InvalidSubnet)
    case invalidTagFault(InvalidTagFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension CreateClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension CreateClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct CreateClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterParameterGroupOutputError>
}

extension CreateClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterParameterGroupInput(description: \(String(describing: description)), parameterGroupFamily: \(String(describing: parameterGroupFamily)), parameterGroupName: \(String(describing: parameterGroupName)), tags: \(String(describing: tags)))"}
}

extension CreateClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: Key("ParameterGroupFamily"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterParameterGroupOutputError>
}

public struct CreateClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterParameterGroupOutputError>
}

/// <p></p>
public struct CreateClusterParameterGroupInput: Equatable {
    /// <p>A description of the parameter group.</p>
    public let description: String?
    /// <p>The Amazon Redshift engine version to which the cluster parameter group applies. The
    ///             cluster engine version determines the set of parameters.</p>
    ///         <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of
    ///             all the parameter groups that are owned by your AWS account, including the default
    ///             parameter groups for each Amazon Redshift engine version. The parameter group family names
    ///             associated with the default parameter groups provide you the valid values. For example,
    ///             a valid family name is "redshift-1.0". </p>
    public let parameterGroupFamily: String?
    /// <p>The name of the cluster parameter group.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique withing your AWS account.</p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>This value is stored as a lower-case string.</p>
    ///         </note>
    public let parameterGroupName: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        parameterGroupFamily: String? = nil,
        parameterGroupName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.parameterGroupFamily = parameterGroupFamily
        self.parameterGroupName = parameterGroupName
        self.tags = tags
    }
}

extension CreateClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupAlreadyExistsFault" : self = .clusterParameterGroupAlreadyExistsFault(try ClusterParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupQuotaExceededFault" : self = .clusterParameterGroupQuotaExceededFault(try ClusterParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterParameterGroupOutputError: Equatable {
    case clusterParameterGroupAlreadyExistsFault(ClusterParameterGroupAlreadyExistsFault)
    case clusterParameterGroupQuotaExceededFault(ClusterParameterGroupQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterParameterGroupOutputResponse(clusterParameterGroup: \(String(describing: clusterParameterGroup)))"}
}

extension CreateClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterParameterGroup = output.clusterParameterGroup
        } else {
            self.clusterParameterGroup = nil
        }
    }
}

public struct CreateClusterParameterGroupOutputResponse: Equatable {
    /// <p>Describes a parameter group.</p>
    public let clusterParameterGroup: ClusterParameterGroup?

    public init (
        clusterParameterGroup: ClusterParameterGroup? = nil
    )
    {
        self.clusterParameterGroup = clusterParameterGroup
    }
}

struct CreateClusterParameterGroupOutputResponseBody: Equatable {
    public let clusterParameterGroup: ClusterParameterGroup?
}

extension CreateClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterParameterGroup = "ClusterParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateClusterParameterGroupResult"))
        let clusterParameterGroupDecoded = try containerValues.decodeIfPresent(ClusterParameterGroup.self, forKey: .clusterParameterGroup)
        clusterParameterGroup = clusterParameterGroupDecoded
    }
}

public struct CreateClusterSecurityGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSecurityGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSecurityGroupOutputError>
}

extension CreateClusterSecurityGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterSecurityGroupInput(clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)), description: \(String(describing: description)), tags: \(String(describing: tags)))"}
}

extension CreateClusterSecurityGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: Key("ClusterSecurityGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterSecurityGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateClusterSecurityGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSecurityGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSecurityGroupOutputError>
}

public struct CreateClusterSecurityGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSecurityGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSecurityGroupOutputError>
}

/// <p></p>
public struct CreateClusterSecurityGroupInput: Equatable {
    /// <p>The name for the security group. Amazon Redshift stores the value as a lowercase
    ///             string.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain no more than 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not be "Default".</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique for all security groups that are created by your AWS
    ///                     account.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>examplesecuritygroup</code>
    ///         </p>
    public let clusterSecurityGroupName: String?
    /// <p>A description for the security group.</p>
    public let description: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        clusterSecurityGroupName: String? = nil,
        description: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.description = description
        self.tags = tags
    }
}

extension CreateClusterSecurityGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterSecurityGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSecurityGroupAlreadyExistsFault" : self = .clusterSecurityGroupAlreadyExistsFault(try ClusterSecurityGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupQuotaExceededFault" : self = .clusterSecurityGroupQuotaExceededFault(try ClusterSecurityGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterSecurityGroupOutputError: Equatable {
    case clusterSecurityGroupAlreadyExistsFault(ClusterSecurityGroupAlreadyExistsFault)
    case clusterSecurityGroupQuotaExceededFault(ClusterSecurityGroupQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterSecurityGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterSecurityGroupOutputResponse(clusterSecurityGroup: \(String(describing: clusterSecurityGroup)))"}
}

extension CreateClusterSecurityGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClusterSecurityGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterSecurityGroup = output.clusterSecurityGroup
        } else {
            self.clusterSecurityGroup = nil
        }
    }
}

public struct CreateClusterSecurityGroupOutputResponse: Equatable {
    /// <p>Describes a security group.</p>
    public let clusterSecurityGroup: ClusterSecurityGroup?

    public init (
        clusterSecurityGroup: ClusterSecurityGroup? = nil
    )
    {
        self.clusterSecurityGroup = clusterSecurityGroup
    }
}

struct CreateClusterSecurityGroupOutputResponseBody: Equatable {
    public let clusterSecurityGroup: ClusterSecurityGroup?
}

extension CreateClusterSecurityGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterSecurityGroup = "ClusterSecurityGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateClusterSecurityGroupResult"))
        let clusterSecurityGroupDecoded = try containerValues.decodeIfPresent(ClusterSecurityGroup.self, forKey: .clusterSecurityGroup)
        clusterSecurityGroup = clusterSecurityGroupDecoded
    }
}

public struct CreateClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSnapshotOutputError>
}

extension CreateClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterSnapshotInput(clusterIdentifier: \(String(describing: clusterIdentifier)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), tags: \(String(describing: tags)))"}
}

extension CreateClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterSnapshot", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSnapshotOutputError>
}

public struct CreateClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSnapshotOutputError>
}

/// <p></p>
public struct CreateClusterSnapshotInput: Equatable {
    /// <p>The cluster identifier for which you want a snapshot.</p>
    public let clusterIdentifier: String?
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely. </p>
    ///
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///
    ///         <p>The default value is -1.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>A unique identifier for the snapshot that you are requesting. This identifier must
    ///             be unique for all snapshots within the AWS account.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>my-snapshot-id</code>
    ///         </p>
    public let snapshotIdentifier: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        clusterIdentifier: String? = nil,
        manualSnapshotRetentionPeriod: Int? = nil,
        snapshotIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
    }
}

extension CreateClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotAlreadyExistsFault" : self = .clusterSnapshotAlreadyExistsFault(try ClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotQuotaExceededFault" : self = .clusterSnapshotQuotaExceededFault(try ClusterSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterSnapshotOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotAlreadyExistsFault(ClusterSnapshotAlreadyExistsFault)
    case clusterSnapshotQuotaExceededFault(ClusterSnapshotQuotaExceededFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterSnapshotOutputResponse(snapshot: \(String(describing: snapshot)))"}
}

extension CreateClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateClusterSnapshotOutputResponse: Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: Snapshot?

    public init (
        snapshot: Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateClusterSnapshotOutputResponseBody: Equatable {
    public let snapshot: Snapshot?
}

extension CreateClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct CreateClusterSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSubnetGroupOutputError>
}

extension CreateClusterSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterSubnetGroupInput(clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), description: \(String(describing: description)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)))"}
}

extension CreateClusterSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateClusterSubnetGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateClusterSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSubnetGroupOutputError>
}

public struct CreateClusterSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterSubnetGroupOutputError>
}

/// <p></p>
public struct CreateClusterSubnetGroupInput: Equatable {
    /// <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase
    ///             string.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain no more than 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not be "Default".</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be unique for all subnet groups that are created by your AWS
    ///                     account.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>examplesubnetgroup</code>
    ///         </p>
    public let clusterSubnetGroupName: String?
    /// <p>A description for the subnet group.</p>
    public let description: String?
    /// <p>An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single
    ///             request.</p>
    public let subnetIds: [String]?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        clusterSubnetGroupName: String? = nil,
        description: String? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.description = description
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension CreateClusterSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateClusterSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupAlreadyExistsFault" : self = .clusterSubnetGroupAlreadyExistsFault(try ClusterSubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupQuotaExceededFault" : self = .clusterSubnetGroupQuotaExceededFault(try ClusterSubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetQuotaExceededFault" : self = .clusterSubnetQuotaExceededFault(try ClusterSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterSubnetGroupOutputError: Equatable {
    case clusterSubnetGroupAlreadyExistsFault(ClusterSubnetGroupAlreadyExistsFault)
    case clusterSubnetGroupQuotaExceededFault(ClusterSubnetGroupQuotaExceededFault)
    case clusterSubnetQuotaExceededFault(ClusterSubnetQuotaExceededFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidSubnet(InvalidSubnet)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterSubnetGroupOutputResponse(clusterSubnetGroup: \(String(describing: clusterSubnetGroup)))"}
}

extension CreateClusterSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClusterSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterSubnetGroup = output.clusterSubnetGroup
        } else {
            self.clusterSubnetGroup = nil
        }
    }
}

public struct CreateClusterSubnetGroupOutputResponse: Equatable {
    /// <p>Describes a subnet group.</p>
    public let clusterSubnetGroup: ClusterSubnetGroup?

    public init (
        clusterSubnetGroup: ClusterSubnetGroup? = nil
    )
    {
        self.clusterSubnetGroup = clusterSubnetGroup
    }
}

struct CreateClusterSubnetGroupOutputResponseBody: Equatable {
    public let clusterSubnetGroup: ClusterSubnetGroup?
}

extension CreateClusterSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterSubnetGroup = "ClusterSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateClusterSubnetGroupResult"))
        let clusterSubnetGroupDecoded = try containerValues.decodeIfPresent(ClusterSubnetGroup.self, forKey: .clusterSubnetGroup)
        clusterSubnetGroup = clusterSubnetGroupDecoded
    }
}

public struct CreateEndpointAccessInputBodyMiddleware: Middleware {
    public let id: String = "CreateEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointAccessInput>
    public typealias MOutput = OperationOutput<CreateEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointAccessOutputError>
}

extension CreateEndpointAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointAccessInput(clusterIdentifier: \(String(describing: clusterIdentifier)), endpointName: \(String(describing: endpointName)), resourceOwner: \(String(describing: resourceOwner)), subnetGroupName: \(String(describing: subnetGroupName)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateEndpointAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: Key("EndpointName"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: Key("ResourceOwner"))
        }
        if let subnetGroupName = subnetGroupName {
            try container.encode(subnetGroupName, forKey: Key("SubnetGroupName"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEndpointAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateEndpointAccessInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointAccessInput>
    public typealias MOutput = OperationOutput<CreateEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointAccessOutputError>
}

public struct CreateEndpointAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointAccessInput>
    public typealias MOutput = OperationOutput<CreateEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointAccessOutputError>
}

public struct CreateEndpointAccessInput: Equatable {
    /// <p>The cluster identifier of the cluster to access.</p>
    public let clusterIdentifier: String?
    /// <p>The Redshift-managed VPC endpoint name.</p>
    ///          <p>An endpoint name must contain 1-30 characters.
    ///           Valid characters are A-Z, a-z, 0-9, and hyphen(-).
    ///           The first character must be a letter.
    ///           The name can't contain two consecutive hyphens or end with a hyphen.</p>
    public let endpointName: String?
    /// <p>The AWS account ID of the owner of the cluster. This is only required if the cluster is in another AWS account.</p>
    public let resourceOwner: String?
    /// <p>The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.</p>
    public let subnetGroupName: String?
    /// <p>The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        clusterIdentifier: String? = nil,
        endpointName: String? = nil,
        resourceOwner: String? = nil,
        subnetGroupName: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.endpointName = endpointName
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateEndpointAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEndpointAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessToClusterDeniedFault" : self = .accessToClusterDeniedFault(try AccessToClusterDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAlreadyExistsFault" : self = .endpointAlreadyExistsFault(try EndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointsPerAuthorizationLimitExceededFault" : self = .endpointsPerAuthorizationLimitExceededFault(try EndpointsPerAuthorizationLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointsPerClusterLimitExceededFault" : self = .endpointsPerClusterLimitExceededFault(try EndpointsPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointAccessOutputError: Equatable {
    case accessToClusterDeniedFault(AccessToClusterDeniedFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case endpointAlreadyExistsFault(EndpointAlreadyExistsFault)
    case endpointsPerAuthorizationLimitExceededFault(EndpointsPerAuthorizationLimitExceededFault)
    case endpointsPerClusterLimitExceededFault(EndpointsPerClusterLimitExceededFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointAccessOutputResponse(address: \(String(describing: address)), clusterIdentifier: \(String(describing: clusterIdentifier)), endpointCreateTime: \(String(describing: endpointCreateTime)), endpointName: \(String(describing: endpointName)), endpointStatus: \(String(describing: endpointStatus)), port: \(String(describing: port)), resourceOwner: \(String(describing: resourceOwner)), subnetGroupName: \(String(describing: subnetGroupName)), vpcEndpoint: \(String(describing: vpcEndpoint)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

extension CreateEndpointAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.address = output.address
            self.clusterIdentifier = output.clusterIdentifier
            self.endpointCreateTime = output.endpointCreateTime
            self.endpointName = output.endpointName
            self.endpointStatus = output.endpointStatus
            self.port = output.port
            self.resourceOwner = output.resourceOwner
            self.subnetGroupName = output.subnetGroupName
            self.vpcEndpoint = output.vpcEndpoint
            self.vpcSecurityGroups = output.vpcSecurityGroups
        } else {
            self.address = nil
            self.clusterIdentifier = nil
            self.endpointCreateTime = nil
            self.endpointName = nil
            self.endpointStatus = nil
            self.port = 0
            self.resourceOwner = nil
            self.subnetGroupName = nil
            self.vpcEndpoint = nil
            self.vpcSecurityGroups = nil
        }
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
public struct CreateEndpointAccessOutputResponse: Equatable {
    /// <p>The DNS address of the endpoint.</p>
    public let address: String?
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    public let clusterIdentifier: String?
    /// <p>The time (UTC) that the endpoint was created.</p>
    public let endpointCreateTime: Date?
    /// <p>The name of the endpoint.</p>
    public let endpointName: String?
    /// <p>The status of the endpoint.</p>
    public let endpointStatus: String?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    public let port: Int
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: String?
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    public let subnetGroupName: String?
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpoint: VpcEndpoint?
    /// <p>The security groups associated with the endpoint.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        address: String? = nil,
        clusterIdentifier: String? = nil,
        endpointCreateTime: Date? = nil,
        endpointName: String? = nil,
        endpointStatus: String? = nil,
        port: Int = 0,
        resourceOwner: String? = nil,
        subnetGroupName: String? = nil,
        vpcEndpoint: VpcEndpoint? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.address = address
        self.clusterIdentifier = clusterIdentifier
        self.endpointCreateTime = endpointCreateTime
        self.endpointName = endpointName
        self.endpointStatus = endpointStatus
        self.port = port
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcEndpoint = vpcEndpoint
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct CreateEndpointAccessOutputResponseBody: Equatable {
    public let clusterIdentifier: String?
    public let resourceOwner: String?
    public let subnetGroupName: String?
    public let endpointStatus: String?
    public let endpointName: String?
    public let endpointCreateTime: Date?
    public let port: Int
    public let address: String?
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?
    public let vpcEndpoint: VpcEndpoint?
}

extension CreateEndpointAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateEndpointAccessResult"))
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), severity: \(String(describing: severity)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIds: \(String(describing: sourceIds)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)), tags: \(String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEventSubscription", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

/// <p></p>
public struct CreateEventSubscriptionInput: Equatable {
    /// <p>A boolean value; set to <code>true</code> to activate the subscription, and set to
    ///                 <code>false</code> to create the subscription but not activate it. </p>
    public let enabled: Bool?
    /// <p>Specifies the Amazon Redshift event categories to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: configuration, management, monitoring, security</p>
    public let eventCategories: [String]?
    /// <p>Specifies the Amazon Redshift event severity to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: ERROR, INFO</p>
    public let severity: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event
    ///             notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to
    ///             it.</p>
    public let snsTopicArn: String?
    /// <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects
    ///             must be of the same type as was specified in the source type parameter. The event
    ///             subscription will return only events generated by the specified objects. If not
    ///             specified, then events are returned for all objects within the source type
    ///             specified.</p>
    ///         <p>Example: my-cluster-1, my-cluster-2</p>
    ///         <p>Example: my-snapshot-20131010</p>
    public let sourceIds: [String]?
    /// <p>The type of source that will be generating the events. For example, if you want to
    ///             be notified of events generated by a cluster, you would set this parameter to cluster.
    ///             If this value is not specified, events are returned for all Amazon Redshift objects in your
    ///             AWS account. You must specify a source type in order to specify source IDs.</p>
    ///         <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
    public let sourceType: String?
    /// <p>The name of the event subscription to be created.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot be null, empty, or blank.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let subscriptionName: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        severity: String? = nil,
        snsTopicArn: String? = nil,
        sourceIds: [String]? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.severity = severity
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

extension CreateEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionAlreadyExistFault" : self = .subscriptionAlreadyExistFault(try SubscriptionAlreadyExistFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionEventIdNotFoundFault" : self = .subscriptionEventIdNotFoundFault(try SubscriptionEventIdNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionSeverityNotFoundFault" : self = .subscriptionSeverityNotFoundFault(try SubscriptionSeverityNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionAlreadyExistFault(SubscriptionAlreadyExistFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionEventIdNotFoundFault(SubscriptionEventIdNotFoundFault)
    case subscriptionSeverityNotFoundFault(SubscriptionSeverityNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct CreateEventSubscriptionOutputResponse: Equatable {
    /// <p>Describes event subscriptions.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct CreateHsmClientCertificateInputBodyMiddleware: Middleware {
    public let id: String = "CreateHsmClientCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmClientCertificateInput>
    public typealias MOutput = OperationOutput<CreateHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmClientCertificateOutputError>
}

extension CreateHsmClientCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmClientCertificateInput(hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), tags: \(String(describing: tags)))"}
}

extension CreateHsmClientCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateHsmClientCertificate", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateHsmClientCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHsmClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmClientCertificateInput>
    public typealias MOutput = OperationOutput<CreateHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmClientCertificateOutputError>
}

public struct CreateHsmClientCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHsmClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmClientCertificateInput>
    public typealias MOutput = OperationOutput<CreateHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmClientCertificateOutputError>
}

/// <p></p>
public struct CreateHsmClientCertificateInput: Equatable {
    /// <p>The identifier to be assigned to the new HSM client certificate that the cluster
    ///             will use to connect to the HSM to use the database encryption keys.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        hsmClientCertificateIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.tags = tags
    }
}

extension CreateHsmClientCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateHsmClientCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HsmClientCertificateAlreadyExistsFault" : self = .hsmClientCertificateAlreadyExistsFault(try HsmClientCertificateAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateQuotaExceededFault" : self = .hsmClientCertificateQuotaExceededFault(try HsmClientCertificateQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHsmClientCertificateOutputError: Equatable {
    case hsmClientCertificateAlreadyExistsFault(HsmClientCertificateAlreadyExistsFault)
    case hsmClientCertificateQuotaExceededFault(HsmClientCertificateQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmClientCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmClientCertificateOutputResponse(hsmClientCertificate: \(String(describing: hsmClientCertificate)))"}
}

extension CreateHsmClientCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHsmClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hsmClientCertificate = output.hsmClientCertificate
        } else {
            self.hsmClientCertificate = nil
        }
    }
}

public struct CreateHsmClientCertificateOutputResponse: Equatable {
    /// <p>Returns information about an HSM client certificate. The certificate is stored in a
    ///             secure Hardware Storage Module (HSM), and used by the Amazon Redshift cluster to encrypt data
    ///             files.</p>
    public let hsmClientCertificate: HsmClientCertificate?

    public init (
        hsmClientCertificate: HsmClientCertificate? = nil
    )
    {
        self.hsmClientCertificate = hsmClientCertificate
    }
}

struct CreateHsmClientCertificateOutputResponseBody: Equatable {
    public let hsmClientCertificate: HsmClientCertificate?
}

extension CreateHsmClientCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmClientCertificate = "HsmClientCertificate"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateHsmClientCertificateResult"))
        let hsmClientCertificateDecoded = try containerValues.decodeIfPresent(HsmClientCertificate.self, forKey: .hsmClientCertificate)
        hsmClientCertificate = hsmClientCertificateDecoded
    }
}

public struct CreateHsmConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateHsmConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmConfigurationInput>
    public typealias MOutput = OperationOutput<CreateHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmConfigurationOutputError>
}

extension CreateHsmConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmConfigurationInput(description: \(String(describing: description)), hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), hsmIpAddress: \(String(describing: hsmIpAddress)), hsmPartitionName: \(String(describing: hsmPartitionName)), hsmPartitionPassword: \(String(describing: hsmPartitionPassword)), hsmServerPublicCertificate: \(String(describing: hsmServerPublicCertificate)), tags: \(String(describing: tags)))"}
}

extension CreateHsmConfigurationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        if let hsmIpAddress = hsmIpAddress {
            try container.encode(hsmIpAddress, forKey: Key("HsmIpAddress"))
        }
        if let hsmPartitionName = hsmPartitionName {
            try container.encode(hsmPartitionName, forKey: Key("HsmPartitionName"))
        }
        if let hsmPartitionPassword = hsmPartitionPassword {
            try container.encode(hsmPartitionPassword, forKey: Key("HsmPartitionPassword"))
        }
        if let hsmServerPublicCertificate = hsmServerPublicCertificate {
            try container.encode(hsmServerPublicCertificate, forKey: Key("HsmServerPublicCertificate"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateHsmConfiguration", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateHsmConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHsmConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmConfigurationInput>
    public typealias MOutput = OperationOutput<CreateHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmConfigurationOutputError>
}

public struct CreateHsmConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHsmConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmConfigurationInput>
    public typealias MOutput = OperationOutput<CreateHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmConfigurationOutputError>
}

/// <p></p>
public struct CreateHsmConfigurationInput: Equatable {
    /// <p>A text description of the HSM configuration to be created.</p>
    public let description: String?
    /// <p>The identifier to be assigned to the new Amazon Redshift HSM configuration.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
    public let hsmIpAddress: String?
    /// <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
    ///             database encryption keys.</p>
    public let hsmPartitionName: String?
    /// <p>The password required to access the HSM partition.</p>
    public let hsmPartitionPassword: String?
    /// <p>The HSMs public certificate file. When using Cloud HSM, the file name is
    ///             server.pem.</p>
    public let hsmServerPublicCertificate: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        hsmConfigurationIdentifier: String? = nil,
        hsmIpAddress: String? = nil,
        hsmPartitionName: String? = nil,
        hsmPartitionPassword: String? = nil,
        hsmServerPublicCertificate: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.hsmIpAddress = hsmIpAddress
        self.hsmPartitionName = hsmPartitionName
        self.hsmPartitionPassword = hsmPartitionPassword
        self.hsmServerPublicCertificate = hsmServerPublicCertificate
        self.tags = tags
    }
}

extension CreateHsmConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateHsmConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HsmConfigurationAlreadyExistsFault" : self = .hsmConfigurationAlreadyExistsFault(try HsmConfigurationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationQuotaExceededFault" : self = .hsmConfigurationQuotaExceededFault(try HsmConfigurationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHsmConfigurationOutputError: Equatable {
    case hsmConfigurationAlreadyExistsFault(HsmConfigurationAlreadyExistsFault)
    case hsmConfigurationQuotaExceededFault(HsmConfigurationQuotaExceededFault)
    case invalidTagFault(InvalidTagFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmConfigurationOutputResponse(hsmConfiguration: \(String(describing: hsmConfiguration)))"}
}

extension CreateHsmConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHsmConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hsmConfiguration = output.hsmConfiguration
        } else {
            self.hsmConfiguration = nil
        }
    }
}

public struct CreateHsmConfigurationOutputResponse: Equatable {
    /// <p>Returns information about an HSM configuration, which is an object that describes
    ///             to Amazon Redshift clusters the information they require to connect to an HSM where they can
    ///             store database encryption keys.</p>
    public let hsmConfiguration: HsmConfiguration?

    public init (
        hsmConfiguration: HsmConfiguration? = nil
    )
    {
        self.hsmConfiguration = hsmConfiguration
    }
}

struct CreateHsmConfigurationOutputResponseBody: Equatable {
    public let hsmConfiguration: HsmConfiguration?
}

extension CreateHsmConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmConfiguration = "HsmConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateHsmConfigurationResult"))
        let hsmConfigurationDecoded = try containerValues.decodeIfPresent(HsmConfiguration.self, forKey: .hsmConfiguration)
        hsmConfiguration = hsmConfigurationDecoded
    }
}

public struct CreateScheduledActionInputBodyMiddleware: Middleware {
    public let id: String = "CreateScheduledActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduledActionInput>
    public typealias MOutput = OperationOutput<CreateScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduledActionOutputError>
}

extension CreateScheduledActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScheduledActionInput(enable: \(String(describing: enable)), endTime: \(String(describing: endTime)), iamRole: \(String(describing: iamRole)), schedule: \(String(describing: schedule)), scheduledActionDescription: \(String(describing: scheduledActionDescription)), scheduledActionName: \(String(describing: scheduledActionName)), startTime: \(String(describing: startTime)), targetAction: \(String(describing: targetAction)))"}
}

extension CreateScheduledActionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enable = enable {
            try container.encode(enable, forKey: Key("Enable"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let iamRole = iamRole {
            try container.encode(iamRole, forKey: Key("IamRole"))
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: Key("Schedule"))
        }
        if let scheduledActionDescription = scheduledActionDescription {
            try container.encode(scheduledActionDescription, forKey: Key("ScheduledActionDescription"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let targetAction = targetAction {
            try container.encode(targetAction, forKey: Key("TargetAction"))
        }
        try container.encode("CreateScheduledAction", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateScheduledActionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateScheduledActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduledActionInput>
    public typealias MOutput = OperationOutput<CreateScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduledActionOutputError>
}

public struct CreateScheduledActionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateScheduledActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduledActionInput>
    public typealias MOutput = OperationOutput<CreateScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduledActionOutputError>
}

public struct CreateScheduledActionInput: Equatable {
    /// <p>If true, the schedule is enabled. If false, the scheduled action does not trigger.
    ///             For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. </p>
    public let enable: Bool?
    /// <p>The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let endTime: Date?
    /// <p>The IAM role to assume to run the target action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let iamRole: String?
    /// <p>The schedule in <code>at( )</code> or <code>cron( )</code> format.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let schedule: String?
    /// <p>The description of the scheduled action.
    ///             </p>
    public let scheduledActionDescription: String?
    /// <p>The name of the scheduled action. The name must be unique within an account.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let scheduledActionName: String?
    /// <p>The start time in UTC of the scheduled action.
    ///             Before this time, the scheduled action does not trigger.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let startTime: Date?
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let targetAction: ScheduledActionType?

    public init (
        enable: Bool? = nil,
        endTime: Date? = nil,
        iamRole: String? = nil,
        schedule: String? = nil,
        scheduledActionDescription: String? = nil,
        scheduledActionName: String? = nil,
        startTime: Date? = nil,
        targetAction: ScheduledActionType? = nil
    )
    {
        self.enable = enable
        self.endTime = endTime
        self.iamRole = iamRole
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

extension CreateScheduledActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateScheduledActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidScheduledActionFault" : self = .invalidScheduledActionFault(try InvalidScheduledActionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionAlreadyExistsFault" : self = .scheduledActionAlreadyExistsFault(try ScheduledActionAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionQuotaExceededFault" : self = .scheduledActionQuotaExceededFault(try ScheduledActionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionTypeUnsupportedFault" : self = .scheduledActionTypeUnsupportedFault(try ScheduledActionTypeUnsupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateScheduledActionOutputError: Equatable {
    case invalidScheduledActionFault(InvalidScheduledActionFault)
    case invalidScheduleFault(InvalidScheduleFault)
    case scheduledActionAlreadyExistsFault(ScheduledActionAlreadyExistsFault)
    case scheduledActionQuotaExceededFault(ScheduledActionQuotaExceededFault)
    case scheduledActionTypeUnsupportedFault(ScheduledActionTypeUnsupportedFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScheduledActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScheduledActionOutputResponse(endTime: \(String(describing: endTime)), iamRole: \(String(describing: iamRole)), nextInvocations: \(String(describing: nextInvocations)), schedule: \(String(describing: schedule)), scheduledActionDescription: \(String(describing: scheduledActionDescription)), scheduledActionName: \(String(describing: scheduledActionName)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), targetAction: \(String(describing: targetAction)))"}
}

extension CreateScheduledActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateScheduledActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.iamRole = output.iamRole
            self.nextInvocations = output.nextInvocations
            self.schedule = output.schedule
            self.scheduledActionDescription = output.scheduledActionDescription
            self.scheduledActionName = output.scheduledActionName
            self.startTime = output.startTime
            self.state = output.state
            self.targetAction = output.targetAction
        } else {
            self.endTime = nil
            self.iamRole = nil
            self.nextInvocations = nil
            self.schedule = nil
            self.scheduledActionDescription = nil
            self.scheduledActionName = nil
            self.startTime = nil
            self.state = nil
            self.targetAction = nil
        }
    }
}

/// <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
///             For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
public struct CreateScheduledActionOutputResponse: Equatable {
    /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
    public let endTime: Date?
    /// <p>The IAM role to assume to run the scheduled action.
    ///             This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
    ///             This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
    ///
    /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public let iamRole: String?
    /// <p>List of times when the scheduled action will run. </p>
    public let nextInvocations: [Date]?
    /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
    ///             Schedule invocations must be separated by at least one hour.</p>
    ///         <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
    ///         <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
    ///             For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
    ///             in the <i>Amazon CloudWatch Events User Guide</i>.</p>
    public let schedule: String?
    /// <p>The description of the scheduled action. </p>
    public let scheduledActionDescription: String?
    /// <p>The name of the scheduled action. </p>
    public let scheduledActionName: String?
    /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
    public let startTime: Date?
    /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
    public let state: ScheduledActionState?
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
    ///         <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
    public let targetAction: ScheduledActionType?

    public init (
        endTime: Date? = nil,
        iamRole: String? = nil,
        nextInvocations: [Date]? = nil,
        schedule: String? = nil,
        scheduledActionDescription: String? = nil,
        scheduledActionName: String? = nil,
        startTime: Date? = nil,
        state: ScheduledActionState? = nil,
        targetAction: ScheduledActionType? = nil
    )
    {
        self.endTime = endTime
        self.iamRole = iamRole
        self.nextInvocations = nextInvocations
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.state = state
        self.targetAction = targetAction
    }
}

struct CreateScheduledActionOutputResponseBody: Equatable {
    public let scheduledActionName: String?
    public let targetAction: ScheduledActionType?
    public let schedule: String?
    public let iamRole: String?
    public let scheduledActionDescription: String?
    public let state: ScheduledActionState?
    public let nextInvocations: [Date]?
    public let startTime: Date?
    public let endTime: Date?
}

extension CreateScheduledActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateScheduledActionResult"))
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        var startTimeBuffer:Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        var endTimeBuffer:Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}

public struct CreateSnapshotCopyGrantInputBodyMiddleware: Middleware {
    public let id: String = "CreateSnapshotCopyGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotCopyGrantInput>
    public typealias MOutput = OperationOutput<CreateSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotCopyGrantOutputError>
}

extension CreateSnapshotCopyGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotCopyGrantInput(kmsKeyId: \(String(describing: kmsKeyId)), snapshotCopyGrantName: \(String(describing: snapshotCopyGrantName)), tags: \(String(describing: tags)))"}
}

extension CreateSnapshotCopyGrantInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: Key("SnapshotCopyGrantName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateSnapshotCopyGrant", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateSnapshotCopyGrantInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSnapshotCopyGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotCopyGrantInput>
    public typealias MOutput = OperationOutput<CreateSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotCopyGrantOutputError>
}

public struct CreateSnapshotCopyGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSnapshotCopyGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotCopyGrantInput>
    public typealias MOutput = OperationOutput<CreateSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotCopyGrantOutputError>
}

/// <p>The result of the <code>CreateSnapshotCopyGrant</code> action.</p>
public struct CreateSnapshotCopyGrantInput: Equatable {
    /// <p>The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift
    ///             permission. If no key is specified, the default key is used.</p>
    public let kmsKeyId: String?
    /// <p>The name of the snapshot copy grant. This name must be unique in the region for the
    ///             AWS account.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    public let snapshotCopyGrantName: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        kmsKeyId: String? = nil,
        snapshotCopyGrantName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.snapshotCopyGrantName = snapshotCopyGrantName
        self.tags = tags
    }
}

extension CreateSnapshotCopyGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSnapshotCopyGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantAlreadyExistsFault" : self = .snapshotCopyGrantAlreadyExistsFault(try SnapshotCopyGrantAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantQuotaExceededFault" : self = .snapshotCopyGrantQuotaExceededFault(try SnapshotCopyGrantQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotCopyGrantOutputError: Equatable {
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidTagFault(InvalidTagFault)
    case limitExceededFault(LimitExceededFault)
    case snapshotCopyGrantAlreadyExistsFault(SnapshotCopyGrantAlreadyExistsFault)
    case snapshotCopyGrantQuotaExceededFault(SnapshotCopyGrantQuotaExceededFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotCopyGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotCopyGrantOutputResponse(snapshotCopyGrant: \(String(describing: snapshotCopyGrant)))"}
}

extension CreateSnapshotCopyGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSnapshotCopyGrantOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshotCopyGrant = output.snapshotCopyGrant
        } else {
            self.snapshotCopyGrant = nil
        }
    }
}

public struct CreateSnapshotCopyGrantOutputResponse: Equatable {
    /// <p>The snapshot copy grant that grants Amazon Redshift permission to encrypt copied
    ///             snapshots with the specified customer master key (CMK) from AWS KMS in the destination
    ///             region.</p>
    ///         <p>
    /// For more information about managing snapshot copy grants, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public let snapshotCopyGrant: SnapshotCopyGrant?

    public init (
        snapshotCopyGrant: SnapshotCopyGrant? = nil
    )
    {
        self.snapshotCopyGrant = snapshotCopyGrant
    }
}

struct CreateSnapshotCopyGrantOutputResponseBody: Equatable {
    public let snapshotCopyGrant: SnapshotCopyGrant?
}

extension CreateSnapshotCopyGrantOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotCopyGrant = "SnapshotCopyGrant"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateSnapshotCopyGrantResult"))
        let snapshotCopyGrantDecoded = try containerValues.decodeIfPresent(SnapshotCopyGrant.self, forKey: .snapshotCopyGrant)
        snapshotCopyGrant = snapshotCopyGrantDecoded
    }
}

public struct CreateSnapshotScheduleInputBodyMiddleware: Middleware {
    public let id: String = "CreateSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<CreateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotScheduleOutputError>
}

extension CreateSnapshotScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotScheduleInput(dryRun: \(String(describing: dryRun)), nextInvocations: \(String(describing: nextInvocations)), scheduleDefinitions: \(String(describing: scheduleDefinitions)), scheduleDescription: \(String(describing: scheduleDescription)), scheduleIdentifier: \(String(describing: scheduleIdentifier)), tags: \(String(describing: tags)))"}
}

extension CreateSnapshotScheduleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dryRun = dryRun {
            try container.encode(dryRun, forKey: Key("DryRun"))
        }
        if let nextInvocations = nextInvocations {
            try container.encode(nextInvocations, forKey: Key("NextInvocations"))
        }
        if let scheduleDefinitions = scheduleDefinitions {
            var scheduleDefinitionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ScheduleDefinitions"))
            for (index0, string0) in scheduleDefinitions.enumerated() {
                try scheduleDefinitionsContainer.encode(string0, forKey: Key("ScheduleDefinition.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleDescription = scheduleDescription {
            try container.encode(scheduleDescription, forKey: Key("ScheduleDescription"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: Key("ScheduleIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateSnapshotSchedule", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateSnapshotScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<CreateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotScheduleOutputError>
}

public struct CreateSnapshotScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<CreateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotScheduleOutputError>
}

public struct CreateSnapshotScheduleInput: Equatable {
    /// <p></p>
    public let dryRun: Bool?
    /// <p></p>
    public let nextInvocations: Int?
    /// <p>The definition of the snapshot schedule. The definition is made up of schedule
    ///             expressions, for example "cron(30 12 *)" or "rate(12 hours)". </p>
    public let scheduleDefinitions: [String]?
    /// <p>The description of the snapshot schedule.</p>
    public let scheduleDescription: String?
    /// <p>A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed
    ///             for the identifier.</p>
    public let scheduleIdentifier: String?
    /// <p>An optional set of tags you can use to search for the schedule.</p>
    public let tags: [Tag]?

    public init (
        dryRun: Bool? = nil,
        nextInvocations: Int? = nil,
        scheduleDefinitions: [String]? = nil,
        scheduleDescription: String? = nil,
        scheduleIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dryRun = dryRun
        self.nextInvocations = nextInvocations
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleDescription = scheduleDescription
        self.scheduleIdentifier = scheduleIdentifier
        self.tags = tags
    }
}

extension CreateSnapshotScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSnapshotScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduleDefinitionTypeUnsupportedFault" : self = .scheduleDefinitionTypeUnsupportedFault(try ScheduleDefinitionTypeUnsupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleAlreadyExistsFault" : self = .snapshotScheduleAlreadyExistsFault(try SnapshotScheduleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleQuotaExceededFault" : self = .snapshotScheduleQuotaExceededFault(try SnapshotScheduleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotScheduleOutputError: Equatable {
    case invalidScheduleFault(InvalidScheduleFault)
    case invalidTagFault(InvalidTagFault)
    case scheduleDefinitionTypeUnsupportedFault(ScheduleDefinitionTypeUnsupportedFault)
    case snapshotScheduleAlreadyExistsFault(SnapshotScheduleAlreadyExistsFault)
    case snapshotScheduleQuotaExceededFault(SnapshotScheduleQuotaExceededFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotScheduleOutputResponse(associatedClusterCount: \(String(describing: associatedClusterCount)), associatedClusters: \(String(describing: associatedClusters)), nextInvocations: \(String(describing: nextInvocations)), scheduleDefinitions: \(String(describing: scheduleDefinitions)), scheduleDescription: \(String(describing: scheduleDescription)), scheduleIdentifier: \(String(describing: scheduleIdentifier)), tags: \(String(describing: tags)))"}
}

extension CreateSnapshotScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associatedClusterCount = output.associatedClusterCount
            self.associatedClusters = output.associatedClusters
            self.nextInvocations = output.nextInvocations
            self.scheduleDefinitions = output.scheduleDefinitions
            self.scheduleDescription = output.scheduleDescription
            self.scheduleIdentifier = output.scheduleIdentifier
            self.tags = output.tags
        } else {
            self.associatedClusterCount = nil
            self.associatedClusters = nil
            self.nextInvocations = nil
            self.scheduleDefinitions = nil
            self.scheduleDescription = nil
            self.scheduleIdentifier = nil
            self.tags = nil
        }
    }
}

/// <p>Describes a snapshot schedule. You can set a regular interval for creating
///             snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
public struct CreateSnapshotScheduleOutputResponse: Equatable {
    /// <p>The number of clusters associated with the schedule.</p>
    public let associatedClusterCount: Int?
    /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
    public let associatedClusters: [ClusterAssociatedToSchedule]?
    /// <p></p>
    public let nextInvocations: [Date]?
    /// <p>A list of ScheduleDefinitions.</p>
    public let scheduleDefinitions: [String]?
    /// <p>The description of the schedule.</p>
    public let scheduleDescription: String?
    /// <p>A unique identifier for the schedule.</p>
    public let scheduleIdentifier: String?
    /// <p>An optional set of tags describing the schedule.</p>
    public let tags: [Tag]?

    public init (
        associatedClusterCount: Int? = nil,
        associatedClusters: [ClusterAssociatedToSchedule]? = nil,
        nextInvocations: [Date]? = nil,
        scheduleDefinitions: [String]? = nil,
        scheduleDescription: String? = nil,
        scheduleIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.associatedClusterCount = associatedClusterCount
        self.associatedClusters = associatedClusters
        self.nextInvocations = nextInvocations
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleDescription = scheduleDescription
        self.scheduleIdentifier = scheduleIdentifier
        self.tags = tags
    }
}

struct CreateSnapshotScheduleOutputResponseBody: Equatable {
    public let scheduleDefinitions: [String]?
    public let scheduleIdentifier: String?
    public let scheduleDescription: String?
    public let tags: [Tag]?
    public let nextInvocations: [Date]?
    public let associatedClusterCount: Int?
    public let associatedClusters: [ClusterAssociatedToSchedule]?
}

extension CreateSnapshotScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedClusterCount = "AssociatedClusterCount"
        case associatedClusters = "AssociatedClusters"
        case nextInvocations = "NextInvocations"
        case scheduleDefinitions = "ScheduleDefinitions"
        case scheduleDescription = "ScheduleDescription"
        case scheduleIdentifier = "ScheduleIdentifier"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateSnapshotScheduleResult"))
        if containerValues.contains(.scheduleDefinitions) {
            struct KeyVal0{struct ScheduleDefinition{}}
            let scheduleDefinitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduleDefinition>.CodingKeys.self, forKey: .scheduleDefinitions)
            if let scheduleDefinitionsWrappedContainer = scheduleDefinitionsWrappedContainer {
                let scheduleDefinitionsContainer = try scheduleDefinitionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var scheduleDefinitionsBuffer:[String]? = nil
                if let scheduleDefinitionsContainer = scheduleDefinitionsContainer {
                    scheduleDefinitionsBuffer = [String]()
                    for stringContainer0 in scheduleDefinitionsContainer {
                        scheduleDefinitionsBuffer?.append(stringContainer0)
                    }
                }
                scheduleDefinitions = scheduleDefinitionsBuffer
            } else {
                scheduleDefinitions = []
            }
        } else {
            scheduleDefinitions = nil
        }
        let scheduleIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleIdentifier)
        scheduleIdentifier = scheduleIdentifierDecoded
        let scheduleDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleDescription)
        scheduleDescription = scheduleDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct SnapshotTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let associatedClusterCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .associatedClusterCount)
        associatedClusterCount = associatedClusterCountDecoded
        if containerValues.contains(.associatedClusters) {
            struct KeyVal0{struct ClusterAssociatedToSchedule{}}
            let associatedClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterAssociatedToSchedule>.CodingKeys.self, forKey: .associatedClusters)
            if let associatedClustersWrappedContainer = associatedClustersWrappedContainer {
                let associatedClustersContainer = try associatedClustersWrappedContainer.decodeIfPresent([ClusterAssociatedToSchedule].self, forKey: .member)
                var associatedClustersBuffer:[ClusterAssociatedToSchedule]? = nil
                if let associatedClustersContainer = associatedClustersContainer {
                    associatedClustersBuffer = [ClusterAssociatedToSchedule]()
                    for structureContainer0 in associatedClustersContainer {
                        associatedClustersBuffer?.append(structureContainer0)
                    }
                }
                associatedClusters = associatedClustersBuffer
            } else {
                associatedClusters = []
            }
        } else {
            associatedClusters = nil
        }
    }
}

public struct CreateTagsInputBodyMiddleware: Middleware {
    public let id: String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsInput(resourceName: \(String(describing: resourceName)), tags: \(String(describing: tags)))"}
}

extension CreateTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateTags", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateTagsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

/// <p>Contains the output from the <code>CreateTags</code> action. </p>
public struct CreateTagsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) to which you want to add the tag or tags. For
    ///             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
    public let resourceName: String?
    /// <p>One or more name/value pairs to add as tags to the specified resource. Each tag
    ///             name is passed in with the parameter <code>Key</code> and the corresponding value is
    ///             passed in with the parameter <code>Value</code>. The <code>Key</code> and
    ///                 <code>Value</code> parameters are separated by a comma (,). Separate multiple tags
    ///             with a space. For example, <code>--tags "Key"="owner","Value"="admin"
    ///                 "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. </p>
    public let tags: [Tag]?

    public init (
        resourceName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

extension CreateTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Equatable {
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidTagFault(InvalidTagFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Equatable {
}

extension CreateTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateUsageLimitInputBodyMiddleware: Middleware {
    public let id: String = "CreateUsageLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsageLimitInput>
    public typealias MOutput = OperationOutput<CreateUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsageLimitOutputError>
}

extension CreateUsageLimitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsageLimitInput(amount: \(String(describing: amount)), breachAction: \(String(describing: breachAction)), clusterIdentifier: \(String(describing: clusterIdentifier)), featureType: \(String(describing: featureType)), limitType: \(String(describing: limitType)), period: \(String(describing: period)), tags: \(String(describing: tags)))"}
}

extension CreateUsageLimitInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if amount != 0 {
            try container.encode(amount, forKey: Key("Amount"))
        }
        if let breachAction = breachAction {
            try container.encode(breachAction, forKey: Key("BreachAction"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let featureType = featureType {
            try container.encode(featureType, forKey: Key("FeatureType"))
        }
        if let limitType = limitType {
            try container.encode(limitType, forKey: Key("LimitType"))
        }
        if let period = period {
            try container.encode(period, forKey: Key("Period"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateUsageLimit", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct CreateUsageLimitInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUsageLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsageLimitInput>
    public typealias MOutput = OperationOutput<CreateUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsageLimitOutputError>
}

public struct CreateUsageLimitInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUsageLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsageLimitInput>
    public typealias MOutput = OperationOutput<CreateUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsageLimitOutputError>
}

public struct CreateUsageLimitInput: Equatable {
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).
    ///             The value must be a positive number.
    ///             </p>
    public let amount: Int
    /// <p>The action that Amazon Redshift takes when the limit is reached. The default is log.
    ///             For more information about this parameter, see <a>UsageLimit</a>.</p>
    public let breachAction: UsageLimitBreachAction?
    /// <p>The identifier of the cluster that you want to limit usage.</p>
    public let clusterIdentifier: String?
    /// <p>The Amazon Redshift feature that you want to limit.</p>
    public let featureType: UsageLimitFeatureType?
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.
    ///             If <code>FeatureType</code> is <code>spectrum</code>, then <code>LimitType</code> must be <code>data-scanned</code>.
    ///             If <code>FeatureType</code> is <code>concurrency-scaling</code>, then <code>LimitType</code> must be <code>time</code>.
    ///            </p>
    public let limitType: UsageLimitLimitType?
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>.
    ///             </p>
    public let period: UsageLimitPeriod?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        amount: Int = 0,
        breachAction: UsageLimitBreachAction? = nil,
        clusterIdentifier: String? = nil,
        featureType: UsageLimitFeatureType? = nil,
        limitType: UsageLimitLimitType? = nil,
        period: UsageLimitPeriod? = nil,
        tags: [Tag]? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.limitType = limitType
        self.period = period
        self.tags = tags
    }
}

extension CreateUsageLimitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateUsageLimitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageLimitFault" : self = .invalidUsageLimitFault(try InvalidUsageLimitFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsageLimitAlreadyExistsFault" : self = .usageLimitAlreadyExistsFault(try UsageLimitAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsageLimitOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidUsageLimitFault(InvalidUsageLimitFault)
    case limitExceededFault(LimitExceededFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case usageLimitAlreadyExistsFault(UsageLimitAlreadyExistsFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsageLimitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsageLimitOutputResponse(amount: \(String(describing: amount)), breachAction: \(String(describing: breachAction)), clusterIdentifier: \(String(describing: clusterIdentifier)), featureType: \(String(describing: featureType)), limitType: \(String(describing: limitType)), period: \(String(describing: period)), tags: \(String(describing: tags)), usageLimitId: \(String(describing: usageLimitId)))"}
}

extension CreateUsageLimitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUsageLimitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.amount = output.amount
            self.breachAction = output.breachAction
            self.clusterIdentifier = output.clusterIdentifier
            self.featureType = output.featureType
            self.limitType = output.limitType
            self.period = output.period
            self.tags = output.tags
            self.usageLimitId = output.usageLimitId
        } else {
            self.amount = 0
            self.breachAction = nil
            self.clusterIdentifier = nil
            self.featureType = nil
            self.limitType = nil
            self.period = nil
            self.tags = nil
            self.usageLimitId = nil
        }
    }
}

/// <p>Describes a usage limit object for a cluster. </p>
public struct CreateUsageLimitOutputResponse: Equatable {
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
    public let amount: Int
    /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>log</b> - To log an event in a system table. The default is log.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>emit-metric</b> - To emit CloudWatch metrics.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>disable</b> - To disable the feature until the next usage period begins.</p>
    ///             </li>
    ///          </ul>
    public let breachAction: UsageLimitBreachAction?
    /// <p>The identifier of the cluster with a usage limit.</p>
    public let clusterIdentifier: String?
    /// <p>The Amazon Redshift feature to which the limit applies.</p>
    public let featureType: UsageLimitFeatureType?
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
    public let limitType: UsageLimitLimitType?
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
    public let period: UsageLimitPeriod?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?
    /// <p>The identifier of the usage limit.</p>
    public let usageLimitId: String?

    public init (
        amount: Int = 0,
        breachAction: UsageLimitBreachAction? = nil,
        clusterIdentifier: String? = nil,
        featureType: UsageLimitFeatureType? = nil,
        limitType: UsageLimitLimitType? = nil,
        period: UsageLimitPeriod? = nil,
        tags: [Tag]? = nil,
        usageLimitId: String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.limitType = limitType
        self.period = period
        self.tags = tags
        self.usageLimitId = usageLimitId
    }
}

struct CreateUsageLimitOutputResponseBody: Equatable {
    public let usageLimitId: String?
    public let clusterIdentifier: String?
    public let featureType: UsageLimitFeatureType?
    public let limitType: UsageLimitLimitType?
    public let amount: Int
    public let period: UsageLimitPeriod?
    public let breachAction: UsageLimitBreachAction?
    public let tags: [Tag]?
}

extension CreateUsageLimitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case amount = "Amount"
        case breachAction = "BreachAction"
        case clusterIdentifier = "ClusterIdentifier"
        case featureType = "FeatureType"
        case limitType = "LimitType"
        case period = "Period"
        case tags = "Tags"
        case usageLimitId = "UsageLimitId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateUsageLimitResult"))
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let featureTypeDecoded = try containerValues.decodeIfPresent(UsageLimitFeatureType.self, forKey: .featureType)
        featureType = featureTypeDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(UsageLimitLimitType.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let amountDecoded = try containerValues.decode(Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension DataTransferProgress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentRateInMegaBytesPerSecond = "CurrentRateInMegaBytesPerSecond"
        case dataTransferredInMegaBytes = "DataTransferredInMegaBytes"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case status = "Status"
        case totalDataInMegaBytes = "TotalDataInMegaBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let currentRateInMegaBytesPerSecond = currentRateInMegaBytesPerSecond {
            try container.encode(currentRateInMegaBytesPerSecond, forKey: Key("CurrentRateInMegaBytesPerSecond"))
        }
        if dataTransferredInMegaBytes != 0 {
            try container.encode(dataTransferredInMegaBytes, forKey: Key("DataTransferredInMegaBytes"))
        }
        if let elapsedTimeInSeconds = elapsedTimeInSeconds {
            try container.encode(elapsedTimeInSeconds, forKey: Key("ElapsedTimeInSeconds"))
        }
        if let estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds {
            try container.encode(estimatedTimeToCompletionInSeconds, forKey: Key("EstimatedTimeToCompletionInSeconds"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if totalDataInMegaBytes != 0 {
            try container.encode(totalDataInMegaBytes, forKey: Key("TotalDataInMegaBytes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let currentRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .currentRateInMegaBytesPerSecond)
        currentRateInMegaBytesPerSecond = currentRateInMegaBytesPerSecondDecoded
        let totalDataInMegaBytesDecoded = try containerValues.decode(Int.self, forKey: .totalDataInMegaBytes)
        totalDataInMegaBytes = totalDataInMegaBytesDecoded
        let dataTransferredInMegaBytesDecoded = try containerValues.decode(Int.self, forKey: .dataTransferredInMegaBytes)
        dataTransferredInMegaBytes = dataTransferredInMegaBytesDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
    }
}

extension DataTransferProgress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataTransferProgress(currentRateInMegaBytesPerSecond: \(String(describing: currentRateInMegaBytesPerSecond)), dataTransferredInMegaBytes: \(String(describing: dataTransferredInMegaBytes)), elapsedTimeInSeconds: \(String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(String(describing: estimatedTimeToCompletionInSeconds)), status: \(String(describing: status)), totalDataInMegaBytes: \(String(describing: totalDataInMegaBytes)))"}
}

/// <p>Describes the status of a cluster while it is in the process of resizing with an
///             incremental resize.</p>
public struct DataTransferProgress: Equatable {
    /// <p>Describes the data transfer rate in MB's per second.</p>
    public let currentRateInMegaBytesPerSecond: Double?
    /// <p>Describes the total amount of data that has been transfered in MB's.</p>
    public let dataTransferredInMegaBytes: Int
    /// <p>Describes the number of seconds that have elapsed during the data transfer.</p>
    public let elapsedTimeInSeconds: Int?
    /// <p>Describes the estimated number of seconds remaining to complete the transfer.</p>
    public let estimatedTimeToCompletionInSeconds: Int?
    /// <p>Describes the status of the cluster. While the transfer is in progress the status is
    ///                 <code>transferringdata</code>.</p>
    public let status: String?
    /// <p>Describes the total amount of data to be transfered in megabytes.</p>
    public let totalDataInMegaBytes: Int

    public init (
        currentRateInMegaBytesPerSecond: Double? = nil,
        dataTransferredInMegaBytes: Int = 0,
        elapsedTimeInSeconds: Int? = nil,
        estimatedTimeToCompletionInSeconds: Int? = nil,
        status: String? = nil,
        totalDataInMegaBytes: Int = 0
    )
    {
        self.currentRateInMegaBytesPerSecond = currentRateInMegaBytesPerSecond
        self.dataTransferredInMegaBytes = dataTransferredInMegaBytes
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
        self.status = status
        self.totalDataInMegaBytes = totalDataInMegaBytes
    }
}

extension DefaultClusterParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case parameterGroupFamily = "ParameterGroupFamily"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: Key("ParameterGroupFamily"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupFamily)
        parameterGroupFamily = parameterGroupFamilyDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension DefaultClusterParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultClusterParameters(marker: \(String(describing: marker)), parameterGroupFamily: \(String(describing: parameterGroupFamily)), parameters: \(String(describing: parameters)))"}
}

/// <p>Describes the default cluster parameters for a parameter group family.</p>
public struct DefaultClusterParameters: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>The name of the cluster parameter group family to which the engine default
    ///             parameters apply.</p>
    public let parameterGroupFamily: String?
    /// <p>The list of cluster default parameters.</p>
    public let parameters: [Parameter]?

    public init (
        marker: String? = nil,
        parameterGroupFamily: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameterGroupFamily = parameterGroupFamily
        self.parameters = parameters
    }
}

extension DeferredMaintenanceWindow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deferMaintenanceEndTime = "DeferMaintenanceEndTime"
        case deferMaintenanceIdentifier = "DeferMaintenanceIdentifier"
        case deferMaintenanceStartTime = "DeferMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deferMaintenanceEndTime = deferMaintenanceEndTime {
            try container.encode(TimestampWrapper(deferMaintenanceEndTime, format: .dateTime), forKey: Key("deferMaintenanceEndTime"))
        }
        if let deferMaintenanceIdentifier = deferMaintenanceIdentifier {
            try container.encode(deferMaintenanceIdentifier, forKey: Key("DeferMaintenanceIdentifier"))
        }
        if let deferMaintenanceStartTime = deferMaintenanceStartTime {
            try container.encode(TimestampWrapper(deferMaintenanceStartTime, format: .dateTime), forKey: Key("deferMaintenanceStartTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deferMaintenanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deferMaintenanceIdentifier)
        deferMaintenanceIdentifier = deferMaintenanceIdentifierDecoded
        let deferMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deferMaintenanceStartTime)
        var deferMaintenanceStartTimeBuffer:Date? = nil
        if let deferMaintenanceStartTimeDecoded = deferMaintenanceStartTimeDecoded {
            deferMaintenanceStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(deferMaintenanceStartTimeDecoded, format: .dateTime)
        }
        deferMaintenanceStartTime = deferMaintenanceStartTimeBuffer
        let deferMaintenanceEndTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deferMaintenanceEndTime)
        var deferMaintenanceEndTimeBuffer:Date? = nil
        if let deferMaintenanceEndTimeDecoded = deferMaintenanceEndTimeDecoded {
            deferMaintenanceEndTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(deferMaintenanceEndTimeDecoded, format: .dateTime)
        }
        deferMaintenanceEndTime = deferMaintenanceEndTimeBuffer
    }
}

extension DeferredMaintenanceWindow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeferredMaintenanceWindow(deferMaintenanceEndTime: \(String(describing: deferMaintenanceEndTime)), deferMaintenanceIdentifier: \(String(describing: deferMaintenanceIdentifier)), deferMaintenanceStartTime: \(String(describing: deferMaintenanceStartTime)))"}
}

/// <p>Describes a deferred maintenance window</p>
public struct DeferredMaintenanceWindow: Equatable {
    /// <p> A timestamp for the end of the time period when we defer maintenance.</p>
    public let deferMaintenanceEndTime: Date?
    /// <p>A unique identifier for the maintenance window.</p>
    public let deferMaintenanceIdentifier: String?
    /// <p> A timestamp for the beginning of the time period when we defer maintenance.</p>
    public let deferMaintenanceStartTime: Date?

    public init (
        deferMaintenanceEndTime: Date? = nil,
        deferMaintenanceIdentifier: String? = nil,
        deferMaintenanceStartTime: Date? = nil
    )
    {
        self.deferMaintenanceEndTime = deferMaintenanceEndTime
        self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
        self.deferMaintenanceStartTime = deferMaintenanceStartTime
    }
}

public struct DeleteClusterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

extension DeleteClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterInput(clusterIdentifier: \(String(describing: clusterIdentifier)), finalClusterSnapshotIdentifier: \(String(describing: finalClusterSnapshotIdentifier)), finalClusterSnapshotRetentionPeriod: \(String(describing: finalClusterSnapshotRetentionPeriod)), skipFinalClusterSnapshot: \(String(describing: skipFinalClusterSnapshot)))"}
}

extension DeleteClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let finalClusterSnapshotIdentifier = finalClusterSnapshotIdentifier {
            try container.encode(finalClusterSnapshotIdentifier, forKey: Key("FinalClusterSnapshotIdentifier"))
        }
        if let finalClusterSnapshotRetentionPeriod = finalClusterSnapshotRetentionPeriod {
            try container.encode(finalClusterSnapshotRetentionPeriod, forKey: Key("FinalClusterSnapshotRetentionPeriod"))
        }
        if skipFinalClusterSnapshot != false {
            try container.encode(skipFinalClusterSnapshot, forKey: Key("SkipFinalClusterSnapshot"))
        }
        try container.encode("DeleteCluster", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

/// <p></p>
public struct DeleteClusterInput: Equatable {
    /// <p>The identifier of the cluster to be deleted.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain lowercase characters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterIdentifier: String?
    /// <p>The identifier of the final snapshot that is to be created immediately before
    ///             deleting the cluster. If this parameter is provided,
    ///                 <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let finalClusterSnapshotIdentifier: String?
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>The default value is -1.</p>
    public let finalClusterSnapshotRetentionPeriod: Int?
    /// <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift
    ///             deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If
    ///                 <code>false</code>, a final cluster snapshot is created before the cluster is
    ///             deleted. </p>
    ///         <note>
    ///             <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be
    ///                 specified if <i>SkipFinalClusterSnapshot</i> is
    ///                 <code>false</code>.</p>
    ///         </note>
    ///         <p>Default: <code>false</code>
    ///         </p>
    public let skipFinalClusterSnapshot: Bool

    public init (
        clusterIdentifier: String? = nil,
        finalClusterSnapshotIdentifier: String? = nil,
        finalClusterSnapshotRetentionPeriod: Int? = nil,
        skipFinalClusterSnapshot: Bool = false
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.finalClusterSnapshotIdentifier = finalClusterSnapshotIdentifier
        self.finalClusterSnapshotRetentionPeriod = finalClusterSnapshotRetentionPeriod
        self.skipFinalClusterSnapshot = skipFinalClusterSnapshot
    }
}

extension DeleteClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotAlreadyExistsFault" : self = .clusterSnapshotAlreadyExistsFault(try ClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotQuotaExceededFault" : self = .clusterSnapshotQuotaExceededFault(try ClusterSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotAlreadyExistsFault(ClusterSnapshotAlreadyExistsFault)
    case clusterSnapshotQuotaExceededFault(ClusterSnapshotQuotaExceededFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension DeleteClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension DeleteClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterParameterGroupOutputError>
}

extension DeleteClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterParameterGroupInput(parameterGroupName: \(String(describing: parameterGroupName)))"}
}

extension DeleteClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
        try container.encode("DeleteClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterParameterGroupOutputError>
}

public struct DeleteClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterParameterGroupOutputError>
}

/// <p></p>
public struct DeleteClusterParameterGroupInput: Equatable {
    /// <p>The name of the parameter group to be deleted.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be the name of an existing cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot delete a default cluster parameter group.</p>
    ///             </li>
    ///          </ul>
    public let parameterGroupName: String?

    public init (
        parameterGroupName: String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

extension DeleteClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterParameterGroupStateFault" : self = .invalidClusterParameterGroupStateFault(try InvalidClusterParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterParameterGroupOutputError: Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidClusterParameterGroupStateFault(InvalidClusterParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterParameterGroupOutputResponse()"}
}

extension DeleteClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClusterParameterGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteClusterParameterGroupOutputResponseBody: Equatable {
}

extension DeleteClusterParameterGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteClusterSecurityGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClusterSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSecurityGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSecurityGroupOutputError>
}

extension DeleteClusterSecurityGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterSecurityGroupInput(clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)))"}
}

extension DeleteClusterSecurityGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: Key("ClusterSecurityGroupName"))
        }
        try container.encode("DeleteClusterSecurityGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteClusterSecurityGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSecurityGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSecurityGroupOutputError>
}

public struct DeleteClusterSecurityGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSecurityGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSecurityGroupOutputError>
}

/// <p></p>
public struct DeleteClusterSecurityGroupInput: Equatable {
    /// <p>The name of the cluster security group to be deleted.</p>
    public let clusterSecurityGroupName: String?

    public init (
        clusterSecurityGroupName: String? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
    }
}

extension DeleteClusterSecurityGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterSecurityGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterSecurityGroupOutputError: Equatable {
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterSecurityGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterSecurityGroupOutputResponse()"}
}

extension DeleteClusterSecurityGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClusterSecurityGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteClusterSecurityGroupOutputResponseBody: Equatable {
}

extension DeleteClusterSecurityGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSnapshotOutputError>
}

extension DeleteClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterSnapshotInput(snapshotClusterIdentifier: \(String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(String(describing: snapshotIdentifier)))"}
}

extension DeleteClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        try container.encode("DeleteClusterSnapshot", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSnapshotOutputError>
}

public struct DeleteClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSnapshotOutputError>
}

/// <p></p>
public struct DeleteClusterSnapshotInput: Equatable {
    /// <p>The unique identifier of the cluster the snapshot was created from. This parameter
    ///             is required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    ///         <p>Constraints: Must be the name of valid cluster.</p>
    public let snapshotClusterIdentifier: String?
    /// <p>The unique identifier of the manual snapshot to be deleted.</p>
    ///         <p>Constraints: Must be the name of an existing snapshot that is in the
    ///                 <code>available</code>, <code>failed</code>, or <code>cancelled</code>
    ///             state.</p>
    public let snapshotIdentifier: String?

    public init (
        snapshotClusterIdentifier: String? = nil,
        snapshotIdentifier: String? = nil
    )
    {
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension DeleteClusterSnapshotMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotClusterIdentifier = "SnapshotClusterIdentifier"
        case snapshotIdentifier = "SnapshotIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let snapshotClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotClusterIdentifier)
        snapshotClusterIdentifier = snapshotClusterIdentifierDecoded
    }
}

extension DeleteClusterSnapshotMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterSnapshotMessage(snapshotClusterIdentifier: \(String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(String(describing: snapshotIdentifier)))"}
}

/// <p></p>
public struct DeleteClusterSnapshotMessage: Equatable {
    /// <p>The unique identifier of the cluster the snapshot was created from. This parameter
    ///             is required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    ///         <p>Constraints: Must be the name of valid cluster.</p>
    public let snapshotClusterIdentifier: String?
    /// <p>The unique identifier of the manual snapshot to be deleted.</p>
    ///         <p>Constraints: Must be the name of an existing snapshot that is in the
    ///                 <code>available</code>, <code>failed</code>, or <code>cancelled</code>
    ///             state.</p>
    public let snapshotIdentifier: String?

    public init (
        snapshotClusterIdentifier: String? = nil,
        snapshotIdentifier: String? = nil
    )
    {
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension DeleteClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterSnapshotOutputError: Equatable {
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterSnapshotOutputResponse(snapshot: \(String(describing: snapshot)))"}
}

extension DeleteClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct DeleteClusterSnapshotOutputResponse: Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: Snapshot?

    public init (
        snapshot: Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct DeleteClusterSnapshotOutputResponseBody: Equatable {
    public let snapshot: Snapshot?
}

extension DeleteClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct DeleteClusterSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClusterSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSubnetGroupOutputError>
}

extension DeleteClusterSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterSubnetGroupInput(clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)))"}
}

extension DeleteClusterSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        try container.encode("DeleteClusterSubnetGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteClusterSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSubnetGroupOutputError>
}

public struct DeleteClusterSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterSubnetGroupOutputError>
}

/// <p></p>
public struct DeleteClusterSubnetGroupInput: Equatable {
    /// <p>The name of the cluster subnet group name to be deleted.</p>
    public let clusterSubnetGroupName: String?

    public init (
        clusterSubnetGroupName: String? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
    }
}

extension DeleteClusterSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteClusterSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetGroupStateFault" : self = .invalidClusterSubnetGroupStateFault(try InvalidClusterSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetStateFault" : self = .invalidClusterSubnetStateFault(try InvalidClusterSubnetStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterSubnetGroupOutputError: Equatable {
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case invalidClusterSubnetGroupStateFault(InvalidClusterSubnetGroupStateFault)
    case invalidClusterSubnetStateFault(InvalidClusterSubnetStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterSubnetGroupOutputResponse()"}
}

extension DeleteClusterSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClusterSubnetGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteClusterSubnetGroupOutputResponseBody: Equatable {
}

extension DeleteClusterSubnetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEndpointAccessInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointAccessInput>
    public typealias MOutput = OperationOutput<DeleteEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointAccessOutputError>
}

extension DeleteEndpointAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointAccessInput(endpointName: \(String(describing: endpointName)))"}
}

extension DeleteEndpointAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: Key("EndpointName"))
        }
        try container.encode("DeleteEndpointAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteEndpointAccessInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointAccessInput>
    public typealias MOutput = OperationOutput<DeleteEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointAccessOutputError>
}

public struct DeleteEndpointAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointAccessInput>
    public typealias MOutput = OperationOutput<DeleteEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointAccessOutputError>
}

public struct DeleteEndpointAccessInput: Equatable {
    /// <p>The Redshift-managed VPC endpoint to delete.</p>
    public let endpointName: String?

    public init (
        endpointName: String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

extension DeleteEndpointAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEndpointAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointStateFault" : self = .invalidEndpointStateFault(try InvalidEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointAccessOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidEndpointStateFault(InvalidEndpointStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointAccessOutputResponse(address: \(String(describing: address)), clusterIdentifier: \(String(describing: clusterIdentifier)), endpointCreateTime: \(String(describing: endpointCreateTime)), endpointName: \(String(describing: endpointName)), endpointStatus: \(String(describing: endpointStatus)), port: \(String(describing: port)), resourceOwner: \(String(describing: resourceOwner)), subnetGroupName: \(String(describing: subnetGroupName)), vpcEndpoint: \(String(describing: vpcEndpoint)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

extension DeleteEndpointAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.address = output.address
            self.clusterIdentifier = output.clusterIdentifier
            self.endpointCreateTime = output.endpointCreateTime
            self.endpointName = output.endpointName
            self.endpointStatus = output.endpointStatus
            self.port = output.port
            self.resourceOwner = output.resourceOwner
            self.subnetGroupName = output.subnetGroupName
            self.vpcEndpoint = output.vpcEndpoint
            self.vpcSecurityGroups = output.vpcSecurityGroups
        } else {
            self.address = nil
            self.clusterIdentifier = nil
            self.endpointCreateTime = nil
            self.endpointName = nil
            self.endpointStatus = nil
            self.port = 0
            self.resourceOwner = nil
            self.subnetGroupName = nil
            self.vpcEndpoint = nil
            self.vpcSecurityGroups = nil
        }
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
public struct DeleteEndpointAccessOutputResponse: Equatable {
    /// <p>The DNS address of the endpoint.</p>
    public let address: String?
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    public let clusterIdentifier: String?
    /// <p>The time (UTC) that the endpoint was created.</p>
    public let endpointCreateTime: Date?
    /// <p>The name of the endpoint.</p>
    public let endpointName: String?
    /// <p>The status of the endpoint.</p>
    public let endpointStatus: String?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    public let port: Int
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: String?
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    public let subnetGroupName: String?
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpoint: VpcEndpoint?
    /// <p>The security groups associated with the endpoint.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        address: String? = nil,
        clusterIdentifier: String? = nil,
        endpointCreateTime: Date? = nil,
        endpointName: String? = nil,
        endpointStatus: String? = nil,
        port: Int = 0,
        resourceOwner: String? = nil,
        subnetGroupName: String? = nil,
        vpcEndpoint: VpcEndpoint? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.address = address
        self.clusterIdentifier = clusterIdentifier
        self.endpointCreateTime = endpointCreateTime
        self.endpointName = endpointName
        self.endpointStatus = endpointStatus
        self.port = port
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcEndpoint = vpcEndpoint
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct DeleteEndpointAccessOutputResponseBody: Equatable {
    public let clusterIdentifier: String?
    public let resourceOwner: String?
    public let subnetGroupName: String?
    public let endpointStatus: String?
    public let endpointName: String?
    public let endpointCreateTime: Date?
    public let port: Int
    public let address: String?
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?
    public let vpcEndpoint: VpcEndpoint?
}

extension DeleteEndpointAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteEndpointAccessResult"))
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionInput(subscriptionName: \(String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("DeleteEventSubscription", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

/// <p></p>
public struct DeleteEventSubscriptionInput: Equatable {
    /// <p>The name of the Amazon Redshift event notification subscription to be deleted.</p>
    public let subscriptionName: String?

    public init (
        subscriptionName: String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

extension DeleteEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidSubscriptionStateFault" : self = .invalidSubscriptionStateFault(try InvalidSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Equatable {
    case invalidSubscriptionStateFault(InvalidSubscriptionStateFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionOutputResponse()"}
}

extension DeleteEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteEventSubscriptionOutputResponseBody: Equatable {
}

extension DeleteEventSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteHsmClientCertificateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteHsmClientCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmClientCertificateInput>
    public typealias MOutput = OperationOutput<DeleteHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmClientCertificateOutputError>
}

extension DeleteHsmClientCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmClientCertificateInput(hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)))"}
}

extension DeleteHsmClientCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        try container.encode("DeleteHsmClientCertificate", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteHsmClientCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHsmClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmClientCertificateInput>
    public typealias MOutput = OperationOutput<DeleteHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmClientCertificateOutputError>
}

public struct DeleteHsmClientCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHsmClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmClientCertificateInput>
    public typealias MOutput = OperationOutput<DeleteHsmClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmClientCertificateOutputError>
}

/// <p></p>
public struct DeleteHsmClientCertificateInput: Equatable {
    /// <p>The identifier of the HSM client certificate to be deleted.</p>
    public let hsmClientCertificateIdentifier: String?

    public init (
        hsmClientCertificateIdentifier: String? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
    }
}

extension DeleteHsmClientCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteHsmClientCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHsmClientCertificateStateFault" : self = .invalidHsmClientCertificateStateFault(try InvalidHsmClientCertificateStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHsmClientCertificateOutputError: Equatable {
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case invalidHsmClientCertificateStateFault(InvalidHsmClientCertificateStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmClientCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmClientCertificateOutputResponse()"}
}

extension DeleteHsmClientCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHsmClientCertificateOutputResponse: Equatable {

    public init() {}
}

struct DeleteHsmClientCertificateOutputResponseBody: Equatable {
}

extension DeleteHsmClientCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteHsmConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteHsmConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmConfigurationOutputError>
}

extension DeleteHsmConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmConfigurationInput(hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)))"}
}

extension DeleteHsmConfigurationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        try container.encode("DeleteHsmConfiguration", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteHsmConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHsmConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmConfigurationOutputError>
}

public struct DeleteHsmConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHsmConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteHsmConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmConfigurationOutputError>
}

/// <p></p>
public struct DeleteHsmConfigurationInput: Equatable {
    /// <p>The identifier of the Amazon Redshift HSM configuration to be deleted.</p>
    public let hsmConfigurationIdentifier: String?

    public init (
        hsmConfigurationIdentifier: String? = nil
    )
    {
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
    }
}

extension DeleteHsmConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteHsmConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHsmConfigurationStateFault" : self = .invalidHsmConfigurationStateFault(try InvalidHsmConfigurationStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHsmConfigurationOutputError: Equatable {
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case invalidHsmConfigurationStateFault(InvalidHsmConfigurationStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmConfigurationOutputResponse()"}
}

extension DeleteHsmConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHsmConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteHsmConfigurationOutputResponseBody: Equatable {
}

extension DeleteHsmConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePartnerInputBodyMiddleware: Middleware {
    public let id: String = "DeletePartnerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartnerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartnerInput>
    public typealias MOutput = OperationOutput<DeletePartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartnerOutputError>
}

extension DeletePartnerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartnerInput(accountId: \(String(describing: accountId)), clusterIdentifier: \(String(describing: clusterIdentifier)), databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)))"}
}

extension DeletePartnerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: Key("PartnerName"))
        }
        try container.encode("DeletePartner", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeletePartnerInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePartnerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartnerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartnerInput>
    public typealias MOutput = OperationOutput<DeletePartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartnerOutputError>
}

public struct DeletePartnerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePartnerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartnerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartnerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartnerInput>
    public typealias MOutput = OperationOutput<DeletePartnerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartnerOutputError>
}

public struct DeletePartnerInput: Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: String?
    /// <p>The cluster identifier of the cluster that receives data from the partner.</p>
    public let clusterIdentifier: String?
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: String?

    public init (
        accountId: String? = nil,
        clusterIdentifier: String? = nil,
        databaseName: String? = nil,
        partnerName: String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

extension DeletePartnerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePartnerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PartnerNotFoundFault" : self = .partnerNotFoundFault(try PartnerNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePartnerOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case partnerNotFoundFault(PartnerNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePartnerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartnerOutputResponse(databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)))"}
}

extension DeletePartnerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeletePartnerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.databaseName = output.databaseName
            self.partnerName = output.partnerName
        } else {
            self.databaseName = nil
            self.partnerName = nil
        }
    }
}

public struct DeletePartnerOutputResponse: Equatable {
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: String?

    public init (
        databaseName: String? = nil,
        partnerName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

struct DeletePartnerOutputResponseBody: Equatable {
    public let databaseName: String?
    public let partnerName: String?
}

extension DeletePartnerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeletePartnerResult"))
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
    }
}

public struct DeleteScheduledActionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteScheduledActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScheduledActionInput>
    public typealias MOutput = OperationOutput<DeleteScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScheduledActionOutputError>
}

extension DeleteScheduledActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScheduledActionInput(scheduledActionName: \(String(describing: scheduledActionName)))"}
}

extension DeleteScheduledActionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: Key("ScheduledActionName"))
        }
        try container.encode("DeleteScheduledAction", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteScheduledActionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteScheduledActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScheduledActionInput>
    public typealias MOutput = OperationOutput<DeleteScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScheduledActionOutputError>
}

public struct DeleteScheduledActionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteScheduledActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScheduledActionInput>
    public typealias MOutput = OperationOutput<DeleteScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScheduledActionOutputError>
}

public struct DeleteScheduledActionInput: Equatable {
    /// <p>The name of the scheduled action to delete. </p>
    public let scheduledActionName: String?

    public init (
        scheduledActionName: String? = nil
    )
    {
        self.scheduledActionName = scheduledActionName
    }
}

extension DeleteScheduledActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteScheduledActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ScheduledActionNotFoundFault" : self = .scheduledActionNotFoundFault(try ScheduledActionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteScheduledActionOutputError: Equatable {
    case scheduledActionNotFoundFault(ScheduledActionNotFoundFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScheduledActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScheduledActionOutputResponse()"}
}

extension DeleteScheduledActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteScheduledActionOutputResponse: Equatable {

    public init() {}
}

struct DeleteScheduledActionOutputResponseBody: Equatable {
}

extension DeleteScheduledActionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSnapshotCopyGrantInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSnapshotCopyGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotCopyGrantInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotCopyGrantOutputError>
}

extension DeleteSnapshotCopyGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotCopyGrantInput(snapshotCopyGrantName: \(String(describing: snapshotCopyGrantName)))"}
}

extension DeleteSnapshotCopyGrantInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: Key("SnapshotCopyGrantName"))
        }
        try container.encode("DeleteSnapshotCopyGrant", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteSnapshotCopyGrantInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSnapshotCopyGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotCopyGrantInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotCopyGrantOutputError>
}

public struct DeleteSnapshotCopyGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSnapshotCopyGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotCopyGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotCopyGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotCopyGrantInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotCopyGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotCopyGrantOutputError>
}

/// <p>The result of the <code>DeleteSnapshotCopyGrant</code> action.</p>
public struct DeleteSnapshotCopyGrantInput: Equatable {
    /// <p>The name of the snapshot copy grant to delete.</p>
    public let snapshotCopyGrantName: String?

    public init (
        snapshotCopyGrantName: String? = nil
    )
    {
        self.snapshotCopyGrantName = snapshotCopyGrantName
    }
}

extension DeleteSnapshotCopyGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSnapshotCopyGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidSnapshotCopyGrantStateFault" : self = .invalidSnapshotCopyGrantStateFault(try InvalidSnapshotCopyGrantStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantNotFoundFault" : self = .snapshotCopyGrantNotFoundFault(try SnapshotCopyGrantNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSnapshotCopyGrantOutputError: Equatable {
    case invalidSnapshotCopyGrantStateFault(InvalidSnapshotCopyGrantStateFault)
    case snapshotCopyGrantNotFoundFault(SnapshotCopyGrantNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotCopyGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotCopyGrantOutputResponse()"}
}

extension DeleteSnapshotCopyGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSnapshotCopyGrantOutputResponse: Equatable {

    public init() {}
}

struct DeleteSnapshotCopyGrantOutputResponseBody: Equatable {
}

extension DeleteSnapshotCopyGrantOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSnapshotScheduleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotScheduleOutputError>
}

extension DeleteSnapshotScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotScheduleInput(scheduleIdentifier: \(String(describing: scheduleIdentifier)))"}
}

extension DeleteSnapshotScheduleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: Key("ScheduleIdentifier"))
        }
        try container.encode("DeleteSnapshotSchedule", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteSnapshotScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInput: Equatable {
    /// <p>A unique identifier of the snapshot schedule to delete.</p>
    public let scheduleIdentifier: String?

    public init (
        scheduleIdentifier: String? = nil
    )
    {
        self.scheduleIdentifier = scheduleIdentifier
    }
}

extension DeleteSnapshotScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSnapshotScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClusterSnapshotScheduleStateFault" : self = .invalidClusterSnapshotScheduleStateFault(try InvalidClusterSnapshotScheduleStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSnapshotScheduleOutputError: Equatable {
    case invalidClusterSnapshotScheduleStateFault(InvalidClusterSnapshotScheduleStateFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotScheduleOutputResponse()"}
}

extension DeleteSnapshotScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSnapshotScheduleOutputResponse: Equatable {

    public init() {}
}

struct DeleteSnapshotScheduleOutputResponseBody: Equatable {
}

extension DeleteSnapshotScheduleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTagsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

extension DeleteTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsInput(resourceName: \(String(describing: resourceName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension DeleteTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DeleteTags", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

/// <p>Contains the output from the <code>DeleteTags</code> action. </p>
public struct DeleteTagsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For
    ///             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
    public let resourceName: String?
    /// <p>The tag key that you want to delete.</p>
    public let tagKeys: [String]?

    public init (
        resourceName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

extension DeleteTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Equatable {
    case invalidTagFault(InvalidTagFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Equatable {
}

extension DeleteTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUsageLimitInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUsageLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsageLimitInput>
    public typealias MOutput = OperationOutput<DeleteUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsageLimitOutputError>
}

extension DeleteUsageLimitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsageLimitInput(usageLimitId: \(String(describing: usageLimitId)))"}
}

extension DeleteUsageLimitInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: Key("UsageLimitId"))
        }
        try container.encode("DeleteUsageLimit", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DeleteUsageLimitInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUsageLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsageLimitInput>
    public typealias MOutput = OperationOutput<DeleteUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsageLimitOutputError>
}

public struct DeleteUsageLimitInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUsageLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsageLimitInput>
    public typealias MOutput = OperationOutput<DeleteUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsageLimitOutputError>
}

public struct DeleteUsageLimitInput: Equatable {
    /// <p>The identifier of the usage limit to delete.</p>
    public let usageLimitId: String?

    public init (
        usageLimitId: String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

extension DeleteUsageLimitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUsageLimitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsageLimitNotFoundFault" : self = .usageLimitNotFoundFault(try UsageLimitNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsageLimitOutputError: Equatable {
    case unsupportedOperationFault(UnsupportedOperationFault)
    case usageLimitNotFoundFault(UsageLimitNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsageLimitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsageLimitOutputResponse()"}
}

extension DeleteUsageLimitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsageLimitOutputResponse: Equatable {

    public init() {}
}

struct DeleteUsageLimitOutputResponseBody: Equatable {
}

extension DeleteUsageLimitOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DependentServiceRequestThrottlingFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependentServiceRequestThrottlingFault(message: \(String(describing: message)))"}
}

extension DependentServiceRequestThrottlingFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DependentServiceRequestThrottlingFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request cannot be completed because a dependent service is throttling requests
///             made by Amazon Redshift on your behalf. Wait and retry the request.</p>
public struct DependentServiceRequestThrottlingFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependentServiceRequestThrottlingFaultBody: Equatable {
    public let message: String?
}

extension DependentServiceRequestThrottlingFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DependentServiceUnavailableFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependentServiceUnavailableFault(message: \(String(describing: message)))"}
}

extension DependentServiceUnavailableFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DependentServiceUnavailableFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request cannot be completed because a dependent internal service is
///             temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
public struct DependentServiceUnavailableFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependentServiceUnavailableFaultBody: Equatable {
    public let message: String?
}

extension DependentServiceUnavailableFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DescribeAccountAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

extension DescribeAccountAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesInput(attributeNames: \(String(describing: attributeNames)))"}
}

extension DescribeAccountAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttributeNames"))
            for (index0, string0) in attributeNames.enumerated() {
                try attributeNamesContainer.encode(string0, forKey: Key("AttributeName.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeAccountAttributes", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInput: Equatable {
    /// <p>A list of attribute names.</p>
    public let attributeNames: [String]?

    public init (
        attributeNames: [String]? = nil
    )
    {
        self.attributeNames = attributeNames
    }
}

extension DescribeAccountAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesOutputResponse(accountAttributes: \(String(describing: accountAttributes)))"}
}

extension DescribeAccountAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAttributes = output.accountAttributes
        } else {
            self.accountAttributes = nil
        }
    }
}

public struct DescribeAccountAttributesOutputResponse: Equatable {
    /// <p>A list of attributes assigned to an account.</p>
    public let accountAttributes: [AccountAttribute]?

    public init (
        accountAttributes: [AccountAttribute]? = nil
    )
    {
        self.accountAttributes = accountAttributes
    }
}

struct DescribeAccountAttributesOutputResponseBody: Equatable {
    public let accountAttributes: [AccountAttribute]?
}

extension DescribeAccountAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAttributes = "AccountAttributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAccountAttributesResult"))
        if containerValues.contains(.accountAttributes) {
            struct KeyVal0{struct AccountAttribute{}}
            let accountAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountAttribute>.CodingKeys.self, forKey: .accountAttributes)
            if let accountAttributesWrappedContainer = accountAttributesWrappedContainer {
                let accountAttributesContainer = try accountAttributesWrappedContainer.decodeIfPresent([AccountAttribute].self, forKey: .member)
                var accountAttributesBuffer:[AccountAttribute]? = nil
                if let accountAttributesContainer = accountAttributesContainer {
                    accountAttributesBuffer = [AccountAttribute]()
                    for structureContainer0 in accountAttributesContainer {
                        accountAttributesBuffer?.append(structureContainer0)
                    }
                }
                accountAttributes = accountAttributesBuffer
            } else {
                accountAttributes = []
            }
        } else {
            accountAttributes = nil
        }
    }
}

public struct DescribeClusterDbRevisionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterDbRevisionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterDbRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterDbRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterDbRevisionsInput>
    public typealias MOutput = OperationOutput<DescribeClusterDbRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterDbRevisionsOutputError>
}

extension DescribeClusterDbRevisionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterDbRevisionsInput(clusterIdentifier: \(String(describing: clusterIdentifier)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeClusterDbRevisionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeClusterDbRevisions", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterDbRevisionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterDbRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterDbRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterDbRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterDbRevisionsInput>
    public typealias MOutput = OperationOutput<DescribeClusterDbRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterDbRevisionsOutputError>
}

public struct DescribeClusterDbRevisionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterDbRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterDbRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterDbRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterDbRevisionsInput>
    public typealias MOutput = OperationOutput<DescribeClusterDbRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterDbRevisionsOutputError>
}

public struct DescribeClusterDbRevisionsInput: Equatable {
    /// <p>A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are
    ///             requesting. This parameter is case sensitive. All clusters defined for an account are
    ///             returned by default.</p>
    public let clusterIdentifier: String?
    /// <p>An optional parameter that specifies the starting point for returning a set of
    ///             response records. When the results of a <code>DescribeClusterDbRevisions</code> request
    ///             exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value
    ///             in the <code>marker</code> field of the response. You can retrieve the next set of
    ///             response records by providing the returned <code>marker</code> value in the
    ///                 <code>marker</code> parameter and retrying the request. </p>
    ///         <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or
    ///             the <code>marker</code> parameter, but not both.</p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified MaxRecords value, a value is returned
    ///             in the <code>marker</code> field of the response. You can retrieve the next set of
    ///             response records by providing the returned <code>marker</code> value in the
    ///                 <code>marker</code> parameter and retrying the request. </p>
    ///         <p>Default: 100</p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        clusterIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeClusterDbRevisionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterDbRevisionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterDbRevisionsOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterDbRevisionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterDbRevisionsOutputResponse(clusterDbRevisions: \(String(describing: clusterDbRevisions)), marker: \(String(describing: marker)))"}
}

extension DescribeClusterDbRevisionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterDbRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterDbRevisions = output.clusterDbRevisions
            self.marker = output.marker
        } else {
            self.clusterDbRevisions = nil
            self.marker = nil
        }
    }
}

public struct DescribeClusterDbRevisionsOutputResponse: Equatable {
    /// <p>A list of revisions.</p>
    public let clusterDbRevisions: [ClusterDbRevision]?
    /// <p>A string representing the starting point for the next set of revisions. If a value is
    ///             returned in a response, you can retrieve the next set of revisions by providing the
    ///             value in the <code>marker</code> parameter and retrying the command. If the
    ///                 <code>marker</code> field is empty, all revisions have already been returned.</p>
    public let marker: String?

    public init (
        clusterDbRevisions: [ClusterDbRevision]? = nil,
        marker: String? = nil
    )
    {
        self.clusterDbRevisions = clusterDbRevisions
        self.marker = marker
    }
}

struct DescribeClusterDbRevisionsOutputResponseBody: Equatable {
    public let marker: String?
    public let clusterDbRevisions: [ClusterDbRevision]?
}

extension DescribeClusterDbRevisionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterDbRevisions = "ClusterDbRevisions"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterDbRevisionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterDbRevisions) {
            struct KeyVal0{struct ClusterDbRevision{}}
            let clusterDbRevisionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterDbRevision>.CodingKeys.self, forKey: .clusterDbRevisions)
            if let clusterDbRevisionsWrappedContainer = clusterDbRevisionsWrappedContainer {
                let clusterDbRevisionsContainer = try clusterDbRevisionsWrappedContainer.decodeIfPresent([ClusterDbRevision].self, forKey: .member)
                var clusterDbRevisionsBuffer:[ClusterDbRevision]? = nil
                if let clusterDbRevisionsContainer = clusterDbRevisionsContainer {
                    clusterDbRevisionsBuffer = [ClusterDbRevision]()
                    for structureContainer0 in clusterDbRevisionsContainer {
                        clusterDbRevisionsBuffer?.append(structureContainer0)
                    }
                }
                clusterDbRevisions = clusterDbRevisionsBuffer
            } else {
                clusterDbRevisions = []
            }
        } else {
            clusterDbRevisions = nil
        }
    }
}

public struct DescribeClusterParameterGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterParameterGroupsOutputError>
}

extension DescribeClusterParameterGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterParameterGroupsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), parameterGroupName: \(String(describing: parameterGroupName)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeClusterParameterGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterParameterGroups", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterParameterGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterParameterGroupsOutputError>
}

public struct DescribeClusterParameterGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterParameterGroupsOutputError>
}

/// <p></p>
public struct DescribeClusterParameterGroupsInput: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterParameterGroups</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of a specific parameter group for which to return details. By default,
    ///             details about all parameter groups and the default parameter group are
    ///             returned.</p>
    public let parameterGroupName: String?
    /// <p>A tag key or keys for which you want to return all matching cluster parameter
    ///             groups that are associated with the specified key or keys. For example, suppose that you
    ///             have parameter groups that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the parameter groups that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching cluster parameter
    ///             groups that are associated with the specified tag value or values. For example, suppose
    ///             that you have parameter groups that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the parameter groups that have either or both of these tag
    ///             values associated with them.</p>
    public let tagValues: [String]?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        parameterGroupName: String? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.parameterGroupName = parameterGroupName
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterParameterGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterParameterGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterParameterGroupsOutputError: Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterParameterGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterParameterGroupsOutputResponse(marker: \(String(describing: marker)), parameterGroups: \(String(describing: parameterGroups)))"}
}

extension DescribeClusterParameterGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.parameterGroups = output.parameterGroups
        } else {
            self.marker = nil
            self.parameterGroups = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterParameterGroups</a>
///             action. </p>
public struct DescribeClusterParameterGroupsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>A list of <a>ClusterParameterGroup</a> instances. Each instance
    ///             describes one cluster parameter group. </p>
    public let parameterGroups: [ClusterParameterGroup]?

    public init (
        marker: String? = nil,
        parameterGroups: [ClusterParameterGroup]? = nil
    )
    {
        self.marker = marker
        self.parameterGroups = parameterGroups
    }
}

struct DescribeClusterParameterGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let parameterGroups: [ClusterParameterGroup]?
}

extension DescribeClusterParameterGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case parameterGroups = "ParameterGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameterGroups) {
            struct KeyVal0{struct ClusterParameterGroup{}}
            let parameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterParameterGroup>.CodingKeys.self, forKey: .parameterGroups)
            if let parameterGroupsWrappedContainer = parameterGroupsWrappedContainer {
                let parameterGroupsContainer = try parameterGroupsWrappedContainer.decodeIfPresent([ClusterParameterGroup].self, forKey: .member)
                var parameterGroupsBuffer:[ClusterParameterGroup]? = nil
                if let parameterGroupsContainer = parameterGroupsContainer {
                    parameterGroupsBuffer = [ClusterParameterGroup]()
                    for structureContainer0 in parameterGroupsContainer {
                        parameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                parameterGroups = parameterGroupsBuffer
            } else {
                parameterGroups = []
            }
        } else {
            parameterGroups = nil
        }
    }
}

public struct DescribeClusterParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterParametersOutputError>
}

extension DescribeClusterParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterParametersInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), parameterGroupName: \(String(describing: parameterGroupName)), source: \(String(describing: source)))"}
}

extension DescribeClusterParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        try container.encode("DescribeClusterParameters", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterParametersOutputError>
}

public struct DescribeClusterParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterParametersOutputError>
}

/// <p></p>
public struct DescribeClusterParametersInput: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterParameters</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of a cluster parameter group for which to return details.</p>
    public let parameterGroupName: String?
    /// <p>The parameter types to return. Specify <code>user</code> to show parameters that
    ///             are different form the default. Similarly, specify <code>engine-default</code> to show
    ///             parameters that are the same as the default parameter group. </p>
    ///         <p>Default: All parameter types returned.</p>
    ///         <p>Valid Values: <code>user</code> | <code>engine-default</code>
    ///         </p>
    public let source: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        parameterGroupName: String? = nil,
        source: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.parameterGroupName = parameterGroupName
        self.source = source
    }
}

extension DescribeClusterParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterParametersOutputError: Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterParametersOutputResponse(marker: \(String(describing: marker)), parameters: \(String(describing: parameters)))"}
}

extension DescribeClusterParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterParameters</a> action.
///         </p>
public struct DescribeClusterParametersOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>A list of <a>Parameter</a> instances. Each instance lists the parameters
    ///             of one cluster parameter group. </p>
    public let parameters: [Parameter]?

    public init (
        marker: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeClusterParametersOutputResponseBody: Equatable {
    public let parameters: [Parameter]?
    public let marker: String?
}

extension DescribeClusterParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeClusterSecurityGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSecurityGroupsOutputError>
}

extension DescribeClusterSecurityGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterSecurityGroupsInput(clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeClusterSecurityGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: Key("ClusterSecurityGroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterSecurityGroups", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterSecurityGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSecurityGroupsOutputError>
}

public struct DescribeClusterSecurityGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSecurityGroupsOutputError>
}

/// <p></p>
public struct DescribeClusterSecurityGroupsInput: Equatable {
    /// <p>The name of a cluster security group for which you are requesting details. You can
    ///             specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p>
    ///         <p> Example: <code>securitygroup1</code>
    ///         </p>
    public let clusterSecurityGroupName: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterSecurityGroups</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A tag key or keys for which you want to return all matching cluster security groups
    ///             that are associated with the specified key or keys. For example, suppose that you have
    ///             security groups that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the security groups that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching cluster security
    ///             groups that are associated with the specified tag value or values. For example, suppose
    ///             that you have security groups that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the security groups that have either or both of these tag values
    ///             associated with them.</p>
    public let tagValues: [String]?

    public init (
        clusterSecurityGroupName: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterSecurityGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterSecurityGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterSecurityGroupsOutputError: Equatable {
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterSecurityGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterSecurityGroupsOutputResponse(clusterSecurityGroups: \(String(describing: clusterSecurityGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeClusterSecurityGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterSecurityGroups = output.clusterSecurityGroups
            self.marker = output.marker
        } else {
            self.clusterSecurityGroups = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeClusterSecurityGroupsOutputResponse: Equatable {
    /// <p>A list of <a>ClusterSecurityGroup</a> instances. </p>
    public let clusterSecurityGroups: [ClusterSecurityGroup]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        clusterSecurityGroups: [ClusterSecurityGroup]? = nil,
        marker: String? = nil
    )
    {
        self.clusterSecurityGroups = clusterSecurityGroups
        self.marker = marker
    }
}

struct DescribeClusterSecurityGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let clusterSecurityGroups: [ClusterSecurityGroup]?
}

extension DescribeClusterSecurityGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterSecurityGroups = "ClusterSecurityGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterSecurityGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterSecurityGroups) {
            struct KeyVal0{struct ClusterSecurityGroup{}}
            let clusterSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterSecurityGroup>.CodingKeys.self, forKey: .clusterSecurityGroups)
            if let clusterSecurityGroupsWrappedContainer = clusterSecurityGroupsWrappedContainer {
                let clusterSecurityGroupsContainer = try clusterSecurityGroupsWrappedContainer.decodeIfPresent([ClusterSecurityGroup].self, forKey: .member)
                var clusterSecurityGroupsBuffer:[ClusterSecurityGroup]? = nil
                if let clusterSecurityGroupsContainer = clusterSecurityGroupsContainer {
                    clusterSecurityGroupsBuffer = [ClusterSecurityGroup]()
                    for structureContainer0 in clusterSecurityGroupsContainer {
                        clusterSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterSecurityGroups = clusterSecurityGroupsBuffer
            } else {
                clusterSecurityGroups = []
            }
        } else {
            clusterSecurityGroups = nil
        }
    }
}

public struct DescribeClusterSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSnapshotsOutputError>
}

extension DescribeClusterSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterSnapshotsInput(clusterExists: \(String(describing: clusterExists)), clusterIdentifier: \(String(describing: clusterIdentifier)), endTime: \(String(describing: endTime)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), ownerAccount: \(String(describing: ownerAccount)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), snapshotType: \(String(describing: snapshotType)), sortingEntities: \(String(describing: sortingEntities)), startTime: \(String(describing: startTime)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeClusterSnapshotsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterExists = clusterExists {
            try container.encode(clusterExists, forKey: Key("ClusterExists"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: Key("OwnerAccount"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        if let sortingEntities = sortingEntities {
            var sortingEntitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SortingEntities"))
            for (index0, snapshotsortingentity0) in sortingEntities.enumerated() {
                try sortingEntitiesContainer.encode(snapshotsortingentity0, forKey: Key("SnapshotSortingEntity.\(index0.advanced(by: 1))"))
            }
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterSnapshots", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSnapshotsOutputError>
}

public struct DescribeClusterSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSnapshotsOutputError>
}

/// <p></p>
public struct DescribeClusterSnapshotsInput: Equatable {
    /// <p>A value that indicates whether to return snapshots only for an existing cluster.
    ///             You can perform table-level restore only by using a snapshot of an existing cluster,
    ///             that is, a cluster that has not been deleted. Values for this parameter work as follows: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>true</code>,
    ///                         <code>ClusterIdentifier</code> is required.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
    ///                         <code>ClusterIdentifier</code> isn't specified, all snapshots
    ///                     associated with deleted clusters (orphaned snapshots) are returned. </p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
    ///                         <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots
    ///                     associated with that cluster are returned.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>ClusterExists</code> is set to <code>false</code> and
    ///                         <code>ClusterIdentifier</code> is specified for an existing cluster, no
    ///                     snapshots are returned. </p>
    ///             </li>
    ///          </ul>
    public let clusterExists: Bool?
    /// <p>The identifier of the cluster which generated the requested snapshots.</p>
    public let clusterIdentifier: String?
    /// <p>A time value that requests only snapshots created at or before the specified time.
    ///             The time value is specified in ISO 8601 format. For more information about ISO 8601, go
    ///             to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia
    ///                 page.</a>
    ///         </p>
    ///         <p>Example: <code>2012-07-16T18:00:00Z</code>
    ///         </p>
    public let endTime: Date?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterSnapshots</a> request exceed
    ///             the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The AWS customer account used to create or copy the snapshot. Use this field to
    ///             filter the results to snapshots owned by a particular account. To describe snapshots you
    ///             own, either specify your AWS customer account, or do not specify the
    ///             parameter.</p>
    public let ownerAccount: String?
    /// <p>The snapshot identifier of the snapshot about which to return
    ///             information.</p>
    public let snapshotIdentifier: String?
    /// <p>The type of snapshots for which you are requesting information. By default,
    ///             snapshots of all types are returned.</p>
    ///         <p>Valid Values: <code>automated</code> | <code>manual</code>
    ///         </p>
    public let snapshotType: String?
    /// <p></p>
    public let sortingEntities: [SnapshotSortingEntity]?
    /// <p>A value that requests only snapshots created at or after the specified time. The
    ///             time value is specified in ISO 8601 format. For more information about ISO 8601, go to
    ///             the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///         </p>
    ///         <p>Example: <code>2012-07-16T18:00:00Z</code>
    ///         </p>
    public let startTime: Date?
    /// <p>A tag key or keys for which you want to return all matching cluster snapshots that
    ///             are associated with the specified key or keys. For example, suppose that you have
    ///             snapshots that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the snapshots that have either or both of these tag
    ///             keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching cluster snapshots
    ///             that are associated with the specified tag value or values. For example, suppose that
    ///             you have snapshots that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the snapshots that have either or both of these tag values
    ///             associated with them.</p>
    public let tagValues: [String]?

    public init (
        clusterExists: Bool? = nil,
        clusterIdentifier: String? = nil,
        endTime: Date? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        ownerAccount: String? = nil,
        snapshotIdentifier: String? = nil,
        snapshotType: String? = nil,
        sortingEntities: [SnapshotSortingEntity]? = nil,
        startTime: Date? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.clusterExists = clusterExists
        self.clusterIdentifier = clusterIdentifier
        self.endTime = endTime
        self.marker = marker
        self.maxRecords = maxRecords
        self.ownerAccount = ownerAccount
        self.snapshotIdentifier = snapshotIdentifier
        self.snapshotType = snapshotType
        self.sortingEntities = sortingEntities
        self.startTime = startTime
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterSnapshotsOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterSnapshotsOutputResponse(marker: \(String(describing: marker)), snapshots: \(String(describing: snapshots)))"}
}

extension DescribeClusterSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.snapshots = output.snapshots
        } else {
            self.marker = nil
            self.snapshots = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterSnapshots</a> action.
///         </p>
public struct DescribeClusterSnapshotsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>A list of <a>Snapshot</a> instances. </p>
    public let snapshots: [Snapshot]?

    public init (
        marker: String? = nil,
        snapshots: [Snapshot]? = nil
    )
    {
        self.marker = marker
        self.snapshots = snapshots
    }
}

struct DescribeClusterSnapshotsOutputResponseBody: Equatable {
    public let marker: String?
    public let snapshots: [Snapshot]?
}

extension DescribeClusterSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case snapshots = "Snapshots"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.snapshots) {
            struct KeyVal0{struct Snapshot{}}
            let snapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Snapshot>.CodingKeys.self, forKey: .snapshots)
            if let snapshotsWrappedContainer = snapshotsWrappedContainer {
                let snapshotsContainer = try snapshotsWrappedContainer.decodeIfPresent([Snapshot].self, forKey: .member)
                var snapshotsBuffer:[Snapshot]? = nil
                if let snapshotsContainer = snapshotsContainer {
                    snapshotsBuffer = [Snapshot]()
                    for structureContainer0 in snapshotsContainer {
                        snapshotsBuffer?.append(structureContainer0)
                    }
                }
                snapshots = snapshotsBuffer
            } else {
                snapshots = []
            }
        } else {
            snapshots = nil
        }
    }
}

public struct DescribeClusterSubnetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSubnetGroupsOutputError>
}

extension DescribeClusterSubnetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterSubnetGroupsInput(clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeClusterSubnetGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusterSubnetGroups", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterSubnetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSubnetGroupsOutputError>
}

public struct DescribeClusterSubnetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeClusterSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterSubnetGroupsOutputError>
}

/// <p></p>
public struct DescribeClusterSubnetGroupsInput: Equatable {
    /// <p>The name of the cluster subnet group for which information is requested.</p>
    public let clusterSubnetGroupName: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterSubnetGroups</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A tag key or keys for which you want to return all matching cluster subnet groups
    ///             that are associated with the specified key or keys. For example, suppose that you have
    ///             subnet groups that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the subnet groups that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching cluster subnet
    ///             groups that are associated with the specified tag value or values. For example, suppose
    ///             that you have subnet groups that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the subnet groups that have either or both of these tag values
    ///             associated with them.</p>
    public let tagValues: [String]?

    public init (
        clusterSubnetGroupName: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClusterSubnetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterSubnetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterSubnetGroupsOutputError: Equatable {
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterSubnetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterSubnetGroupsOutputResponse(clusterSubnetGroups: \(String(describing: clusterSubnetGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeClusterSubnetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterSubnetGroups = output.clusterSubnetGroups
            self.marker = output.marker
        } else {
            self.clusterSubnetGroups = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterSubnetGroups</a> action.
///         </p>
public struct DescribeClusterSubnetGroupsOutputResponse: Equatable {
    /// <p>A list of <a>ClusterSubnetGroup</a> instances. </p>
    public let clusterSubnetGroups: [ClusterSubnetGroup]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        clusterSubnetGroups: [ClusterSubnetGroup]? = nil,
        marker: String? = nil
    )
    {
        self.clusterSubnetGroups = clusterSubnetGroups
        self.marker = marker
    }
}

struct DescribeClusterSubnetGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let clusterSubnetGroups: [ClusterSubnetGroup]?
}

extension DescribeClusterSubnetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterSubnetGroups = "ClusterSubnetGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterSubnetGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterSubnetGroups) {
            struct KeyVal0{struct ClusterSubnetGroup{}}
            let clusterSubnetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterSubnetGroup>.CodingKeys.self, forKey: .clusterSubnetGroups)
            if let clusterSubnetGroupsWrappedContainer = clusterSubnetGroupsWrappedContainer {
                let clusterSubnetGroupsContainer = try clusterSubnetGroupsWrappedContainer.decodeIfPresent([ClusterSubnetGroup].self, forKey: .member)
                var clusterSubnetGroupsBuffer:[ClusterSubnetGroup]? = nil
                if let clusterSubnetGroupsContainer = clusterSubnetGroupsContainer {
                    clusterSubnetGroupsBuffer = [ClusterSubnetGroup]()
                    for structureContainer0 in clusterSubnetGroupsContainer {
                        clusterSubnetGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterSubnetGroups = clusterSubnetGroupsBuffer
            } else {
                clusterSubnetGroups = []
            }
        } else {
            clusterSubnetGroups = nil
        }
    }
}

public struct DescribeClusterTracksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterTracksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterTracksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterTracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterTracksInput>
    public typealias MOutput = OperationOutput<DescribeClusterTracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterTracksOutputError>
}

extension DescribeClusterTracksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterTracksInput(maintenanceTrackName: \(String(describing: maintenanceTrackName)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeClusterTracksInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeClusterTracks", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterTracksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterTracksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterTracksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterTracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterTracksInput>
    public typealias MOutput = OperationOutput<DescribeClusterTracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterTracksOutputError>
}

public struct DescribeClusterTracksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterTracksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterTracksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterTracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterTracksInput>
    public typealias MOutput = OperationOutput<DescribeClusterTracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterTracksOutputError>
}

public struct DescribeClusterTracksInput: Equatable {
    /// <p>The name of the maintenance track. </p>
    public let maintenanceTrackName: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <code>DescribeClusterTracks</code> request exceed the
    ///             value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>An integer value for the maximum number of maintenance tracks to return.</p>
    public let maxRecords: Int?

    public init (
        maintenanceTrackName: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.maintenanceTrackName = maintenanceTrackName
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeClusterTracksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterTracksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterTracksOutputError: Equatable {
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterTracksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterTracksOutputResponse(maintenanceTracks: \(String(describing: maintenanceTracks)), marker: \(String(describing: marker)))"}
}

extension DescribeClusterTracksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterTracksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.maintenanceTracks = output.maintenanceTracks
            self.marker = output.marker
        } else {
            self.maintenanceTracks = nil
            self.marker = nil
        }
    }
}

public struct DescribeClusterTracksOutputResponse: Equatable {
    /// <p>A list of maintenance tracks output by the <code>DescribeClusterTracks</code>
    ///             operation. </p>
    public let maintenanceTracks: [MaintenanceTrack]?
    /// <p>The starting point to return a set of response tracklist records. You can retrieve the
    ///             next set of response records by providing the returned marker value in the
    ///                 <code>Marker</code> parameter and retrying the request.</p>
    public let marker: String?

    public init (
        maintenanceTracks: [MaintenanceTrack]? = nil,
        marker: String? = nil
    )
    {
        self.maintenanceTracks = maintenanceTracks
        self.marker = marker
    }
}

struct DescribeClusterTracksOutputResponseBody: Equatable {
    public let maintenanceTracks: [MaintenanceTrack]?
    public let marker: String?
}

extension DescribeClusterTracksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maintenanceTracks = "MaintenanceTracks"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterTracksResult"))
        if containerValues.contains(.maintenanceTracks) {
            struct KeyVal0{struct MaintenanceTrack{}}
            let maintenanceTracksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.MaintenanceTrack>.CodingKeys.self, forKey: .maintenanceTracks)
            if let maintenanceTracksWrappedContainer = maintenanceTracksWrappedContainer {
                let maintenanceTracksContainer = try maintenanceTracksWrappedContainer.decodeIfPresent([MaintenanceTrack].self, forKey: .member)
                var maintenanceTracksBuffer:[MaintenanceTrack]? = nil
                if let maintenanceTracksContainer = maintenanceTracksContainer {
                    maintenanceTracksBuffer = [MaintenanceTrack]()
                    for structureContainer0 in maintenanceTracksContainer {
                        maintenanceTracksBuffer?.append(structureContainer0)
                    }
                }
                maintenanceTracks = maintenanceTracksBuffer
            } else {
                maintenanceTracks = []
            }
        } else {
            maintenanceTracks = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeClusterVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterVersionsInput>
    public typealias MOutput = OperationOutput<DescribeClusterVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterVersionsOutputError>
}

extension DescribeClusterVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterVersionsInput(clusterParameterGroupFamily: \(String(describing: clusterParameterGroupFamily)), clusterVersion: \(String(describing: clusterVersion)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeClusterVersionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterParameterGroupFamily = clusterParameterGroupFamily {
            try container.encode(clusterParameterGroupFamily, forKey: Key("ClusterParameterGroupFamily"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeClusterVersions", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClusterVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterVersionsInput>
    public typealias MOutput = OperationOutput<DescribeClusterVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterVersionsOutputError>
}

public struct DescribeClusterVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterVersionsInput>
    public typealias MOutput = OperationOutput<DescribeClusterVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterVersionsOutputError>
}

/// <p></p>
public struct DescribeClusterVersionsInput: Equatable {
    /// <p>The name of a specific cluster parameter group family to return details
    ///             for.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let clusterParameterGroupFamily: String?
    /// <p>The specific cluster version to return.</p>
    ///         <p>Example: <code>1.0</code>
    ///         </p>
    public let clusterVersion: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusterVersions</a> request exceed
    ///             the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        clusterParameterGroupFamily: String? = nil,
        clusterVersion: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.clusterParameterGroupFamily = clusterParameterGroupFamily
        self.clusterVersion = clusterVersion
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeClusterVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClusterVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterVersionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterVersionsOutputResponse(clusterVersions: \(String(describing: clusterVersions)), marker: \(String(describing: marker)))"}
}

extension DescribeClusterVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterVersions = output.clusterVersions
            self.marker = output.marker
        } else {
            self.clusterVersions = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusterVersions</a> action.
///         </p>
public struct DescribeClusterVersionsOutputResponse: Equatable {
    /// <p>A list of <code>Version</code> elements. </p>
    public let clusterVersions: [ClusterVersion]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        clusterVersions: [ClusterVersion]? = nil,
        marker: String? = nil
    )
    {
        self.clusterVersions = clusterVersions
        self.marker = marker
    }
}

struct DescribeClusterVersionsOutputResponseBody: Equatable {
    public let marker: String?
    public let clusterVersions: [ClusterVersion]?
}

extension DescribeClusterVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterVersions = "ClusterVersions"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClusterVersionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusterVersions) {
            struct KeyVal0{struct ClusterVersion{}}
            let clusterVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterVersion>.CodingKeys.self, forKey: .clusterVersions)
            if let clusterVersionsWrappedContainer = clusterVersionsWrappedContainer {
                let clusterVersionsContainer = try clusterVersionsWrappedContainer.decodeIfPresent([ClusterVersion].self, forKey: .member)
                var clusterVersionsBuffer:[ClusterVersion]? = nil
                if let clusterVersionsContainer = clusterVersionsContainer {
                    clusterVersionsBuffer = [ClusterVersion]()
                    for structureContainer0 in clusterVersionsContainer {
                        clusterVersionsBuffer?.append(structureContainer0)
                    }
                }
                clusterVersions = clusterVersionsBuffer
            } else {
                clusterVersions = []
            }
        } else {
            clusterVersions = nil
        }
    }
}

public struct DescribeClustersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

extension DescribeClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClustersInput(clusterIdentifier: \(String(describing: clusterIdentifier)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeClustersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeClusters", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeClustersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

/// <p></p>
public struct DescribeClustersInput: Equatable {
    /// <p>The unique identifier of a cluster whose properties you are requesting. This
    ///             parameter is case sensitive.</p>
    ///         <p>The default is that all clusters defined for an account are returned.</p>
    public let clusterIdentifier: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeClusters</a> request exceed the
    ///             value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A tag key or keys for which you want to return all matching clusters that are
    ///             associated with the specified key or keys. For example, suppose that you have clusters
    ///             that are tagged with keys called <code>owner</code> and <code>environment</code>. If you
    ///             specify both of these tag keys in the request, Amazon Redshift returns a response with the
    ///             clusters that have either or both of these tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching clusters that are
    ///             associated with the specified tag value or values. For example, suppose that you have
    ///             clusters that are tagged with values called <code>admin</code> and <code>test</code>. If
    ///             you specify both of these tag values in the request, Amazon Redshift returns a response with
    ///             the clusters that have either or both of these tag values associated with
    ///             them.</p>
    public let tagValues: [String]?

    public init (
        clusterIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClustersOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClustersOutputResponse(clusters: \(String(describing: clusters)), marker: \(String(describing: marker)))"}
}

extension DescribeClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusters = output.clusters
            self.marker = output.marker
        } else {
            self.clusters = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeClusters</a> action. </p>
public struct DescribeClustersOutputResponse: Equatable {
    /// <p>A list of <code>Cluster</code> objects, where each object describes one cluster.
    ///         </p>
    public let clusters: [Cluster]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        clusters: [Cluster]? = nil,
        marker: String? = nil
    )
    {
        self.clusters = clusters
        self.marker = marker
    }
}

struct DescribeClustersOutputResponseBody: Equatable {
    public let marker: String?
    public let clusters: [Cluster]?
}

extension DescribeClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusters = "Clusters"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.clusters) {
            struct KeyVal0{struct Cluster{}}
            let clustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Cluster>.CodingKeys.self, forKey: .clusters)
            if let clustersWrappedContainer = clustersWrappedContainer {
                let clustersContainer = try clustersWrappedContainer.decodeIfPresent([Cluster].self, forKey: .member)
                var clustersBuffer:[Cluster]? = nil
                if let clustersContainer = clustersContainer {
                    clustersBuffer = [Cluster]()
                    for structureContainer0 in clustersContainer {
                        clustersBuffer?.append(structureContainer0)
                    }
                }
                clusters = clustersBuffer
            } else {
                clusters = []
            }
        } else {
            clusters = nil
        }
    }
}

public struct DescribeDefaultClusterParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDefaultClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultClusterParametersOutputError>
}

extension DescribeDefaultClusterParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultClusterParametersInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), parameterGroupFamily: \(String(describing: parameterGroupFamily)))"}
}

extension DescribeDefaultClusterParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let parameterGroupFamily = parameterGroupFamily {
            try container.encode(parameterGroupFamily, forKey: Key("ParameterGroupFamily"))
        }
        try container.encode("DescribeDefaultClusterParameters", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeDefaultClusterParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDefaultClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultClusterParametersOutputError>
}

public struct DescribeDefaultClusterParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDefaultClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultClusterParametersOutputError>
}

/// <p></p>
public struct DescribeDefaultClusterParametersInput: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeDefaultClusterParameters</a>
    ///             request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in
    ///             the <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the cluster parameter group family.</p>
    public let parameterGroupFamily: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        parameterGroupFamily: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.parameterGroupFamily = parameterGroupFamily
    }
}

extension DescribeDefaultClusterParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDefaultClusterParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultClusterParametersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultClusterParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultClusterParametersOutputResponse(defaultClusterParameters: \(String(describing: defaultClusterParameters)))"}
}

extension DescribeDefaultClusterParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDefaultClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultClusterParameters = output.defaultClusterParameters
        } else {
            self.defaultClusterParameters = nil
        }
    }
}

public struct DescribeDefaultClusterParametersOutputResponse: Equatable {
    /// <p>Describes the default cluster parameters for a parameter group family.</p>
    public let defaultClusterParameters: DefaultClusterParameters?

    public init (
        defaultClusterParameters: DefaultClusterParameters? = nil
    )
    {
        self.defaultClusterParameters = defaultClusterParameters
    }
}

struct DescribeDefaultClusterParametersOutputResponseBody: Equatable {
    public let defaultClusterParameters: DefaultClusterParameters?
}

extension DescribeDefaultClusterParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultClusterParameters = "DefaultClusterParameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDefaultClusterParametersResult"))
        let defaultClusterParametersDecoded = try containerValues.decodeIfPresent(DefaultClusterParameters.self, forKey: .defaultClusterParameters)
        defaultClusterParameters = defaultClusterParametersDecoded
    }
}

public struct DescribeEndpointAccessInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointAccessInput>
    public typealias MOutput = OperationOutput<DescribeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointAccessOutputError>
}

extension DescribeEndpointAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointAccessInput(clusterIdentifier: \(String(describing: clusterIdentifier)), endpointName: \(String(describing: endpointName)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), resourceOwner: \(String(describing: resourceOwner)), vpcId: \(String(describing: vpcId)))"}
}

extension DescribeEndpointAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: Key("EndpointName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: Key("ResourceOwner"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
        try container.encode("DescribeEndpointAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEndpointAccessInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointAccessInput>
    public typealias MOutput = OperationOutput<DescribeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointAccessOutputError>
}

public struct DescribeEndpointAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointAccessInput>
    public typealias MOutput = OperationOutput<DescribeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointAccessOutputError>
}

public struct DescribeEndpointAccessInput: Equatable {
    /// <p>The cluster identifier associated with the described endpoint.</p>
    public let clusterIdentifier: String?
    /// <p>The name of the endpoint to be described.</p>
    public let endpointName: String?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAccess</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///             than the specified <code>MaxRecords</code> value, a pagination token called a <code>Marker</code> is
    ///             included in the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Int?
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: String?
    /// <p>The virtual private cloud (VPC) identifier with access to the cluster.</p>
    public let vpcId: String?

    public init (
        clusterIdentifier: String? = nil,
        endpointName: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        resourceOwner: String? = nil,
        vpcId: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.endpointName = endpointName
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceOwner = resourceOwner
        self.vpcId = vpcId
    }
}

extension DescribeEndpointAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEndpointAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointAccessOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointAccessOutputResponse(endpointAccessList: \(String(describing: endpointAccessList)), marker: \(String(describing: marker)))"}
}

extension DescribeEndpointAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointAccessList = output.endpointAccessList
            self.marker = output.marker
        } else {
            self.endpointAccessList = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointAccessOutputResponse: Equatable {
    /// <p>The list of endpoints with access to the cluster.</p>
    public let endpointAccessList: [EndpointAccess]?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAccess</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: String?

    public init (
        endpointAccessList: [EndpointAccess]? = nil,
        marker: String? = nil
    )
    {
        self.endpointAccessList = endpointAccessList
        self.marker = marker
    }
}

struct DescribeEndpointAccessOutputResponseBody: Equatable {
    public let endpointAccessList: [EndpointAccess]?
    public let marker: String?
}

extension DescribeEndpointAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointAccessList = "EndpointAccessList"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEndpointAccessResult"))
        if containerValues.contains(.endpointAccessList) {
            struct KeyVal0{struct member{}}
            let endpointAccessListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endpointAccessList)
            if let endpointAccessListWrappedContainer = endpointAccessListWrappedContainer {
                let endpointAccessListContainer = try endpointAccessListWrappedContainer.decodeIfPresent([EndpointAccess].self, forKey: .member)
                var endpointAccessListBuffer:[EndpointAccess]? = nil
                if let endpointAccessListContainer = endpointAccessListContainer {
                    endpointAccessListBuffer = [EndpointAccess]()
                    for structureContainer0 in endpointAccessListContainer {
                        endpointAccessListBuffer?.append(structureContainer0)
                    }
                }
                endpointAccessList = endpointAccessListBuffer
            } else {
                endpointAccessList = []
            }
        } else {
            endpointAccessList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeEndpointAuthorizationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEndpointAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointAuthorizationInput>
    public typealias MOutput = OperationOutput<DescribeEndpointAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointAuthorizationOutputError>
}

extension DescribeEndpointAuthorizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointAuthorizationInput(account: \(String(describing: account)), clusterIdentifier: \(String(describing: clusterIdentifier)), grantee: \(String(describing: grantee)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEndpointAuthorizationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let account = account {
            try container.encode(account, forKey: Key("Account"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let grantee = grantee {
            try container.encode(grantee, forKey: Key("Grantee"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeEndpointAuthorization", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEndpointAuthorizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointAuthorizationInput>
    public typealias MOutput = OperationOutput<DescribeEndpointAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointAuthorizationOutputError>
}

public struct DescribeEndpointAuthorizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointAuthorizationInput>
    public typealias MOutput = OperationOutput<DescribeEndpointAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointAuthorizationOutputError>
}

public struct DescribeEndpointAuthorizationInput: Equatable {
    /// <p>The AWS account ID of either the cluster owner (grantor) or grantee.
    ///        If <code>Grantee</code> parameter is true, then the <code>Account</code> value is of the grantor.</p>
    public let account: String?
    /// <p>The cluster identifier of the cluster to access.</p>
    public let clusterIdentifier: String?
    /// <p>Indicates whether to check authorization from a grantor or grantee point of view.
    ///            If true, Amazon Redshift returns endpoint authorizations that you've been granted.
    ///            If false (default), checks authorization from a grantor point of view.</p>
    public let grantee: Bool?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAuthorization</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///             than the specified <code>MaxRecords</code> value, a pagination token called a <code>Marker</code> is
    ///             included in the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Int?

    public init (
        account: String? = nil,
        clusterIdentifier: String? = nil,
        grantee: Bool? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.account = account
        self.clusterIdentifier = clusterIdentifier
        self.grantee = grantee
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEndpointAuthorizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEndpointAuthorizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointAuthorizationOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointAuthorizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointAuthorizationOutputResponse(endpointAuthorizationList: \(String(describing: endpointAuthorizationList)), marker: \(String(describing: marker)))"}
}

extension DescribeEndpointAuthorizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointAuthorizationList = output.endpointAuthorizationList
            self.marker = output.marker
        } else {
            self.endpointAuthorizationList = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointAuthorizationOutputResponse: Equatable {
    /// <p>The authorizations to an endpoint.</p>
    public let endpointAuthorizationList: [EndpointAuthorization]?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeEndpointAuthorization</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///             <code>MaxRecords</code> parameter.</p>
    public let marker: String?

    public init (
        endpointAuthorizationList: [EndpointAuthorization]? = nil,
        marker: String? = nil
    )
    {
        self.endpointAuthorizationList = endpointAuthorizationList
        self.marker = marker
    }
}

struct DescribeEndpointAuthorizationOutputResponseBody: Equatable {
    public let endpointAuthorizationList: [EndpointAuthorization]?
    public let marker: String?
}

extension DescribeEndpointAuthorizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointAuthorizationList = "EndpointAuthorizationList"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEndpointAuthorizationResult"))
        if containerValues.contains(.endpointAuthorizationList) {
            struct KeyVal0{struct member{}}
            let endpointAuthorizationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endpointAuthorizationList)
            if let endpointAuthorizationListWrappedContainer = endpointAuthorizationListWrappedContainer {
                let endpointAuthorizationListContainer = try endpointAuthorizationListWrappedContainer.decodeIfPresent([EndpointAuthorization].self, forKey: .member)
                var endpointAuthorizationListBuffer:[EndpointAuthorization]? = nil
                if let endpointAuthorizationListContainer = endpointAuthorizationListContainer {
                    endpointAuthorizationListBuffer = [EndpointAuthorization]()
                    for structureContainer0 in endpointAuthorizationListContainer {
                        endpointAuthorizationListBuffer?.append(structureContainer0)
                    }
                }
                endpointAuthorizationList = endpointAuthorizationListBuffer
            } else {
                endpointAuthorizationList = []
            }
        } else {
            endpointAuthorizationList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesInput(sourceType: \(String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        try container.encode("DescribeEventCategories", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

/// <p></p>
public struct DescribeEventCategoriesInput: Equatable {
    /// <p>The source type, such as cluster or parameter group, to which the described event
    ///             categories apply.</p>
    ///         <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
    public let sourceType: String?

    public init (
        sourceType: String? = nil
    )
    {
        self.sourceType = sourceType
    }
}

extension DescribeEventCategoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesOutputResponse(eventCategoriesMapList: \(String(describing: eventCategoriesMapList)))"}
}

extension DescribeEventCategoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventCategoriesMapList = output.eventCategoriesMapList
        } else {
            self.eventCategoriesMapList = nil
        }
    }
}

/// <p></p>
public struct DescribeEventCategoriesOutputResponse: Equatable {
    /// <p>A list of event categories descriptions.</p>
    public let eventCategoriesMapList: [EventCategoriesMap]?

    public init (
        eventCategoriesMapList: [EventCategoriesMap]? = nil
    )
    {
        self.eventCategoriesMapList = eventCategoriesMapList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Equatable {
    public let eventCategoriesMapList: [EventCategoriesMap]?
}

extension DescribeEventCategoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventCategoriesMapList = "EventCategoriesMapList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventCategoriesResult"))
        if containerValues.contains(.eventCategoriesMapList) {
            struct KeyVal0{struct EventCategoriesMap{}}
            let eventCategoriesMapListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategoriesMap>.CodingKeys.self, forKey: .eventCategoriesMapList)
            if let eventCategoriesMapListWrappedContainer = eventCategoriesMapListWrappedContainer {
                let eventCategoriesMapListContainer = try eventCategoriesMapListWrappedContainer.decodeIfPresent([EventCategoriesMap].self, forKey: .member)
                var eventCategoriesMapListBuffer:[EventCategoriesMap]? = nil
                if let eventCategoriesMapListContainer = eventCategoriesMapListContainer {
                    eventCategoriesMapListBuffer = [EventCategoriesMap]()
                    for structureContainer0 in eventCategoriesMapListContainer {
                        eventCategoriesMapListBuffer?.append(structureContainer0)
                    }
                }
                eventCategoriesMapList = eventCategoriesMapListBuffer
            } else {
                eventCategoriesMapList = []
            }
        } else {
            eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), subscriptionName: \(String(describing: subscriptionName)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeEventSubscriptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeEventSubscriptions", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

/// <p></p>
public struct DescribeEventSubscriptionsInput: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a DescribeEventSubscriptions request exceed the value
    ///             specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code>
    ///             field of the response. You can retrieve the next set of response records by providing
    ///             the returned marker value in the <code>Marker</code> parameter and retrying the request.
    ///         </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the Amazon Redshift event notification subscription to be
    ///             described.</p>
    public let subscriptionName: String?
    /// <p>A tag key or keys for which you want to return all matching event notification
    ///             subscriptions that are associated with the specified key or keys. For example, suppose
    ///             that you have subscriptions that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the subscriptions that have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching event notification
    ///             subscriptions that are associated with the specified tag value or values. For example,
    ///             suppose that you have subscriptions that are tagged with values called
    ///                 <code>admin</code> and <code>test</code>. If you specify both of these tag values in
    ///             the request, Amazon Redshift returns a response with the subscriptions that have either or
    ///             both of these tag values associated with them.</p>
    public let tagValues: [String]?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        subscriptionName: String? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeEventSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Equatable {
    case invalidTagFault(InvalidTagFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(String(describing: eventSubscriptionsList)), marker: \(String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventSubscriptionsOutputResponse: Equatable {
    /// <p>A list of event subscriptions.</p>
    public let eventSubscriptionsList: [EventSubscription]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        eventSubscriptionsList: [EventSubscription]? = nil,
        marker: String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Equatable {
    public let marker: String?
    public let eventSubscriptionsList: [EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventSubscriptionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.eventSubscriptionsList) {
            struct KeyVal0{struct EventSubscription{}}
            let eventSubscriptionsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventSubscription>.CodingKeys.self, forKey: .eventSubscriptionsList)
            if let eventSubscriptionsListWrappedContainer = eventSubscriptionsListWrappedContainer {
                let eventSubscriptionsListContainer = try eventSubscriptionsListWrappedContainer.decodeIfPresent([EventSubscription].self, forKey: .member)
                var eventSubscriptionsListBuffer:[EventSubscription]? = nil
                if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
                    eventSubscriptionsListBuffer = [EventSubscription]()
                    for structureContainer0 in eventSubscriptionsListContainer {
                        eventSubscriptionsListBuffer?.append(structureContainer0)
                    }
                }
                eventSubscriptionsList = eventSubscriptionsListBuffer
            } else {
                eventSubscriptionsList = []
            }
        } else {
            eventSubscriptionsList = nil
        }
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(duration: \(String(describing: duration)), endTime: \(String(describing: endTime)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)), startTime: \(String(describing: startTime)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        try container.encode("DescribeEvents", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

/// <p></p>
public struct DescribeEventsInput: Equatable {
    /// <p>The number of minutes prior to the time of the request for which to retrieve
    ///             events. For example, if the request is sent at 18:00 and you specify a duration of 60,
    ///             then only events which have occurred after 17:00 will be returned.</p>
    ///         <p>Default: <code>60</code>
    ///         </p>
    public let duration: Int?
    /// <p>The end of the time interval for which to retrieve events, specified in ISO 8601
    ///             format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///         </p>
    ///         <p>Example: <code>2009-07-08T18:00Z</code>
    ///         </p>
    public let endTime: Date?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeEvents</a> request exceed the value
    ///             specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code>
    ///             field of the response. You can retrieve the next set of response records by providing
    ///             the returned marker value in the <code>Marker</code> parameter and retrying the request.
    ///         </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The identifier of the event source for which events will be returned. If this
    ///             parameter is not specified, then all sources are included in the response.</p>
    ///         <p>Constraints:</p>
    ///         <p>If <i>SourceIdentifier</i> is supplied,
    ///                 <i>SourceType</i> must also be provided.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Specify a cluster identifier when <i>SourceType</i> is
    ///                         <code>cluster</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify a cluster security group name when <i>SourceType</i>
    ///                     is <code>cluster-security-group</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify a cluster parameter group name when <i>SourceType</i>
    ///                     is <code>cluster-parameter-group</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify a cluster snapshot identifier when <i>SourceType</i>
    ///                     is <code>cluster-snapshot</code>.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: String?
    /// <p>The event source to retrieve events for. If no value is specified, all events are
    ///             returned.</p>
    ///         <p>Constraints:</p>
    ///         <p>If <i>SourceType</i> is supplied,
    ///                 <i>SourceIdentifier</i> must also be provided.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is
    ///                     a cluster identifier.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>cluster-security-group</code> when
    ///                         <i>SourceIdentifier</i> is a cluster security group
    ///                     name.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>cluster-parameter-group</code> when
    ///                         <i>SourceIdentifier</i> is a cluster parameter group
    ///                     name.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>cluster-snapshot</code> when
    ///                         <i>SourceIdentifier</i> is a cluster snapshot
    ///                     identifier.</p>
    ///             </li>
    ///          </ul>
    public let sourceType: SourceType?
    /// <p>The beginning of the time interval to retrieve events for, specified in ISO 8601
    ///             format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///         </p>
    ///         <p>Example: <code>2009-07-08T18:00Z</code>
    ///         </p>
    public let startTime: Date?

    public init (
        duration: Int? = nil,
        endTime: Date? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil,
        startTime: Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(events: \(String(describing: events)), marker: \(String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventsOutputResponse: Equatable {
    /// <p>A list of <code>Event</code> instances. </p>
    public let events: [Event]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        events: [Event]? = nil,
        marker: String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let marker: String?
    public let events: [Event]?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct Event{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Event>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([Event].self, forKey: .member)
                var eventsBuffer:[Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [Event]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

public struct DescribeHsmClientCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeHsmClientCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmClientCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmClientCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeHsmClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmClientCertificatesOutputError>
}

extension DescribeHsmClientCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHsmClientCertificatesInput(hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeHsmClientCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeHsmClientCertificates", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeHsmClientCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHsmClientCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmClientCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmClientCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeHsmClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmClientCertificatesOutputError>
}

public struct DescribeHsmClientCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHsmClientCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmClientCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmClientCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeHsmClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmClientCertificatesOutputError>
}

/// <p></p>
public struct DescribeHsmClientCertificatesInput: Equatable {
    /// <p>The identifier of a specific HSM client certificate for which you want information.
    ///             If no identifier is specified, information is returned for all HSM client certificates
    ///             owned by your AWS customer account.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeHsmClientCertificates</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A tag key or keys for which you want to return all matching HSM client certificates
    ///             that are associated with the specified key or keys. For example, suppose that you have
    ///             HSM client certificates that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the HSM client certificates that have either or both
    ///             of these tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching HSM client
    ///             certificates that are associated with the specified tag value or values. For example,
    ///             suppose that you have HSM client certificates that are tagged with values called
    ///                 <code>admin</code> and <code>test</code>. If you specify both of these tag values in
    ///             the request, Amazon Redshift returns a response with the HSM client certificates that have
    ///             either or both of these tag values associated with them.</p>
    public let tagValues: [String]?

    public init (
        hsmClientCertificateIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeHsmClientCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeHsmClientCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHsmClientCertificatesOutputError: Equatable {
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHsmClientCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHsmClientCertificatesOutputResponse(hsmClientCertificates: \(String(describing: hsmClientCertificates)), marker: \(String(describing: marker)))"}
}

extension DescribeHsmClientCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHsmClientCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hsmClientCertificates = output.hsmClientCertificates
            self.marker = output.marker
        } else {
            self.hsmClientCertificates = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeHsmClientCertificatesOutputResponse: Equatable {
    /// <p>A list of the identifiers for one or more HSM client certificates used by Amazon Redshift
    ///             clusters to store and retrieve database encryption keys in an HSM.</p>
    public let hsmClientCertificates: [HsmClientCertificate]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        hsmClientCertificates: [HsmClientCertificate]? = nil,
        marker: String? = nil
    )
    {
        self.hsmClientCertificates = hsmClientCertificates
        self.marker = marker
    }
}

struct DescribeHsmClientCertificatesOutputResponseBody: Equatable {
    public let marker: String?
    public let hsmClientCertificates: [HsmClientCertificate]?
}

extension DescribeHsmClientCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmClientCertificates = "HsmClientCertificates"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeHsmClientCertificatesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.hsmClientCertificates) {
            struct KeyVal0{struct HsmClientCertificate{}}
            let hsmClientCertificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.HsmClientCertificate>.CodingKeys.self, forKey: .hsmClientCertificates)
            if let hsmClientCertificatesWrappedContainer = hsmClientCertificatesWrappedContainer {
                let hsmClientCertificatesContainer = try hsmClientCertificatesWrappedContainer.decodeIfPresent([HsmClientCertificate].self, forKey: .member)
                var hsmClientCertificatesBuffer:[HsmClientCertificate]? = nil
                if let hsmClientCertificatesContainer = hsmClientCertificatesContainer {
                    hsmClientCertificatesBuffer = [HsmClientCertificate]()
                    for structureContainer0 in hsmClientCertificatesContainer {
                        hsmClientCertificatesBuffer?.append(structureContainer0)
                    }
                }
                hsmClientCertificates = hsmClientCertificatesBuffer
            } else {
                hsmClientCertificates = []
            }
        } else {
            hsmClientCertificates = nil
        }
    }
}

public struct DescribeHsmConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeHsmConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeHsmConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmConfigurationsOutputError>
}

extension DescribeHsmConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHsmConfigurationsInput(hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeHsmConfigurationsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeHsmConfigurations", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeHsmConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHsmConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeHsmConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmConfigurationsOutputError>
}

public struct DescribeHsmConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHsmConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeHsmConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmConfigurationsOutputError>
}

/// <p></p>
public struct DescribeHsmConfigurationsInput: Equatable {
    /// <p>The identifier of a specific Amazon Redshift HSM configuration to be described. If no
    ///             identifier is specified, information is returned for all HSM configurations owned by
    ///             your AWS customer account.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeHsmConfigurations</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A tag key or keys for which you want to return all matching HSM configurations that
    ///             are associated with the specified key or keys. For example, suppose that you have HSM
    ///             configurations that are tagged with keys called <code>owner</code> and
    ///                 <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the HSM configurations that have either or both of
    ///             these tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching HSM configurations
    ///             that are associated with the specified tag value or values. For example, suppose that
    ///             you have HSM configurations that are tagged with values called <code>admin</code> and
    ///                 <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the HSM configurations that have either or both of these tag
    ///             values associated with them.</p>
    public let tagValues: [String]?

    public init (
        hsmConfigurationIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeHsmConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeHsmConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHsmConfigurationsOutputError: Equatable {
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case invalidTagFault(InvalidTagFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHsmConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHsmConfigurationsOutputResponse(hsmConfigurations: \(String(describing: hsmConfigurations)), marker: \(String(describing: marker)))"}
}

extension DescribeHsmConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHsmConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hsmConfigurations = output.hsmConfigurations
            self.marker = output.marker
        } else {
            self.hsmConfigurations = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeHsmConfigurationsOutputResponse: Equatable {
    /// <p>A list of <code>HsmConfiguration</code> objects.</p>
    public let hsmConfigurations: [HsmConfiguration]?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?

    public init (
        hsmConfigurations: [HsmConfiguration]? = nil,
        marker: String? = nil
    )
    {
        self.hsmConfigurations = hsmConfigurations
        self.marker = marker
    }
}

struct DescribeHsmConfigurationsOutputResponseBody: Equatable {
    public let marker: String?
    public let hsmConfigurations: [HsmConfiguration]?
}

extension DescribeHsmConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmConfigurations = "HsmConfigurations"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeHsmConfigurationsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.hsmConfigurations) {
            struct KeyVal0{struct HsmConfiguration{}}
            let hsmConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.HsmConfiguration>.CodingKeys.self, forKey: .hsmConfigurations)
            if let hsmConfigurationsWrappedContainer = hsmConfigurationsWrappedContainer {
                let hsmConfigurationsContainer = try hsmConfigurationsWrappedContainer.decodeIfPresent([HsmConfiguration].self, forKey: .member)
                var hsmConfigurationsBuffer:[HsmConfiguration]? = nil
                if let hsmConfigurationsContainer = hsmConfigurationsContainer {
                    hsmConfigurationsBuffer = [HsmConfiguration]()
                    for structureContainer0 in hsmConfigurationsContainer {
                        hsmConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                hsmConfigurations = hsmConfigurationsBuffer
            } else {
                hsmConfigurations = []
            }
        } else {
            hsmConfigurations = nil
        }
    }
}

public struct DescribeLoggingStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoggingStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingStatusInput>
    public typealias MOutput = OperationOutput<DescribeLoggingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingStatusOutputError>
}

extension DescribeLoggingStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingStatusInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension DescribeLoggingStatusInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("DescribeLoggingStatus", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeLoggingStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoggingStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingStatusInput>
    public typealias MOutput = OperationOutput<DescribeLoggingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingStatusOutputError>
}

public struct DescribeLoggingStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoggingStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingStatusInput>
    public typealias MOutput = OperationOutput<DescribeLoggingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingStatusOutputError>
}

/// <p></p>
public struct DescribeLoggingStatusInput: Equatable {
    /// <p>The identifier of the cluster from which to get the logging status.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DescribeLoggingStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoggingStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingStatusOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingStatusOutputResponse(bucketName: \(String(describing: bucketName)), lastFailureMessage: \(String(describing: lastFailureMessage)), lastFailureTime: \(String(describing: lastFailureTime)), lastSuccessfulDeliveryTime: \(String(describing: lastSuccessfulDeliveryTime)), loggingEnabled: \(String(describing: loggingEnabled)), s3KeyPrefix: \(String(describing: s3KeyPrefix)))"}
}

extension DescribeLoggingStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoggingStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucketName = output.bucketName
            self.lastFailureMessage = output.lastFailureMessage
            self.lastFailureTime = output.lastFailureTime
            self.lastSuccessfulDeliveryTime = output.lastSuccessfulDeliveryTime
            self.loggingEnabled = output.loggingEnabled
            self.s3KeyPrefix = output.s3KeyPrefix
        } else {
            self.bucketName = nil
            self.lastFailureMessage = nil
            self.lastFailureTime = nil
            self.lastSuccessfulDeliveryTime = nil
            self.loggingEnabled = false
            self.s3KeyPrefix = nil
        }
    }
}

/// <p>Describes the status of logging for a cluster.</p>
public struct DescribeLoggingStatusOutputResponse: Equatable {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    public let bucketName: String?
    /// <p>The message indicating that logs failed to be delivered.</p>
    public let lastFailureMessage: String?
    /// <p>The last time when logs failed to be delivered.</p>
    public let lastFailureTime: Date?
    /// <p>The last time that logs were delivered.</p>
    public let lastSuccessfulDeliveryTime: Date?
    /// <p>
    ///             <code>true</code> if logging is on, <code>false</code> if logging is off.</p>
    public let loggingEnabled: Bool
    /// <p>The prefix applied to the log file names.</p>
    public let s3KeyPrefix: String?

    public init (
        bucketName: String? = nil,
        lastFailureMessage: String? = nil,
        lastFailureTime: Date? = nil,
        lastSuccessfulDeliveryTime: Date? = nil,
        loggingEnabled: Bool = false,
        s3KeyPrefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.lastFailureMessage = lastFailureMessage
        self.lastFailureTime = lastFailureTime
        self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
        self.loggingEnabled = loggingEnabled
        self.s3KeyPrefix = s3KeyPrefix
    }
}

struct DescribeLoggingStatusOutputResponseBody: Equatable {
    public let loggingEnabled: Bool
    public let bucketName: String?
    public let s3KeyPrefix: String?
    public let lastSuccessfulDeliveryTime: Date?
    public let lastFailureTime: Date?
    public let lastFailureMessage: String?
}

extension DescribeLoggingStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case lastFailureMessage = "LastFailureMessage"
        case lastFailureTime = "LastFailureTime"
        case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
        case loggingEnabled = "LoggingEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeLoggingStatusResult"))
        let loggingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let lastSuccessfulDeliveryTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSuccessfulDeliveryTime)
        var lastSuccessfulDeliveryTimeBuffer:Date? = nil
        if let lastSuccessfulDeliveryTimeDecoded = lastSuccessfulDeliveryTimeDecoded {
            lastSuccessfulDeliveryTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastSuccessfulDeliveryTimeDecoded, format: .dateTime)
        }
        lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTimeBuffer
        let lastFailureTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureTime)
        var lastFailureTimeBuffer:Date? = nil
        if let lastFailureTimeDecoded = lastFailureTimeDecoded {
            lastFailureTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastFailureTimeDecoded, format: .dateTime)
        }
        lastFailureTime = lastFailureTimeBuffer
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

public struct DescribeNodeConfigurationOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeNodeConfigurationOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNodeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNodeConfigurationOptionsInput>
    public typealias MOutput = OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNodeConfigurationOptionsOutputError>
}

extension DescribeNodeConfigurationOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNodeConfigurationOptionsInput(actionType: \(String(describing: actionType)), clusterIdentifier: \(String(describing: clusterIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), ownerAccount: \(String(describing: ownerAccount)), snapshotIdentifier: \(String(describing: snapshotIdentifier)))"}
}

extension DescribeNodeConfigurationOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionType = actionType {
            try container.encode(actionType, forKey: Key("ActionType"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filter"))
            for (index0, nodeconfigurationoptionsfilter0) in filters.enumerated() {
                try filtersContainer.encode(nodeconfigurationoptionsfilter0, forKey: Key("NodeConfigurationOptionsFilter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: Key("OwnerAccount"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        try container.encode("DescribeNodeConfigurationOptions", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeNodeConfigurationOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNodeConfigurationOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNodeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNodeConfigurationOptionsInput>
    public typealias MOutput = OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNodeConfigurationOptionsOutputError>
}

public struct DescribeNodeConfigurationOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNodeConfigurationOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNodeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNodeConfigurationOptionsInput>
    public typealias MOutput = OperationOutput<DescribeNodeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNodeConfigurationOptionsOutputError>
}

public struct DescribeNodeConfigurationOptionsInput: Equatable {
    /// <p>The action type to evaluate for possible node configurations.
    ///             Specify "restore-cluster" to get configuration combinations based on an existing snapshot.
    ///             Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot.
    ///             Specify "resize-cluster" to get configuration combinations for elastic resize based on an existing cluster.
    ///         </p>
    public let actionType: ActionType?
    /// <p>The identifier of the cluster to evaluate for possible node configurations.</p>
    public let clusterIdentifier: String?
    /// <p>A set of name, operator, and value items to filter the results.</p>
    public let filters: [NodeConfigurationOptionsFilter]?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeNodeConfigurationOptions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>500</code>
    ///         </p>
    ///         <p>Constraints: minimum 100, maximum 500.</p>
    public let maxRecords: Int?
    /// <p>The AWS customer account used to create or copy the snapshot.
    ///             Required if you are restoring a snapshot you do not own,
    ///             optional if you own the snapshot.</p>
    public let ownerAccount: String?
    /// <p>The identifier of the snapshot to evaluate for possible node configurations.</p>
    public let snapshotIdentifier: String?

    public init (
        actionType: ActionType? = nil,
        clusterIdentifier: String? = nil,
        filters: [NodeConfigurationOptionsFilter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        ownerAccount: String? = nil,
        snapshotIdentifier: String? = nil
    )
    {
        self.actionType = actionType
        self.clusterIdentifier = clusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.ownerAccount = ownerAccount
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension DescribeNodeConfigurationOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeNodeConfigurationOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessToSnapshotDeniedFault" : self = .accessToSnapshotDeniedFault(try AccessToSnapshotDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNodeConfigurationOptionsOutputError: Equatable {
    case accessToSnapshotDeniedFault(AccessToSnapshotDeniedFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNodeConfigurationOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNodeConfigurationOptionsOutputResponse(marker: \(String(describing: marker)), nodeConfigurationOptionList: \(String(describing: nodeConfigurationOptionList)))"}
}

extension DescribeNodeConfigurationOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNodeConfigurationOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.nodeConfigurationOptionList = output.nodeConfigurationOptionList
        } else {
            self.marker = nil
            self.nodeConfigurationOptionList = nil
        }
    }
}

public struct DescribeNodeConfigurationOptionsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>A list of valid node configurations.</p>
    public let nodeConfigurationOptionList: [NodeConfigurationOption]?

    public init (
        marker: String? = nil,
        nodeConfigurationOptionList: [NodeConfigurationOption]? = nil
    )
    {
        self.marker = marker
        self.nodeConfigurationOptionList = nodeConfigurationOptionList
    }
}

struct DescribeNodeConfigurationOptionsOutputResponseBody: Equatable {
    public let nodeConfigurationOptionList: [NodeConfigurationOption]?
    public let marker: String?
}

extension DescribeNodeConfigurationOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case nodeConfigurationOptionList = "NodeConfigurationOptionList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeNodeConfigurationOptionsResult"))
        if containerValues.contains(.nodeConfigurationOptionList) {
            struct KeyVal0{struct NodeConfigurationOption{}}
            let nodeConfigurationOptionListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeConfigurationOption>.CodingKeys.self, forKey: .nodeConfigurationOptionList)
            if let nodeConfigurationOptionListWrappedContainer = nodeConfigurationOptionListWrappedContainer {
                let nodeConfigurationOptionListContainer = try nodeConfigurationOptionListWrappedContainer.decodeIfPresent([NodeConfigurationOption].self, forKey: .member)
                var nodeConfigurationOptionListBuffer:[NodeConfigurationOption]? = nil
                if let nodeConfigurationOptionListContainer = nodeConfigurationOptionListContainer {
                    nodeConfigurationOptionListBuffer = [NodeConfigurationOption]()
                    for structureContainer0 in nodeConfigurationOptionListContainer {
                        nodeConfigurationOptionListBuffer?.append(structureContainer0)
                    }
                }
                nodeConfigurationOptionList = nodeConfigurationOptionListBuffer
            } else {
                nodeConfigurationOptionList = []
            }
        } else {
            nodeConfigurationOptionList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeOrderableClusterOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrderableClusterOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableClusterOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableClusterOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableClusterOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableClusterOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableClusterOptionsOutputError>
}

extension DescribeOrderableClusterOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableClusterOptionsInput(clusterVersion: \(String(describing: clusterVersion)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), nodeType: \(String(describing: nodeType)))"}
}

extension DescribeOrderableClusterOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        try container.encode("DescribeOrderableClusterOptions", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeOrderableClusterOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrderableClusterOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableClusterOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableClusterOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableClusterOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableClusterOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableClusterOptionsOutputError>
}

public struct DescribeOrderableClusterOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrderableClusterOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableClusterOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableClusterOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableClusterOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableClusterOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableClusterOptionsOutputError>
}

/// <p></p>
public struct DescribeOrderableClusterOptionsInput: Equatable {
    /// <p>The version filter value. Specify this parameter to show only the available
    ///             offerings matching the specified version.</p>
    ///         <p>Default: All versions.</p>
    ///         <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
    public let clusterVersion: String?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeOrderableClusterOptions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The node type filter value. Specify this parameter to show only the available
    ///             offerings matching the specified node type.</p>
    public let nodeType: String?

    public init (
        clusterVersion: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        nodeType: String? = nil
    )
    {
        self.clusterVersion = clusterVersion
        self.marker = marker
        self.maxRecords = maxRecords
        self.nodeType = nodeType
    }
}

extension DescribeOrderableClusterOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOrderableClusterOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableClusterOptionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableClusterOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableClusterOptionsOutputResponse(marker: \(String(describing: marker)), orderableClusterOptions: \(String(describing: orderableClusterOptions)))"}
}

extension DescribeOrderableClusterOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrderableClusterOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.orderableClusterOptions = output.orderableClusterOptions
        } else {
            self.marker = nil
            self.orderableClusterOptions = nil
        }
    }
}

/// <p>Contains the output from the <a>DescribeOrderableClusterOptions</a>
///             action. </p>
public struct DescribeOrderableClusterOptionsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>An <code>OrderableClusterOption</code> structure containing information about
    ///             orderable options for the cluster.</p>
    public let orderableClusterOptions: [OrderableClusterOption]?

    public init (
        marker: String? = nil,
        orderableClusterOptions: [OrderableClusterOption]? = nil
    )
    {
        self.marker = marker
        self.orderableClusterOptions = orderableClusterOptions
    }
}

struct DescribeOrderableClusterOptionsOutputResponseBody: Equatable {
    public let orderableClusterOptions: [OrderableClusterOption]?
    public let marker: String?
}

extension DescribeOrderableClusterOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case orderableClusterOptions = "OrderableClusterOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeOrderableClusterOptionsResult"))
        if containerValues.contains(.orderableClusterOptions) {
            struct KeyVal0{struct OrderableClusterOption{}}
            let orderableClusterOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OrderableClusterOption>.CodingKeys.self, forKey: .orderableClusterOptions)
            if let orderableClusterOptionsWrappedContainer = orderableClusterOptionsWrappedContainer {
                let orderableClusterOptionsContainer = try orderableClusterOptionsWrappedContainer.decodeIfPresent([OrderableClusterOption].self, forKey: .member)
                var orderableClusterOptionsBuffer:[OrderableClusterOption]? = nil
                if let orderableClusterOptionsContainer = orderableClusterOptionsContainer {
                    orderableClusterOptionsBuffer = [OrderableClusterOption]()
                    for structureContainer0 in orderableClusterOptionsContainer {
                        orderableClusterOptionsBuffer?.append(structureContainer0)
                    }
                }
                orderableClusterOptions = orderableClusterOptionsBuffer
            } else {
                orderableClusterOptions = []
            }
        } else {
            orderableClusterOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePartnersInputBodyMiddleware: Middleware {
    public let id: String = "DescribePartnersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePartnersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePartnersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePartnersInput>
    public typealias MOutput = OperationOutput<DescribePartnersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePartnersOutputError>
}

extension DescribePartnersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePartnersInput(accountId: \(String(describing: accountId)), clusterIdentifier: \(String(describing: clusterIdentifier)), databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)))"}
}

extension DescribePartnersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: Key("PartnerName"))
        }
        try container.encode("DescribePartners", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribePartnersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePartnersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePartnersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePartnersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePartnersInput>
    public typealias MOutput = OperationOutput<DescribePartnersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePartnersOutputError>
}

public struct DescribePartnersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePartnersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePartnersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePartnersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePartnersInput>
    public typealias MOutput = OperationOutput<DescribePartnersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePartnersOutputError>
}

public struct DescribePartnersInput: Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: String?
    /// <p>The cluster identifier of the cluster whose partner integration is being described.</p>
    public let clusterIdentifier: String?
    /// <p>The name of the database whose partner integration is being described. If database name is not specified, then all databases in the cluster are described.</p>
    public let databaseName: String?
    /// <p>The name of the partner that is being described. If partner name is not specified, then all partner integrations are described.</p>
    public let partnerName: String?

    public init (
        accountId: String? = nil,
        clusterIdentifier: String? = nil,
        databaseName: String? = nil,
        partnerName: String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

extension DescribePartnersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePartnersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePartnersOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePartnersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePartnersOutputResponse(partnerIntegrationInfoList: \(String(describing: partnerIntegrationInfoList)))"}
}

extension DescribePartnersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePartnersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.partnerIntegrationInfoList = output.partnerIntegrationInfoList
        } else {
            self.partnerIntegrationInfoList = nil
        }
    }
}

public struct DescribePartnersOutputResponse: Equatable {
    /// <p>A list of partner integrations.</p>
    public let partnerIntegrationInfoList: [PartnerIntegrationInfo]?

    public init (
        partnerIntegrationInfoList: [PartnerIntegrationInfo]? = nil
    )
    {
        self.partnerIntegrationInfoList = partnerIntegrationInfoList
    }
}

struct DescribePartnersOutputResponseBody: Equatable {
    public let partnerIntegrationInfoList: [PartnerIntegrationInfo]?
}

extension DescribePartnersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case partnerIntegrationInfoList = "PartnerIntegrationInfoList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribePartnersResult"))
        if containerValues.contains(.partnerIntegrationInfoList) {
            struct KeyVal0{struct PartnerIntegrationInfo{}}
            let partnerIntegrationInfoListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PartnerIntegrationInfo>.CodingKeys.self, forKey: .partnerIntegrationInfoList)
            if let partnerIntegrationInfoListWrappedContainer = partnerIntegrationInfoListWrappedContainer {
                let partnerIntegrationInfoListContainer = try partnerIntegrationInfoListWrappedContainer.decodeIfPresent([PartnerIntegrationInfo].self, forKey: .member)
                var partnerIntegrationInfoListBuffer:[PartnerIntegrationInfo]? = nil
                if let partnerIntegrationInfoListContainer = partnerIntegrationInfoListContainer {
                    partnerIntegrationInfoListBuffer = [PartnerIntegrationInfo]()
                    for structureContainer0 in partnerIntegrationInfoListContainer {
                        partnerIntegrationInfoListBuffer?.append(structureContainer0)
                    }
                }
                partnerIntegrationInfoList = partnerIntegrationInfoListBuffer
            } else {
                partnerIntegrationInfoList = []
            }
        } else {
            partnerIntegrationInfoList = nil
        }
    }
}

public struct DescribeReservedNodeOfferingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReservedNodeOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedNodeOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedNodeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedNodeOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeReservedNodeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedNodeOfferingsOutputError>
}

extension DescribeReservedNodeOfferingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedNodeOfferingsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), reservedNodeOfferingId: \(String(describing: reservedNodeOfferingId)))"}
}

extension DescribeReservedNodeOfferingsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: Key("ReservedNodeOfferingId"))
        }
        try container.encode("DescribeReservedNodeOfferings", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeReservedNodeOfferingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReservedNodeOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedNodeOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedNodeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedNodeOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeReservedNodeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedNodeOfferingsOutputError>
}

public struct DescribeReservedNodeOfferingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReservedNodeOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedNodeOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedNodeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedNodeOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeReservedNodeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedNodeOfferingsOutputError>
}

/// <p></p>
public struct DescribeReservedNodeOfferingsInput: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeReservedNodeOfferings</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The unique identifier for the offering.</p>
    public let reservedNodeOfferingId: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        reservedNodeOfferingId: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.reservedNodeOfferingId = reservedNodeOfferingId
    }
}

extension DescribeReservedNodeOfferingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedNodeOfferingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedNodeOfferingsOutputError: Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedNodeOfferingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedNodeOfferingsOutputResponse(marker: \(String(describing: marker)), reservedNodeOfferings: \(String(describing: reservedNodeOfferings)))"}
}

extension DescribeReservedNodeOfferingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReservedNodeOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.reservedNodeOfferings = output.reservedNodeOfferings
        } else {
            self.marker = nil
            self.reservedNodeOfferings = nil
        }
    }
}

/// <p></p>
public struct DescribeReservedNodeOfferingsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>A list of <code>ReservedNodeOffering</code> objects.</p>
    public let reservedNodeOfferings: [ReservedNodeOffering]?

    public init (
        marker: String? = nil,
        reservedNodeOfferings: [ReservedNodeOffering]? = nil
    )
    {
        self.marker = marker
        self.reservedNodeOfferings = reservedNodeOfferings
    }
}

struct DescribeReservedNodeOfferingsOutputResponseBody: Equatable {
    public let marker: String?
    public let reservedNodeOfferings: [ReservedNodeOffering]?
}

extension DescribeReservedNodeOfferingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case reservedNodeOfferings = "ReservedNodeOfferings"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeReservedNodeOfferingsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedNodeOfferings) {
            struct KeyVal0{struct ReservedNodeOffering{}}
            let reservedNodeOfferingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedNodeOffering>.CodingKeys.self, forKey: .reservedNodeOfferings)
            if let reservedNodeOfferingsWrappedContainer = reservedNodeOfferingsWrappedContainer {
                let reservedNodeOfferingsContainer = try reservedNodeOfferingsWrappedContainer.decodeIfPresent([ReservedNodeOffering].self, forKey: .member)
                var reservedNodeOfferingsBuffer:[ReservedNodeOffering]? = nil
                if let reservedNodeOfferingsContainer = reservedNodeOfferingsContainer {
                    reservedNodeOfferingsBuffer = [ReservedNodeOffering]()
                    for structureContainer0 in reservedNodeOfferingsContainer {
                        reservedNodeOfferingsBuffer?.append(structureContainer0)
                    }
                }
                reservedNodeOfferings = reservedNodeOfferingsBuffer
            } else {
                reservedNodeOfferings = []
            }
        } else {
            reservedNodeOfferings = nil
        }
    }
}

public struct DescribeReservedNodesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReservedNodesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedNodesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedNodesInput>
    public typealias MOutput = OperationOutput<DescribeReservedNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedNodesOutputError>
}

extension DescribeReservedNodesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedNodesInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), reservedNodeId: \(String(describing: reservedNodeId)))"}
}

extension DescribeReservedNodesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: Key("ReservedNodeId"))
        }
        try container.encode("DescribeReservedNodes", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeReservedNodesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReservedNodesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedNodesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedNodesInput>
    public typealias MOutput = OperationOutput<DescribeReservedNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedNodesOutputError>
}

public struct DescribeReservedNodesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReservedNodesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedNodesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedNodesInput>
    public typealias MOutput = OperationOutput<DescribeReservedNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedNodesOutputError>
}

/// <p></p>
public struct DescribeReservedNodesInput: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeReservedNodes</a> request exceed
    ///             the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>Identifier for the node reservation.</p>
    public let reservedNodeId: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        reservedNodeId: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.reservedNodeId = reservedNodeId
    }
}

extension DescribeReservedNodesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedNodesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeNotFoundFault" : self = .reservedNodeNotFoundFault(try ReservedNodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedNodesOutputError: Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case reservedNodeNotFoundFault(ReservedNodeNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedNodesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedNodesOutputResponse(marker: \(String(describing: marker)), reservedNodes: \(String(describing: reservedNodes)))"}
}

extension DescribeReservedNodesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReservedNodesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.reservedNodes = output.reservedNodes
        } else {
            self.marker = nil
            self.reservedNodes = nil
        }
    }
}

/// <p></p>
public struct DescribeReservedNodesOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>The list of <code>ReservedNode</code> objects.</p>
    public let reservedNodes: [ReservedNode]?

    public init (
        marker: String? = nil,
        reservedNodes: [ReservedNode]? = nil
    )
    {
        self.marker = marker
        self.reservedNodes = reservedNodes
    }
}

struct DescribeReservedNodesOutputResponseBody: Equatable {
    public let marker: String?
    public let reservedNodes: [ReservedNode]?
}

extension DescribeReservedNodesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case reservedNodes = "ReservedNodes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeReservedNodesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedNodes) {
            struct KeyVal0{struct ReservedNode{}}
            let reservedNodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedNode>.CodingKeys.self, forKey: .reservedNodes)
            if let reservedNodesWrappedContainer = reservedNodesWrappedContainer {
                let reservedNodesContainer = try reservedNodesWrappedContainer.decodeIfPresent([ReservedNode].self, forKey: .member)
                var reservedNodesBuffer:[ReservedNode]? = nil
                if let reservedNodesContainer = reservedNodesContainer {
                    reservedNodesBuffer = [ReservedNode]()
                    for structureContainer0 in reservedNodesContainer {
                        reservedNodesBuffer?.append(structureContainer0)
                    }
                }
                reservedNodes = reservedNodesBuffer
            } else {
                reservedNodes = []
            }
        } else {
            reservedNodes = nil
        }
    }
}

public struct DescribeResizeInputBodyMiddleware: Middleware {
    public let id: String = "DescribeResizeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResizeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResizeInput>
    public typealias MOutput = OperationOutput<DescribeResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResizeOutputError>
}

extension DescribeResizeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResizeInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension DescribeResizeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("DescribeResize", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeResizeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResizeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResizeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResizeInput>
    public typealias MOutput = OperationOutput<DescribeResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResizeOutputError>
}

public struct DescribeResizeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResizeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResizeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResizeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResizeInput>
    public typealias MOutput = OperationOutput<DescribeResizeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResizeOutputError>
}

/// <p></p>
public struct DescribeResizeInput: Equatable {
    /// <p>The unique identifier of a cluster whose resize progress you are requesting. This
    ///             parameter is case-sensitive.</p>
    ///         <p>By default, resize operations for all clusters defined for an AWS account are
    ///             returned.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DescribeResizeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeResizeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResizeNotFoundFault" : self = .resizeNotFoundFault(try ResizeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResizeOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case resizeNotFoundFault(ResizeNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResizeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResizeOutputResponse(avgResizeRateInMegaBytesPerSecond: \(String(describing: avgResizeRateInMegaBytesPerSecond)), dataTransferProgressPercent: \(String(describing: dataTransferProgressPercent)), elapsedTimeInSeconds: \(String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(String(describing: estimatedTimeToCompletionInSeconds)), importTablesCompleted: \(String(describing: importTablesCompleted)), importTablesInProgress: \(String(describing: importTablesInProgress)), importTablesNotStarted: \(String(describing: importTablesNotStarted)), message: \(String(describing: message)), progressInMegaBytes: \(String(describing: progressInMegaBytes)), resizeType: \(String(describing: resizeType)), status: \(String(describing: status)), targetClusterType: \(String(describing: targetClusterType)), targetEncryptionType: \(String(describing: targetEncryptionType)), targetNodeType: \(String(describing: targetNodeType)), targetNumberOfNodes: \(String(describing: targetNumberOfNodes)), totalResizeDataInMegaBytes: \(String(describing: totalResizeDataInMegaBytes)))"}
}

extension DescribeResizeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResizeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.avgResizeRateInMegaBytesPerSecond = output.avgResizeRateInMegaBytesPerSecond
            self.dataTransferProgressPercent = output.dataTransferProgressPercent
            self.elapsedTimeInSeconds = output.elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = output.estimatedTimeToCompletionInSeconds
            self.importTablesCompleted = output.importTablesCompleted
            self.importTablesInProgress = output.importTablesInProgress
            self.importTablesNotStarted = output.importTablesNotStarted
            self.message = output.message
            self.progressInMegaBytes = output.progressInMegaBytes
            self.resizeType = output.resizeType
            self.status = output.status
            self.targetClusterType = output.targetClusterType
            self.targetEncryptionType = output.targetEncryptionType
            self.targetNodeType = output.targetNodeType
            self.targetNumberOfNodes = output.targetNumberOfNodes
            self.totalResizeDataInMegaBytes = output.totalResizeDataInMegaBytes
        } else {
            self.avgResizeRateInMegaBytesPerSecond = nil
            self.dataTransferProgressPercent = nil
            self.elapsedTimeInSeconds = nil
            self.estimatedTimeToCompletionInSeconds = nil
            self.importTablesCompleted = nil
            self.importTablesInProgress = nil
            self.importTablesNotStarted = nil
            self.message = nil
            self.progressInMegaBytes = nil
            self.resizeType = nil
            self.status = nil
            self.targetClusterType = nil
            self.targetEncryptionType = nil
            self.targetNodeType = nil
            self.targetNumberOfNodes = nil
            self.totalResizeDataInMegaBytes = nil
        }
    }
}

/// <p>Describes the result of a cluster resize operation.</p>
public struct DescribeResizeOutputResponse: Equatable {
    /// <p>The average rate of the resize operation over the last few minutes, measured in
    ///             megabytes per second. After the resize operation completes, this value shows the average
    ///             rate of the entire resize operation.</p>
    public let avgResizeRateInMegaBytesPerSecond: Double?
    /// <p>The percent of data transferred from source cluster to target cluster.</p>
    public let dataTransferProgressPercent: Double?
    /// <p>The amount of seconds that have elapsed since the resize operation began. After the
    ///             resize operation completes, this value shows the total actual time, in seconds, for the
    ///             resize operation.</p>
    public let elapsedTimeInSeconds: Int?
    /// <p>The estimated time remaining, in seconds, until the resize operation is complete.
    ///             This value is calculated based on the average resize rate and the estimated amount of
    ///             data remaining to be processed. Once the resize operation is complete, this value will
    ///             be 0.</p>
    public let estimatedTimeToCompletionInSeconds: Int?
    /// <p>The names of tables that have been completely imported .</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesCompleted: [String]?
    /// <p>The names of tables that are being currently imported.</p>
    ///         <p>Valid Values: List of table names.</p>
    public let importTablesInProgress: [String]?
    /// <p>The names of tables that have not been yet imported.</p>
    ///         <p>Valid Values: List of table names</p>
    public let importTablesNotStarted: [String]?
    /// <p>An optional string to provide additional details about the resize action.</p>
    public let message: String?
    /// <p>While the resize operation is in progress, this value shows the current amount of
    ///             data, in megabytes, that has been processed so far. When the resize operation is
    ///             complete, this value shows the total amount of data, in megabytes, on the cluster, which
    ///             may be more or less than TotalResizeDataInMegaBytes (the estimated total amount of data
    ///             before resize).</p>
    public let progressInMegaBytes: Int?
    /// <p>An enum with possible values of <code>ClassicResize</code> and
    ///                 <code>ElasticResize</code>. These values describe the type of resize operation being
    ///             performed. </p>
    public let resizeType: String?
    /// <p>The status of the resize operation.</p>
    ///         <p>Valid Values: <code>NONE</code> | <code>IN_PROGRESS</code> | <code>FAILED</code> |
    ///                 <code>SUCCEEDED</code> | <code>CANCELLING</code>
    ///         </p>
    public let status: String?
    /// <p>The cluster type after the resize operation is complete.</p>
    ///         <p>Valid Values: <code>multi-node</code> | <code>single-node</code>
    ///         </p>
    public let targetClusterType: String?
    /// <p>The type of encryption for the cluster after the resize is complete.</p>
    ///         <p>Possible values are <code>KMS</code> and <code>None</code>. </p>
    public let targetEncryptionType: String?
    /// <p>The node type that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNodeType: String?
    /// <p>The number of nodes that the cluster will have after the resize operation is
    ///             complete.</p>
    public let targetNumberOfNodes: Int?
    /// <p>The estimated total amount of data, in megabytes, on the cluster before the resize
    ///             operation began.</p>
    public let totalResizeDataInMegaBytes: Int?

    public init (
        avgResizeRateInMegaBytesPerSecond: Double? = nil,
        dataTransferProgressPercent: Double? = nil,
        elapsedTimeInSeconds: Int? = nil,
        estimatedTimeToCompletionInSeconds: Int? = nil,
        importTablesCompleted: [String]? = nil,
        importTablesInProgress: [String]? = nil,
        importTablesNotStarted: [String]? = nil,
        message: String? = nil,
        progressInMegaBytes: Int? = nil,
        resizeType: String? = nil,
        status: String? = nil,
        targetClusterType: String? = nil,
        targetEncryptionType: String? = nil,
        targetNodeType: String? = nil,
        targetNumberOfNodes: Int? = nil,
        totalResizeDataInMegaBytes: Int? = nil
    )
    {
        self.avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecond
        self.dataTransferProgressPercent = dataTransferProgressPercent
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
        self.importTablesCompleted = importTablesCompleted
        self.importTablesInProgress = importTablesInProgress
        self.importTablesNotStarted = importTablesNotStarted
        self.message = message
        self.progressInMegaBytes = progressInMegaBytes
        self.resizeType = resizeType
        self.status = status
        self.targetClusterType = targetClusterType
        self.targetEncryptionType = targetEncryptionType
        self.targetNodeType = targetNodeType
        self.targetNumberOfNodes = targetNumberOfNodes
        self.totalResizeDataInMegaBytes = totalResizeDataInMegaBytes
    }
}

struct DescribeResizeOutputResponseBody: Equatable {
    public let targetNodeType: String?
    public let targetNumberOfNodes: Int?
    public let targetClusterType: String?
    public let status: String?
    public let importTablesCompleted: [String]?
    public let importTablesInProgress: [String]?
    public let importTablesNotStarted: [String]?
    public let avgResizeRateInMegaBytesPerSecond: Double?
    public let totalResizeDataInMegaBytes: Int?
    public let progressInMegaBytes: Int?
    public let elapsedTimeInSeconds: Int?
    public let estimatedTimeToCompletionInSeconds: Int?
    public let resizeType: String?
    public let message: String?
    public let targetEncryptionType: String?
    public let dataTransferProgressPercent: Double?
}

extension DescribeResizeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case avgResizeRateInMegaBytesPerSecond = "AvgResizeRateInMegaBytesPerSecond"
        case dataTransferProgressPercent = "DataTransferProgressPercent"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case importTablesCompleted = "ImportTablesCompleted"
        case importTablesInProgress = "ImportTablesInProgress"
        case importTablesNotStarted = "ImportTablesNotStarted"
        case message = "Message"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case resizeType = "ResizeType"
        case status = "Status"
        case targetClusterType = "TargetClusterType"
        case targetEncryptionType = "TargetEncryptionType"
        case targetNodeType = "TargetNodeType"
        case targetNumberOfNodes = "TargetNumberOfNodes"
        case totalResizeDataInMegaBytes = "TotalResizeDataInMegaBytes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeResizeResult"))
        let targetNodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetNodeType)
        targetNodeType = targetNodeTypeDecoded
        let targetNumberOfNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .targetNumberOfNodes)
        targetNumberOfNodes = targetNumberOfNodesDecoded
        let targetClusterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetClusterType)
        targetClusterType = targetClusterTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.importTablesCompleted) {
            struct KeyVal0{struct member{}}
            let importTablesCompletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesCompleted)
            if let importTablesCompletedWrappedContainer = importTablesCompletedWrappedContainer {
                let importTablesCompletedContainer = try importTablesCompletedWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesCompletedBuffer:[String]? = nil
                if let importTablesCompletedContainer = importTablesCompletedContainer {
                    importTablesCompletedBuffer = [String]()
                    for stringContainer0 in importTablesCompletedContainer {
                        importTablesCompletedBuffer?.append(stringContainer0)
                    }
                }
                importTablesCompleted = importTablesCompletedBuffer
            } else {
                importTablesCompleted = []
            }
        } else {
            importTablesCompleted = nil
        }
        if containerValues.contains(.importTablesInProgress) {
            struct KeyVal0{struct member{}}
            let importTablesInProgressWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesInProgress)
            if let importTablesInProgressWrappedContainer = importTablesInProgressWrappedContainer {
                let importTablesInProgressContainer = try importTablesInProgressWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesInProgressBuffer:[String]? = nil
                if let importTablesInProgressContainer = importTablesInProgressContainer {
                    importTablesInProgressBuffer = [String]()
                    for stringContainer0 in importTablesInProgressContainer {
                        importTablesInProgressBuffer?.append(stringContainer0)
                    }
                }
                importTablesInProgress = importTablesInProgressBuffer
            } else {
                importTablesInProgress = []
            }
        } else {
            importTablesInProgress = nil
        }
        if containerValues.contains(.importTablesNotStarted) {
            struct KeyVal0{struct member{}}
            let importTablesNotStartedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesNotStarted)
            if let importTablesNotStartedWrappedContainer = importTablesNotStartedWrappedContainer {
                let importTablesNotStartedContainer = try importTablesNotStartedWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importTablesNotStartedBuffer:[String]? = nil
                if let importTablesNotStartedContainer = importTablesNotStartedContainer {
                    importTablesNotStartedBuffer = [String]()
                    for stringContainer0 in importTablesNotStartedContainer {
                        importTablesNotStartedBuffer?.append(stringContainer0)
                    }
                }
                importTablesNotStarted = importTablesNotStartedBuffer
            } else {
                importTablesNotStarted = []
            }
        } else {
            importTablesNotStarted = nil
        }
        let avgResizeRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .avgResizeRateInMegaBytesPerSecond)
        avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecondDecoded
        let totalResizeDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalResizeDataInMegaBytes)
        totalResizeDataInMegaBytes = totalResizeDataInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let targetEncryptionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetEncryptionType)
        targetEncryptionType = targetEncryptionTypeDecoded
        let dataTransferProgressPercentDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .dataTransferProgressPercent)
        dataTransferProgressPercent = dataTransferProgressPercentDecoded
    }
}

public struct DescribeScheduledActionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeScheduledActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScheduledActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScheduledActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScheduledActionsInput>
    public typealias MOutput = OperationOutput<DescribeScheduledActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScheduledActionsOutputError>
}

extension DescribeScheduledActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScheduledActionsInput(active: \(String(describing: active)), endTime: \(String(describing: endTime)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), scheduledActionName: \(String(describing: scheduledActionName)), startTime: \(String(describing: startTime)), targetActionType: \(String(describing: targetActionType)))"}
}

extension DescribeScheduledActionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let active = active {
            try container.encode(active, forKey: Key("Active"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, scheduledactionfilter0) in filters.enumerated() {
                try filtersContainer.encode(scheduledactionfilter0, forKey: Key("ScheduledActionFilter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let targetActionType = targetActionType {
            try container.encode(targetActionType, forKey: Key("TargetActionType"))
        }
        try container.encode("DescribeScheduledActions", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeScheduledActionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeScheduledActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScheduledActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScheduledActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScheduledActionsInput>
    public typealias MOutput = OperationOutput<DescribeScheduledActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScheduledActionsOutputError>
}

public struct DescribeScheduledActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeScheduledActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScheduledActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScheduledActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScheduledActionsInput>
    public typealias MOutput = OperationOutput<DescribeScheduledActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScheduledActionsOutputError>
}

public struct DescribeScheduledActionsInput: Equatable {
    /// <p>If true, retrieve only active scheduled actions.
    ///            If false, retrieve only disabled scheduled actions. </p>
    public let active: Bool?
    /// <p>The end time in UTC of the scheduled action to retrieve.
    ///             Only active scheduled actions that have invocations before this time are retrieved.</p>
    public let endTime: Date?
    /// <p>List of scheduled action filters. </p>
    public let filters: [ScheduledActionFilter]?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeScheduledActions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///             <p>Default: <code>100</code>
    ///             </p>
    ///             <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the scheduled action to retrieve. </p>
    public let scheduledActionName: String?
    /// <p>The start time in UTC of the scheduled actions to retrieve.
    ///             Only active scheduled actions that have invocations after this time are retrieved.</p>
    public let startTime: Date?
    /// <p>The type of the scheduled actions to retrieve. </p>
    public let targetActionType: ScheduledActionTypeValues?

    public init (
        active: Bool? = nil,
        endTime: Date? = nil,
        filters: [ScheduledActionFilter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        scheduledActionName: String? = nil,
        startTime: Date? = nil,
        targetActionType: ScheduledActionTypeValues? = nil
    )
    {
        self.active = active
        self.endTime = endTime
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetActionType = targetActionType
    }
}

extension DescribeScheduledActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeScheduledActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ScheduledActionNotFoundFault" : self = .scheduledActionNotFoundFault(try ScheduledActionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScheduledActionsOutputError: Equatable {
    case scheduledActionNotFoundFault(ScheduledActionNotFoundFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScheduledActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScheduledActionsOutputResponse(marker: \(String(describing: marker)), scheduledActions: \(String(describing: scheduledActions)))"}
}

extension DescribeScheduledActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeScheduledActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.scheduledActions = output.scheduledActions
        } else {
            self.marker = nil
            self.scheduledActions = nil
        }
    }
}

public struct DescribeScheduledActionsOutputResponse: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeScheduledActions</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>List of retrieved scheduled actions. </p>
    public let scheduledActions: [ScheduledAction]?

    public init (
        marker: String? = nil,
        scheduledActions: [ScheduledAction]? = nil
    )
    {
        self.marker = marker
        self.scheduledActions = scheduledActions
    }
}

struct DescribeScheduledActionsOutputResponseBody: Equatable {
    public let marker: String?
    public let scheduledActions: [ScheduledAction]?
}

extension DescribeScheduledActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case scheduledActions = "ScheduledActions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeScheduledActionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.scheduledActions) {
            struct KeyVal0{struct ScheduledAction{}}
            let scheduledActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledAction>.CodingKeys.self, forKey: .scheduledActions)
            if let scheduledActionsWrappedContainer = scheduledActionsWrappedContainer {
                let scheduledActionsContainer = try scheduledActionsWrappedContainer.decodeIfPresent([ScheduledAction].self, forKey: .member)
                var scheduledActionsBuffer:[ScheduledAction]? = nil
                if let scheduledActionsContainer = scheduledActionsContainer {
                    scheduledActionsBuffer = [ScheduledAction]()
                    for structureContainer0 in scheduledActionsContainer {
                        scheduledActionsBuffer?.append(structureContainer0)
                    }
                }
                scheduledActions = scheduledActionsBuffer
            } else {
                scheduledActions = []
            }
        } else {
            scheduledActions = nil
        }
    }
}

public struct DescribeSnapshotCopyGrantsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSnapshotCopyGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotCopyGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotCopyGrantsInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotCopyGrantsOutputError>
}

extension DescribeSnapshotCopyGrantsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotCopyGrantsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), snapshotCopyGrantName: \(String(describing: snapshotCopyGrantName)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeSnapshotCopyGrantsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: Key("SnapshotCopyGrantName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeSnapshotCopyGrants", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeSnapshotCopyGrantsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSnapshotCopyGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotCopyGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotCopyGrantsInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotCopyGrantsOutputError>
}

public struct DescribeSnapshotCopyGrantsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSnapshotCopyGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotCopyGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotCopyGrantsInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotCopyGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotCopyGrantsOutputError>
}

/// <p>The result of the <code>DescribeSnapshotCopyGrants</code> action.</p>
public struct DescribeSnapshotCopyGrantsInput: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the
    ///             value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the snapshot copy grant.</p>
    public let snapshotCopyGrantName: String?
    /// <p>A tag key or keys for which you want to return all matching resources that are
    ///             associated with the specified key or keys. For example, suppose that you have resources
    ///             tagged with keys called <code>owner</code> and <code>environment</code>. If you specify
    ///             both of these tag keys in the request, Amazon Redshift returns a response with all resources
    ///             that have either or both of these tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching resources that are
    ///             associated with the specified value or values. For example, suppose that you have
    ///             resources tagged with values called <code>admin</code> and <code>test</code>. If you
    ///             specify both of these tag values in the request, Amazon Redshift returns a response with all
    ///             resources that have either or both of these tag values associated with them.</p>
    public let tagValues: [String]?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        snapshotCopyGrantName: String? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotCopyGrantName = snapshotCopyGrantName
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeSnapshotCopyGrantsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSnapshotCopyGrantsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantNotFoundFault" : self = .snapshotCopyGrantNotFoundFault(try SnapshotCopyGrantNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSnapshotCopyGrantsOutputError: Equatable {
    case invalidTagFault(InvalidTagFault)
    case snapshotCopyGrantNotFoundFault(SnapshotCopyGrantNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotCopyGrantsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotCopyGrantsOutputResponse(marker: \(String(describing: marker)), snapshotCopyGrants: \(String(describing: snapshotCopyGrants)))"}
}

extension DescribeSnapshotCopyGrantsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSnapshotCopyGrantsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.snapshotCopyGrants = output.snapshotCopyGrants
        } else {
            self.marker = nil
            self.snapshotCopyGrants = nil
        }
    }
}

/// <p></p>
public struct DescribeSnapshotCopyGrantsOutputResponse: Equatable {
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the
    ///             value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///                 <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    ///         <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
    public let marker: String?
    /// <p>The list of <code>SnapshotCopyGrant</code> objects.</p>
    public let snapshotCopyGrants: [SnapshotCopyGrant]?

    public init (
        marker: String? = nil,
        snapshotCopyGrants: [SnapshotCopyGrant]? = nil
    )
    {
        self.marker = marker
        self.snapshotCopyGrants = snapshotCopyGrants
    }
}

struct DescribeSnapshotCopyGrantsOutputResponseBody: Equatable {
    public let marker: String?
    public let snapshotCopyGrants: [SnapshotCopyGrant]?
}

extension DescribeSnapshotCopyGrantsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case snapshotCopyGrants = "SnapshotCopyGrants"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeSnapshotCopyGrantsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.snapshotCopyGrants) {
            struct KeyVal0{struct SnapshotCopyGrant{}}
            let snapshotCopyGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotCopyGrant>.CodingKeys.self, forKey: .snapshotCopyGrants)
            if let snapshotCopyGrantsWrappedContainer = snapshotCopyGrantsWrappedContainer {
                let snapshotCopyGrantsContainer = try snapshotCopyGrantsWrappedContainer.decodeIfPresent([SnapshotCopyGrant].self, forKey: .member)
                var snapshotCopyGrantsBuffer:[SnapshotCopyGrant]? = nil
                if let snapshotCopyGrantsContainer = snapshotCopyGrantsContainer {
                    snapshotCopyGrantsBuffer = [SnapshotCopyGrant]()
                    for structureContainer0 in snapshotCopyGrantsContainer {
                        snapshotCopyGrantsBuffer?.append(structureContainer0)
                    }
                }
                snapshotCopyGrants = snapshotCopyGrantsBuffer
            } else {
                snapshotCopyGrants = []
            }
        } else {
            snapshotCopyGrants = nil
        }
    }
}

public struct DescribeSnapshotSchedulesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSnapshotSchedulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotSchedulesInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotSchedulesOutputError>
}

extension DescribeSnapshotSchedulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotSchedulesInput(clusterIdentifier: \(String(describing: clusterIdentifier)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), scheduleIdentifier: \(String(describing: scheduleIdentifier)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeSnapshotSchedulesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: Key("ScheduleIdentifier"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeSnapshotSchedules", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeSnapshotSchedulesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSnapshotSchedulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotSchedulesInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotSchedulesOutputError>
}

public struct DescribeSnapshotSchedulesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSnapshotSchedulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotSchedulesInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotSchedulesOutputError>
}

public struct DescribeSnapshotSchedulesInput: Equatable {
    /// <p>The unique identifier for the cluster whose snapshot schedules you want to
    ///             view.</p>
    public let clusterIdentifier: String?
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>marker</code> parameter
    ///             and retrying the command. If the <code>marker</code> field is empty, all response
    ///             records have been retrieved for the request.</p>
    public let marker: String?
    /// <p>The maximum number or response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned <code>marker</code>
    ///             value.</p>
    public let maxRecords: Int?
    /// <p>A unique identifier for a snapshot schedule.</p>
    public let scheduleIdentifier: String?
    /// <p>The key value for a snapshot schedule tag.</p>
    public let tagKeys: [String]?
    /// <p>The value corresponding to the key of the snapshot schedule tag.</p>
    public let tagValues: [String]?

    public init (
        clusterIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        scheduleIdentifier: String? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.scheduleIdentifier = scheduleIdentifier
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeSnapshotSchedulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSnapshotSchedulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSnapshotSchedulesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotSchedulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotSchedulesOutputResponse(marker: \(String(describing: marker)), snapshotSchedules: \(String(describing: snapshotSchedules)))"}
}

extension DescribeSnapshotSchedulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSnapshotSchedulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.snapshotSchedules = output.snapshotSchedules
        } else {
            self.marker = nil
            self.snapshotSchedules = nil
        }
    }
}

public struct DescribeSnapshotSchedulesOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>marker</code> parameter
    ///             and retrying the command. If the <code>marker</code> field is empty, all response
    ///             records have been retrieved for the request.</p>
    public let marker: String?
    /// <p>A list of SnapshotSchedules.</p>
    public let snapshotSchedules: [SnapshotSchedule]?

    public init (
        marker: String? = nil,
        snapshotSchedules: [SnapshotSchedule]? = nil
    )
    {
        self.marker = marker
        self.snapshotSchedules = snapshotSchedules
    }
}

struct DescribeSnapshotSchedulesOutputResponseBody: Equatable {
    public let snapshotSchedules: [SnapshotSchedule]?
    public let marker: String?
}

extension DescribeSnapshotSchedulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case snapshotSchedules = "SnapshotSchedules"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeSnapshotSchedulesResult"))
        if containerValues.contains(.snapshotSchedules) {
            struct KeyVal0{struct SnapshotSchedule{}}
            let snapshotSchedulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotSchedule>.CodingKeys.self, forKey: .snapshotSchedules)
            if let snapshotSchedulesWrappedContainer = snapshotSchedulesWrappedContainer {
                let snapshotSchedulesContainer = try snapshotSchedulesWrappedContainer.decodeIfPresent([SnapshotSchedule].self, forKey: .member)
                var snapshotSchedulesBuffer:[SnapshotSchedule]? = nil
                if let snapshotSchedulesContainer = snapshotSchedulesContainer {
                    snapshotSchedulesBuffer = [SnapshotSchedule]()
                    for structureContainer0 in snapshotSchedulesContainer {
                        snapshotSchedulesBuffer?.append(structureContainer0)
                    }
                }
                snapshotSchedules = snapshotSchedulesBuffer
            } else {
                snapshotSchedules = []
            }
        } else {
            snapshotSchedules = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeStorageInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStorageInput>
    public typealias MOutput = OperationOutput<DescribeStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStorageOutputError>
}

extension DescribeStorageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStorageInput()"}
}

extension DescribeStorageInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("DescribeStorage", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeStorageInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStorageInput>
    public typealias MOutput = OperationOutput<DescribeStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStorageOutputError>
}

public struct DescribeStorageInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStorageInput>
    public typealias MOutput = OperationOutput<DescribeStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStorageOutputError>
}

public struct DescribeStorageInput: Equatable {

    public init() {}
}

extension DescribeStorageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStorageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStorageOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStorageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStorageOutputResponse(totalBackupSizeInMegaBytes: \(String(describing: totalBackupSizeInMegaBytes)), totalProvisionedStorageInMegaBytes: \(String(describing: totalProvisionedStorageInMegaBytes)))"}
}

extension DescribeStorageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStorageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.totalBackupSizeInMegaBytes = output.totalBackupSizeInMegaBytes
            self.totalProvisionedStorageInMegaBytes = output.totalProvisionedStorageInMegaBytes
        } else {
            self.totalBackupSizeInMegaBytes = 0.0
            self.totalProvisionedStorageInMegaBytes = 0.0
        }
    }
}

public struct DescribeStorageOutputResponse: Equatable {
    /// <p>The total amount of storage currently used for snapshots.</p>
    public let totalBackupSizeInMegaBytes: Double
    /// <p>The total amount of storage currently provisioned.</p>
    public let totalProvisionedStorageInMegaBytes: Double

    public init (
        totalBackupSizeInMegaBytes: Double = 0.0,
        totalProvisionedStorageInMegaBytes: Double = 0.0
    )
    {
        self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
        self.totalProvisionedStorageInMegaBytes = totalProvisionedStorageInMegaBytes
    }
}

struct DescribeStorageOutputResponseBody: Equatable {
    public let totalBackupSizeInMegaBytes: Double
    public let totalProvisionedStorageInMegaBytes: Double
}

extension DescribeStorageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case totalBackupSizeInMegaBytes = "TotalBackupSizeInMegaBytes"
        case totalProvisionedStorageInMegaBytes = "TotalProvisionedStorageInMegaBytes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStorageResult"))
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let totalProvisionedStorageInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .totalProvisionedStorageInMegaBytes)
        totalProvisionedStorageInMegaBytes = totalProvisionedStorageInMegaBytesDecoded
    }
}

public struct DescribeTableRestoreStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTableRestoreStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableRestoreStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableRestoreStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableRestoreStatusInput>
    public typealias MOutput = OperationOutput<DescribeTableRestoreStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableRestoreStatusOutputError>
}

extension DescribeTableRestoreStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableRestoreStatusInput(clusterIdentifier: \(String(describing: clusterIdentifier)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), tableRestoreRequestId: \(String(describing: tableRestoreRequestId)))"}
}

extension DescribeTableRestoreStatusInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let tableRestoreRequestId = tableRestoreRequestId {
            try container.encode(tableRestoreRequestId, forKey: Key("TableRestoreRequestId"))
        }
        try container.encode("DescribeTableRestoreStatus", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeTableRestoreStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTableRestoreStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableRestoreStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableRestoreStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableRestoreStatusInput>
    public typealias MOutput = OperationOutput<DescribeTableRestoreStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableRestoreStatusOutputError>
}

public struct DescribeTableRestoreStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTableRestoreStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableRestoreStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableRestoreStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableRestoreStatusInput>
    public typealias MOutput = OperationOutput<DescribeTableRestoreStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableRestoreStatusOutputError>
}

/// <p></p>
public struct DescribeTableRestoreStatusInput: Equatable {
    /// <p>The Amazon Redshift cluster that the table is being restored to.</p>
    public let clusterIdentifier: String?
    /// <p>An optional pagination token provided by a previous
    ///                 <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the
    ///             response includes only records beyond the marker, up to the value specified by the
    ///                 <code>MaxRecords</code> parameter.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///             than the specified <code>MaxRecords</code> value, a pagination token called a marker is
    ///             included in the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Int?
    /// <p>The identifier of the table restore request to return status for. If you don't
    ///             specify a <code>TableRestoreRequestId</code> value, then
    ///                 <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table
    ///             restore requests.</p>
    public let tableRestoreRequestId: String?

    public init (
        clusterIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        tableRestoreRequestId: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
        self.tableRestoreRequestId = tableRestoreRequestId
    }
}

extension DescribeTableRestoreStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTableRestoreStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TableRestoreNotFoundFault" : self = .tableRestoreNotFoundFault(try TableRestoreNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableRestoreStatusOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case tableRestoreNotFoundFault(TableRestoreNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableRestoreStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableRestoreStatusOutputResponse(marker: \(String(describing: marker)), tableRestoreStatusDetails: \(String(describing: tableRestoreStatusDetails)))"}
}

extension DescribeTableRestoreStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTableRestoreStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.tableRestoreStatusDetails = output.tableRestoreStatusDetails
        } else {
            self.marker = nil
            self.tableRestoreStatusDetails = nil
        }
    }
}

/// <p></p>
public struct DescribeTableRestoreStatusOutputResponse: Equatable {
    /// <p>A pagination token that can be used in a subsequent <a>DescribeTableRestoreStatus</a> request.</p>
    public let marker: String?
    /// <p>A list of status details for one or more table restore requests.</p>
    public let tableRestoreStatusDetails: [TableRestoreStatus]?

    public init (
        marker: String? = nil,
        tableRestoreStatusDetails: [TableRestoreStatus]? = nil
    )
    {
        self.marker = marker
        self.tableRestoreStatusDetails = tableRestoreStatusDetails
    }
}

struct DescribeTableRestoreStatusOutputResponseBody: Equatable {
    public let tableRestoreStatusDetails: [TableRestoreStatus]?
    public let marker: String?
}

extension DescribeTableRestoreStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case tableRestoreStatusDetails = "TableRestoreStatusDetails"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTableRestoreStatusResult"))
        if containerValues.contains(.tableRestoreStatusDetails) {
            struct KeyVal0{struct TableRestoreStatus{}}
            let tableRestoreStatusDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.TableRestoreStatus>.CodingKeys.self, forKey: .tableRestoreStatusDetails)
            if let tableRestoreStatusDetailsWrappedContainer = tableRestoreStatusDetailsWrappedContainer {
                let tableRestoreStatusDetailsContainer = try tableRestoreStatusDetailsWrappedContainer.decodeIfPresent([TableRestoreStatus].self, forKey: .member)
                var tableRestoreStatusDetailsBuffer:[TableRestoreStatus]? = nil
                if let tableRestoreStatusDetailsContainer = tableRestoreStatusDetailsContainer {
                    tableRestoreStatusDetailsBuffer = [TableRestoreStatus]()
                    for structureContainer0 in tableRestoreStatusDetailsContainer {
                        tableRestoreStatusDetailsBuffer?.append(structureContainer0)
                    }
                }
                tableRestoreStatusDetails = tableRestoreStatusDetailsBuffer
            } else {
                tableRestoreStatusDetails = []
            }
        } else {
            tableRestoreStatusDetails = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeTagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)))"}
}

extension DescribeTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTags", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

/// <p></p>
public struct DescribeTagsInput: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>marker</code> parameter
    ///             and retrying the command. If the <code>marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>The maximum number or response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned <code>marker</code> value.
    ///         </p>
    public let maxRecords: Int?
    /// <p>The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For
    ///             example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. </p>
    public let resourceName: String?
    /// <p>The type of resource with which you want to view tags. Valid resource types are: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cluster</p>
    ///             </li>
    ///             <li>
    ///                 <p>CIDR/IP</p>
    ///             </li>
    ///             <li>
    ///                 <p>EC2 security group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Snapshot</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cluster security group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Subnet group</p>
    ///             </li>
    ///             <li>
    ///                 <p>HSM connection</p>
    ///             </li>
    ///             <li>
    ///                 <p>HSM certificate</p>
    ///             </li>
    ///             <li>
    ///                 <p>Parameter group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Snapshot copy grant</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
    ///                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in
    ///             the Amazon Redshift Cluster Management Guide. </p>
    public let resourceType: String?
    /// <p>A tag key or keys for which you want to return all matching resources that are
    ///             associated with the specified key or keys. For example, suppose that you have resources
    ///             tagged with keys called <code>owner</code> and <code>environment</code>. If you specify
    ///             both of these tag keys in the request, Amazon Redshift returns a response with all resources
    ///             that have either or both of these tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching resources that are
    ///             associated with the specified value or values. For example, suppose that you have
    ///             resources tagged with values called <code>admin</code> and <code>test</code>. If you
    ///             specify both of these tag values in the request, Amazon Redshift returns a response with all
    ///             resources that have either or both of these tag values associated with them.</p>
    public let tagValues: [String]?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        resourceName: String? = nil,
        resourceType: String? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.tagKeys = tagKeys
        self.tagValues = tagValues
    }
}

extension DescribeTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Equatable {
    case invalidTagFault(InvalidTagFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsOutputResponse(marker: \(String(describing: marker)), taggedResources: \(String(describing: taggedResources)))"}
}

extension DescribeTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.taggedResources = output.taggedResources
        } else {
            self.marker = nil
            self.taggedResources = nil
        }
    }
}

/// <p></p>
public struct DescribeTagsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>A list of tags with their associated resources.</p>
    public let taggedResources: [TaggedResource]?

    public init (
        marker: String? = nil,
        taggedResources: [TaggedResource]? = nil
    )
    {
        self.marker = marker
        self.taggedResources = taggedResources
    }
}

struct DescribeTagsOutputResponseBody: Equatable {
    public let taggedResources: [TaggedResource]?
    public let marker: String?
}

extension DescribeTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case taggedResources = "TaggedResources"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTagsResult"))
        if containerValues.contains(.taggedResources) {
            struct KeyVal0{struct TaggedResource{}}
            let taggedResourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.TaggedResource>.CodingKeys.self, forKey: .taggedResources)
            if let taggedResourcesWrappedContainer = taggedResourcesWrappedContainer {
                let taggedResourcesContainer = try taggedResourcesWrappedContainer.decodeIfPresent([TaggedResource].self, forKey: .member)
                var taggedResourcesBuffer:[TaggedResource]? = nil
                if let taggedResourcesContainer = taggedResourcesContainer {
                    taggedResourcesBuffer = [TaggedResource]()
                    for structureContainer0 in taggedResourcesContainer {
                        taggedResourcesBuffer?.append(structureContainer0)
                    }
                }
                taggedResources = taggedResourcesBuffer
            } else {
                taggedResources = []
            }
        } else {
            taggedResources = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeUsageLimitsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUsageLimitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsageLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsageLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsageLimitsInput>
    public typealias MOutput = OperationOutput<DescribeUsageLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsageLimitsOutputError>
}

extension DescribeUsageLimitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsageLimitsInput(clusterIdentifier: \(String(describing: clusterIdentifier)), featureType: \(String(describing: featureType)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), tagKeys: \(String(describing: tagKeys)), tagValues: \(String(describing: tagValues)), usageLimitId: \(String(describing: usageLimitId)))"}
}

extension DescribeUsageLimitsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let featureType = featureType {
            try container.encode(featureType, forKey: Key("FeatureType"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("TagKey.\(index0.advanced(by: 1))"))
            }
        }
        if let tagValues = tagValues {
            var tagValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagValues"))
            for (index0, string0) in tagValues.enumerated() {
                try tagValuesContainer.encode(string0, forKey: Key("TagValue.\(index0.advanced(by: 1))"))
            }
        }
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: Key("UsageLimitId"))
        }
        try container.encode("DescribeUsageLimits", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DescribeUsageLimitsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUsageLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsageLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsageLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsageLimitsInput>
    public typealias MOutput = OperationOutput<DescribeUsageLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsageLimitsOutputError>
}

public struct DescribeUsageLimitsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUsageLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsageLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsageLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsageLimitsInput>
    public typealias MOutput = OperationOutput<DescribeUsageLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsageLimitsOutputError>
}

public struct DescribeUsageLimitsInput: Equatable {
    /// <p>The identifier of the cluster for which you want to describe usage limits.</p>
    public let clusterIdentifier: String?
    /// <p>The feature type for which you want to describe usage limits.</p>
    public let featureType: UsageLimitFeatureType?
    /// <p>An optional parameter that specifies the starting point to return a set of response
    ///             records. When the results of a <a>DescribeUsageLimits</a> request
    ///             exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the
    ///             <code>Marker</code> field of the response. You can retrieve the next set of response
    ///             records by providing the returned marker value in the <code>Marker</code> parameter and
    ///             retrying the request. </p>
    public let marker: String?
    /// <p>The maximum number of response records to return in each call. If the number of
    ///             remaining response records exceeds the specified <code>MaxRecords</code> value, a value
    ///             is returned in a <code>marker</code> field of the response. You can retrieve the next
    ///             set of records by retrying the command with the returned marker value. </p>
    ///         <p>Default: <code>100</code>
    ///         </p>
    ///         <p>Constraints: minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A tag key or keys for which you want to return all matching usage limit objects
    ///             that are associated with the specified key or keys. For example, suppose that you
    ///             have parameter groups that are tagged with keys called <code>owner</code> and
    ///             <code>environment</code>. If you specify both of these tag keys in the request,
    ///             Amazon Redshift returns a response with the usage limit objects have either or both of these
    ///             tag keys associated with them.</p>
    public let tagKeys: [String]?
    /// <p>A tag value or values for which you want to return all matching usage limit objects
    ///             that are associated with the specified tag value or values. For example, suppose
    ///             that you have parameter groups that are tagged with values called <code>admin</code> and
    ///             <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift
    ///             returns a response with the usage limit objects that have either or both of these tag
    ///             values associated with them.</p>
    public let tagValues: [String]?
    /// <p>The identifier of the usage limit to describe.</p>
    public let usageLimitId: String?

    public init (
        clusterIdentifier: String? = nil,
        featureType: UsageLimitFeatureType? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        tagKeys: [String]? = nil,
        tagValues: [String]? = nil,
        usageLimitId: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.marker = marker
        self.maxRecords = maxRecords
        self.tagKeys = tagKeys
        self.tagValues = tagValues
        self.usageLimitId = usageLimitId
    }
}

extension DescribeUsageLimitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeUsageLimitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsageLimitsOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsageLimitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsageLimitsOutputResponse(marker: \(String(describing: marker)), usageLimits: \(String(describing: usageLimits)))"}
}

extension DescribeUsageLimitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUsageLimitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.usageLimits = output.usageLimits
        } else {
            self.marker = nil
            self.usageLimits = nil
        }
    }
}

public struct DescribeUsageLimitsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a
    ///             subsequent request. If a value is returned in a response, you can retrieve the next set
    ///             of records by providing this returned marker value in the <code>Marker</code> parameter
    ///             and retrying the command. If the <code>Marker</code> field is empty, all response
    ///             records have been retrieved for the request. </p>
    public let marker: String?
    /// <p>Contains the output from the <a>DescribeUsageLimits</a>
    ///             action. </p>
    public let usageLimits: [UsageLimit]?

    public init (
        marker: String? = nil,
        usageLimits: [UsageLimit]? = nil
    )
    {
        self.marker = marker
        self.usageLimits = usageLimits
    }
}

struct DescribeUsageLimitsOutputResponseBody: Equatable {
    public let usageLimits: [UsageLimit]?
    public let marker: String?
}

extension DescribeUsageLimitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case usageLimits = "UsageLimits"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeUsageLimitsResult"))
        if containerValues.contains(.usageLimits) {
            struct KeyVal0{struct member{}}
            let usageLimitsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .usageLimits)
            if let usageLimitsWrappedContainer = usageLimitsWrappedContainer {
                let usageLimitsContainer = try usageLimitsWrappedContainer.decodeIfPresent([UsageLimit].self, forKey: .member)
                var usageLimitsBuffer:[UsageLimit]? = nil
                if let usageLimitsContainer = usageLimitsContainer {
                    usageLimitsBuffer = [UsageLimit]()
                    for structureContainer0 in usageLimitsContainer {
                        usageLimitsBuffer?.append(structureContainer0)
                    }
                }
                usageLimits = usageLimitsBuffer
            } else {
                usageLimits = []
            }
        } else {
            usageLimits = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DisableLoggingInputBodyMiddleware: Middleware {
    public let id: String = "DisableLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableLoggingInput>
    public typealias MOutput = OperationOutput<DisableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableLoggingOutputError>
}

extension DisableLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableLoggingInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension DisableLoggingInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("DisableLogging", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DisableLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "DisableLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableLoggingInput>
    public typealias MOutput = OperationOutput<DisableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableLoggingOutputError>
}

public struct DisableLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableLoggingInput>
    public typealias MOutput = OperationOutput<DisableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableLoggingOutputError>
}

/// <p></p>
public struct DisableLoggingInput: Equatable {
    /// <p>The identifier of the cluster on which logging is to be stopped.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DisableLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DisableLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableLoggingOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableLoggingOutputResponse(bucketName: \(String(describing: bucketName)), lastFailureMessage: \(String(describing: lastFailureMessage)), lastFailureTime: \(String(describing: lastFailureTime)), lastSuccessfulDeliveryTime: \(String(describing: lastSuccessfulDeliveryTime)), loggingEnabled: \(String(describing: loggingEnabled)), s3KeyPrefix: \(String(describing: s3KeyPrefix)))"}
}

extension DisableLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisableLoggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucketName = output.bucketName
            self.lastFailureMessage = output.lastFailureMessage
            self.lastFailureTime = output.lastFailureTime
            self.lastSuccessfulDeliveryTime = output.lastSuccessfulDeliveryTime
            self.loggingEnabled = output.loggingEnabled
            self.s3KeyPrefix = output.s3KeyPrefix
        } else {
            self.bucketName = nil
            self.lastFailureMessage = nil
            self.lastFailureTime = nil
            self.lastSuccessfulDeliveryTime = nil
            self.loggingEnabled = false
            self.s3KeyPrefix = nil
        }
    }
}

/// <p>Describes the status of logging for a cluster.</p>
public struct DisableLoggingOutputResponse: Equatable {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    public let bucketName: String?
    /// <p>The message indicating that logs failed to be delivered.</p>
    public let lastFailureMessage: String?
    /// <p>The last time when logs failed to be delivered.</p>
    public let lastFailureTime: Date?
    /// <p>The last time that logs were delivered.</p>
    public let lastSuccessfulDeliveryTime: Date?
    /// <p>
    ///             <code>true</code> if logging is on, <code>false</code> if logging is off.</p>
    public let loggingEnabled: Bool
    /// <p>The prefix applied to the log file names.</p>
    public let s3KeyPrefix: String?

    public init (
        bucketName: String? = nil,
        lastFailureMessage: String? = nil,
        lastFailureTime: Date? = nil,
        lastSuccessfulDeliveryTime: Date? = nil,
        loggingEnabled: Bool = false,
        s3KeyPrefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.lastFailureMessage = lastFailureMessage
        self.lastFailureTime = lastFailureTime
        self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
        self.loggingEnabled = loggingEnabled
        self.s3KeyPrefix = s3KeyPrefix
    }
}

struct DisableLoggingOutputResponseBody: Equatable {
    public let loggingEnabled: Bool
    public let bucketName: String?
    public let s3KeyPrefix: String?
    public let lastSuccessfulDeliveryTime: Date?
    public let lastFailureTime: Date?
    public let lastFailureMessage: String?
}

extension DisableLoggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case lastFailureMessage = "LastFailureMessage"
        case lastFailureTime = "LastFailureTime"
        case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
        case loggingEnabled = "LoggingEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DisableLoggingResult"))
        let loggingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let lastSuccessfulDeliveryTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSuccessfulDeliveryTime)
        var lastSuccessfulDeliveryTimeBuffer:Date? = nil
        if let lastSuccessfulDeliveryTimeDecoded = lastSuccessfulDeliveryTimeDecoded {
            lastSuccessfulDeliveryTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastSuccessfulDeliveryTimeDecoded, format: .dateTime)
        }
        lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTimeBuffer
        let lastFailureTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureTime)
        var lastFailureTimeBuffer:Date? = nil
        if let lastFailureTimeDecoded = lastFailureTimeDecoded {
            lastFailureTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastFailureTimeDecoded, format: .dateTime)
        }
        lastFailureTime = lastFailureTimeBuffer
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

public struct DisableSnapshotCopyInputBodyMiddleware: Middleware {
    public let id: String = "DisableSnapshotCopyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSnapshotCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSnapshotCopyInput>
    public typealias MOutput = OperationOutput<DisableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSnapshotCopyOutputError>
}

extension DisableSnapshotCopyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableSnapshotCopyInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension DisableSnapshotCopyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("DisableSnapshotCopy", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct DisableSnapshotCopyInputHeadersMiddleware: Middleware {
    public let id: String = "DisableSnapshotCopyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSnapshotCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSnapshotCopyInput>
    public typealias MOutput = OperationOutput<DisableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSnapshotCopyOutputError>
}

public struct DisableSnapshotCopyInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableSnapshotCopyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSnapshotCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSnapshotCopyInput>
    public typealias MOutput = OperationOutput<DisableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSnapshotCopyOutputError>
}

/// <p></p>
public struct DisableSnapshotCopyInput: Equatable {
    /// <p>The unique identifier of the source cluster that you want to disable copying of
    ///             snapshots to a destination region.</p>
    ///         <p>Constraints: Must be the valid name of an existing cluster that has cross-region
    ///             snapshot copy enabled.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension DisableSnapshotCopyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DisableSnapshotCopyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyAlreadyDisabledFault" : self = .snapshotCopyAlreadyDisabledFault(try SnapshotCopyAlreadyDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableSnapshotCopyOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case snapshotCopyAlreadyDisabledFault(SnapshotCopyAlreadyDisabledFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableSnapshotCopyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableSnapshotCopyOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension DisableSnapshotCopyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisableSnapshotCopyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DisableSnapshotCopyOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DisableSnapshotCopyOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension DisableSnapshotCopyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DisableSnapshotCopyResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension EC2SecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eC2SecurityGroupName = "EC2SecurityGroupName"
        case eC2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: Key("EC2SecurityGroupOwnerId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let eC2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eC2SecurityGroupName)
        eC2SecurityGroupName = eC2SecurityGroupNameDecoded
        let eC2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eC2SecurityGroupOwnerId)
        eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerIdDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension EC2SecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2SecurityGroup(eC2SecurityGroupName: \(String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(String(describing: eC2SecurityGroupOwnerId)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

/// <p>Describes an Amazon EC2 security group.</p>
public struct EC2SecurityGroup: Equatable {
    /// <p>The name of the EC2 Security Group.</p>
    public let eC2SecurityGroupName: String?
    /// <p>The AWS ID of the owner of the EC2 security group specified in the
    ///                 <code>EC2SecurityGroupName</code> field. </p>
    public let eC2SecurityGroupOwnerId: String?
    /// <p>The status of the EC2 security group.</p>
    public let status: String?
    /// <p>The list of tags for the EC2 security group.</p>
    public let tags: [Tag]?

    public init (
        eC2SecurityGroupName: String? = nil,
        eC2SecurityGroupOwnerId: String? = nil,
        status: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
        self.status = status
        self.tags = tags
    }
}

extension ElasticIpStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: Key("ElasticIp"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ElasticIpStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticIpStatus(elasticIp: \(String(describing: elasticIp)), status: \(String(describing: status)))"}
}

/// <p>Describes the status of the elastic IP (EIP) address.</p>
public struct ElasticIpStatus: Equatable {
    /// <p>The elastic IP (EIP) address for the cluster.</p>
    public let elasticIp: String?
    /// <p>The status of the elastic IP (EIP) address.</p>
    public let status: String?

    public init (
        elasticIp: String? = nil,
        status: String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.status = status
    }
}

public struct EnableLoggingInputBodyMiddleware: Middleware {
    public let id: String = "EnableLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableLoggingInput>
    public typealias MOutput = OperationOutput<EnableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableLoggingOutputError>
}

extension EnableLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableLoggingInput(bucketName: \(String(describing: bucketName)), clusterIdentifier: \(String(describing: clusterIdentifier)), s3KeyPrefix: \(String(describing: s3KeyPrefix)))"}
}

extension EnableLoggingInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bucketName = bucketName {
            try container.encode(bucketName, forKey: Key("BucketName"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try container.encode(s3KeyPrefix, forKey: Key("S3KeyPrefix"))
        }
        try container.encode("EnableLogging", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct EnableLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "EnableLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableLoggingInput>
    public typealias MOutput = OperationOutput<EnableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableLoggingOutputError>
}

public struct EnableLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableLoggingInput>
    public typealias MOutput = OperationOutput<EnableLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableLoggingOutputError>
}

/// <p></p>
public struct EnableLoggingInput: Equatable {
    /// <p>The name of an existing S3 bucket where the log files are to be stored.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be in the same region as the cluster</p>
    ///             </li>
    ///             <li>
    ///                 <p>The cluster must have read bucket and put object permissions</p>
    ///             </li>
    ///          </ul>
    public let bucketName: String?
    /// <p>The identifier of the cluster on which logging is to be started.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: String?
    /// <p>The prefix applied to the log file names.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cannot exceed 512 characters</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash
    ///                     (\), or control characters. The hexadecimal codes for invalid characters are: </p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>x00 to x20</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x22</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x27</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x5c</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>x7f or larger</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let s3KeyPrefix: String?

    public init (
        bucketName: String? = nil,
        clusterIdentifier: String? = nil,
        s3KeyPrefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.clusterIdentifier = clusterIdentifier
        self.s3KeyPrefix = s3KeyPrefix
    }
}

extension EnableLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BucketNotFoundFault" : self = .bucketNotFoundFault(try BucketNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicyFault" : self = .insufficientS3BucketPolicyFault(try InsufficientS3BucketPolicyFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketNameFault" : self = .invalidS3BucketNameFault(try InvalidS3BucketNameFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KeyPrefixFault" : self = .invalidS3KeyPrefixFault(try InvalidS3KeyPrefixFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableLoggingOutputError: Equatable {
    case bucketNotFoundFault(BucketNotFoundFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientS3BucketPolicyFault(InsufficientS3BucketPolicyFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidS3BucketNameFault(InvalidS3BucketNameFault)
    case invalidS3KeyPrefixFault(InvalidS3KeyPrefixFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableLoggingOutputResponse(bucketName: \(String(describing: bucketName)), lastFailureMessage: \(String(describing: lastFailureMessage)), lastFailureTime: \(String(describing: lastFailureTime)), lastSuccessfulDeliveryTime: \(String(describing: lastSuccessfulDeliveryTime)), loggingEnabled: \(String(describing: loggingEnabled)), s3KeyPrefix: \(String(describing: s3KeyPrefix)))"}
}

extension EnableLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableLoggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucketName = output.bucketName
            self.lastFailureMessage = output.lastFailureMessage
            self.lastFailureTime = output.lastFailureTime
            self.lastSuccessfulDeliveryTime = output.lastSuccessfulDeliveryTime
            self.loggingEnabled = output.loggingEnabled
            self.s3KeyPrefix = output.s3KeyPrefix
        } else {
            self.bucketName = nil
            self.lastFailureMessage = nil
            self.lastFailureTime = nil
            self.lastSuccessfulDeliveryTime = nil
            self.loggingEnabled = false
            self.s3KeyPrefix = nil
        }
    }
}

/// <p>Describes the status of logging for a cluster.</p>
public struct EnableLoggingOutputResponse: Equatable {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    public let bucketName: String?
    /// <p>The message indicating that logs failed to be delivered.</p>
    public let lastFailureMessage: String?
    /// <p>The last time when logs failed to be delivered.</p>
    public let lastFailureTime: Date?
    /// <p>The last time that logs were delivered.</p>
    public let lastSuccessfulDeliveryTime: Date?
    /// <p>
    ///             <code>true</code> if logging is on, <code>false</code> if logging is off.</p>
    public let loggingEnabled: Bool
    /// <p>The prefix applied to the log file names.</p>
    public let s3KeyPrefix: String?

    public init (
        bucketName: String? = nil,
        lastFailureMessage: String? = nil,
        lastFailureTime: Date? = nil,
        lastSuccessfulDeliveryTime: Date? = nil,
        loggingEnabled: Bool = false,
        s3KeyPrefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.lastFailureMessage = lastFailureMessage
        self.lastFailureTime = lastFailureTime
        self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
        self.loggingEnabled = loggingEnabled
        self.s3KeyPrefix = s3KeyPrefix
    }
}

struct EnableLoggingOutputResponseBody: Equatable {
    public let loggingEnabled: Bool
    public let bucketName: String?
    public let s3KeyPrefix: String?
    public let lastSuccessfulDeliveryTime: Date?
    public let lastFailureTime: Date?
    public let lastFailureMessage: String?
}

extension EnableLoggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case lastFailureMessage = "LastFailureMessage"
        case lastFailureTime = "LastFailureTime"
        case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
        case loggingEnabled = "LoggingEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("EnableLoggingResult"))
        let loggingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let lastSuccessfulDeliveryTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSuccessfulDeliveryTime)
        var lastSuccessfulDeliveryTimeBuffer:Date? = nil
        if let lastSuccessfulDeliveryTimeDecoded = lastSuccessfulDeliveryTimeDecoded {
            lastSuccessfulDeliveryTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastSuccessfulDeliveryTimeDecoded, format: .dateTime)
        }
        lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTimeBuffer
        let lastFailureTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureTime)
        var lastFailureTimeBuffer:Date? = nil
        if let lastFailureTimeDecoded = lastFailureTimeDecoded {
            lastFailureTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastFailureTimeDecoded, format: .dateTime)
        }
        lastFailureTime = lastFailureTimeBuffer
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

public struct EnableSnapshotCopyInputBodyMiddleware: Middleware {
    public let id: String = "EnableSnapshotCopyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSnapshotCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSnapshotCopyInput>
    public typealias MOutput = OperationOutput<EnableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSnapshotCopyOutputError>
}

extension EnableSnapshotCopyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSnapshotCopyInput(clusterIdentifier: \(String(describing: clusterIdentifier)), destinationRegion: \(String(describing: destinationRegion)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), retentionPeriod: \(String(describing: retentionPeriod)), snapshotCopyGrantName: \(String(describing: snapshotCopyGrantName)))"}
}

extension EnableSnapshotCopyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let destinationRegion = destinationRegion {
            try container.encode(destinationRegion, forKey: Key("DestinationRegion"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let retentionPeriod = retentionPeriod {
            try container.encode(retentionPeriod, forKey: Key("RetentionPeriod"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: Key("SnapshotCopyGrantName"))
        }
        try container.encode("EnableSnapshotCopy", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct EnableSnapshotCopyInputHeadersMiddleware: Middleware {
    public let id: String = "EnableSnapshotCopyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSnapshotCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSnapshotCopyInput>
    public typealias MOutput = OperationOutput<EnableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSnapshotCopyOutputError>
}

public struct EnableSnapshotCopyInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableSnapshotCopyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSnapshotCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSnapshotCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSnapshotCopyInput>
    public typealias MOutput = OperationOutput<EnableSnapshotCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSnapshotCopyOutputError>
}

/// <p></p>
public struct EnableSnapshotCopyInput: Equatable {
    /// <p>The unique identifier of the source cluster to copy snapshots from.</p>
    ///         <p>Constraints: Must be the valid name of an existing cluster that does not already
    ///             have cross-region snapshot copy enabled.</p>
    public let clusterIdentifier: String?
    /// <p>The destination AWS Region that you want to copy snapshots to.</p>
    ///         <p>Constraints: Must be the name of a valid AWS Region. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference.
    ///         </p>
    public let destinationRegion: String?
    /// <p>The number of days to retain newly copied snapshots in the destination AWS Region
    ///             after they are copied from the source AWS Region. If the value is -1, the manual
    ///             snapshot is retained indefinitely. </p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>The number of days to retain automated snapshots in the destination region after
    ///             they are copied from the source region.</p>
    ///         <p>Default: 7.</p>
    ///         <p>Constraints: Must be at least 1 and no more than 35.</p>
    public let retentionPeriod: Int?
    /// <p>The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted
    ///             cluster are copied to the destination region.</p>
    public let snapshotCopyGrantName: String?

    public init (
        clusterIdentifier: String? = nil,
        destinationRegion: String? = nil,
        manualSnapshotRetentionPeriod: Int? = nil,
        retentionPeriod: Int? = nil,
        snapshotCopyGrantName: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.destinationRegion = destinationRegion
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.retentionPeriod = retentionPeriod
        self.snapshotCopyGrantName = snapshotCopyGrantName
    }
}

extension EnableSnapshotCopyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableSnapshotCopyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CopyToRegionDisabledFault" : self = .copyToRegionDisabledFault(try CopyToRegionDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleOrderableOptions" : self = .incompatibleOrderableOptions(try IncompatibleOrderableOptions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyAlreadyEnabledFault" : self = .snapshotCopyAlreadyEnabledFault(try SnapshotCopyAlreadyEnabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyGrantNotFoundFault" : self = .snapshotCopyGrantNotFoundFault(try SnapshotCopyGrantNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSnapshotCopyRegionFault" : self = .unknownSnapshotCopyRegionFault(try UnknownSnapshotCopyRegionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableSnapshotCopyOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case copyToRegionDisabledFault(CopyToRegionDisabledFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case incompatibleOrderableOptions(IncompatibleOrderableOptions)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case limitExceededFault(LimitExceededFault)
    case snapshotCopyAlreadyEnabledFault(SnapshotCopyAlreadyEnabledFault)
    case snapshotCopyGrantNotFoundFault(SnapshotCopyGrantNotFoundFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknownSnapshotCopyRegionFault(UnknownSnapshotCopyRegionFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSnapshotCopyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSnapshotCopyOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension EnableSnapshotCopyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableSnapshotCopyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct EnableSnapshotCopyOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct EnableSnapshotCopyOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension EnableSnapshotCopyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("EnableSnapshotCopyResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case port = "Port"
        case vpcEndpoints = "VpcEndpoints"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let address = address {
            try container.encode(address, forKey: Key("Address"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let vpcEndpoints = vpcEndpoints {
            var vpcEndpointsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcEndpoints"))
            for (index0, vpcendpoint0) in vpcEndpoints.enumerated() {
                try vpcEndpointsContainer.encode(vpcendpoint0, forKey: Key("VpcEndpoint.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        if containerValues.contains(.vpcEndpoints) {
            struct KeyVal0{struct VpcEndpoint{}}
            let vpcEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcEndpoint>.CodingKeys.self, forKey: .vpcEndpoints)
            if let vpcEndpointsWrappedContainer = vpcEndpointsWrappedContainer {
                let vpcEndpointsContainer = try vpcEndpointsWrappedContainer.decodeIfPresent([VpcEndpoint].self, forKey: .member)
                var vpcEndpointsBuffer:[VpcEndpoint]? = nil
                if let vpcEndpointsContainer = vpcEndpointsContainer {
                    vpcEndpointsBuffer = [VpcEndpoint]()
                    for structureContainer0 in vpcEndpointsContainer {
                        vpcEndpointsBuffer?.append(structureContainer0)
                    }
                }
                vpcEndpoints = vpcEndpointsBuffer
            } else {
                vpcEndpoints = []
            }
        } else {
            vpcEndpoints = nil
        }
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(address: \(String(describing: address)), port: \(String(describing: port)), vpcEndpoints: \(String(describing: vpcEndpoints)))"}
}

/// <p>Describes a connection endpoint.</p>
public struct Endpoint: Equatable {
    /// <p>The DNS address of the Cluster.</p>
    public let address: String?
    /// <p>The port that the database engine is listening on.</p>
    public let port: Int
    /// <p>Describes a connection endpoint.</p>
    public let vpcEndpoints: [VpcEndpoint]?

    public init (
        address: String? = nil,
        port: Int = 0,
        vpcEndpoints: [VpcEndpoint]? = nil
    )
    {
        self.address = address
        self.port = port
        self.vpcEndpoints = vpcEndpoints
    }
}

extension EndpointAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let address = address {
            try container.encode(address, forKey: Key("Address"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let endpointCreateTime = endpointCreateTime {
            try container.encode(TimestampWrapper(endpointCreateTime, format: .dateTime), forKey: Key("endpointCreateTime"))
        }
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: Key("EndpointName"))
        }
        if let endpointStatus = endpointStatus {
            try container.encode(endpointStatus, forKey: Key("EndpointStatus"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: Key("ResourceOwner"))
        }
        if let subnetGroupName = subnetGroupName {
            try container.encode(subnetGroupName, forKey: Key("SubnetGroupName"))
        }
        if let vpcEndpoint = vpcEndpoint {
            try container.encode(vpcEndpoint, forKey: Key("VpcEndpoint"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

extension EndpointAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointAccess(address: \(String(describing: address)), clusterIdentifier: \(String(describing: clusterIdentifier)), endpointCreateTime: \(String(describing: endpointCreateTime)), endpointName: \(String(describing: endpointName)), endpointStatus: \(String(describing: endpointStatus)), port: \(String(describing: port)), resourceOwner: \(String(describing: resourceOwner)), subnetGroupName: \(String(describing: subnetGroupName)), vpcEndpoint: \(String(describing: vpcEndpoint)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
public struct EndpointAccess: Equatable {
    /// <p>The DNS address of the endpoint.</p>
    public let address: String?
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    public let clusterIdentifier: String?
    /// <p>The time (UTC) that the endpoint was created.</p>
    public let endpointCreateTime: Date?
    /// <p>The name of the endpoint.</p>
    public let endpointName: String?
    /// <p>The status of the endpoint.</p>
    public let endpointStatus: String?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    public let port: Int
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: String?
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    public let subnetGroupName: String?
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpoint: VpcEndpoint?
    /// <p>The security groups associated with the endpoint.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        address: String? = nil,
        clusterIdentifier: String? = nil,
        endpointCreateTime: Date? = nil,
        endpointName: String? = nil,
        endpointStatus: String? = nil,
        port: Int = 0,
        resourceOwner: String? = nil,
        subnetGroupName: String? = nil,
        vpcEndpoint: VpcEndpoint? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.address = address
        self.clusterIdentifier = clusterIdentifier
        self.endpointCreateTime = endpointCreateTime
        self.endpointName = endpointName
        self.endpointStatus = endpointStatus
        self.port = port
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcEndpoint = vpcEndpoint
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension EndpointAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension EndpointAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The account already has a Redshift-managed VPC endpoint with the given identifier.</p>
public struct EndpointAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension EndpointAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointAuthorization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedAllVPCs = "AllowedAllVPCs"
        case allowedVPCs = "AllowedVPCs"
        case authorizeTime = "AuthorizeTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterStatus = "ClusterStatus"
        case endpointCount = "EndpointCount"
        case grantee = "Grantee"
        case grantor = "Grantor"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowedAllVPCs != false {
            try container.encode(allowedAllVPCs, forKey: Key("AllowedAllVPCs"))
        }
        if let allowedVPCs = allowedVPCs {
            var allowedVPCsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedVPCs"))
            for (index0, string0) in allowedVPCs.enumerated() {
                try allowedVPCsContainer.encode(string0, forKey: Key("VpcIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let authorizeTime = authorizeTime {
            try container.encode(TimestampWrapper(authorizeTime, format: .dateTime), forKey: Key("authorizeTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterStatus = clusterStatus {
            try container.encode(clusterStatus, forKey: Key("ClusterStatus"))
        }
        if endpointCount != 0 {
            try container.encode(endpointCount, forKey: Key("EndpointCount"))
        }
        if let grantee = grantee {
            try container.encode(grantee, forKey: Key("Grantee"))
        }
        if let grantor = grantor {
            try container.encode(grantor, forKey: Key("Grantor"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantor)
        grantor = grantorDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantee)
        grantee = granteeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let authorizeTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizeTime)
        var authorizeTimeBuffer:Date? = nil
        if let authorizeTimeDecoded = authorizeTimeDecoded {
            authorizeTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(authorizeTimeDecoded, format: .dateTime)
        }
        authorizeTime = authorizeTimeBuffer
        let clusterStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let allowedAllVPCsDecoded = try containerValues.decode(Bool.self, forKey: .allowedAllVPCs)
        allowedAllVPCs = allowedAllVPCsDecoded
        if containerValues.contains(.allowedVPCs) {
            struct KeyVal0{struct VpcIdentifier{}}
            let allowedVPCsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcIdentifier>.CodingKeys.self, forKey: .allowedVPCs)
            if let allowedVPCsWrappedContainer = allowedVPCsWrappedContainer {
                let allowedVPCsContainer = try allowedVPCsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var allowedVPCsBuffer:[String]? = nil
                if let allowedVPCsContainer = allowedVPCsContainer {
                    allowedVPCsBuffer = [String]()
                    for stringContainer0 in allowedVPCsContainer {
                        allowedVPCsBuffer?.append(stringContainer0)
                    }
                }
                allowedVPCs = allowedVPCsBuffer
            } else {
                allowedVPCs = []
            }
        } else {
            allowedVPCs = nil
        }
        let endpointCountDecoded = try containerValues.decode(Int.self, forKey: .endpointCount)
        endpointCount = endpointCountDecoded
    }
}

extension EndpointAuthorization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointAuthorization(allowedAllVPCs: \(String(describing: allowedAllVPCs)), allowedVPCs: \(String(describing: allowedVPCs)), authorizeTime: \(String(describing: authorizeTime)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterStatus: \(String(describing: clusterStatus)), endpointCount: \(String(describing: endpointCount)), grantee: \(String(describing: grantee)), grantor: \(String(describing: grantor)), status: \(String(describing: status)))"}
}

/// <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across AWS accounts.</p>
public struct EndpointAuthorization: Equatable {
    /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
    public let allowedAllVPCs: Bool
    /// <p>The VPCs allowed access to the cluster.</p>
    public let allowedVPCs: [String]?
    /// <p>The time (UTC) when the authorization was created.</p>
    public let authorizeTime: Date?
    /// <p>The cluster identifier.</p>
    public let clusterIdentifier: String?
    /// <p>The status of the cluster.</p>
    public let clusterStatus: String?
    /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
    public let endpointCount: Int
    /// <p>The AWS account ID of the grantee of the cluster.</p>
    public let grantee: String?
    /// <p>The AWS account ID of the cluster owner.</p>
    public let grantor: String?
    /// <p>The status of the authorization action.</p>
    public let status: AuthorizationStatus?

    public init (
        allowedAllVPCs: Bool = false,
        allowedVPCs: [String]? = nil,
        authorizeTime: Date? = nil,
        clusterIdentifier: String? = nil,
        clusterStatus: String? = nil,
        endpointCount: Int = 0,
        grantee: String? = nil,
        grantor: String? = nil,
        status: AuthorizationStatus? = nil
    )
    {
        self.allowedAllVPCs = allowedAllVPCs
        self.allowedVPCs = allowedVPCs
        self.authorizeTime = authorizeTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterStatus = clusterStatus
        self.endpointCount = endpointCount
        self.grantee = grantee
        self.grantor = grantor
        self.status = status
    }
}

extension EndpointAuthorizationAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointAuthorizationAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension EndpointAuthorizationAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointAuthorizationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The authorization already exists for this endpoint.</p>
public struct EndpointAuthorizationAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAuthorizationAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension EndpointAuthorizationAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointAuthorizationNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointAuthorizationNotFoundFault(message: \(String(describing: message)))"}
}

extension EndpointAuthorizationNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointAuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The authorization for this endpoint can't be found.</p>
public struct EndpointAuthorizationNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAuthorizationNotFoundFaultBody: Equatable {
    public let message: String?
}

extension EndpointAuthorizationNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointAuthorizationsPerClusterLimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointAuthorizationsPerClusterLimitExceededFault(message: \(String(describing: message)))"}
}

extension EndpointAuthorizationsPerClusterLimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointAuthorizationsPerClusterLimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of endpoint authorizations per cluster has exceeded its limit.</p>
public struct EndpointAuthorizationsPerClusterLimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAuthorizationsPerClusterLimitExceededFaultBody: Equatable {
    public let message: String?
}

extension EndpointAuthorizationsPerClusterLimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointNotFoundFault(message: \(String(describing: message)))"}
}

extension EndpointNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint name doesn't refer to an existing endpoint.</p>
public struct EndpointNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointNotFoundFaultBody: Equatable {
    public let message: String?
}

extension EndpointNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointsPerAuthorizationLimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointsPerAuthorizationLimitExceededFault(message: \(String(describing: message)))"}
}

extension EndpointsPerAuthorizationLimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointsPerAuthorizationLimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of Redshift-managed VPC endpoints per authorization has exceeded its limit.</p>
public struct EndpointsPerAuthorizationLimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointsPerAuthorizationLimitExceededFaultBody: Equatable {
    public let message: String?
}

extension EndpointsPerAuthorizationLimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointsPerClusterLimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointsPerClusterLimitExceededFault(message: \(String(describing: message)))"}
}

extension EndpointsPerClusterLimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointsPerClusterLimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of Redshift-managed VPC endpoints per cluster has exceeded its limit.</p>
public struct EndpointsPerClusterLimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointsPerClusterLimitExceededFaultBody: Equatable {
    public let message: String?
}

extension EndpointsPerClusterLimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case eventId = "EventId"
        case message = "Message"
        case severity = "Severity"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let date = date {
            try container.encode(TimestampWrapper(date, format: .dateTime), forKey: Key("date"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventId = eventId {
            try container.encode(eventId, forKey: Key("EventId"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesBuffer:[String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        var dateBuffer:Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(date: \(String(describing: date)), eventCategories: \(String(describing: eventCategories)), eventId: \(String(describing: eventId)), message: \(String(describing: message)), severity: \(String(describing: severity)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Describes an event.</p>
public struct Event: Equatable {
    /// <p>The date and time of the event.</p>
    public let date: Date?
    /// <p>A list of the event categories.</p>
    ///         <p>Values: Configuration, Management, Monitoring, Security</p>
    public let eventCategories: [String]?
    /// <p>The identifier of the event.</p>
    public let eventId: String?
    /// <p>The text of this event.</p>
    public let message: String?
    /// <p>The severity of the event.</p>
    ///         <p>Values: ERROR, INFO</p>
    public let severity: String?
    /// <p>The identifier for the source of the event.</p>
    public let sourceIdentifier: String?
    /// <p>The source type for this event.</p>
    public let sourceType: SourceType?

    public init (
        date: Date? = nil,
        eventCategories: [String]? = nil,
        eventId: String? = nil,
        message: String? = nil,
        severity: String? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil
    )
    {
        self.date = date
        self.eventCategories = eventCategories
        self.eventId = eventId
        self.message = message
        self.severity = severity
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
    }
}

extension EventCategoriesMap: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let events = events {
            var eventsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Events"))
            for (index0, eventinfomap0) in events.enumerated() {
                try eventsContainer.encode(eventinfomap0, forKey: Key("EventInfoMap.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct EventInfoMap{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventInfoMap>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([EventInfoMap].self, forKey: .member)
                var eventsBuffer:[EventInfoMap]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [EventInfoMap]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

extension EventCategoriesMap: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventCategoriesMap(events: \(String(describing: events)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Describes event categories.</p>
public struct EventCategoriesMap: Equatable {
    /// <p>The events in the event category.</p>
    public let events: [EventInfoMap]?
    /// <p>The source type, such as cluster or cluster-snapshot, that the returned categories
    ///             belong to.</p>
    public let sourceType: String?

    public init (
        events: [EventInfoMap]? = nil,
        sourceType: String? = nil
    )
    {
        self.events = events
        self.sourceType = sourceType
    }
}

extension EventInfoMap: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventCategories = "EventCategories"
        case eventDescription = "EventDescription"
        case eventId = "EventId"
        case severity = "Severity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventDescription = eventDescription {
            try container.encode(eventDescription, forKey: Key("EventDescription"))
        }
        if let eventId = eventId {
            try container.encode(eventId, forKey: Key("EventId"))
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesBuffer:[String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
    }
}

extension EventInfoMap: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventInfoMap(eventCategories: \(String(describing: eventCategories)), eventDescription: \(String(describing: eventDescription)), eventId: \(String(describing: eventId)), severity: \(String(describing: severity)))"}
}

/// <p>Describes event information.</p>
public struct EventInfoMap: Equatable {
    /// <p>The category of an Amazon Redshift event.</p>
    public let eventCategories: [String]?
    /// <p>The description of an Amazon Redshift event.</p>
    public let eventDescription: String?
    /// <p>The identifier of an Amazon Redshift event.</p>
    public let eventId: String?
    /// <p>The severity of the event.</p>
    ///         <p>Values: ERROR, INFO</p>
    public let severity: String?

    public init (
        eventCategories: [String]? = nil,
        eventDescription: String? = nil,
        eventId: String? = nil,
        severity: String? = nil
    )
    {
        self.eventCategories = eventCategories
        self.eventDescription = eventDescription
        self.eventId = eventId
        self.severity = severity
    }
}

extension EventSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case severity = "Severity"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let custSubscriptionId = custSubscriptionId {
            try container.encode(custSubscriptionId, forKey: Key("CustSubscriptionId"))
        }
        if let customerAwsId = customerAwsId {
            try container.encode(customerAwsId, forKey: Key("CustomerAwsId"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategoriesList"))
            for (index0, string0) in eventCategoriesList.enumerated() {
                try eventCategoriesListContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceIdsList"))
            for (index0, string0) in sourceIdsList.enumerated() {
                try sourceIdsListContainer.encode(string0, forKey: Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try container.encode(TimestampWrapper(subscriptionCreationTime, format: .dateTime), forKey: Key("subscriptionCreationTime"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionCreationTime)
        var subscriptionCreationTimeBuffer:Date? = nil
        if let subscriptionCreationTimeDecoded = subscriptionCreationTimeDecoded {
            subscriptionCreationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(subscriptionCreationTimeDecoded, format: .dateTime)
        }
        subscriptionCreationTime = subscriptionCreationTimeBuffer
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.sourceIdsList) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIdsList)
            if let sourceIdsListWrappedContainer = sourceIdsListWrappedContainer {
                let sourceIdsListContainer = try sourceIdsListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sourceIdsListBuffer:[String]? = nil
                if let sourceIdsListContainer = sourceIdsListContainer {
                    sourceIdsListBuffer = [String]()
                    for stringContainer0 in sourceIdsListContainer {
                        sourceIdsListBuffer?.append(stringContainer0)
                    }
                }
                sourceIdsList = sourceIdsListBuffer
            } else {
                sourceIdsList = []
            }
        } else {
            sourceIdsList = nil
        }
        if containerValues.contains(.eventCategoriesList) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategoriesList)
            if let eventCategoriesListWrappedContainer = eventCategoriesListWrappedContainer {
                let eventCategoriesListContainer = try eventCategoriesListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesListBuffer:[String]? = nil
                if let eventCategoriesListContainer = eventCategoriesListContainer {
                    eventCategoriesListBuffer = [String]()
                    for stringContainer0 in eventCategoriesListContainer {
                        eventCategoriesListBuffer?.append(stringContainer0)
                    }
                }
                eventCategoriesList = eventCategoriesListBuffer
            } else {
                eventCategoriesList = []
            }
        } else {
            eventCategoriesList = nil
        }
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension EventSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscription(custSubscriptionId: \(String(describing: custSubscriptionId)), customerAwsId: \(String(describing: customerAwsId)), enabled: \(String(describing: enabled)), eventCategoriesList: \(String(describing: eventCategoriesList)), severity: \(String(describing: severity)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIdsList: \(String(describing: sourceIdsList)), sourceType: \(String(describing: sourceType)), status: \(String(describing: status)), subscriptionCreationTime: \(String(describing: subscriptionCreationTime)), tags: \(String(describing: tags)))"}
}

/// <p>Describes event subscriptions.</p>
public struct EventSubscription: Equatable {
    /// <p>The name of the Amazon Redshift event notification subscription.</p>
    public let custSubscriptionId: String?
    /// <p>The AWS customer account associated with the Amazon Redshift event notification
    ///             subscription.</p>
    public let customerAwsId: String?
    /// <p>A boolean value indicating whether the subscription is enabled; <code>true</code>
    ///             indicates that the subscription is enabled.</p>
    public let enabled: Bool
    /// <p>The list of Amazon Redshift event categories specified in the event notification
    ///             subscription.</p>
    ///         <p>Values: Configuration, Management, Monitoring, Security</p>
    public let eventCategoriesList: [String]?
    /// <p>The event severity specified in the Amazon Redshift event notification
    ///             subscription.</p>
    ///         <p>Values: ERROR, INFO</p>
    public let severity: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used by the event
    ///             notification subscription.</p>
    public let snsTopicArn: String?
    /// <p>A list of the sources that publish events to the Amazon Redshift event notification
    ///             subscription.</p>
    public let sourceIdsList: [String]?
    /// <p>The source type of the events returned by the Amazon Redshift event notification, such as
    ///             cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, or scheduled-action. </p>
    public let sourceType: String?
    /// <p>The status of the Amazon Redshift event notification subscription.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Can be one of the following: active | no-permission |
    ///                     topic-not-exist</p>
    ///             </li>
    ///             <li>
    ///                 <p>The status "no-permission" indicates that Amazon Redshift no longer has
    ///                     permission to post to the Amazon SNS topic. The status "topic-not-exist"
    ///                     indicates that the topic was deleted after the subscription was
    ///                     created.</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The date and time the Amazon Redshift event notification subscription was
    ///             created.</p>
    public let subscriptionCreationTime: Date?
    /// <p>The list of tags for the event subscription.</p>
    public let tags: [Tag]?

    public init (
        custSubscriptionId: String? = nil,
        customerAwsId: String? = nil,
        enabled: Bool = false,
        eventCategoriesList: [String]? = nil,
        severity: String? = nil,
        snsTopicArn: String? = nil,
        sourceIdsList: [String]? = nil,
        sourceType: String? = nil,
        status: String? = nil,
        subscriptionCreationTime: Date? = nil,
        tags: [Tag]? = nil
    )
    {
        self.custSubscriptionId = custSubscriptionId
        self.customerAwsId = customerAwsId
        self.enabled = enabled
        self.eventCategoriesList = eventCategoriesList
        self.severity = severity
        self.snsTopicArn = snsTopicArn
        self.sourceIdsList = sourceIdsList
        self.sourceType = sourceType
        self.status = status
        self.subscriptionCreationTime = subscriptionCreationTime
        self.tags = tags
    }
}

extension EventSubscriptionQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscriptionQuotaExceededFault(message: \(String(describing: message)))"}
}

extension EventSubscriptionQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EventSubscriptionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would exceed the allowed number of event subscriptions for this
///             account.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct EventSubscriptionQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EventSubscriptionQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension EventSubscriptionQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetClusterCredentialsInputBodyMiddleware: Middleware {
    public let id: String = "GetClusterCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClusterCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClusterCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClusterCredentialsInput>
    public typealias MOutput = OperationOutput<GetClusterCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClusterCredentialsOutputError>
}

extension GetClusterCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClusterCredentialsInput(autoCreate: \(String(describing: autoCreate)), clusterIdentifier: \(String(describing: clusterIdentifier)), dbGroups: \(String(describing: dbGroups)), dbName: \(String(describing: dbName)), dbUser: \(String(describing: dbUser)), durationSeconds: \(String(describing: durationSeconds)))"}
}

extension GetClusterCredentialsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoCreate = autoCreate {
            try container.encode(autoCreate, forKey: Key("AutoCreate"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let dbGroups = dbGroups {
            var dbGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DbGroups"))
            for (index0, string0) in dbGroups.enumerated() {
                try dbGroupsContainer.encode(string0, forKey: Key("DbGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dbName = dbName {
            try container.encode(dbName, forKey: Key("DbName"))
        }
        if let dbUser = dbUser {
            try container.encode(dbUser, forKey: Key("DbUser"))
        }
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: Key("DurationSeconds"))
        }
        try container.encode("GetClusterCredentials", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct GetClusterCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "GetClusterCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClusterCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClusterCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClusterCredentialsInput>
    public typealias MOutput = OperationOutput<GetClusterCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClusterCredentialsOutputError>
}

public struct GetClusterCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetClusterCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClusterCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClusterCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClusterCredentialsInput>
    public typealias MOutput = OperationOutput<GetClusterCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClusterCredentialsOutputError>
}

/// <p>The request parameters to get cluster credentials.</p>
public struct GetClusterCredentialsInput: Equatable {
    /// <p>Create a database user with the name specified for the user named in
    ///                 <code>DbUser</code> if one does not exist.</p>
    public let autoCreate: Bool?
    /// <p>The unique identifier of the cluster that contains the database for which your are
    ///             requesting credentials. This parameter is case sensitive.</p>
    public let clusterIdentifier: String?
    /// <p>A list of the names of existing database groups that the user named in
    ///                 <code>DbUser</code> will join for the current session, in addition to any group
    ///             memberships for an existing user. If not specified, a new user is added only to
    ///             PUBLIC.</p>
    ///         <p>Database group name constraints</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 64 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
    ///                     (dot), at symbol (@), or hyphen.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
    ///                     Redshift Database Developer Guide.</p>
    ///             </li>
    ///          </ul>
    public let dbGroups: [String]?
    /// <p>The name of a database that <code>DbUser</code> is authorized to log on to. If
    ///                 <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing
    ///             database.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 64 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
    ///                     (dot), at symbol (@), or hyphen.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
    ///                     Redshift Database Developer Guide.</p>
    ///             </li>
    ///          </ul>
    public let dbName: String?
    /// <p>The name of a database user. If a user name matching <code>DbUser</code> exists in
    ///             the database, the temporary user credentials have the same permissions as the existing
    ///             user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code>
    ///             is <code>True</code>, a new user is created using the value for <code>DbUser</code> with
    ///             PUBLIC permissions. If a database user matching the value for <code>DbUser</code>
    ///             doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command
    ///             succeeds but the connection attempt will fail because the user doesn't exist in the
    ///             database.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon
    ///             Redshift Database Developer Guide. </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be
    ///                         <code>PUBLIC</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain only lowercase letters, numbers, underscore, plus sign, period
    ///                     (dot), at symbol (@), or hyphen.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must not contain a colon ( : ) or slash ( / ). </p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot be a reserved word. A list of reserved words can be found in <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon
    ///                     Redshift Database Developer Guide.</p>
    ///             </li>
    ///          </ul>
    public let dbUser: String?
    /// <p>The number of seconds until the returned temporary password expires.</p>
    ///         <p>Constraint: minimum 900, maximum 3600.</p>
    ///         <p>Default: 900</p>
    public let durationSeconds: Int?

    public init (
        autoCreate: Bool? = nil,
        clusterIdentifier: String? = nil,
        dbGroups: [String]? = nil,
        dbName: String? = nil,
        dbUser: String? = nil,
        durationSeconds: Int? = nil
    )
    {
        self.autoCreate = autoCreate
        self.clusterIdentifier = clusterIdentifier
        self.dbGroups = dbGroups
        self.dbName = dbName
        self.dbUser = dbUser
        self.durationSeconds = durationSeconds
    }
}

extension GetClusterCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetClusterCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClusterCredentialsOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClusterCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClusterCredentialsOutputResponse(dbPassword: \(String(describing: dbPassword)), dbUser: \(String(describing: dbUser)), expiration: \(String(describing: expiration)))"}
}

extension GetClusterCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetClusterCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dbPassword = output.dbPassword
            self.dbUser = output.dbUser
            self.expiration = output.expiration
        } else {
            self.dbPassword = nil
            self.dbUser = nil
            self.expiration = nil
        }
    }
}

/// <p>Temporary credentials with authorization to log on to an Amazon Redshift database.
///         </p>
public struct GetClusterCredentialsOutputResponse: Equatable {
    /// <p>A temporary password that authorizes the user name returned by <code>DbUser</code>
    ///             to log on to the database <code>DbName</code>. </p>
    public let dbPassword: String?
    /// <p>A database user name that is authorized to log on to the database
    ///                 <code>DbName</code> using the password <code>DbPassword</code>. If the specified
    ///             DbUser exists in the database, the new user name has the same database privileges as the
    ///             the user named in DbUser. By default, the user is added to PUBLIC. If the
    ///                 <code>DbGroups</code> parameter is specifed, <code>DbUser</code> is added to the
    ///             listed groups for any sessions created using these credentials.</p>
    public let dbUser: String?
    /// <p>The date and time the password in <code>DbPassword</code> expires.</p>
    public let expiration: Date?

    public init (
        dbPassword: String? = nil,
        dbUser: String? = nil,
        expiration: Date? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.expiration = expiration
    }
}

struct GetClusterCredentialsOutputResponseBody: Equatable {
    public let dbUser: String?
    public let dbPassword: String?
    public let expiration: Date?
}

extension GetClusterCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case expiration = "Expiration"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetClusterCredentialsResult"))
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiration)
        var expirationBuffer:Date? = nil
        if let expirationDecoded = expirationDecoded {
            expirationBuffer = try TimestampWrapperDecoder.parseDateStringValue(expirationDecoded, format: .dateTime)
        }
        expiration = expirationBuffer
    }
}

public struct GetReservedNodeExchangeOfferingsInputBodyMiddleware: Middleware {
    public let id: String = "GetReservedNodeExchangeOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservedNodeExchangeOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservedNodeExchangeOfferingsInput>
    public typealias MOutput = OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservedNodeExchangeOfferingsOutputError>
}

extension GetReservedNodeExchangeOfferingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservedNodeExchangeOfferingsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), reservedNodeId: \(String(describing: reservedNodeId)))"}
}

extension GetReservedNodeExchangeOfferingsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: Key("ReservedNodeId"))
        }
        try container.encode("GetReservedNodeExchangeOfferings", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct GetReservedNodeExchangeOfferingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetReservedNodeExchangeOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservedNodeExchangeOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservedNodeExchangeOfferingsInput>
    public typealias MOutput = OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservedNodeExchangeOfferingsOutputError>
}

public struct GetReservedNodeExchangeOfferingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReservedNodeExchangeOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservedNodeExchangeOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservedNodeExchangeOfferingsInput>
    public typealias MOutput = OperationOutput<GetReservedNodeExchangeOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservedNodeExchangeOfferingsOutputError>
}

/// <p></p>
public struct GetReservedNodeExchangeOfferingsInput: Equatable {
    /// <p>A value that indicates the starting point for the next set of
    ///             ReservedNodeOfferings.</p>
    public let marker: String?
    /// <p>An integer setting the maximum number of ReservedNodeOfferings to
    ///             retrieve.</p>
    public let maxRecords: Int?
    /// <p>A string representing the node identifier for the DC1 Reserved Node to be
    ///             exchanged.</p>
    public let reservedNodeId: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        reservedNodeId: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.reservedNodeId = reservedNodeId
    }
}

extension GetReservedNodeExchangeOfferingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetReservedNodeExchangeOfferingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependentServiceUnavailableFault" : self = .dependentServiceUnavailableFault(try DependentServiceUnavailableFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReservedNodeStateFault" : self = .invalidReservedNodeStateFault(try InvalidReservedNodeStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeAlreadyMigratedFault" : self = .reservedNodeAlreadyMigratedFault(try ReservedNodeAlreadyMigratedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeNotFoundFault" : self = .reservedNodeNotFoundFault(try ReservedNodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservedNodeExchangeOfferingsOutputError: Equatable {
    case dependentServiceUnavailableFault(DependentServiceUnavailableFault)
    case invalidReservedNodeStateFault(InvalidReservedNodeStateFault)
    case reservedNodeAlreadyMigratedFault(ReservedNodeAlreadyMigratedFault)
    case reservedNodeNotFoundFault(ReservedNodeNotFoundFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservedNodeExchangeOfferingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservedNodeExchangeOfferingsOutputResponse(marker: \(String(describing: marker)), reservedNodeOfferings: \(String(describing: reservedNodeOfferings)))"}
}

extension GetReservedNodeExchangeOfferingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReservedNodeExchangeOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.reservedNodeOfferings = output.reservedNodeOfferings
        } else {
            self.marker = nil
            self.reservedNodeOfferings = nil
        }
    }
}

public struct GetReservedNodeExchangeOfferingsOutputResponse: Equatable {
    /// <p>An optional parameter that specifies the starting point for returning a set of
    ///             response records. When the results of a <code>GetReservedNodeExchangeOfferings</code>
    ///             request exceed the value specified in MaxRecords, Amazon Redshift returns a value in the
    ///             marker field of the response. You can retrieve the next set of response records by
    ///             providing the returned marker value in the marker parameter and retrying the request.
    ///         </p>
    public let marker: String?
    /// <p>Returns an array of <a>ReservedNodeOffering</a> objects.</p>
    public let reservedNodeOfferings: [ReservedNodeOffering]?

    public init (
        marker: String? = nil,
        reservedNodeOfferings: [ReservedNodeOffering]? = nil
    )
    {
        self.marker = marker
        self.reservedNodeOfferings = reservedNodeOfferings
    }
}

struct GetReservedNodeExchangeOfferingsOutputResponseBody: Equatable {
    public let marker: String?
    public let reservedNodeOfferings: [ReservedNodeOffering]?
}

extension GetReservedNodeExchangeOfferingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case reservedNodeOfferings = "ReservedNodeOfferings"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetReservedNodeExchangeOfferingsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedNodeOfferings) {
            struct KeyVal0{struct ReservedNodeOffering{}}
            let reservedNodeOfferingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedNodeOffering>.CodingKeys.self, forKey: .reservedNodeOfferings)
            if let reservedNodeOfferingsWrappedContainer = reservedNodeOfferingsWrappedContainer {
                let reservedNodeOfferingsContainer = try reservedNodeOfferingsWrappedContainer.decodeIfPresent([ReservedNodeOffering].self, forKey: .member)
                var reservedNodeOfferingsBuffer:[ReservedNodeOffering]? = nil
                if let reservedNodeOfferingsContainer = reservedNodeOfferingsContainer {
                    reservedNodeOfferingsBuffer = [ReservedNodeOffering]()
                    for structureContainer0 in reservedNodeOfferingsContainer {
                        reservedNodeOfferingsBuffer?.append(structureContainer0)
                    }
                }
                reservedNodeOfferings = reservedNodeOfferingsBuffer
            } else {
                reservedNodeOfferings = []
            }
        } else {
            reservedNodeOfferings = nil
        }
    }
}

extension HsmClientCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
        case hsmClientCertificatePublicKey = "HsmClientCertificatePublicKey"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        if let hsmClientCertificatePublicKey = hsmClientCertificatePublicKey {
            try container.encode(hsmClientCertificatePublicKey, forKey: Key("HsmClientCertificatePublicKey"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmClientCertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmClientCertificateIdentifier)
        hsmClientCertificateIdentifier = hsmClientCertificateIdentifierDecoded
        let hsmClientCertificatePublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmClientCertificatePublicKey)
        hsmClientCertificatePublicKey = hsmClientCertificatePublicKeyDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension HsmClientCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmClientCertificate(hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), hsmClientCertificatePublicKey: \(String(describing: hsmClientCertificatePublicKey)), tags: \(String(describing: tags)))"}
}

/// <p>Returns information about an HSM client certificate. The certificate is stored in a
///             secure Hardware Storage Module (HSM), and used by the Amazon Redshift cluster to encrypt data
///             files.</p>
public struct HsmClientCertificate: Equatable {
    /// <p>The identifier of the HSM client certificate.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>The public key that the Amazon Redshift cluster will use to connect to the HSM. You must
    ///             register the public key in the HSM.</p>
    public let hsmClientCertificatePublicKey: String?
    /// <p>The list of tags for the HSM client certificate.</p>
    public let tags: [Tag]?

    public init (
        hsmClientCertificateIdentifier: String? = nil,
        hsmClientCertificatePublicKey: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmClientCertificatePublicKey = hsmClientCertificatePublicKey
        self.tags = tags
    }
}

extension HsmClientCertificateAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmClientCertificateAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension HsmClientCertificateAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<HsmClientCertificateAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is already an existing Amazon Redshift HSM client certificate with the specified
///             identifier.</p>
public struct HsmClientCertificateAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HsmClientCertificateAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension HsmClientCertificateAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmClientCertificateNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmClientCertificateNotFoundFault(message: \(String(describing: message)))"}
}

extension HsmClientCertificateNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<HsmClientCertificateNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no Amazon Redshift HSM client certificate with the specified
///             identifier.</p>
public struct HsmClientCertificateNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HsmClientCertificateNotFoundFaultBody: Equatable {
    public let message: String?
}

extension HsmClientCertificateNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmClientCertificateQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmClientCertificateQuotaExceededFault(message: \(String(describing: message)))"}
}

extension HsmClientCertificateQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<HsmClientCertificateQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for HSM client certificates has been reached.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct HsmClientCertificateQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HsmClientCertificateQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension HsmClientCertificateQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
        case hsmIpAddress = "HsmIpAddress"
        case hsmPartitionName = "HsmPartitionName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        if let hsmIpAddress = hsmIpAddress {
            try container.encode(hsmIpAddress, forKey: Key("HsmIpAddress"))
        }
        if let hsmPartitionName = hsmPartitionName {
            try container.encode(hsmPartitionName, forKey: Key("HsmPartitionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmConfigurationIdentifier)
        hsmConfigurationIdentifier = hsmConfigurationIdentifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let hsmIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmIpAddress)
        hsmIpAddress = hsmIpAddressDecoded
        let hsmPartitionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmPartitionName)
        hsmPartitionName = hsmPartitionNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension HsmConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmConfiguration(description: \(String(describing: description)), hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), hsmIpAddress: \(String(describing: hsmIpAddress)), hsmPartitionName: \(String(describing: hsmPartitionName)), tags: \(String(describing: tags)))"}
}

/// <p>Returns information about an HSM configuration, which is an object that describes
///             to Amazon Redshift clusters the information they require to connect to an HSM where they can
///             store database encryption keys.</p>
public struct HsmConfiguration: Equatable {
    /// <p>A text description of the HSM configuration.</p>
    public let description: String?
    /// <p>The name of the Amazon Redshift HSM configuration.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
    public let hsmIpAddress: String?
    /// <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
    ///             database encryption keys.</p>
    public let hsmPartitionName: String?
    /// <p>The list of tags for the HSM configuration.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        hsmConfigurationIdentifier: String? = nil,
        hsmIpAddress: String? = nil,
        hsmPartitionName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.hsmIpAddress = hsmIpAddress
        self.hsmPartitionName = hsmPartitionName
        self.tags = tags
    }
}

extension HsmConfigurationAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmConfigurationAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension HsmConfigurationAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<HsmConfigurationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is already an existing Amazon Redshift HSM configuration with the specified
///             identifier.</p>
public struct HsmConfigurationAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HsmConfigurationAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension HsmConfigurationAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmConfigurationNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmConfigurationNotFoundFault(message: \(String(describing: message)))"}
}

extension HsmConfigurationNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<HsmConfigurationNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
public struct HsmConfigurationNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HsmConfigurationNotFoundFaultBody: Equatable {
    public let message: String?
}

extension HsmConfigurationNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmConfigurationQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmConfigurationQuotaExceededFault(message: \(String(describing: message)))"}
}

extension HsmConfigurationQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<HsmConfigurationQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for HSM configurations has been reached.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct HsmConfigurationQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HsmConfigurationQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension HsmConfigurationQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HsmStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
        case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmClientCertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmClientCertificateIdentifier)
        hsmClientCertificateIdentifier = hsmClientCertificateIdentifierDecoded
        let hsmConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmConfigurationIdentifier)
        hsmConfigurationIdentifier = hsmConfigurationIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension HsmStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HsmStatus(hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), status: \(String(describing: status)))"}
}

/// <p>Describes the status of changes to HSM settings.</p>
public struct HsmStatus: Equatable {
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    ///             retrieve the data encryption keys stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>Specifies the name of the HSM configuration that contains the information the
    ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>Reports whether the Amazon Redshift cluster has finished applying any HSM settings
    ///             changes specified in a modify cluster command.</p>
    ///         <p>Values: active, applying</p>
    public let status: String?

    public init (
        hsmClientCertificateIdentifier: String? = nil,
        hsmConfigurationIdentifier: String? = nil,
        status: String? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.status = status
    }
}

extension IPRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cIDRIP = "CIDRIP"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: Key("CIDRIP"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let cIDRIPDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cIDRIP)
        cIDRIP = cIDRIPDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IPRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPRange(cIDRIP: \(String(describing: cIDRIP)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

/// <p>Describes an IP range used in a security group.</p>
public struct IPRange: Equatable {
    /// <p>The IP range in Classless Inter-Domain Routing (CIDR) notation.</p>
    public let cIDRIP: String?
    /// <p>The status of the IP range, for example, "authorized".</p>
    public let status: String?
    /// <p>The list of tags for the IP range.</p>
    public let tags: [Tag]?

    public init (
        cIDRIP: String? = nil,
        status: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.status = status
        self.tags = tags
    }
}

extension InProgressTableRestoreQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InProgressTableRestoreQuotaExceededFault(message: \(String(describing: message)))"}
}

extension InProgressTableRestoreQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InProgressTableRestoreQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the allowed number of table restore requests. Wait for your
///             current table restore requests to complete before making a new request.</p>
public struct InProgressTableRestoreQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InProgressTableRestoreQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension InProgressTableRestoreQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatibleOrderableOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibleOrderableOptions(message: \(String(describing: message)))"}
}

extension IncompatibleOrderableOptions: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IncompatibleOrderableOptionsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified options are incompatible.</p>
public struct IncompatibleOrderableOptions: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleOrderableOptionsBody: Equatable {
    public let message: String?
}

extension IncompatibleOrderableOptionsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientClusterCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientClusterCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientClusterCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of nodes specified exceeds the allotted capacity of the
///             cluster.</p>
public struct InsufficientClusterCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientClusterCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientClusterCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientS3BucketPolicyFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientS3BucketPolicyFault(message: \(String(describing: message)))"}
}

extension InsufficientS3BucketPolicyFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientS3BucketPolicyFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster does not have read bucket or put object permissions on the S3 bucket
///             specified when enabling logging.</p>
public struct InsufficientS3BucketPolicyFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientS3BucketPolicyFaultBody: Equatable {
    public let message: String?
}

extension InsufficientS3BucketPolicyFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorizationStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAuthorizationStateFault(message: \(String(describing: message)))"}
}

extension InvalidAuthorizationStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidAuthorizationStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The status of the authorization is not valid.</p>
public struct InvalidAuthorizationStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthorizationStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidAuthorizationStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterParameterGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterParameterGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterParameterGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterParameterGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster parameter group action can not be completed because another task is in
///             progress that involves the parameter group. Wait a few moments and try the operation
///             again.</p>
public struct InvalidClusterParameterGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterParameterGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterParameterGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSecurityGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterSecurityGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterSecurityGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterSecurityGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the cluster security group is not <code>available</code>. </p>
public struct InvalidClusterSecurityGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSecurityGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterSecurityGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSnapshotScheduleStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterSnapshotScheduleStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterSnapshotScheduleStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterSnapshotScheduleStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster snapshot schedule state is not valid.</p>
public struct InvalidClusterSnapshotScheduleStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSnapshotScheduleStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterSnapshotScheduleStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSnapshotStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterSnapshotStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterSnapshotStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified cluster snapshot is not in the <code>available</code> state, or other
///             accounts are authorized to access the snapshot. </p>
public struct InvalidClusterSnapshotStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSnapshotStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterSnapshotStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified cluster is not in the <code>available</code> state. </p>
public struct InvalidClusterStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSubnetGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterSubnetGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterSubnetGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterSubnetGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster subnet group cannot be deleted because it is in use.</p>
public struct InvalidClusterSubnetGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSubnetGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterSubnetGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterSubnetStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterSubnetStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterSubnetStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterSubnetStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the subnet is invalid.</p>
public struct InvalidClusterSubnetStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterSubnetStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterSubnetStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterTrackFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterTrackFault(message: \(String(describing: message)))"}
}

extension InvalidClusterTrackFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidClusterTrackFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided cluster track name is not valid.</p>
public struct InvalidClusterTrackFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterTrackFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterTrackFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidElasticIpFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidElasticIpFault(message: \(String(describing: message)))"}
}

extension InvalidElasticIpFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidElasticIpFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
public struct InvalidElasticIpFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidElasticIpFaultBody: Equatable {
    public let message: String?
}

extension InvalidElasticIpFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEndpointStateFault(message: \(String(describing: message)))"}
}

extension InvalidEndpointStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidEndpointStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The status of the endpoint is not valid.</p>
public struct InvalidEndpointStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidEndpointStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHsmClientCertificateStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidHsmClientCertificateStateFault(message: \(String(describing: message)))"}
}

extension InvalidHsmClientCertificateStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidHsmClientCertificateStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified HSM client certificate is not in the <code>available</code> state, or
///             it is still in use by one or more Amazon Redshift clusters.</p>
public struct InvalidHsmClientCertificateStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHsmClientCertificateStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidHsmClientCertificateStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHsmConfigurationStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidHsmConfigurationStateFault(message: \(String(describing: message)))"}
}

extension InvalidHsmConfigurationStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidHsmConfigurationStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified HSM configuration is not in the <code>available</code> state, or it
///             is still in use by one or more Amazon Redshift clusters.</p>
public struct InvalidHsmConfigurationStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHsmConfigurationStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidHsmConfigurationStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReservedNodeStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidReservedNodeStateFault(message: \(String(describing: message)))"}
}

extension InvalidReservedNodeStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidReservedNodeStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
public struct InvalidReservedNodeStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReservedNodeStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidReservedNodeStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRestoreFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRestoreFault(message: \(String(describing: message)))"}
}

extension InvalidRestoreFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRestoreFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The restore is invalid.</p>
public struct InvalidRestoreFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRestoreFaultBody: Equatable {
    public let message: String?
}

extension InvalidRestoreFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRetentionPeriodFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRetentionPeriodFault(message: \(String(describing: message)))"}
}

extension InvalidRetentionPeriodFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRetentionPeriodFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The retention period specified is either in the past or is not a valid value.</p>
///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
public struct InvalidRetentionPeriodFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRetentionPeriodFaultBody: Equatable {
    public let message: String?
}

extension InvalidRetentionPeriodFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketNameFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3BucketNameFault(message: \(String(describing: message)))"}
}

extension InvalidS3BucketNameFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidS3BucketNameFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The S3 bucket name is invalid. For more information about naming rules, go to
///                 <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket
///                 Restrictions and Limitations</a> in the Amazon Simple Storage Service (S3)
///             Developer Guide.</p>
public struct InvalidS3BucketNameFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketNameFaultBody: Equatable {
    public let message: String?
}

extension InvalidS3BucketNameFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KeyPrefixFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3KeyPrefixFault(message: \(String(describing: message)))"}
}

extension InvalidS3KeyPrefixFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidS3KeyPrefixFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The string specified for the logging S3 key prefix does not comply with the
///             documented constraints.</p>
public struct InvalidS3KeyPrefixFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KeyPrefixFaultBody: Equatable {
    public let message: String?
}

extension InvalidS3KeyPrefixFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidScheduleFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidScheduleFault(message: \(String(describing: message)))"}
}

extension InvalidScheduleFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidScheduleFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The schedule you submitted isn't valid.</p>
public struct InvalidScheduleFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidScheduleFaultBody: Equatable {
    public let message: String?
}

extension InvalidScheduleFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidScheduledActionFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidScheduledActionFault(message: \(String(describing: message)))"}
}

extension InvalidScheduledActionFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidScheduledActionFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The scheduled action is not valid. </p>
public struct InvalidScheduledActionFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidScheduledActionFaultBody: Equatable {
    public let message: String?
}

extension InvalidScheduledActionFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnapshotCopyGrantStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSnapshotCopyGrantStateFault(message: \(String(describing: message)))"}
}

extension InvalidSnapshotCopyGrantStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSnapshotCopyGrantStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The snapshot copy grant can't be deleted because it is used by one or more
///             clusters.</p>
public struct InvalidSnapshotCopyGrantStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSnapshotCopyGrantStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidSnapshotCopyGrantStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnet(message: \(String(describing: message)))"}
}

extension InvalidSubnet: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSubnetBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet is not valid, or not all of the subnets are in the same
///             VPC.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Equatable {
    public let message: String?
}

extension InvalidSubnetBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubscriptionStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubscriptionStateFault(message: \(String(describing: message)))"}
}

extension InvalidSubscriptionStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSubscriptionStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The subscription request is invalid because it is a duplicate request. This
///             subscription request is already in progress.</p>
public struct InvalidSubscriptionStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubscriptionStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidSubscriptionStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTableRestoreArgumentFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTableRestoreArgumentFault(message: \(String(describing: message)))"}
}

extension InvalidTableRestoreArgumentFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTableRestoreArgumentFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified for the <code>sourceDatabaseName</code>,
///                 <code>sourceSchemaName</code>, or <code>sourceTableName</code> parameter, or a
///             combination of these, doesn't exist in the snapshot.</p>
public struct InvalidTableRestoreArgumentFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTableRestoreArgumentFaultBody: Equatable {
    public let message: String?
}

extension InvalidTableRestoreArgumentFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagFault(message: \(String(describing: message)))"}
}

extension InvalidTagFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTagFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tag is invalid.</p>
public struct InvalidTagFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagFaultBody: Equatable {
    public let message: String?
}

extension InvalidTagFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageLimitFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidUsageLimitFault(message: \(String(describing: message)))"}
}

extension InvalidUsageLimitFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidUsageLimitFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage limit is not valid.</p>
public struct InvalidUsageLimitFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUsageLimitFaultBody: Equatable {
    public let message: String?
}

extension InvalidUsageLimitFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidVPCNetworkStateFault(message: \(String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidVPCNetworkStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster subnet group does not cover all Availability Zones.</p>
public struct InvalidVPCNetworkStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidVPCNetworkStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededFault(message: \(String(describing: message)))"}
}

extension LimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<LimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The encryption key has exceeded its grant limit in AWS KMS.</p>
public struct LimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededFaultBody: Equatable {
    public let message: String?
}

extension LimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaintenanceTrack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseVersion = "DatabaseVersion"
        case maintenanceTrackName = "MaintenanceTrackName"
        case updateTargets = "UpdateTargets"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let databaseVersion = databaseVersion {
            try container.encode(databaseVersion, forKey: Key("DatabaseVersion"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let updateTargets = updateTargets {
            var updateTargetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("UpdateTargets"))
            for (index0, updatetarget0) in updateTargets.enumerated() {
                try updateTargetsContainer.encode(updatetarget0, forKey: Key("UpdateTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let databaseVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseVersion)
        databaseVersion = databaseVersionDecoded
        if containerValues.contains(.updateTargets) {
            struct KeyVal0{struct UpdateTarget{}}
            let updateTargetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpdateTarget>.CodingKeys.self, forKey: .updateTargets)
            if let updateTargetsWrappedContainer = updateTargetsWrappedContainer {
                let updateTargetsContainer = try updateTargetsWrappedContainer.decodeIfPresent([UpdateTarget].self, forKey: .member)
                var updateTargetsBuffer:[UpdateTarget]? = nil
                if let updateTargetsContainer = updateTargetsContainer {
                    updateTargetsBuffer = [UpdateTarget]()
                    for structureContainer0 in updateTargetsContainer {
                        updateTargetsBuffer?.append(structureContainer0)
                    }
                }
                updateTargets = updateTargetsBuffer
            } else {
                updateTargets = []
            }
        } else {
            updateTargets = nil
        }
    }
}

extension MaintenanceTrack: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceTrack(databaseVersion: \(String(describing: databaseVersion)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), updateTargets: \(String(describing: updateTargets)))"}
}

/// <p>Defines a maintenance track that determines which Amazon Redshift version to apply
///             during a maintenance window. If the value for <code>MaintenanceTrack</code> is
///                 <code>current</code>, the cluster is updated to the most recently certified
///             maintenance release. If the value is <code>trailing</code>, the cluster is updated to
///             the previously certified maintenance release. </p>
public struct MaintenanceTrack: Equatable {
    /// <p>The version number for the cluster release.</p>
    public let databaseVersion: String?
    /// <p>The name of the maintenance track. Possible values are <code>current</code> and
    ///                 <code>trailing</code>.</p>
    public let maintenanceTrackName: String?
    /// <p>An array of <a>UpdateTarget</a> objects to update with the maintenance
    ///             track. </p>
    public let updateTargets: [UpdateTarget]?

    public init (
        databaseVersion: String? = nil,
        maintenanceTrackName: String? = nil,
        updateTargets: [UpdateTarget]? = nil
    )
    {
        self.databaseVersion = databaseVersion
        self.maintenanceTrackName = maintenanceTrackName
        self.updateTargets = updateTargets
    }
}

public enum Mode {
    case highPerformance
    case standard
    case sdkUnknown(String)
}

extension Mode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Mode] {
        return [
            .highPerformance,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .highPerformance: return "high-performance"
        case .standard: return "standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
    }
}

public struct ModifyAquaConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "ModifyAquaConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyAquaConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyAquaConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyAquaConfigurationInput>
    public typealias MOutput = OperationOutput<ModifyAquaConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyAquaConfigurationOutputError>
}

extension ModifyAquaConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyAquaConfigurationInput(aquaConfigurationStatus: \(String(describing: aquaConfigurationStatus)), clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension ModifyAquaConfigurationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: Key("AquaConfigurationStatus"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("ModifyAquaConfiguration", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyAquaConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyAquaConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyAquaConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyAquaConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyAquaConfigurationInput>
    public typealias MOutput = OperationOutput<ModifyAquaConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyAquaConfigurationOutputError>
}

public struct ModifyAquaConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyAquaConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyAquaConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyAquaConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyAquaConfigurationInput>
    public typealias MOutput = OperationOutput<ModifyAquaConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyAquaConfigurationOutputError>
}

public struct ModifyAquaConfigurationInput: Equatable {
    /// <p>The new value of AQUA configuration status. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - Don't use AQUA. </p>
    ///             </li>
    ///             <li>
    ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    ///             </li>
    ///          </ul>
    public let aquaConfigurationStatus: AquaConfigurationStatus?
    /// <p>The identifier of the cluster to be modified.</p>
    public let clusterIdentifier: String?

    public init (
        aquaConfigurationStatus: AquaConfigurationStatus? = nil,
        clusterIdentifier: String? = nil
    )
    {
        self.aquaConfigurationStatus = aquaConfigurationStatus
        self.clusterIdentifier = clusterIdentifier
    }
}

extension ModifyAquaConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyAquaConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyAquaConfigurationOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyAquaConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyAquaConfigurationOutputResponse(aquaConfiguration: \(String(describing: aquaConfiguration)))"}
}

extension ModifyAquaConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyAquaConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aquaConfiguration = output.aquaConfiguration
        } else {
            self.aquaConfiguration = nil
        }
    }
}

public struct ModifyAquaConfigurationOutputResponse: Equatable {
    /// <p>The updated AQUA configuration of the cluster. </p>
    public let aquaConfiguration: AquaConfiguration?

    public init (
        aquaConfiguration: AquaConfiguration? = nil
    )
    {
        self.aquaConfiguration = aquaConfiguration
    }
}

struct ModifyAquaConfigurationOutputResponseBody: Equatable {
    public let aquaConfiguration: AquaConfiguration?
}

extension ModifyAquaConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aquaConfiguration = "AquaConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyAquaConfigurationResult"))
        let aquaConfigurationDecoded = try containerValues.decodeIfPresent(AquaConfiguration.self, forKey: .aquaConfiguration)
        aquaConfiguration = aquaConfigurationDecoded
    }
}

public struct ModifyClusterDbRevisionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterDbRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterDbRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterDbRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterDbRevisionInput>
    public typealias MOutput = OperationOutput<ModifyClusterDbRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterDbRevisionOutputError>
}

extension ModifyClusterDbRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterDbRevisionInput(clusterIdentifier: \(String(describing: clusterIdentifier)), revisionTarget: \(String(describing: revisionTarget)))"}
}

extension ModifyClusterDbRevisionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let revisionTarget = revisionTarget {
            try container.encode(revisionTarget, forKey: Key("RevisionTarget"))
        }
        try container.encode("ModifyClusterDbRevision", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterDbRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterDbRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterDbRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterDbRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterDbRevisionInput>
    public typealias MOutput = OperationOutput<ModifyClusterDbRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterDbRevisionOutputError>
}

public struct ModifyClusterDbRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterDbRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterDbRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterDbRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterDbRevisionInput>
    public typealias MOutput = OperationOutput<ModifyClusterDbRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterDbRevisionOutputError>
}

public struct ModifyClusterDbRevisionInput: Equatable {
    /// <p>The unique identifier of a cluster whose database revision you want to modify. </p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: String?
    /// <p>The identifier of the database revision. You can retrieve this value from the
    ///             response to the <a>DescribeClusterDbRevisions</a> request.</p>
    public let revisionTarget: String?

    public init (
        clusterIdentifier: String? = nil,
        revisionTarget: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.revisionTarget = revisionTarget
    }
}

extension ModifyClusterDbRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterDbRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterOnLatestRevisionFault" : self = .clusterOnLatestRevisionFault(try ClusterOnLatestRevisionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterDbRevisionOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterOnLatestRevisionFault(ClusterOnLatestRevisionFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterDbRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterDbRevisionOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ModifyClusterDbRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyClusterDbRevisionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterDbRevisionOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterDbRevisionOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ModifyClusterDbRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyClusterDbRevisionResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifyClusterIamRolesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterIamRolesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterIamRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterIamRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterIamRolesInput>
    public typealias MOutput = OperationOutput<ModifyClusterIamRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterIamRolesOutputError>
}

extension ModifyClusterIamRolesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterIamRolesInput(addIamRoles: \(String(describing: addIamRoles)), clusterIdentifier: \(String(describing: clusterIdentifier)), removeIamRoles: \(String(describing: removeIamRoles)))"}
}

extension ModifyClusterIamRolesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let addIamRoles = addIamRoles {
            var addIamRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AddIamRoles"))
            for (index0, string0) in addIamRoles.enumerated() {
                try addIamRolesContainer.encode(string0, forKey: Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let removeIamRoles = removeIamRoles {
            var removeIamRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RemoveIamRoles"))
            for (index0, string0) in removeIamRoles.enumerated() {
                try removeIamRolesContainer.encode(string0, forKey: Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyClusterIamRoles", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterIamRolesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterIamRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterIamRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterIamRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterIamRolesInput>
    public typealias MOutput = OperationOutput<ModifyClusterIamRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterIamRolesOutputError>
}

public struct ModifyClusterIamRolesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterIamRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterIamRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterIamRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterIamRolesInput>
    public typealias MOutput = OperationOutput<ModifyClusterIamRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterIamRolesOutputError>
}

/// <p></p>
public struct ModifyClusterIamRolesInput: Equatable {
    /// <p>Zero or more IAM roles to associate with the cluster. The roles must be in their
    ///             Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single
    ///             cluster in a single request.</p>
    public let addIamRoles: [String]?
    /// <p>The unique identifier of the cluster for which you want to associate or
    ///             disassociate IAM roles.</p>
    public let clusterIdentifier: String?
    /// <p>Zero or more IAM roles in ARN format to disassociate from the cluster. You can
    ///             disassociate up to 10 IAM roles from a single cluster in a single request.</p>
    public let removeIamRoles: [String]?

    public init (
        addIamRoles: [String]? = nil,
        clusterIdentifier: String? = nil,
        removeIamRoles: [String]? = nil
    )
    {
        self.addIamRoles = addIamRoles
        self.clusterIdentifier = clusterIdentifier
        self.removeIamRoles = removeIamRoles
    }
}

extension ModifyClusterIamRolesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterIamRolesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterIamRolesOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterIamRolesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterIamRolesOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ModifyClusterIamRolesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyClusterIamRolesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterIamRolesOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterIamRolesOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ModifyClusterIamRolesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyClusterIamRolesResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifyClusterInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterOutputError>
}

extension ModifyClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterInput(allowVersionUpgrade: \(String(describing: allowVersionUpgrade)), automatedSnapshotRetentionPeriod: \(String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(String(describing: availabilityZone)), availabilityZoneRelocation: \(String(describing: availabilityZoneRelocation)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterParameterGroupName: \(String(describing: clusterParameterGroupName)), clusterSecurityGroups: \(String(describing: clusterSecurityGroups)), clusterType: \(String(describing: clusterType)), clusterVersion: \(String(describing: clusterVersion)), elasticIp: \(String(describing: elasticIp)), encrypted: \(String(describing: encrypted)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), kmsKeyId: \(String(describing: kmsKeyId)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), masterUserPassword: \(String(describing: masterUserPassword)), newClusterIdentifier: \(String(describing: newClusterIdentifier)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), port: \(String(describing: port)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(String(describing: publiclyAccessible)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowVersionUpgrade = allowVersionUpgrade {
            try container.encode(allowVersionUpgrade, forKey: Key("AllowVersionUpgrade"))
        }
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocation = availabilityZoneRelocation {
            try container.encode(availabilityZoneRelocation, forKey: Key("AvailabilityZoneRelocation"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterParameterGroupName = clusterParameterGroupName {
            try container.encode(clusterParameterGroupName, forKey: Key("ClusterParameterGroupName"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClusterSecurityGroups"))
            for (index0, string0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(string0, forKey: Key("ClusterSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: Key("ElasticIp"))
        }
        if let encrypted = encrypted {
            try container.encode(encrypted, forKey: Key("Encrypted"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: Key("EnhancedVpcRouting"))
        }
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let newClusterIdentifier = newClusterIdentifier {
            try container.encode(newClusterIdentifier, forKey: Key("NewClusterIdentifier"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyCluster", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterOutputError>
}

public struct ModifyClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterOutputError>
}

/// <p></p>
public struct ModifyClusterInput: Equatable {
    /// <p>If <code>true</code>, major version upgrades will be applied automatically to the
    ///             cluster during the maintenance window. </p>
    ///         <p>Default: <code>false</code>
    ///         </p>
    public let allowVersionUpgrade: Bool?
    /// <p>The number of days that automated snapshots are retained. If the value is 0,
    ///             automated snapshots are disabled. Even if automated snapshots are disabled, you can
    ///             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
    ///         <p>If you decrease the automated snapshot retention period from its current value,
    ///             existing automated snapshots that fall outside of the new retention period will be
    ///             immediately deleted.</p>
    ///
    ///         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Constraints: Must be a value from 0 to 35.</p>
    public let automatedSnapshotRetentionPeriod: Int?
    /// <p>The option to initiate relocation for an Amazon Redshift cluster to the target Availability Zone.</p>
    public let availabilityZone: String?
    /// <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete.</p>
    public let availabilityZoneRelocation: Bool?
    /// <p>The unique identifier of the cluster to be modified.</p>
    ///         <p>Example: <code>examplecluster</code>
    ///         </p>
    public let clusterIdentifier: String?
    /// <p>The name of the cluster parameter group to apply to this cluster. This change is
    ///             applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Constraints: The cluster parameter group must be in the same parameter group family
    ///             that matches the cluster version.</p>
    public let clusterParameterGroupName: String?
    /// <p>A list of cluster security groups to be authorized on this cluster. This change is
    ///             asynchronously applied as soon as possible.</p>
    ///         <p>Security groups currently associated with the cluster, and not in the list of
    ///             groups to apply, will be revoked from the cluster.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let clusterSecurityGroups: [String]?
    /// <p>The new cluster type.</p>
    ///         <p>When you submit your cluster resize request, your existing cluster goes into a
    ///             read-only mode. After Amazon Redshift provisions a new cluster based on your resize
    ///             requirements, there will be outage for a period while the old cluster is deleted and
    ///             your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p>
    ///         <p>Valid Values: <code> multi-node | single-node </code>
    ///         </p>
    public let clusterType: String?
    /// <p>The new version number of the Amazon Redshift engine to upgrade to.</p>
    ///         <p>For major version upgrades, if a non-default cluster parameter group is currently
    ///             in use, a new cluster parameter group in the cluster parameter group family for the new
    ///             version must be specified. The new cluster parameter group can be the default for that
    ///             cluster parameter group family.
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///         <p>Example: <code>1.0</code>
    ///         </p>
    public let clusterVersion: String?
    /// <p>The Elastic IP (EIP) address for the cluster.</p>
    ///         <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible
    ///             through an Internet gateway. For more information about provisioning clusters in
    ///             EC2-VPC, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported
    ///                 Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
    public let elasticIp: String?
    /// <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you
    ///             provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster
    ///             with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>,
    ///             we encrypt with the default key. </p>
    ///             <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
    public let encrypted: Bool?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Bool?
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    ///             retrieve the data encryption keys stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>Specifies the name of the HSM configuration that contains the information the
    ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that you want to use
    ///             to encrypt data in the cluster.</p>
    public let kmsKeyId: String?
    /// <p>The name for the maintenance track that you want to assign for the cluster. This name
    ///             change is asynchronous. The new track name stays in the
    ///                 <code>PendingModifiedValues</code> for the cluster until the next maintenance
    ///             window. When the maintenance track changes, the cluster is switched to the latest
    ///             cluster release available for the maintenance track. At this point, the maintenance
    ///             track name is applied.</p>
    public let maintenanceTrackName: String?
    /// <p>The default for number of days that a newly created manual snapshot is retained. If
    ///             the value is -1, the manual snapshot is retained indefinitely. This value doesn't
    ///             retroactively change the retention periods of existing manual snapshots.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    ///         <p>The default value is -1.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>The new password for the cluster master user. This change is asynchronously applied
    ///             as soon as possible. Between the time of the request and the completion of the request,
    ///             the <code>MasterUserPassword</code> element exists in the
    ///                 <code>PendingModifiedValues</code> element of the operation response. </p>
    ///         <note>
    ///             <p>Operations never return the password, so this operation provides a way to
    ///                 regain access to the master user account for a cluster if the password is
    ///                 lost.</p>
    ///         </note>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be between 8 and 64 characters in length.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one uppercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain at least one lowercase letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must contain one number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can be any printable ASCII character (ASCII code 33 to 126) except '
    ///                     (single quote), " (double quote), \, /, @, or space.</p>
    ///             </li>
    ///          </ul>
    public let masterUserPassword: String?
    /// <p>The new identifier for the cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    ///
    ///             <p>Example: <code>examplecluster</code>
    ///         </p>
    public let newClusterIdentifier: String?
    /// <p>The new node type of the cluster. If you specify a new node type, you must also
    ///             specify the number of nodes parameter.</p>
    ///         <p>
    /// For more information about resizing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///
    ///         <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> |
    ///             <code>dc1.large</code> | <code>dc1.8xlarge</code> |
    ///             <code>dc2.large</code> | <code>dc2.8xlarge</code> |
    ///             <code>ra3.xlplus</code> |  <code>ra3.4xlarge</code> | <code>ra3.16xlarge</code>
    ///          </p>
    public let nodeType: String?
    /// <p>The new number of nodes of the cluster. If you specify a new number of nodes, you
    ///             must also specify the node type parameter.</p>
    ///         <p>
    /// For more information about resizing clusters, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    ///
    ///         <p>Valid Values: Integer greater than <code>0</code>.</p>
    public let numberOfNodes: Int?
    /// <p>The option to change the port of an Amazon Redshift cluster.</p>
    public let port: Int?
    /// <p>The weekly time range (in UTC) during which system maintenance can occur, if
    ///             necessary. If system maintenance is necessary during the window, it may result in an
    ///             outage.</p>
    ///         <p>This maintenance window change is made immediately. If the new maintenance window
    ///             indicates the current time, there must be at least 120 minutes between the current time
    ///             and end of the window in order to ensure that pending changes are applied.</p>
    ///         <p>Default: Uses existing setting.</p>
    ///         <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example
    ///             <code>wed:07:30-wed:08:00</code>.</p>
    ///         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///         <p>Constraints: Must be at least 30 minutes.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>If <code>true</code>, the cluster can be accessed from a public network. Only
    ///             clusters in VPCs can be set to be publicly available.</p>
    public let publiclyAccessible: Bool?
    /// <p>A list of virtual private cloud (VPC) security groups to be associated with the
    ///             cluster. This change is asynchronously applied as soon as possible.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allowVersionUpgrade: Bool? = nil,
        automatedSnapshotRetentionPeriod: Int? = nil,
        availabilityZone: String? = nil,
        availabilityZoneRelocation: Bool? = nil,
        clusterIdentifier: String? = nil,
        clusterParameterGroupName: String? = nil,
        clusterSecurityGroups: [String]? = nil,
        clusterType: String? = nil,
        clusterVersion: String? = nil,
        elasticIp: String? = nil,
        encrypted: Bool? = nil,
        enhancedVpcRouting: Bool? = nil,
        hsmClientCertificateIdentifier: String? = nil,
        hsmConfigurationIdentifier: String? = nil,
        kmsKeyId: String? = nil,
        maintenanceTrackName: String? = nil,
        manualSnapshotRetentionPeriod: Int? = nil,
        masterUserPassword: String? = nil,
        newClusterIdentifier: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int? = nil,
        port: Int? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allowVersionUpgrade = allowVersionUpgrade
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.availabilityZoneRelocation = availabilityZoneRelocation
        self.clusterIdentifier = clusterIdentifier
        self.clusterParameterGroupName = clusterParameterGroupName
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterType = clusterType
        self.clusterVersion = clusterVersion
        self.elasticIp = elasticIp
        self.encrypted = encrypted
        self.enhancedVpcRouting = enhancedVpcRouting
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.masterUserPassword = masterUserPassword
        self.newClusterIdentifier = newClusterIdentifier
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.port = port
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

public struct ModifyClusterMaintenanceInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterMaintenanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterMaintenanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterMaintenanceInput>
    public typealias MOutput = OperationOutput<ModifyClusterMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterMaintenanceOutputError>
}

extension ModifyClusterMaintenanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterMaintenanceInput(clusterIdentifier: \(String(describing: clusterIdentifier)), deferMaintenance: \(String(describing: deferMaintenance)), deferMaintenanceDuration: \(String(describing: deferMaintenanceDuration)), deferMaintenanceEndTime: \(String(describing: deferMaintenanceEndTime)), deferMaintenanceIdentifier: \(String(describing: deferMaintenanceIdentifier)), deferMaintenanceStartTime: \(String(describing: deferMaintenanceStartTime)))"}
}

extension ModifyClusterMaintenanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let deferMaintenance = deferMaintenance {
            try container.encode(deferMaintenance, forKey: Key("DeferMaintenance"))
        }
        if let deferMaintenanceDuration = deferMaintenanceDuration {
            try container.encode(deferMaintenanceDuration, forKey: Key("DeferMaintenanceDuration"))
        }
        if let deferMaintenanceEndTime = deferMaintenanceEndTime {
            try container.encode(TimestampWrapper(deferMaintenanceEndTime, format: .dateTime), forKey: Key("deferMaintenanceEndTime"))
        }
        if let deferMaintenanceIdentifier = deferMaintenanceIdentifier {
            try container.encode(deferMaintenanceIdentifier, forKey: Key("DeferMaintenanceIdentifier"))
        }
        if let deferMaintenanceStartTime = deferMaintenanceStartTime {
            try container.encode(TimestampWrapper(deferMaintenanceStartTime, format: .dateTime), forKey: Key("deferMaintenanceStartTime"))
        }
        try container.encode("ModifyClusterMaintenance", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterMaintenanceInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterMaintenanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterMaintenanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterMaintenanceInput>
    public typealias MOutput = OperationOutput<ModifyClusterMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterMaintenanceOutputError>
}

public struct ModifyClusterMaintenanceInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterMaintenanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterMaintenanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterMaintenanceInput>
    public typealias MOutput = OperationOutput<ModifyClusterMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterMaintenanceOutputError>
}

public struct ModifyClusterMaintenanceInput: Equatable {
    /// <p>A unique identifier for the cluster.</p>
    public let clusterIdentifier: String?
    /// <p>A boolean indicating whether to enable the deferred maintenance window. </p>
    public let deferMaintenance: Bool?
    /// <p>An integer indicating the duration of the maintenance window in days. If you specify a
    ///             duration, you can't specify an end time. The duration must be 45 days or less.</p>
    public let deferMaintenanceDuration: Int?
    /// <p>A timestamp indicating end time for the deferred maintenance window. If you specify an
    ///             end time, you can't specify a duration.</p>
    public let deferMaintenanceEndTime: Date?
    /// <p>A unique identifier for the deferred maintenance window.</p>
    public let deferMaintenanceIdentifier: String?
    /// <p>A timestamp indicating the start time for the deferred maintenance window.</p>
    public let deferMaintenanceStartTime: Date?

    public init (
        clusterIdentifier: String? = nil,
        deferMaintenance: Bool? = nil,
        deferMaintenanceDuration: Int? = nil,
        deferMaintenanceEndTime: Date? = nil,
        deferMaintenanceIdentifier: String? = nil,
        deferMaintenanceStartTime: Date? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.deferMaintenance = deferMaintenance
        self.deferMaintenanceDuration = deferMaintenanceDuration
        self.deferMaintenanceEndTime = deferMaintenanceEndTime
        self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
        self.deferMaintenanceStartTime = deferMaintenanceStartTime
    }
}

extension ModifyClusterMaintenanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterMaintenanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterMaintenanceOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterMaintenanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterMaintenanceOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ModifyClusterMaintenanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyClusterMaintenanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterMaintenanceOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterMaintenanceOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ModifyClusterMaintenanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyClusterMaintenanceResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension ModifyClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidElasticIpFault" : self = .invalidElasticIpFault(try InvalidElasticIpFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TableLimitExceededFault" : self = .tableLimitExceededFault(try TableLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOptionFault" : self = .unsupportedOptionFault(try UnsupportedOptionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterOutputError: Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case invalidElasticIpFault(InvalidElasticIpFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case tableLimitExceededFault(TableLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unsupportedOptionFault(UnsupportedOptionFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ModifyClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ModifyClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifyClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterParameterGroupOutputError>
}

extension ModifyClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterParameterGroupInput(parameterGroupName: \(String(describing: parameterGroupName)), parameters: \(String(describing: parameters)))"}
}

extension ModifyClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterParameterGroupOutputError>
}

public struct ModifyClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterParameterGroupOutputError>
}

/// <p>Describes a modify cluster parameter group operation. </p>
public struct ModifyClusterParameterGroupInput: Equatable {
    /// <p>The name of the parameter group to be modified.</p>
    public let parameterGroupName: String?
    /// <p>An array of parameters to be modified. A maximum of 20 parameters can be modified
    ///             in a single request.</p>
    ///         <p>For each parameter to be modified, you must supply at least the parameter name and
    ///             parameter value; other name-value pairs of the parameter are optional.</p>
    ///         <p>For the workload management (WLM) configuration, you must supply all the name-value
    ///             pairs in the wlm_json_configuration parameter.</p>
    public let parameters: [Parameter]?

    public init (
        parameterGroupName: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameters = parameters
    }
}

extension ModifyClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterParameterGroupStateFault" : self = .invalidClusterParameterGroupStateFault(try InvalidClusterParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterParameterGroupOutputError: Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidClusterParameterGroupStateFault(InvalidClusterParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterParameterGroupOutputResponse(parameterGroupName: \(String(describing: parameterGroupName)), parameterGroupStatus: \(String(describing: parameterGroupStatus)))"}
}

extension ModifyClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.parameterGroupName = output.parameterGroupName
            self.parameterGroupStatus = output.parameterGroupStatus
        } else {
            self.parameterGroupName = nil
            self.parameterGroupStatus = nil
        }
    }
}

/// <p></p>
public struct ModifyClusterParameterGroupOutputResponse: Equatable {
    /// <p>The name of the cluster parameter group.</p>
    public let parameterGroupName: String?
    /// <p>The status of the parameter group. For example, if you made a change to a parameter
    ///             group name-value pair, then the change could be pending a reboot of an associated
    ///             cluster.</p>
    public let parameterGroupStatus: String?

    public init (
        parameterGroupName: String? = nil,
        parameterGroupStatus: String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterGroupStatus = parameterGroupStatus
    }
}

struct ModifyClusterParameterGroupOutputResponseBody: Equatable {
    public let parameterGroupName: String?
    public let parameterGroupStatus: String?
}

extension ModifyClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyClusterParameterGroupResult"))
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

public struct ModifyClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSnapshotInput>
    public typealias MOutput = OperationOutput<ModifyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSnapshotOutputError>
}

extension ModifyClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterSnapshotInput(force: \(String(describing: force)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), snapshotIdentifier: \(String(describing: snapshotIdentifier)))"}
}

extension ModifyClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if force != false {
            try container.encode(force, forKey: Key("Force"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        try container.encode("ModifyClusterSnapshot", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSnapshotInput>
    public typealias MOutput = OperationOutput<ModifyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSnapshotOutputError>
}

public struct ModifyClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSnapshotInput>
    public typealias MOutput = OperationOutput<ModifyClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSnapshotOutputError>
}

public struct ModifyClusterSnapshotInput: Equatable {
    /// <p>A Boolean option to override an exception if the retention period has already
    ///             passed.</p>
    public let force: Bool
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely.</p>
    ///         <p>If the manual snapshot falls outside of the new retention period, you can specify the
    ///             force option to immediately delete the snapshot.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>The identifier of the snapshot whose setting you want to modify.</p>
    public let snapshotIdentifier: String?

    public init (
        force: Bool = false,
        manualSnapshotRetentionPeriod: Int? = nil,
        snapshotIdentifier: String? = nil
    )
    {
        self.force = force
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension ModifyClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterSnapshotOutputError: Equatable {
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterSnapshotOutputResponse(snapshot: \(String(describing: snapshot)))"}
}

extension ModifyClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct ModifyClusterSnapshotOutputResponse: Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: Snapshot?

    public init (
        snapshot: Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct ModifyClusterSnapshotOutputResponseBody: Equatable {
    public let snapshot: Snapshot?
}

extension ModifyClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyClusterSnapshotResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct ModifyClusterSnapshotScheduleInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSnapshotScheduleOutputError>
}

extension ModifyClusterSnapshotScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterSnapshotScheduleInput(clusterIdentifier: \(String(describing: clusterIdentifier)), disassociateSchedule: \(String(describing: disassociateSchedule)), scheduleIdentifier: \(String(describing: scheduleIdentifier)))"}
}

extension ModifyClusterSnapshotScheduleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let disassociateSchedule = disassociateSchedule {
            try container.encode(disassociateSchedule, forKey: Key("DisassociateSchedule"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: Key("ScheduleIdentifier"))
        }
        try container.encode("ModifyClusterSnapshotSchedule", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterSnapshotScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSnapshotScheduleOutputError>
}

public struct ModifyClusterSnapshotScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<ModifyClusterSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSnapshotScheduleOutputError>
}

public struct ModifyClusterSnapshotScheduleInput: Equatable {
    /// <p>A unique identifier for the cluster whose snapshot schedule you want to modify.
    ///         </p>
    public let clusterIdentifier: String?
    /// <p>A boolean to indicate whether to remove the assoiciation between the cluster and the
    ///             schedule.</p>
    public let disassociateSchedule: Bool?
    /// <p>A unique alphanumeric identifier for the schedule that you want to associate with the
    ///             cluster.</p>
    public let scheduleIdentifier: String?

    public init (
        clusterIdentifier: String? = nil,
        disassociateSchedule: Bool? = nil,
        scheduleIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.disassociateSchedule = disassociateSchedule
        self.scheduleIdentifier = scheduleIdentifier
    }
}

extension ModifyClusterSnapshotScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterSnapshotScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotScheduleStateFault" : self = .invalidClusterSnapshotScheduleStateFault(try InvalidClusterSnapshotScheduleStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterSnapshotScheduleOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterSnapshotScheduleStateFault(InvalidClusterSnapshotScheduleStateFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterSnapshotScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterSnapshotScheduleOutputResponse()"}
}

extension ModifyClusterSnapshotScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyClusterSnapshotScheduleOutputResponse: Equatable {

    public init() {}
}

struct ModifyClusterSnapshotScheduleOutputResponseBody: Equatable {
}

extension ModifyClusterSnapshotScheduleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ModifyClusterSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSubnetGroupOutputError>
}

extension ModifyClusterSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterSubnetGroupInput(clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), description: \(String(describing: description)), subnetIds: \(String(describing: subnetIds)))"}
}

extension ModifyClusterSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyClusterSubnetGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyClusterSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSubnetGroupOutputError>
}

public struct ModifyClusterSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyClusterSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterSubnetGroupOutputError>
}

/// <p></p>
public struct ModifyClusterSubnetGroupInput: Equatable {
    /// <p>The name of the subnet group to be modified.</p>
    public let clusterSubnetGroupName: String?
    /// <p>A text description of the subnet group to be modified.</p>
    public let description: String?
    /// <p>An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single
    ///             request.</p>
    public let subnetIds: [String]?

    public init (
        clusterSubnetGroupName: String? = nil,
        description: String? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.description = description
        self.subnetIds = subnetIds
    }
}

extension ModifyClusterSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyClusterSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetQuotaExceededFault" : self = .clusterSubnetQuotaExceededFault(try ClusterSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterSubnetGroupOutputError: Equatable {
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case clusterSubnetQuotaExceededFault(ClusterSubnetQuotaExceededFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidSubnet(InvalidSubnet)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterSubnetGroupOutputResponse(clusterSubnetGroup: \(String(describing: clusterSubnetGroup)))"}
}

extension ModifyClusterSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyClusterSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterSubnetGroup = output.clusterSubnetGroup
        } else {
            self.clusterSubnetGroup = nil
        }
    }
}

public struct ModifyClusterSubnetGroupOutputResponse: Equatable {
    /// <p>Describes a subnet group.</p>
    public let clusterSubnetGroup: ClusterSubnetGroup?

    public init (
        clusterSubnetGroup: ClusterSubnetGroup? = nil
    )
    {
        self.clusterSubnetGroup = clusterSubnetGroup
    }
}

struct ModifyClusterSubnetGroupOutputResponseBody: Equatable {
    public let clusterSubnetGroup: ClusterSubnetGroup?
}

extension ModifyClusterSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterSubnetGroup = "ClusterSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyClusterSubnetGroupResult"))
        let clusterSubnetGroupDecoded = try containerValues.decodeIfPresent(ClusterSubnetGroup.self, forKey: .clusterSubnetGroup)
        clusterSubnetGroup = clusterSubnetGroupDecoded
    }
}

public struct ModifyEndpointAccessInputBodyMiddleware: Middleware {
    public let id: String = "ModifyEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEndpointAccessInput>
    public typealias MOutput = OperationOutput<ModifyEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEndpointAccessOutputError>
}

extension ModifyEndpointAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEndpointAccessInput(endpointName: \(String(describing: endpointName)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyEndpointAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpointName = endpointName {
            try container.encode(endpointName, forKey: Key("EndpointName"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyEndpointAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyEndpointAccessInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEndpointAccessInput>
    public typealias MOutput = OperationOutput<ModifyEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEndpointAccessOutputError>
}

public struct ModifyEndpointAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEndpointAccessInput>
    public typealias MOutput = OperationOutput<ModifyEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEndpointAccessOutputError>
}

public struct ModifyEndpointAccessInput: Equatable {
    /// <p>The endpoint to be modified.</p>
    public let endpointName: String?
    /// <p>The complete list of VPC security groups associated with the endpoint after the endpoint is modified.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        endpointName: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.endpointName = endpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyEndpointAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEndpointAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointStateFault" : self = .invalidEndpointStateFault(try InvalidEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEndpointAccessOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidEndpointStateFault(InvalidEndpointStateFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEndpointAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEndpointAccessOutputResponse(address: \(String(describing: address)), clusterIdentifier: \(String(describing: clusterIdentifier)), endpointCreateTime: \(String(describing: endpointCreateTime)), endpointName: \(String(describing: endpointName)), endpointStatus: \(String(describing: endpointStatus)), port: \(String(describing: port)), resourceOwner: \(String(describing: resourceOwner)), subnetGroupName: \(String(describing: subnetGroupName)), vpcEndpoint: \(String(describing: vpcEndpoint)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

extension ModifyEndpointAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.address = output.address
            self.clusterIdentifier = output.clusterIdentifier
            self.endpointCreateTime = output.endpointCreateTime
            self.endpointName = output.endpointName
            self.endpointStatus = output.endpointStatus
            self.port = output.port
            self.resourceOwner = output.resourceOwner
            self.subnetGroupName = output.subnetGroupName
            self.vpcEndpoint = output.vpcEndpoint
            self.vpcSecurityGroups = output.vpcSecurityGroups
        } else {
            self.address = nil
            self.clusterIdentifier = nil
            self.endpointCreateTime = nil
            self.endpointName = nil
            self.endpointStatus = nil
            self.port = 0
            self.resourceOwner = nil
            self.subnetGroupName = nil
            self.vpcEndpoint = nil
            self.vpcSecurityGroups = nil
        }
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
public struct ModifyEndpointAccessOutputResponse: Equatable {
    /// <p>The DNS address of the endpoint.</p>
    public let address: String?
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    public let clusterIdentifier: String?
    /// <p>The time (UTC) that the endpoint was created.</p>
    public let endpointCreateTime: Date?
    /// <p>The name of the endpoint.</p>
    public let endpointName: String?
    /// <p>The status of the endpoint.</p>
    public let endpointStatus: String?
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    public let port: Int
    /// <p>The AWS account ID of the owner of the cluster.</p>
    public let resourceOwner: String?
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    public let subnetGroupName: String?
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpoint: VpcEndpoint?
    /// <p>The security groups associated with the endpoint.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        address: String? = nil,
        clusterIdentifier: String? = nil,
        endpointCreateTime: Date? = nil,
        endpointName: String? = nil,
        endpointStatus: String? = nil,
        port: Int = 0,
        resourceOwner: String? = nil,
        subnetGroupName: String? = nil,
        vpcEndpoint: VpcEndpoint? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.address = address
        self.clusterIdentifier = clusterIdentifier
        self.endpointCreateTime = endpointCreateTime
        self.endpointName = endpointName
        self.endpointStatus = endpointStatus
        self.port = port
        self.resourceOwner = resourceOwner
        self.subnetGroupName = subnetGroupName
        self.vpcEndpoint = vpcEndpoint
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct ModifyEndpointAccessOutputResponseBody: Equatable {
    public let clusterIdentifier: String?
    public let resourceOwner: String?
    public let subnetGroupName: String?
    public let endpointStatus: String?
    public let endpointName: String?
    public let endpointCreateTime: Date?
    public let port: Int
    public let address: String?
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?
    public let vpcEndpoint: VpcEndpoint?
}

extension ModifyEndpointAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case clusterIdentifier = "ClusterIdentifier"
        case endpointCreateTime = "EndpointCreateTime"
        case endpointName = "EndpointName"
        case endpointStatus = "EndpointStatus"
        case port = "Port"
        case resourceOwner = "ResourceOwner"
        case subnetGroupName = "SubnetGroupName"
        case vpcEndpoint = "VpcEndpoint"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyEndpointAccessResult"))
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointCreateTime)
        var endpointCreateTimeBuffer:Date? = nil
        if let endpointCreateTimeDecoded = endpointCreateTimeDecoded {
            endpointCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endpointCreateTimeDecoded, format: .dateTime)
        }
        endpointCreateTime = endpointCreateTimeBuffer
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), severity: \(String(describing: severity)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIds: \(String(describing: sourceIds)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("ModifyEventSubscription", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

/// <p></p>
public struct ModifyEventSubscriptionInput: Equatable {
    /// <p>A Boolean value indicating if the subscription is enabled. <code>true</code>
    ///             indicates the subscription is enabled </p>
    public let enabled: Bool?
    /// <p>Specifies the Amazon Redshift event categories to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: configuration, management, monitoring, security</p>
    public let eventCategories: [String]?
    /// <p>Specifies the Amazon Redshift event severity to be published by the event notification
    ///             subscription.</p>
    ///         <p>Values: ERROR, INFO</p>
    public let severity: String?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic to be used by the event
    ///             notification subscription.</p>
    public let snsTopicArn: String?
    /// <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects
    ///             must be of the same type as was specified in the source type parameter. The event
    ///             subscription will return only events generated by the specified objects. If not
    ///             specified, then events are returned for all objects within the source type
    ///             specified.</p>
    ///         <p>Example: my-cluster-1, my-cluster-2</p>
    ///         <p>Example: my-snapshot-20131010</p>
    public let sourceIds: [String]?
    /// <p>The type of source that will be generating the events. For example, if you want to
    ///             be notified of events generated by a cluster, you would set this parameter to cluster.
    ///             If this value is not specified, events are returned for all Amazon Redshift objects in your
    ///             AWS account. You must specify a source type in order to specify source IDs.</p>
    ///         <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
    public let sourceType: String?
    /// <p>The name of the modified Amazon Redshift event notification subscription.</p>
    public let subscriptionName: String?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        severity: String? = nil,
        snsTopicArn: String? = nil,
        sourceIds: [String]? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.severity = severity
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

extension ModifyEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidSubscriptionStateFault" : self = .invalidSubscriptionStateFault(try InvalidSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionEventIdNotFoundFault" : self = .subscriptionEventIdNotFoundFault(try SubscriptionEventIdNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionSeverityNotFoundFault" : self = .subscriptionSeverityNotFoundFault(try SubscriptionSeverityNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Equatable {
    case invalidSubscriptionStateFault(InvalidSubscriptionStateFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionEventIdNotFoundFault(SubscriptionEventIdNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case subscriptionSeverityNotFoundFault(SubscriptionSeverityNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct ModifyEventSubscriptionOutputResponse: Equatable {
    /// <p>Describes event subscriptions.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct ModifyScheduledActionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyScheduledActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyScheduledActionInput>
    public typealias MOutput = OperationOutput<ModifyScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyScheduledActionOutputError>
}

extension ModifyScheduledActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyScheduledActionInput(enable: \(String(describing: enable)), endTime: \(String(describing: endTime)), iamRole: \(String(describing: iamRole)), schedule: \(String(describing: schedule)), scheduledActionDescription: \(String(describing: scheduledActionDescription)), scheduledActionName: \(String(describing: scheduledActionName)), startTime: \(String(describing: startTime)), targetAction: \(String(describing: targetAction)))"}
}

extension ModifyScheduledActionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enable = enable {
            try container.encode(enable, forKey: Key("Enable"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let iamRole = iamRole {
            try container.encode(iamRole, forKey: Key("IamRole"))
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: Key("Schedule"))
        }
        if let scheduledActionDescription = scheduledActionDescription {
            try container.encode(scheduledActionDescription, forKey: Key("ScheduledActionDescription"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let targetAction = targetAction {
            try container.encode(targetAction, forKey: Key("TargetAction"))
        }
        try container.encode("ModifyScheduledAction", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyScheduledActionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyScheduledActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyScheduledActionInput>
    public typealias MOutput = OperationOutput<ModifyScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyScheduledActionOutputError>
}

public struct ModifyScheduledActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyScheduledActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyScheduledActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyScheduledActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyScheduledActionInput>
    public typealias MOutput = OperationOutput<ModifyScheduledActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyScheduledActionOutputError>
}

public struct ModifyScheduledActionInput: Equatable {
    /// <p>A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. </p>
    public let enable: Bool?
    /// <p>A modified end time of the scheduled action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let endTime: Date?
    /// <p>A different IAM role to assume to run the target action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let iamRole: String?
    /// <p>A modified schedule in either <code>at( )</code> or <code>cron( )</code> format.
    ///             For more information about this parameter, see <a>ScheduledAction</a>.</p>
    public let schedule: String?
    /// <p>A modified description of the scheduled action. </p>
    public let scheduledActionDescription: String?
    /// <p>The name of the scheduled action to modify. </p>
    public let scheduledActionName: String?
    /// <p>A modified start time of the scheduled action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let startTime: Date?
    /// <p>A modified JSON format of the scheduled action.
    ///             For more information about this parameter, see <a>ScheduledAction</a>. </p>
    public let targetAction: ScheduledActionType?

    public init (
        enable: Bool? = nil,
        endTime: Date? = nil,
        iamRole: String? = nil,
        schedule: String? = nil,
        scheduledActionDescription: String? = nil,
        scheduledActionName: String? = nil,
        startTime: Date? = nil,
        targetAction: ScheduledActionType? = nil
    )
    {
        self.enable = enable
        self.endTime = endTime
        self.iamRole = iamRole
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

extension ModifyScheduledActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyScheduledActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidScheduledActionFault" : self = .invalidScheduledActionFault(try InvalidScheduledActionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionNotFoundFault" : self = .scheduledActionNotFoundFault(try ScheduledActionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScheduledActionTypeUnsupportedFault" : self = .scheduledActionTypeUnsupportedFault(try ScheduledActionTypeUnsupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyScheduledActionOutputError: Equatable {
    case invalidScheduledActionFault(InvalidScheduledActionFault)
    case invalidScheduleFault(InvalidScheduleFault)
    case scheduledActionNotFoundFault(ScheduledActionNotFoundFault)
    case scheduledActionTypeUnsupportedFault(ScheduledActionTypeUnsupportedFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyScheduledActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyScheduledActionOutputResponse(endTime: \(String(describing: endTime)), iamRole: \(String(describing: iamRole)), nextInvocations: \(String(describing: nextInvocations)), schedule: \(String(describing: schedule)), scheduledActionDescription: \(String(describing: scheduledActionDescription)), scheduledActionName: \(String(describing: scheduledActionName)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), targetAction: \(String(describing: targetAction)))"}
}

extension ModifyScheduledActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyScheduledActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.iamRole = output.iamRole
            self.nextInvocations = output.nextInvocations
            self.schedule = output.schedule
            self.scheduledActionDescription = output.scheduledActionDescription
            self.scheduledActionName = output.scheduledActionName
            self.startTime = output.startTime
            self.state = output.state
            self.targetAction = output.targetAction
        } else {
            self.endTime = nil
            self.iamRole = nil
            self.nextInvocations = nil
            self.schedule = nil
            self.scheduledActionDescription = nil
            self.scheduledActionName = nil
            self.startTime = nil
            self.state = nil
            self.targetAction = nil
        }
    }
}

/// <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
///             For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
public struct ModifyScheduledActionOutputResponse: Equatable {
    /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
    public let endTime: Date?
    /// <p>The IAM role to assume to run the scheduled action.
    ///             This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
    ///             This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
    ///
    /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public let iamRole: String?
    /// <p>List of times when the scheduled action will run. </p>
    public let nextInvocations: [Date]?
    /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
    ///             Schedule invocations must be separated by at least one hour.</p>
    ///         <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
    ///         <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
    ///             For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
    ///             in the <i>Amazon CloudWatch Events User Guide</i>.</p>
    public let schedule: String?
    /// <p>The description of the scheduled action. </p>
    public let scheduledActionDescription: String?
    /// <p>The name of the scheduled action. </p>
    public let scheduledActionName: String?
    /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
    public let startTime: Date?
    /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
    public let state: ScheduledActionState?
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
    ///         <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
    public let targetAction: ScheduledActionType?

    public init (
        endTime: Date? = nil,
        iamRole: String? = nil,
        nextInvocations: [Date]? = nil,
        schedule: String? = nil,
        scheduledActionDescription: String? = nil,
        scheduledActionName: String? = nil,
        startTime: Date? = nil,
        state: ScheduledActionState? = nil,
        targetAction: ScheduledActionType? = nil
    )
    {
        self.endTime = endTime
        self.iamRole = iamRole
        self.nextInvocations = nextInvocations
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.state = state
        self.targetAction = targetAction
    }
}

struct ModifyScheduledActionOutputResponseBody: Equatable {
    public let scheduledActionName: String?
    public let targetAction: ScheduledActionType?
    public let schedule: String?
    public let iamRole: String?
    public let scheduledActionDescription: String?
    public let state: ScheduledActionState?
    public let nextInvocations: [Date]?
    public let startTime: Date?
    public let endTime: Date?
}

extension ModifyScheduledActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyScheduledActionResult"))
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        var startTimeBuffer:Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        var endTimeBuffer:Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}

public struct ModifySnapshotCopyRetentionPeriodInputBodyMiddleware: Middleware {
    public let id: String = "ModifySnapshotCopyRetentionPeriodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>
    public typealias MOutput = OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySnapshotCopyRetentionPeriodOutputError>
}

extension ModifySnapshotCopyRetentionPeriodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifySnapshotCopyRetentionPeriodInput(clusterIdentifier: \(String(describing: clusterIdentifier)), manual: \(String(describing: manual)), retentionPeriod: \(String(describing: retentionPeriod)))"}
}

extension ModifySnapshotCopyRetentionPeriodInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if manual != false {
            try container.encode(manual, forKey: Key("Manual"))
        }
        if retentionPeriod != 0 {
            try container.encode(retentionPeriod, forKey: Key("RetentionPeriod"))
        }
        try container.encode("ModifySnapshotCopyRetentionPeriod", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifySnapshotCopyRetentionPeriodInputHeadersMiddleware: Middleware {
    public let id: String = "ModifySnapshotCopyRetentionPeriodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>
    public typealias MOutput = OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySnapshotCopyRetentionPeriodOutputError>
}

public struct ModifySnapshotCopyRetentionPeriodInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifySnapshotCopyRetentionPeriodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySnapshotCopyRetentionPeriodInput>
    public typealias MOutput = OperationOutput<ModifySnapshotCopyRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySnapshotCopyRetentionPeriodOutputError>
}

/// <p></p>
public struct ModifySnapshotCopyRetentionPeriodInput: Equatable {
    /// <p>The unique identifier of the cluster for which you want to change the retention
    ///             period for either automated or manual snapshots that are copied to a destination AWS
    ///             Region.</p>
    ///         <p>Constraints: Must be the valid name of an existing cluster that has cross-region
    ///             snapshot copy enabled.</p>
    public let clusterIdentifier: String?
    /// <p>Indicates whether to apply the snapshot retention period to newly copied manual
    ///             snapshots instead of automated snapshots.</p>
    public let manual: Bool
    /// <p>The number of days to retain automated snapshots in the destination AWS Region
    ///             after they are copied from the source AWS Region.</p>
    ///         <p>By default, this only changes the retention period of copied automated snapshots. </p>
    ///         <p>If you decrease the retention period for automated snapshots that are copied to a
    ///             destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were
    ///             copied to the destination AWS Region and that fall outside of the new retention
    ///             period.</p>
    ///         <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p>
    ///         <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will
    ///             have the new retention period. </p>
    ///         <p>If you specify the value of -1 newly copied manual snapshots are retained
    ///             indefinitely.</p>
    ///         <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653
    ///             for manual snapshots.</p>
    public let retentionPeriod: Int

    public init (
        clusterIdentifier: String? = nil,
        manual: Bool = false,
        retentionPeriod: Int = 0
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.manual = manual
        self.retentionPeriod = retentionPeriod
    }
}

extension ModifySnapshotCopyRetentionPeriodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifySnapshotCopyRetentionPeriodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRetentionPeriodFault" : self = .invalidRetentionPeriodFault(try InvalidRetentionPeriodFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotCopyDisabledFault" : self = .snapshotCopyDisabledFault(try SnapshotCopyDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifySnapshotCopyRetentionPeriodOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidRetentionPeriodFault(InvalidRetentionPeriodFault)
    case snapshotCopyDisabledFault(SnapshotCopyDisabledFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySnapshotCopyRetentionPeriodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifySnapshotCopyRetentionPeriodOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ModifySnapshotCopyRetentionPeriodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifySnapshotCopyRetentionPeriodOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifySnapshotCopyRetentionPeriodOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifySnapshotCopyRetentionPeriodOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ModifySnapshotCopyRetentionPeriodOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifySnapshotCopyRetentionPeriodResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct ModifySnapshotScheduleInputBodyMiddleware: Middleware {
    public let id: String = "ModifySnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySnapshotScheduleInput>
    public typealias MOutput = OperationOutput<ModifySnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySnapshotScheduleOutputError>
}

extension ModifySnapshotScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifySnapshotScheduleInput(scheduleDefinitions: \(String(describing: scheduleDefinitions)), scheduleIdentifier: \(String(describing: scheduleIdentifier)))"}
}

extension ModifySnapshotScheduleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let scheduleDefinitions = scheduleDefinitions {
            var scheduleDefinitionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ScheduleDefinitions"))
            for (index0, string0) in scheduleDefinitions.enumerated() {
                try scheduleDefinitionsContainer.encode(string0, forKey: Key("ScheduleDefinition.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: Key("ScheduleIdentifier"))
        }
        try container.encode("ModifySnapshotSchedule", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifySnapshotScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "ModifySnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySnapshotScheduleInput>
    public typealias MOutput = OperationOutput<ModifySnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySnapshotScheduleOutputError>
}

public struct ModifySnapshotScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifySnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySnapshotScheduleInput>
    public typealias MOutput = OperationOutput<ModifySnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySnapshotScheduleOutputError>
}

public struct ModifySnapshotScheduleInput: Equatable {
    /// <p>An updated list of schedule definitions. A schedule definition is made up of schedule
    ///             expressions, for example, "cron(30 12 *)" or "rate(12 hours)".</p>
    public let scheduleDefinitions: [String]?
    /// <p>A unique alphanumeric identifier of the schedule to modify.</p>
    public let scheduleIdentifier: String?

    public init (
        scheduleDefinitions: [String]? = nil,
        scheduleIdentifier: String? = nil
    )
    {
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleIdentifier = scheduleIdentifier
    }
}

extension ModifySnapshotScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifySnapshotScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidScheduleFault" : self = .invalidScheduleFault(try InvalidScheduleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleUpdateInProgressFault" : self = .snapshotScheduleUpdateInProgressFault(try SnapshotScheduleUpdateInProgressFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifySnapshotScheduleOutputError: Equatable {
    case invalidScheduleFault(InvalidScheduleFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case snapshotScheduleUpdateInProgressFault(SnapshotScheduleUpdateInProgressFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySnapshotScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifySnapshotScheduleOutputResponse(associatedClusterCount: \(String(describing: associatedClusterCount)), associatedClusters: \(String(describing: associatedClusters)), nextInvocations: \(String(describing: nextInvocations)), scheduleDefinitions: \(String(describing: scheduleDefinitions)), scheduleDescription: \(String(describing: scheduleDescription)), scheduleIdentifier: \(String(describing: scheduleIdentifier)), tags: \(String(describing: tags)))"}
}

extension ModifySnapshotScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifySnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associatedClusterCount = output.associatedClusterCount
            self.associatedClusters = output.associatedClusters
            self.nextInvocations = output.nextInvocations
            self.scheduleDefinitions = output.scheduleDefinitions
            self.scheduleDescription = output.scheduleDescription
            self.scheduleIdentifier = output.scheduleIdentifier
            self.tags = output.tags
        } else {
            self.associatedClusterCount = nil
            self.associatedClusters = nil
            self.nextInvocations = nil
            self.scheduleDefinitions = nil
            self.scheduleDescription = nil
            self.scheduleIdentifier = nil
            self.tags = nil
        }
    }
}

/// <p>Describes a snapshot schedule. You can set a regular interval for creating
///             snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
public struct ModifySnapshotScheduleOutputResponse: Equatable {
    /// <p>The number of clusters associated with the schedule.</p>
    public let associatedClusterCount: Int?
    /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
    public let associatedClusters: [ClusterAssociatedToSchedule]?
    /// <p></p>
    public let nextInvocations: [Date]?
    /// <p>A list of ScheduleDefinitions.</p>
    public let scheduleDefinitions: [String]?
    /// <p>The description of the schedule.</p>
    public let scheduleDescription: String?
    /// <p>A unique identifier for the schedule.</p>
    public let scheduleIdentifier: String?
    /// <p>An optional set of tags describing the schedule.</p>
    public let tags: [Tag]?

    public init (
        associatedClusterCount: Int? = nil,
        associatedClusters: [ClusterAssociatedToSchedule]? = nil,
        nextInvocations: [Date]? = nil,
        scheduleDefinitions: [String]? = nil,
        scheduleDescription: String? = nil,
        scheduleIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.associatedClusterCount = associatedClusterCount
        self.associatedClusters = associatedClusters
        self.nextInvocations = nextInvocations
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleDescription = scheduleDescription
        self.scheduleIdentifier = scheduleIdentifier
        self.tags = tags
    }
}

struct ModifySnapshotScheduleOutputResponseBody: Equatable {
    public let scheduleDefinitions: [String]?
    public let scheduleIdentifier: String?
    public let scheduleDescription: String?
    public let tags: [Tag]?
    public let nextInvocations: [Date]?
    public let associatedClusterCount: Int?
    public let associatedClusters: [ClusterAssociatedToSchedule]?
}

extension ModifySnapshotScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedClusterCount = "AssociatedClusterCount"
        case associatedClusters = "AssociatedClusters"
        case nextInvocations = "NextInvocations"
        case scheduleDefinitions = "ScheduleDefinitions"
        case scheduleDescription = "ScheduleDescription"
        case scheduleIdentifier = "ScheduleIdentifier"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifySnapshotScheduleResult"))
        if containerValues.contains(.scheduleDefinitions) {
            struct KeyVal0{struct ScheduleDefinition{}}
            let scheduleDefinitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduleDefinition>.CodingKeys.self, forKey: .scheduleDefinitions)
            if let scheduleDefinitionsWrappedContainer = scheduleDefinitionsWrappedContainer {
                let scheduleDefinitionsContainer = try scheduleDefinitionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var scheduleDefinitionsBuffer:[String]? = nil
                if let scheduleDefinitionsContainer = scheduleDefinitionsContainer {
                    scheduleDefinitionsBuffer = [String]()
                    for stringContainer0 in scheduleDefinitionsContainer {
                        scheduleDefinitionsBuffer?.append(stringContainer0)
                    }
                }
                scheduleDefinitions = scheduleDefinitionsBuffer
            } else {
                scheduleDefinitions = []
            }
        } else {
            scheduleDefinitions = nil
        }
        let scheduleIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleIdentifier)
        scheduleIdentifier = scheduleIdentifierDecoded
        let scheduleDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleDescription)
        scheduleDescription = scheduleDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct SnapshotTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let associatedClusterCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .associatedClusterCount)
        associatedClusterCount = associatedClusterCountDecoded
        if containerValues.contains(.associatedClusters) {
            struct KeyVal0{struct ClusterAssociatedToSchedule{}}
            let associatedClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterAssociatedToSchedule>.CodingKeys.self, forKey: .associatedClusters)
            if let associatedClustersWrappedContainer = associatedClustersWrappedContainer {
                let associatedClustersContainer = try associatedClustersWrappedContainer.decodeIfPresent([ClusterAssociatedToSchedule].self, forKey: .member)
                var associatedClustersBuffer:[ClusterAssociatedToSchedule]? = nil
                if let associatedClustersContainer = associatedClustersContainer {
                    associatedClustersBuffer = [ClusterAssociatedToSchedule]()
                    for structureContainer0 in associatedClustersContainer {
                        associatedClustersBuffer?.append(structureContainer0)
                    }
                }
                associatedClusters = associatedClustersBuffer
            } else {
                associatedClusters = []
            }
        } else {
            associatedClusters = nil
        }
    }
}

public struct ModifyUsageLimitInputBodyMiddleware: Middleware {
    public let id: String = "ModifyUsageLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyUsageLimitInput>
    public typealias MOutput = OperationOutput<ModifyUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyUsageLimitOutputError>
}

extension ModifyUsageLimitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyUsageLimitInput(amount: \(String(describing: amount)), breachAction: \(String(describing: breachAction)), usageLimitId: \(String(describing: usageLimitId)))"}
}

extension ModifyUsageLimitInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let amount = amount {
            try container.encode(amount, forKey: Key("Amount"))
        }
        if let breachAction = breachAction {
            try container.encode(breachAction, forKey: Key("BreachAction"))
        }
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: Key("UsageLimitId"))
        }
        try container.encode("ModifyUsageLimit", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ModifyUsageLimitInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyUsageLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyUsageLimitInput>
    public typealias MOutput = OperationOutput<ModifyUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyUsageLimitOutputError>
}

public struct ModifyUsageLimitInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyUsageLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyUsageLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyUsageLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyUsageLimitInput>
    public typealias MOutput = OperationOutput<ModifyUsageLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyUsageLimitOutputError>
}

public struct ModifyUsageLimitInput: Equatable {
    /// <p>The new limit amount.
    ///             For more information about this parameter, see <a>UsageLimit</a>. </p>
    public let amount: Int?
    /// <p>The new action that Amazon Redshift takes when the limit is reached.
    ///             For more information about this parameter, see <a>UsageLimit</a>. </p>
    public let breachAction: UsageLimitBreachAction?
    /// <p>The identifier of the usage limit to modify.</p>
    public let usageLimitId: String?

    public init (
        amount: Int? = nil,
        breachAction: UsageLimitBreachAction? = nil,
        usageLimitId: String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.usageLimitId = usageLimitId
    }
}

extension ModifyUsageLimitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyUsageLimitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidUsageLimitFault" : self = .invalidUsageLimitFault(try InvalidUsageLimitFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsageLimitNotFoundFault" : self = .usageLimitNotFoundFault(try UsageLimitNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyUsageLimitOutputError: Equatable {
    case invalidUsageLimitFault(InvalidUsageLimitFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case usageLimitNotFoundFault(UsageLimitNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyUsageLimitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyUsageLimitOutputResponse(amount: \(String(describing: amount)), breachAction: \(String(describing: breachAction)), clusterIdentifier: \(String(describing: clusterIdentifier)), featureType: \(String(describing: featureType)), limitType: \(String(describing: limitType)), period: \(String(describing: period)), tags: \(String(describing: tags)), usageLimitId: \(String(describing: usageLimitId)))"}
}

extension ModifyUsageLimitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyUsageLimitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.amount = output.amount
            self.breachAction = output.breachAction
            self.clusterIdentifier = output.clusterIdentifier
            self.featureType = output.featureType
            self.limitType = output.limitType
            self.period = output.period
            self.tags = output.tags
            self.usageLimitId = output.usageLimitId
        } else {
            self.amount = 0
            self.breachAction = nil
            self.clusterIdentifier = nil
            self.featureType = nil
            self.limitType = nil
            self.period = nil
            self.tags = nil
            self.usageLimitId = nil
        }
    }
}

/// <p>Describes a usage limit object for a cluster. </p>
public struct ModifyUsageLimitOutputResponse: Equatable {
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
    public let amount: Int
    /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>log</b> - To log an event in a system table. The default is log.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>emit-metric</b> - To emit CloudWatch metrics.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>disable</b> - To disable the feature until the next usage period begins.</p>
    ///             </li>
    ///          </ul>
    public let breachAction: UsageLimitBreachAction?
    /// <p>The identifier of the cluster with a usage limit.</p>
    public let clusterIdentifier: String?
    /// <p>The Amazon Redshift feature to which the limit applies.</p>
    public let featureType: UsageLimitFeatureType?
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
    public let limitType: UsageLimitLimitType?
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
    public let period: UsageLimitPeriod?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?
    /// <p>The identifier of the usage limit.</p>
    public let usageLimitId: String?

    public init (
        amount: Int = 0,
        breachAction: UsageLimitBreachAction? = nil,
        clusterIdentifier: String? = nil,
        featureType: UsageLimitFeatureType? = nil,
        limitType: UsageLimitLimitType? = nil,
        period: UsageLimitPeriod? = nil,
        tags: [Tag]? = nil,
        usageLimitId: String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.limitType = limitType
        self.period = period
        self.tags = tags
        self.usageLimitId = usageLimitId
    }
}

struct ModifyUsageLimitOutputResponseBody: Equatable {
    public let usageLimitId: String?
    public let clusterIdentifier: String?
    public let featureType: UsageLimitFeatureType?
    public let limitType: UsageLimitLimitType?
    public let amount: Int
    public let period: UsageLimitPeriod?
    public let breachAction: UsageLimitBreachAction?
    public let tags: [Tag]?
}

extension ModifyUsageLimitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case amount = "Amount"
        case breachAction = "BreachAction"
        case clusterIdentifier = "ClusterIdentifier"
        case featureType = "FeatureType"
        case limitType = "LimitType"
        case period = "Period"
        case tags = "Tags"
        case usageLimitId = "UsageLimitId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyUsageLimitResult"))
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let featureTypeDecoded = try containerValues.decodeIfPresent(UsageLimitFeatureType.self, forKey: .featureType)
        featureType = featureTypeDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(UsageLimitLimitType.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let amountDecoded = try containerValues.decode(Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let networkInterfaceId = networkInterfaceId {
            try container.encode(networkInterfaceId, forKey: Key("NetworkInterfaceId"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: Key("PrivateIpAddress"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension NetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterface(availabilityZone: \(String(describing: availabilityZone)), networkInterfaceId: \(String(describing: networkInterfaceId)), privateIpAddress: \(String(describing: privateIpAddress)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>Describes a network interface. </p>
public struct NetworkInterface: Equatable {
    /// <p>The Availability Zone. </p>
    public let availabilityZone: String?
    /// <p>The network interface identifier. </p>
    public let networkInterfaceId: String?
    /// <p>The IPv4 address of the network interface within the subnet. </p>
    public let privateIpAddress: String?
    /// <p>The subnet identifier. </p>
    public let subnetId: String?

    public init (
        availabilityZone: String? = nil,
        networkInterfaceId: String? = nil,
        privateIpAddress: String? = nil,
        subnetId: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.subnetId = subnetId
    }
}

extension NodeConfigurationOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case estimatedDiskUtilizationPercent = "EstimatedDiskUtilizationPercent"
        case mode = "Mode"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let estimatedDiskUtilizationPercent = estimatedDiskUtilizationPercent {
            try container.encode(estimatedDiskUtilizationPercent, forKey: Key("EstimatedDiskUtilizationPercent"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: Key("Mode"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let estimatedDiskUtilizationPercentDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .estimatedDiskUtilizationPercent)
        estimatedDiskUtilizationPercent = estimatedDiskUtilizationPercentDecoded
        let modeDecoded = try containerValues.decodeIfPresent(Mode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension NodeConfigurationOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeConfigurationOption(estimatedDiskUtilizationPercent: \(String(describing: estimatedDiskUtilizationPercent)), mode: \(String(describing: mode)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)))"}
}

/// <p>A list of node configurations.</p>
public struct NodeConfigurationOption: Equatable {
    /// <p>The estimated disk utilizaton percentage.</p>
    public let estimatedDiskUtilizationPercent: Double?
    /// <p>The category of the node configuration recommendation.</p>
    public let mode: Mode?
    /// <p>The node type, such as, "ds2.8xlarge".</p>
    public let nodeType: String?
    /// <p>The number of nodes.</p>
    public let numberOfNodes: Int

    public init (
        estimatedDiskUtilizationPercent: Double? = nil,
        mode: Mode? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int = 0
    )
    {
        self.estimatedDiskUtilizationPercent = estimatedDiskUtilizationPercent
        self.mode = mode
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
    }
}

extension NodeConfigurationOptionsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case values = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let `operator` = `operator` {
            try container.encode(`operator`, forKey: Key("Operator"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Value"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: Key("item.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(NodeConfigurationOptionsFilterName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(OperatorType.self, forKey: .operator)
        `operator` = operatorDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct item{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension NodeConfigurationOptionsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeConfigurationOptionsFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>A set of elements to filter the returned node configurations.</p>
public struct NodeConfigurationOptionsFilter: Equatable {
    /// <p>The filter operator.
    ///             If filter Name is NodeType only the 'in' operator is supported.
    ///             Provide one value to evaluate for 'eq', 'lt', 'le', 'gt', and 'ge'.
    ///             Provide two values to evaluate for 'between'.
    ///             Provide a list of values for 'in'.</p>
    public let `operator`: OperatorType?
    /// <p>The name of the element to filter.</p>
    public let name: NodeConfigurationOptionsFilterName?
    /// <p>List of values. Compare Name using Operator to Values.
    ///             If filter Name is NumberOfNodes, then values can range from 0 to 200.
    ///             If filter Name is EstimatedDiskUtilizationPercent, then values can range from 0 to 100.
    ///             For example, filter NumberOfNodes (name) GT (operator) 3 (values).</p>
    public let values: [String]?

    public init (
        `operator`: OperatorType? = nil,
        name: NodeConfigurationOptionsFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum NodeConfigurationOptionsFilterName {
    case estimatedDiskUtilizationPercent
    case mode
    case nodeType
    case numNodes
    case sdkUnknown(String)
}

extension NodeConfigurationOptionsFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NodeConfigurationOptionsFilterName] {
        return [
            .estimatedDiskUtilizationPercent,
            .mode,
            .nodeType,
            .numNodes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .estimatedDiskUtilizationPercent: return "EstimatedDiskUtilizationPercent"
        case .mode: return "Mode"
        case .nodeType: return "NodeType"
        case .numNodes: return "NumberOfNodes"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NodeConfigurationOptionsFilterName(rawValue: rawValue) ?? NodeConfigurationOptionsFilterName.sdkUnknown(rawValue)
    }
}

extension NumberOfNodesPerClusterLimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberOfNodesPerClusterLimitExceededFault(message: \(String(describing: message)))"}
}

extension NumberOfNodesPerClusterLimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NumberOfNodesPerClusterLimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
public struct NumberOfNodesPerClusterLimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfNodesPerClusterLimitExceededFaultBody: Equatable {
    public let message: String?
}

extension NumberOfNodesPerClusterLimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfNodesQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberOfNodesQuotaExceededFault(message: \(String(describing: message)))"}
}

extension NumberOfNodesQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NumberOfNodesQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation would exceed the number of nodes allotted to the account.
///
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct NumberOfNodesQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfNodesQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension NumberOfNodesQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OperatorType {
    case between
    case eq
    case ge
    case gt
    case `in`
    case le
    case lt
    case sdkUnknown(String)
}

extension OperatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperatorType] {
        return [
            .between,
            .eq,
            .ge,
            .gt,
            .in,
            .le,
            .lt,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .between: return "between"
        case .eq: return "eq"
        case .ge: return "ge"
        case .gt: return "gt"
        case .in: return "in"
        case .le: return "le"
        case .lt: return "lt"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperatorType(rawValue: rawValue) ?? OperatorType.sdkUnknown(rawValue)
    }
}

extension OrderableClusterOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterType = "ClusterType"
        case clusterVersion = "ClusterVersion"
        case nodeType = "NodeType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension OrderableClusterOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrderableClusterOption(availabilityZones: \(String(describing: availabilityZones)), clusterType: \(String(describing: clusterType)), clusterVersion: \(String(describing: clusterVersion)), nodeType: \(String(describing: nodeType)))"}
}

/// <p>Describes an orderable cluster option.</p>
public struct OrderableClusterOption: Equatable {
    /// <p>A list of availability zones for the orderable cluster.</p>
    public let availabilityZones: [AvailabilityZone]?
    /// <p>The cluster type, for example <code>multi-node</code>. </p>
    public let clusterType: String?
    /// <p>The version of the orderable cluster.</p>
    public let clusterVersion: String?
    /// <p>The node type for the orderable cluster.</p>
    public let nodeType: String?

    public init (
        availabilityZones: [AvailabilityZone]? = nil,
        clusterType: String? = nil,
        clusterVersion: String? = nil,
        nodeType: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterType = clusterType
        self.clusterVersion = clusterVersion
        self.nodeType = nodeType
    }
}

extension Parameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case minimumEngineVersion = "MinimumEngineVersion"
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: Key("DataType"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: Key("IsModifiable"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: Key("MinimumEngineVersion"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: Key("ParameterName"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: Key("ParameterValue"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(ParameterApplyType.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let isModifiableDecoded = try containerValues.decode(Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
    }
}

extension Parameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameter(allowedValues: \(String(describing: allowedValues)), applyType: \(String(describing: applyType)), dataType: \(String(describing: dataType)), description: \(String(describing: description)), isModifiable: \(String(describing: isModifiable)), minimumEngineVersion: \(String(describing: minimumEngineVersion)), parameterName: \(String(describing: parameterName)), parameterValue: \(String(describing: parameterValue)), source: \(String(describing: source)))"}
}

/// <p>Describes a parameter in a cluster parameter group.</p>
public struct Parameter: Equatable {
    /// <p>The valid range of values for the parameter.</p>
    public let allowedValues: String?
    /// <p>Specifies how to apply the WLM configuration parameter. Some properties can be
    ///             applied dynamically, while other properties require that any associated clusters be
    ///             rebooted for the configuration changes to be applied.
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    public let applyType: ParameterApplyType?
    /// <p>The data type of the parameter.</p>
    public let dataType: String?
    /// <p>A description of the parameter.</p>
    public let description: String?
    /// <p>If <code>true</code>, the parameter can be modified. Some parameters have security
    ///             or operational implications that prevent them from being changed. </p>
    public let isModifiable: Bool
    /// <p>The earliest engine version to which the parameter can apply.</p>
    public let minimumEngineVersion: String?
    /// <p>The name of the parameter.</p>
    public let parameterName: String?
    /// <p>The value of the parameter. If <code>ParameterName</code> is <code>wlm_json_configuration</code>,
    ///             then the maximum size of <code>ParameterValue</code> is 8000 characters.</p>
    public let parameterValue: String?
    /// <p>The source of the parameter value, such as "engine-default" or "user".</p>
    public let source: String?

    public init (
        allowedValues: String? = nil,
        applyType: ParameterApplyType? = nil,
        dataType: String? = nil,
        description: String? = nil,
        isModifiable: Bool = false,
        minimumEngineVersion: String? = nil,
        parameterName: String? = nil,
        parameterValue: String? = nil,
        source: String? = nil
    )
    {
        self.allowedValues = allowedValues
        self.applyType = applyType
        self.dataType = dataType
        self.description = description
        self.isModifiable = isModifiable
        self.minimumEngineVersion = minimumEngineVersion
        self.parameterName = parameterName
        self.parameterValue = parameterValue
        self.source = source
    }
}

public enum ParameterApplyType {
    case `dynamic`
    case `static`
    case sdkUnknown(String)
}

extension ParameterApplyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterApplyType] {
        return [
            .dynamic,
            .static,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dynamic: return "dynamic"
        case .static: return "static"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterApplyType(rawValue: rawValue) ?? ParameterApplyType.sdkUnknown(rawValue)
    }
}

extension PartnerIntegrationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createdAt = createdAt {
            try container.encode(TimestampWrapper(createdAt, format: .dateTime), forKey: Key("createdAt"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: Key("PartnerName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusMessage = statusMessage {
            try container.encode(statusMessage, forKey: Key("StatusMessage"))
        }
        if let updatedAt = updatedAt {
            try container.encode(TimestampWrapper(updatedAt, format: .dateTime), forKey: Key("updatedAt"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PartnerIntegrationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        var createdAtBuffer:Date? = nil
        if let createdAtDecoded = createdAtDecoded {
            createdAtBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdAtDecoded, format: .dateTime)
        }
        createdAt = createdAtBuffer
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        var updatedAtBuffer:Date? = nil
        if let updatedAtDecoded = updatedAtDecoded {
            updatedAtBuffer = try TimestampWrapperDecoder.parseDateStringValue(updatedAtDecoded, format: .dateTime)
        }
        updatedAt = updatedAtBuffer
    }
}

extension PartnerIntegrationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartnerIntegrationInfo(createdAt: \(String(describing: createdAt)), databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Describes a partner integration.</p>
public struct PartnerIntegrationInfo: Equatable {
    /// <p>The date (UTC) that the partner integration was created.</p>
    public let createdAt: Date?
    /// <p>The name of the database that receives data from a partner.</p>
    public let databaseName: String?
    /// <p>The name of the partner.</p>
    public let partnerName: String?
    /// <p>The partner integration status.</p>
    public let status: PartnerIntegrationStatus?
    /// <p>The status message provided by the partner.</p>
    public let statusMessage: String?
    /// <p>The date (UTC) that the partner integration status was last updated by the partner.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        databaseName: String? = nil,
        partnerName: String? = nil,
        status: PartnerIntegrationStatus? = nil,
        statusMessage: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.databaseName = databaseName
        self.partnerName = partnerName
        self.status = status
        self.statusMessage = statusMessage
        self.updatedAt = updatedAt
    }
}

public enum PartnerIntegrationStatus {
    case active
    case connectionfailure
    case inactive
    case runtimefailure
    case sdkUnknown(String)
}

extension PartnerIntegrationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PartnerIntegrationStatus] {
        return [
            .active,
            .connectionfailure,
            .inactive,
            .runtimefailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .connectionfailure: return "ConnectionFailure"
        case .inactive: return "Inactive"
        case .runtimefailure: return "RuntimeFailure"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PartnerIntegrationStatus(rawValue: rawValue) ?? PartnerIntegrationStatus.sdkUnknown(rawValue)
    }
}

extension PartnerNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartnerNotFoundFault(message: \(String(describing: message)))"}
}

extension PartnerNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PartnerNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The name of the partner was not found.</p>
public struct PartnerNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PartnerNotFoundFaultBody: Equatable {
    public let message: String?
}

extension PartnerNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PauseClusterInputBodyMiddleware: Middleware {
    public let id: String = "PauseClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PauseClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PauseClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PauseClusterInput>
    public typealias MOutput = OperationOutput<PauseClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PauseClusterOutputError>
}

extension PauseClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PauseClusterInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension PauseClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("PauseCluster", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct PauseClusterInputHeadersMiddleware: Middleware {
    public let id: String = "PauseClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PauseClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PauseClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PauseClusterInput>
    public typealias MOutput = OperationOutput<PauseClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PauseClusterOutputError>
}

public struct PauseClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "PauseClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PauseClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PauseClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PauseClusterInput>
    public typealias MOutput = OperationOutput<PauseClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PauseClusterOutputError>
}

/// <p>Describes a pause cluster operation. For example, a scheduled action to run the <code>PauseCluster</code> API operation. </p>
public struct PauseClusterInput: Equatable {
    /// <p>The identifier of the cluster to be paused.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension PauseClusterMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
    }
}

extension PauseClusterMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PauseClusterMessage(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

/// <p>Describes a pause cluster operation. For example, a scheduled action to run the <code>PauseCluster</code> API operation. </p>
public struct PauseClusterMessage: Equatable {
    /// <p>The identifier of the cluster to be paused.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension PauseClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PauseClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PauseClusterOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PauseClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PauseClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension PauseClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PauseClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct PauseClusterOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct PauseClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension PauseClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("PauseClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension PendingModifiedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterType = "ClusterType"
        case clusterVersion = "ClusterVersion"
        case encryptionType = "EncryptionType"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case maintenanceTrackName = "MaintenanceTrackName"
        case masterUserPassword = "MasterUserPassword"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case publiclyAccessible = "PubliclyAccessible"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: Key("ClusterType"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if let encryptionType = encryptionType {
            try container.encode(encryptionType, forKey: Key("EncryptionType"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: Key("EnhancedVpcRouting"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automatedSnapshotRetentionPeriod)
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension PendingModifiedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingModifiedValues(automatedSnapshotRetentionPeriod: \(String(describing: automatedSnapshotRetentionPeriod)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterType: \(String(describing: clusterType)), clusterVersion: \(String(describing: clusterVersion)), encryptionType: \(String(describing: encryptionType)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), masterUserPassword: \(String(describing: masterUserPassword)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), publiclyAccessible: \(String(describing: publiclyAccessible)))"}
}

/// <p>Describes cluster attributes that are in a pending state. A change to one or more
///             the attributes was requested and is in progress or will be applied.</p>
public struct PendingModifiedValues: Equatable {
    /// <p>The pending or in-progress change of the automated snapshot retention
    ///             period.</p>
    public let automatedSnapshotRetentionPeriod: Int?
    /// <p>The pending or in-progress change of the new identifier for the cluster.</p>
    public let clusterIdentifier: String?
    /// <p>The pending or in-progress change of the cluster type.</p>
    public let clusterType: String?
    /// <p>The pending or in-progress change of the service version.</p>
    public let clusterVersion: String?
    /// <p>The encryption type for a cluster. Possible values are: KMS and None. </p>
    public let encryptionType: String?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Bool?
    /// <p>The name of the maintenance track that the cluster will change to during the next
    ///             maintenance window.</p>
    public let maintenanceTrackName: String?
    /// <p>The pending or in-progress change of the master user password for the
    ///             cluster.</p>
    public let masterUserPassword: String?
    /// <p>The pending or in-progress change of the cluster's node type.</p>
    public let nodeType: String?
    /// <p>The pending or in-progress change of the number of nodes in the cluster.</p>
    public let numberOfNodes: Int?
    /// <p>The pending or in-progress change of the ability to connect to the cluster from the
    ///             public network.</p>
    public let publiclyAccessible: Bool?

    public init (
        automatedSnapshotRetentionPeriod: Int? = nil,
        clusterIdentifier: String? = nil,
        clusterType: String? = nil,
        clusterVersion: String? = nil,
        encryptionType: String? = nil,
        enhancedVpcRouting: Bool? = nil,
        maintenanceTrackName: String? = nil,
        masterUserPassword: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int? = nil,
        publiclyAccessible: Bool? = nil
    )
    {
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.clusterIdentifier = clusterIdentifier
        self.clusterType = clusterType
        self.clusterVersion = clusterVersion
        self.encryptionType = encryptionType
        self.enhancedVpcRouting = enhancedVpcRouting
        self.maintenanceTrackName = maintenanceTrackName
        self.masterUserPassword = masterUserPassword
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.publiclyAccessible = publiclyAccessible
    }
}

public struct PurchaseReservedNodeOfferingInputBodyMiddleware: Middleware {
    public let id: String = "PurchaseReservedNodeOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseReservedNodeOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseReservedNodeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseReservedNodeOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseReservedNodeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseReservedNodeOfferingOutputError>
}

extension PurchaseReservedNodeOfferingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseReservedNodeOfferingInput(nodeCount: \(String(describing: nodeCount)), reservedNodeOfferingId: \(String(describing: reservedNodeOfferingId)))"}
}

extension PurchaseReservedNodeOfferingInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nodeCount = nodeCount {
            try container.encode(nodeCount, forKey: Key("NodeCount"))
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: Key("ReservedNodeOfferingId"))
        }
        try container.encode("PurchaseReservedNodeOffering", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct PurchaseReservedNodeOfferingInputHeadersMiddleware: Middleware {
    public let id: String = "PurchaseReservedNodeOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseReservedNodeOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseReservedNodeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseReservedNodeOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseReservedNodeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseReservedNodeOfferingOutputError>
}

public struct PurchaseReservedNodeOfferingInputQueryItemMiddleware: Middleware {
    public let id: String = "PurchaseReservedNodeOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseReservedNodeOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseReservedNodeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseReservedNodeOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseReservedNodeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseReservedNodeOfferingOutputError>
}

/// <p></p>
public struct PurchaseReservedNodeOfferingInput: Equatable {
    /// <p>The number of reserved nodes that you want to purchase.</p>
    ///         <p>Default: <code>1</code>
    ///         </p>
    public let nodeCount: Int?
    /// <p>The unique identifier of the reserved node offering you want to purchase.</p>
    public let reservedNodeOfferingId: String?

    public init (
        nodeCount: Int? = nil,
        reservedNodeOfferingId: String? = nil
    )
    {
        self.nodeCount = nodeCount
        self.reservedNodeOfferingId = reservedNodeOfferingId
    }
}

extension PurchaseReservedNodeOfferingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PurchaseReservedNodeOfferingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ReservedNodeAlreadyExistsFault" : self = .reservedNodeAlreadyExistsFault(try ReservedNodeAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeOfferingNotFoundFault" : self = .reservedNodeOfferingNotFoundFault(try ReservedNodeOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNodeQuotaExceededFault" : self = .reservedNodeQuotaExceededFault(try ReservedNodeQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseReservedNodeOfferingOutputError: Equatable {
    case reservedNodeAlreadyExistsFault(ReservedNodeAlreadyExistsFault)
    case reservedNodeOfferingNotFoundFault(ReservedNodeOfferingNotFoundFault)
    case reservedNodeQuotaExceededFault(ReservedNodeQuotaExceededFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseReservedNodeOfferingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseReservedNodeOfferingOutputResponse(reservedNode: \(String(describing: reservedNode)))"}
}

extension PurchaseReservedNodeOfferingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PurchaseReservedNodeOfferingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reservedNode = output.reservedNode
        } else {
            self.reservedNode = nil
        }
    }
}

public struct PurchaseReservedNodeOfferingOutputResponse: Equatable {
    /// <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
    ///             offerings. </p>
    public let reservedNode: ReservedNode?

    public init (
        reservedNode: ReservedNode? = nil
    )
    {
        self.reservedNode = reservedNode
    }
}

struct PurchaseReservedNodeOfferingOutputResponseBody: Equatable {
    public let reservedNode: ReservedNode?
}

extension PurchaseReservedNodeOfferingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservedNode = "ReservedNode"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("PurchaseReservedNodeOfferingResult"))
        let reservedNodeDecoded = try containerValues.decodeIfPresent(ReservedNode.self, forKey: .reservedNode)
        reservedNode = reservedNodeDecoded
    }
}

public struct RebootClusterInputBodyMiddleware: Middleware {
    public let id: String = "RebootClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootClusterInput>
    public typealias MOutput = OperationOutput<RebootClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootClusterOutputError>
}

extension RebootClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootClusterInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension RebootClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("RebootCluster", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct RebootClusterInputHeadersMiddleware: Middleware {
    public let id: String = "RebootClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootClusterInput>
    public typealias MOutput = OperationOutput<RebootClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootClusterOutputError>
}

public struct RebootClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootClusterInput>
    public typealias MOutput = OperationOutput<RebootClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootClusterOutputError>
}

/// <p></p>
public struct RebootClusterInput: Equatable {
    /// <p>The cluster identifier.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension RebootClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootClusterOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension RebootClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebootClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RebootClusterOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RebootClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension RebootClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RebootClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RecurringCharge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if recurringChargeAmount != 0.0 {
            try container.encode(String(recurringChargeAmount), forKey: Key("RecurringChargeAmount"))
        }
        if let recurringChargeFrequency = recurringChargeFrequency {
            try container.encode(recurringChargeFrequency, forKey: Key("RecurringChargeFrequency"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recurringChargeAmountDecoded = try containerValues.decode(Double.self, forKey: .recurringChargeAmount)
        recurringChargeAmount = recurringChargeAmountDecoded
        let recurringChargeFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recurringChargeFrequency)
        recurringChargeFrequency = recurringChargeFrequencyDecoded
    }
}

extension RecurringCharge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecurringCharge(recurringChargeAmount: \(String(describing: recurringChargeAmount)), recurringChargeFrequency: \(String(describing: recurringChargeFrequency)))"}
}

/// <p>Describes a recurring charge.</p>
public struct RecurringCharge: Equatable {
    /// <p>The amount charged per the period of time specified by the recurring charge
    ///             frequency.</p>
    public let recurringChargeAmount: Double
    /// <p>The frequency at which the recurring charge amount is applied.</p>
    public let recurringChargeFrequency: String?

    public init (
        recurringChargeAmount: Double = 0.0,
        recurringChargeFrequency: String? = nil
    )
    {
        self.recurringChargeAmount = recurringChargeAmount
        self.recurringChargeFrequency = recurringChargeFrequency
    }
}

extension ReservedNode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case nodeCount = "NodeCount"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case recurringCharges = "RecurringCharges"
        case reservedNodeId = "ReservedNodeId"
        case reservedNodeOfferingId = "ReservedNodeOfferingId"
        case reservedNodeOfferingType = "ReservedNodeOfferingType"
        case startTime = "StartTime"
        case state = "State"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: Key("CurrencyCode"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(String(fixedPrice), forKey: Key("FixedPrice"))
        }
        if nodeCount != 0 {
            try container.encode(nodeCount, forKey: Key("NodeCount"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: Key("OfferingType"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedNodeId = reservedNodeId {
            try container.encode(reservedNodeId, forKey: Key("ReservedNodeId"))
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: Key("ReservedNodeOfferingId"))
        }
        if let reservedNodeOfferingType = reservedNodeOfferingType {
            try container.encode(reservedNodeOfferingType, forKey: Key("ReservedNodeOfferingType"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if usagePrice != 0.0 {
            try container.encode(String(usagePrice), forKey: Key("UsagePrice"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedNodeId)
        reservedNodeId = reservedNodeIdDecoded
        let reservedNodeOfferingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedNodeOfferingId)
        reservedNodeOfferingId = reservedNodeOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        var startTimeBuffer:Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let nodeCountDecoded = try containerValues.decode(Int.self, forKey: .nodeCount)
        nodeCount = nodeCountDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
        let reservedNodeOfferingTypeDecoded = try containerValues.decodeIfPresent(ReservedNodeOfferingType.self, forKey: .reservedNodeOfferingType)
        reservedNodeOfferingType = reservedNodeOfferingTypeDecoded
    }
}

extension ReservedNode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNode(currencyCode: \(String(describing: currencyCode)), duration: \(String(describing: duration)), fixedPrice: \(String(describing: fixedPrice)), nodeCount: \(String(describing: nodeCount)), nodeType: \(String(describing: nodeType)), offeringType: \(String(describing: offeringType)), recurringCharges: \(String(describing: recurringCharges)), reservedNodeId: \(String(describing: reservedNodeId)), reservedNodeOfferingId: \(String(describing: reservedNodeOfferingId)), reservedNodeOfferingType: \(String(describing: reservedNodeOfferingType)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), usagePrice: \(String(describing: usagePrice)))"}
}

/// <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
///             offerings. </p>
public struct ReservedNode: Equatable {
    /// <p>The currency code for the reserved cluster.</p>
    public let currencyCode: String?
    /// <p>The duration of the node reservation in seconds.</p>
    public let duration: Int
    /// <p>The fixed cost Amazon Redshift charges you for this reserved node.</p>
    public let fixedPrice: Double
    /// <p>The number of reserved compute nodes.</p>
    public let nodeCount: Int
    /// <p>The node type of the reserved node.</p>
    public let nodeType: String?
    /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
    ///             offering.</p>
    public let offeringType: String?
    /// <p>The recurring charges for the reserved node.</p>
    public let recurringCharges: [RecurringCharge]?
    /// <p>The unique identifier for the reservation.</p>
    public let reservedNodeId: String?
    /// <p>The identifier for the reserved node offering.</p>
    public let reservedNodeOfferingId: String?
    /// <p></p>
    public let reservedNodeOfferingType: ReservedNodeOfferingType?
    /// <p>The time the reservation started. You purchase a reserved node offering for a
    ///             duration. This is the start time of that duration.</p>
    public let startTime: Date?
    /// <p>The state of the reserved compute node.</p>
    ///         <p>Possible Values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>pending-payment-This reserved node has recently been purchased, and the
    ///                     sale has been approved, but payment has not yet been confirmed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>active-This reserved node is owned by the caller and is available for
    ///                     use.</p>
    ///             </li>
    ///             <li>
    ///                 <p>payment-failed-Payment failed for the purchase attempt.</p>
    ///             </li>
    ///             <li>
    ///                 <p>retired-The reserved node is no longer available. </p>
    ///             </li>
    ///             <li>
    ///                 <p>exchanging-The owner is exchanging the reserved node for another reserved
    ///                     node.</p>
    ///             </li>
    ///          </ul>
    public let state: String?
    /// <p>The hourly rate Amazon Redshift charges you for this reserved node.</p>
    public let usagePrice: Double

    public init (
        currencyCode: String? = nil,
        duration: Int = 0,
        fixedPrice: Double = 0.0,
        nodeCount: Int = 0,
        nodeType: String? = nil,
        offeringType: String? = nil,
        recurringCharges: [RecurringCharge]? = nil,
        reservedNodeId: String? = nil,
        reservedNodeOfferingId: String? = nil,
        reservedNodeOfferingType: ReservedNodeOfferingType? = nil,
        startTime: Date? = nil,
        state: String? = nil,
        usagePrice: Double = 0.0
    )
    {
        self.currencyCode = currencyCode
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.nodeCount = nodeCount
        self.nodeType = nodeType
        self.offeringType = offeringType
        self.recurringCharges = recurringCharges
        self.reservedNodeId = reservedNodeId
        self.reservedNodeOfferingId = reservedNodeOfferingId
        self.reservedNodeOfferingType = reservedNodeOfferingType
        self.startTime = startTime
        self.state = state
        self.usagePrice = usagePrice
    }
}

extension ReservedNodeAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNodeAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ReservedNodeAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedNodeAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a reservation with the given identifier.</p>
public struct ReservedNodeAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ReservedNodeAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedNodeAlreadyMigratedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNodeAlreadyMigratedFault(message: \(String(describing: message)))"}
}

extension ReservedNodeAlreadyMigratedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedNodeAlreadyMigratedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the reserved node has already been exchanged.</p>
public struct ReservedNodeAlreadyMigratedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeAlreadyMigratedFaultBody: Equatable {
    public let message: String?
}

extension ReservedNodeAlreadyMigratedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedNodeNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNodeNotFoundFault(message: \(String(describing: message)))"}
}

extension ReservedNodeNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedNodeNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified reserved compute node not found.</p>
public struct ReservedNodeNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ReservedNodeNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedNodeOffering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case recurringCharges = "RecurringCharges"
        case reservedNodeOfferingId = "ReservedNodeOfferingId"
        case reservedNodeOfferingType = "ReservedNodeOfferingType"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: Key("CurrencyCode"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(String(fixedPrice), forKey: Key("FixedPrice"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: Key("OfferingType"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedNodeOfferingId = reservedNodeOfferingId {
            try container.encode(reservedNodeOfferingId, forKey: Key("ReservedNodeOfferingId"))
        }
        if let reservedNodeOfferingType = reservedNodeOfferingType {
            try container.encode(reservedNodeOfferingType, forKey: Key("ReservedNodeOfferingType"))
        }
        if usagePrice != 0.0 {
            try container.encode(String(usagePrice), forKey: Key("UsagePrice"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodeOfferingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedNodeOfferingId)
        reservedNodeOfferingId = reservedNodeOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
        let reservedNodeOfferingTypeDecoded = try containerValues.decodeIfPresent(ReservedNodeOfferingType.self, forKey: .reservedNodeOfferingType)
        reservedNodeOfferingType = reservedNodeOfferingTypeDecoded
    }
}

extension ReservedNodeOffering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNodeOffering(currencyCode: \(String(describing: currencyCode)), duration: \(String(describing: duration)), fixedPrice: \(String(describing: fixedPrice)), nodeType: \(String(describing: nodeType)), offeringType: \(String(describing: offeringType)), recurringCharges: \(String(describing: recurringCharges)), reservedNodeOfferingId: \(String(describing: reservedNodeOfferingId)), reservedNodeOfferingType: \(String(describing: reservedNodeOfferingType)), usagePrice: \(String(describing: usagePrice)))"}
}

/// <p>Describes a reserved node offering.</p>
public struct ReservedNodeOffering: Equatable {
    /// <p>The currency code for the compute nodes offering.</p>
    public let currencyCode: String?
    /// <p>The duration, in seconds, for which the offering will reserve the node.</p>
    public let duration: Int
    /// <p>The upfront fixed charge you will pay to purchase the specific reserved node
    ///             offering.</p>
    public let fixedPrice: Double
    /// <p>The node type offered by the reserved node offering.</p>
    public let nodeType: String?
    /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
    ///             offering.</p>
    public let offeringType: String?
    /// <p>The charge to your account regardless of whether you are creating any clusters
    ///             using the node offering. Recurring charges are only in effect for heavy-utilization
    ///             reserved nodes.</p>
    public let recurringCharges: [RecurringCharge]?
    /// <p>The offering identifier.</p>
    public let reservedNodeOfferingId: String?
    /// <p></p>
    public let reservedNodeOfferingType: ReservedNodeOfferingType?
    /// <p>The rate you are charged for each hour the cluster that is using the offering is
    ///             running.</p>
    public let usagePrice: Double

    public init (
        currencyCode: String? = nil,
        duration: Int = 0,
        fixedPrice: Double = 0.0,
        nodeType: String? = nil,
        offeringType: String? = nil,
        recurringCharges: [RecurringCharge]? = nil,
        reservedNodeOfferingId: String? = nil,
        reservedNodeOfferingType: ReservedNodeOfferingType? = nil,
        usagePrice: Double = 0.0
    )
    {
        self.currencyCode = currencyCode
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.nodeType = nodeType
        self.offeringType = offeringType
        self.recurringCharges = recurringCharges
        self.reservedNodeOfferingId = reservedNodeOfferingId
        self.reservedNodeOfferingType = reservedNodeOfferingType
        self.usagePrice = usagePrice
    }
}

extension ReservedNodeOfferingNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNodeOfferingNotFoundFault(message: \(String(describing: message)))"}
}

extension ReservedNodeOfferingNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedNodeOfferingNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified offering does not exist.</p>
public struct ReservedNodeOfferingNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeOfferingNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ReservedNodeOfferingNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ReservedNodeOfferingType {
    case regular
    case upgradable
    case sdkUnknown(String)
}

extension ReservedNodeOfferingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReservedNodeOfferingType] {
        return [
            .regular,
            .upgradable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .regular: return "Regular"
        case .upgradable: return "Upgradable"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReservedNodeOfferingType(rawValue: rawValue) ?? ReservedNodeOfferingType.sdkUnknown(rawValue)
    }
}

extension ReservedNodeQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNodeQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ReservedNodeQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedNodeQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would exceed the user's compute node quota.
/// For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct ReservedNodeQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNodeQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ReservedNodeQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResetClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ResetClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetClusterParameterGroupOutputError>
}

extension ResetClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetClusterParameterGroupInput(parameterGroupName: \(String(describing: parameterGroupName)), parameters: \(String(describing: parameters)), resetAllParameters: \(String(describing: resetAllParameters)))"}
}

extension ResetClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let parameterGroupName = parameterGroupName {
            try container.encode(parameterGroupName, forKey: Key("ParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: Key("ResetAllParameters"))
        }
        try container.encode("ResetClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ResetClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ResetClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetClusterParameterGroupOutputError>
}

public struct ResetClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetClusterParameterGroupOutputError>
}

/// <p></p>
public struct ResetClusterParameterGroupInput: Equatable {
    /// <p>The name of the cluster parameter group to be reset.</p>
    public let parameterGroupName: String?
    /// <p>An array of names of parameters to be reset. If
    ///                 <i>ResetAllParameters</i> option is not used, then at least one
    ///             parameter name must be supplied. </p>
    ///         <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
    public let parameters: [Parameter]?
    /// <p>If <code>true</code>, all parameters in the specified parameter group will be reset
    ///             to their default values. </p>
    ///         <p>Default: <code>true</code>
    ///         </p>
    public let resetAllParameters: Bool

    public init (
        parameterGroupName: String? = nil,
        parameters: [Parameter]? = nil,
        resetAllParameters: Bool = false
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterParameterGroupStateFault" : self = .invalidClusterParameterGroupStateFault(try InvalidClusterParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetClusterParameterGroupOutputError: Equatable {
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case invalidClusterParameterGroupStateFault(InvalidClusterParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetClusterParameterGroupOutputResponse(parameterGroupName: \(String(describing: parameterGroupName)), parameterGroupStatus: \(String(describing: parameterGroupStatus)))"}
}

extension ResetClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.parameterGroupName = output.parameterGroupName
            self.parameterGroupStatus = output.parameterGroupStatus
        } else {
            self.parameterGroupName = nil
            self.parameterGroupStatus = nil
        }
    }
}

/// <p></p>
public struct ResetClusterParameterGroupOutputResponse: Equatable {
    /// <p>The name of the cluster parameter group.</p>
    public let parameterGroupName: String?
    /// <p>The status of the parameter group. For example, if you made a change to a parameter
    ///             group name-value pair, then the change could be pending a reboot of an associated
    ///             cluster.</p>
    public let parameterGroupStatus: String?

    public init (
        parameterGroupName: String? = nil,
        parameterGroupStatus: String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterGroupStatus = parameterGroupStatus
    }
}

struct ResetClusterParameterGroupOutputResponseBody: Equatable {
    public let parameterGroupName: String?
    public let parameterGroupStatus: String?
}

extension ResetClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResetClusterParameterGroupResult"))
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

public struct ResizeClusterInputBodyMiddleware: Middleware {
    public let id: String = "ResizeClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResizeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ResizeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResizeClusterInput>
    public typealias MOutput = OperationOutput<ResizeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResizeClusterOutputError>
}

extension ResizeClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResizeClusterInput(classic: \(String(describing: classic)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterType: \(String(describing: clusterType)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)))"}
}

extension ResizeClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let classic = classic {
            try container.encode(classic, forKey: Key("Classic"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: Key("ClusterType"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        try container.encode("ResizeCluster", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ResizeClusterInputHeadersMiddleware: Middleware {
    public let id: String = "ResizeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResizeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ResizeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResizeClusterInput>
    public typealias MOutput = OperationOutput<ResizeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResizeClusterOutputError>
}

public struct ResizeClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "ResizeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResizeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ResizeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResizeClusterInput>
    public typealias MOutput = OperationOutput<ResizeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResizeClusterOutputError>
}

/// <p>Describes a resize cluster operation. For example, a scheduled action to run the <code>ResizeCluster</code> API operation. </p>
public struct ResizeClusterInput: Equatable {
    /// <p>A boolean value indicating whether the resize operation is using the classic resize
    ///             process. If you don't provide this parameter or set the value to
    ///             <code>false</code>, the resize type is elastic. </p>
    public let classic: Bool?
    /// <p>The unique identifier for the cluster to resize.</p>
    public let clusterIdentifier: String?
    /// <p>The new cluster type for the specified cluster.</p>
    public let clusterType: String?
    /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
    public let nodeType: String?
    /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
    public let numberOfNodes: Int?

    public init (
        classic: Bool? = nil,
        clusterIdentifier: String? = nil,
        clusterType: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int? = nil
    )
    {
        self.classic = classic
        self.clusterIdentifier = clusterIdentifier
        self.clusterType = clusterType
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
    }
}

extension ResizeClusterMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classic = "Classic"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterType = "ClusterType"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let classic = classic {
            try container.encode(classic, forKey: Key("Classic"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterType = clusterType {
            try container.encode(clusterType, forKey: Key("ClusterType"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let classicDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .classic)
        classic = classicDecoded
    }
}

extension ResizeClusterMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResizeClusterMessage(classic: \(String(describing: classic)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterType: \(String(describing: clusterType)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)))"}
}

/// <p>Describes a resize cluster operation. For example, a scheduled action to run the <code>ResizeCluster</code> API operation. </p>
public struct ResizeClusterMessage: Equatable {
    /// <p>A boolean value indicating whether the resize operation is using the classic resize
    ///             process. If you don't provide this parameter or set the value to
    ///             <code>false</code>, the resize type is elastic. </p>
    public let classic: Bool?
    /// <p>The unique identifier for the cluster to resize.</p>
    public let clusterIdentifier: String?
    /// <p>The new cluster type for the specified cluster.</p>
    public let clusterType: String?
    /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
    public let nodeType: String?
    /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
    public let numberOfNodes: Int?

    public init (
        classic: Bool? = nil,
        clusterIdentifier: String? = nil,
        clusterType: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int? = nil
    )
    {
        self.classic = classic
        self.clusterIdentifier = clusterIdentifier
        self.clusterType = clusterType
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
    }
}

extension ResizeClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResizeClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOptionFault" : self = .unsupportedOptionFault(try UnsupportedOptionFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResizeClusterOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unsupportedOptionFault(UnsupportedOptionFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResizeClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResizeClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ResizeClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResizeClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ResizeClusterOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ResizeClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ResizeClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResizeClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension ResizeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowCancelResize = "AllowCancelResize"
        case resizeType = "ResizeType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowCancelResize != false {
            try container.encode(allowCancelResize, forKey: Key("AllowCancelResize"))
        }
        if let resizeType = resizeType {
            try container.encode(resizeType, forKey: Key("ResizeType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resizeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let allowCancelResizeDecoded = try containerValues.decode(Bool.self, forKey: .allowCancelResize)
        allowCancelResize = allowCancelResizeDecoded
    }
}

extension ResizeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResizeInfo(allowCancelResize: \(String(describing: allowCancelResize)), resizeType: \(String(describing: resizeType)))"}
}

/// <p>Describes a resize operation.</p>
public struct ResizeInfo: Equatable {
    /// <p>A boolean value indicating if the resize operation can be cancelled.</p>
    public let allowCancelResize: Bool
    /// <p>Returns the value <code>ClassicResize</code>.</p>
    public let resizeType: String?

    public init (
        allowCancelResize: Bool = false,
        resizeType: String? = nil
    )
    {
        self.allowCancelResize = allowCancelResize
        self.resizeType = resizeType
    }
}

extension ResizeNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResizeNotFoundFault(message: \(String(describing: message)))"}
}

extension ResizeNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResizeNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resize operation for the specified cluster is not found.</p>
public struct ResizeNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResizeNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ResizeNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundFault(message: \(String(describing: message)))"}
}

extension ResourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource could not be found.</p>
public struct ResourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreFromClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "RestoreFromClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreFromClusterSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreFromClusterSnapshotOutputError>
}

extension RestoreFromClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreFromClusterSnapshotInput(additionalInfo: \(String(describing: additionalInfo)), allowVersionUpgrade: \(String(describing: allowVersionUpgrade)), aquaConfigurationStatus: \(String(describing: aquaConfigurationStatus)), automatedSnapshotRetentionPeriod: \(String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(String(describing: availabilityZone)), availabilityZoneRelocation: \(String(describing: availabilityZoneRelocation)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterParameterGroupName: \(String(describing: clusterParameterGroupName)), clusterSecurityGroups: \(String(describing: clusterSecurityGroups)), clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), elasticIp: \(String(describing: elasticIp)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), iamRoles: \(String(describing: iamRoles)), kmsKeyId: \(String(describing: kmsKeyId)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), ownerAccount: \(String(describing: ownerAccount)), port: \(String(describing: port)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(String(describing: publiclyAccessible)), snapshotClusterIdentifier: \(String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), snapshotScheduleIdentifier: \(String(describing: snapshotScheduleIdentifier)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreFromClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let additionalInfo = additionalInfo {
            try container.encode(additionalInfo, forKey: Key("AdditionalInfo"))
        }
        if let allowVersionUpgrade = allowVersionUpgrade {
            try container.encode(allowVersionUpgrade, forKey: Key("AllowVersionUpgrade"))
        }
        if let aquaConfigurationStatus = aquaConfigurationStatus {
            try container.encode(aquaConfigurationStatus, forKey: Key("AquaConfigurationStatus"))
        }
        if let automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocation = availabilityZoneRelocation {
            try container.encode(availabilityZoneRelocation, forKey: Key("AvailabilityZoneRelocation"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterParameterGroupName = clusterParameterGroupName {
            try container.encode(clusterParameterGroupName, forKey: Key("ClusterParameterGroupName"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ClusterSecurityGroups"))
            for (index0, string0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(string0, forKey: Key("ClusterSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: Key("ClusterSubnetGroupName"))
        }
        if let elasticIp = elasticIp {
            try container.encode(elasticIp, forKey: Key("ElasticIp"))
        }
        if let enhancedVpcRouting = enhancedVpcRouting {
            try container.encode(enhancedVpcRouting, forKey: Key("EnhancedVpcRouting"))
        }
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try container.encode(hsmClientCertificateIdentifier, forKey: Key("HsmClientCertificateIdentifier"))
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try container.encode(hsmConfigurationIdentifier, forKey: Key("HsmConfigurationIdentifier"))
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("IamRoles"))
            for (index0, string0) in iamRoles.enumerated() {
                try iamRolesContainer.encode(string0, forKey: Key("IamRoleArn.\(index0.advanced(by: 1))"))
            }
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if let numberOfNodes = numberOfNodes {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: Key("OwnerAccount"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try container.encode(snapshotScheduleIdentifier, forKey: Key("SnapshotScheduleIdentifier"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreFromClusterSnapshot", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct RestoreFromClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreFromClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreFromClusterSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreFromClusterSnapshotOutputError>
}

public struct RestoreFromClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreFromClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreFromClusterSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreFromClusterSnapshotOutputError>
}

/// <p></p>
public struct RestoreFromClusterSnapshotInput: Equatable {
    /// <p>Reserved.</p>
    public let additionalInfo: String?
    /// <p>If <code>true</code>, major version upgrades can be applied during the maintenance
    ///             window to the Amazon Redshift engine that is running on the cluster. </p>
    ///         <p>Default: <code>true</code>
    ///         </p>
    public let allowVersionUpgrade: Bool?
    /// <p>The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) after the cluster is restored. Possible values include the following.</p>
    ///         <ul>
    ///             <li>
    ///                <p>enabled - Use AQUA if it is available for the current AWS Region and Amazon Redshift node type.</p>
    ///             </li>
    ///             <li>
    ///                <p>disabled - Don't use AQUA. </p>
    ///             </li>
    ///             <li>
    ///                <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    ///             </li>
    ///          </ul>
    public let aquaConfigurationStatus: AquaConfigurationStatus?
    /// <p>The number of days that automated snapshots are retained. If the value is 0,
    ///             automated snapshots are disabled. Even if automated snapshots are disabled, you can
    ///             still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p>
    ///
    ///         <p>You can't disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.</p>
    ///         <p>Default: The value selected for the cluster from which the snapshot was
    ///             taken.</p>
    ///         <p>Constraints: Must be a value from 0 to 35.</p>
    public let automatedSnapshotRetentionPeriod: Int?
    /// <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p>
    ///         <p>Default: A random, system-chosen Availability Zone.</p>
    ///         <p>Example: <code>us-east-2a</code>
    ///         </p>
    public let availabilityZone: String?
    /// <p>The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is restored.</p>
    public let availabilityZoneRelocation: Bool?
    /// <p>The identifier of the cluster that will be created from restoring the
    ///             snapshot.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Alphabetic characters must be lowercase.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be unique for all clusters within an AWS account.</p>
    ///             </li>
    ///          </ul>
    public let clusterIdentifier: String?
    /// <p>The name of the parameter group to be associated with this cluster.</p>
    ///         <p>Default: The default Amazon Redshift cluster parameter group. For information about the
    ///             default parameter group, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon
    ///                 Redshift Parameter Groups</a>.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must be 1 to 255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterParameterGroupName: String?
    /// <p>A list of security groups to be associated with this cluster.</p>
    ///         <p>Default: The default cluster security group for Amazon Redshift.</p>
    ///         <p>Cluster security groups only apply to clusters outside of VPCs.</p>
    public let clusterSecurityGroups: [String]?
    /// <p>The name of the subnet group where you want to cluster restored.</p>
    ///         <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must
    ///             provide subnet group name where you want the cluster restored.</p>
    public let clusterSubnetGroupName: String?
    /// <p>The elastic IP (EIP) address for the cluster.</p>
    public let elasticIp: String?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Bool?
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    ///             retrieve the data encryption keys stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>Specifies the name of the HSM configuration that contains the information the
    ///             Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the
    ///             cluster to access other AWS services. You must supply the IAM roles in their Amazon
    ///             Resource Name (ARN) format. You can supply up to 10 IAM roles in a single
    ///             request.</p>
    ///         <p>A cluster can have up to 10 IAM roles associated at any time.</p>
    public let iamRoles: [String]?
    /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that you want to
    ///             use to encrypt data in the cluster that you restore from a shared snapshot.</p>
    public let kmsKeyId: String?
    /// <p>The name of the maintenance track for the restored cluster. When you take a snapshot,
    ///             the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The
    ///             snapshot might be on a different track than the cluster that was the source for the
    ///             snapshot. For example, suppose that you take a snapshot of a cluster that is on the
    ///             current track and then change the cluster to be on the trailing track. In this case, the
    ///             snapshot and the source cluster are on different tracks.</p>
    public let maintenanceTrackName: String?
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
    ///             snapshot is retained indefinitely. This setting doesn't change the retention period
    ///             of existing snapshots.</p>
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>The node type that the restored cluster will be provisioned with.</p>
    ///         <p>Default: The node type of the cluster from which the snapshot was taken. You can
    ///             modify this if you are using any DS node type. In that case, you can choose to restore
    ///             into another DS node type of the same size. For example, you can restore ds1.8xlarge
    ///             into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you
    ///             must restore into that same instance type and size. In other words, you can only restore
    ///             a dc1.large instance type into another dc1.large instance type or dc2.large instance
    ///             type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlarge
    ///             cluster, then resize to a dc2.8large cluster. For more information about node types, see
    ///                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes">
    ///                 About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    public let nodeType: String?
    /// <p>The number of nodes specified when provisioning the restored cluster.</p>
    public let numberOfNodes: Int?
    /// <p>The AWS customer account used to create or copy the snapshot. Required if you are
    ///             restoring a snapshot you do not own, optional if you own the snapshot.</p>
    public let ownerAccount: String?
    /// <p>The port number on which the cluster accepts connections.</p>
    ///         <p>Default: The same port as the original cluster.</p>
    ///         <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
    public let port: Int?
    /// <p>The weekly time range (in UTC) during which automated cluster maintenance can
    ///             occur.</p>
    ///         <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///         </p>
    ///         <p> Default: The value selected for the cluster from which the snapshot was taken. For
    ///             more information about the time blocks for each region, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p>
    ///         <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///         <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>If <code>true</code>, the cluster can be accessed from a public network. </p>
    public let publiclyAccessible: Bool?
    /// <p>The name of the cluster the source snapshot was created from. This parameter is
    ///             required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    public let snapshotClusterIdentifier: String?
    /// <p>The name of the snapshot from which to create the new cluster. This parameter isn't
    ///             case sensitive.</p>
    ///         <p>Example: <code>my-snapshot-id</code>
    ///         </p>
    public let snapshotIdentifier: String?
    /// <p>A unique identifier for the snapshot schedule.</p>
    public let snapshotScheduleIdentifier: String?
    /// <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the
    ///             cluster.</p>
    ///         <p>Default: The default VPC security group is associated with the cluster.</p>
    ///         <p>VPC security groups only apply to clusters in VPCs.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        additionalInfo: String? = nil,
        allowVersionUpgrade: Bool? = nil,
        aquaConfigurationStatus: AquaConfigurationStatus? = nil,
        automatedSnapshotRetentionPeriod: Int? = nil,
        availabilityZone: String? = nil,
        availabilityZoneRelocation: Bool? = nil,
        clusterIdentifier: String? = nil,
        clusterParameterGroupName: String? = nil,
        clusterSecurityGroups: [String]? = nil,
        clusterSubnetGroupName: String? = nil,
        elasticIp: String? = nil,
        enhancedVpcRouting: Bool? = nil,
        hsmClientCertificateIdentifier: String? = nil,
        hsmConfigurationIdentifier: String? = nil,
        iamRoles: [String]? = nil,
        kmsKeyId: String? = nil,
        maintenanceTrackName: String? = nil,
        manualSnapshotRetentionPeriod: Int? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int? = nil,
        ownerAccount: String? = nil,
        port: Int? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool? = nil,
        snapshotClusterIdentifier: String? = nil,
        snapshotIdentifier: String? = nil,
        snapshotScheduleIdentifier: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.allowVersionUpgrade = allowVersionUpgrade
        self.aquaConfigurationStatus = aquaConfigurationStatus
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.availabilityZoneRelocation = availabilityZoneRelocation
        self.clusterIdentifier = clusterIdentifier
        self.clusterParameterGroupName = clusterParameterGroupName
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.elasticIp = elasticIp
        self.enhancedVpcRouting = enhancedVpcRouting
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.ownerAccount = ownerAccount
        self.port = port
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
        self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreFromClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreFromClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessToSnapshotDeniedFault" : self = .accessToSnapshotDeniedFault(try AccessToSnapshotDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterParameterGroupNotFoundFault" : self = .clusterParameterGroupNotFoundFault(try ClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaExceededFault" : self = .clusterQuotaExceededFault(try ClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSubnetGroupNotFoundFault" : self = .clusterSubnetGroupNotFoundFault(try ClusterSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmClientCertificateNotFoundFault" : self = .hsmClientCertificateNotFoundFault(try HsmClientCertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HsmConfigurationNotFoundFault" : self = .hsmConfigurationNotFoundFault(try HsmConfigurationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSubnetGroupStateFault" : self = .invalidClusterSubnetGroupStateFault(try InvalidClusterSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterTrackFault" : self = .invalidClusterTrackFault(try InvalidClusterTrackFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidElasticIpFault" : self = .invalidElasticIpFault(try InvalidElasticIpFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagFault" : self = .invalidTagFault(try InvalidTagFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededFault" : self = .limitExceededFault(try LimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesPerClusterLimitExceededFault" : self = .numberOfNodesPerClusterLimitExceededFault(try NumberOfNodesPerClusterLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfNodesQuotaExceededFault" : self = .numberOfNodesQuotaExceededFault(try NumberOfNodesQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotScheduleNotFoundFault" : self = .snapshotScheduleNotFoundFault(try SnapshotScheduleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededFault" : self = .tagLimitExceededFault(try TagLimitExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreFromClusterSnapshotOutputError: Equatable {
    case accessToSnapshotDeniedFault(AccessToSnapshotDeniedFault)
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterParameterGroupNotFoundFault(ClusterParameterGroupNotFoundFault)
    case clusterQuotaExceededFault(ClusterQuotaExceededFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case clusterSubnetGroupNotFoundFault(ClusterSubnetGroupNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case hsmClientCertificateNotFoundFault(HsmClientCertificateNotFoundFault)
    case hsmConfigurationNotFoundFault(HsmConfigurationNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidClusterSubnetGroupStateFault(InvalidClusterSubnetGroupStateFault)
    case invalidClusterTrackFault(InvalidClusterTrackFault)
    case invalidElasticIpFault(InvalidElasticIpFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidTagFault(InvalidTagFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case limitExceededFault(LimitExceededFault)
    case numberOfNodesPerClusterLimitExceededFault(NumberOfNodesPerClusterLimitExceededFault)
    case numberOfNodesQuotaExceededFault(NumberOfNodesQuotaExceededFault)
    case snapshotScheduleNotFoundFault(SnapshotScheduleNotFoundFault)
    case tagLimitExceededFault(TagLimitExceededFault)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreFromClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreFromClusterSnapshotOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension RestoreFromClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreFromClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RestoreFromClusterSnapshotOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RestoreFromClusterSnapshotOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension RestoreFromClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreFromClusterSnapshotResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RestoreStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentRestoreRateInMegaBytesPerSecond = "CurrentRestoreRateInMegaBytesPerSecond"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case snapshotSizeInMegaBytes = "SnapshotSizeInMegaBytes"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if currentRestoreRateInMegaBytesPerSecond != 0.0 {
            try container.encode(String(currentRestoreRateInMegaBytesPerSecond), forKey: Key("CurrentRestoreRateInMegaBytesPerSecond"))
        }
        if elapsedTimeInSeconds != 0 {
            try container.encode(elapsedTimeInSeconds, forKey: Key("ElapsedTimeInSeconds"))
        }
        if estimatedTimeToCompletionInSeconds != 0 {
            try container.encode(estimatedTimeToCompletionInSeconds, forKey: Key("EstimatedTimeToCompletionInSeconds"))
        }
        if progressInMegaBytes != 0 {
            try container.encode(progressInMegaBytes, forKey: Key("ProgressInMegaBytes"))
        }
        if snapshotSizeInMegaBytes != 0 {
            try container.encode(snapshotSizeInMegaBytes, forKey: Key("SnapshotSizeInMegaBytes"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let currentRestoreRateInMegaBytesPerSecondDecoded = try containerValues.decode(Double.self, forKey: .currentRestoreRateInMegaBytesPerSecond)
        currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecondDecoded
        let snapshotSizeInMegaBytesDecoded = try containerValues.decode(Int.self, forKey: .snapshotSizeInMegaBytes)
        snapshotSizeInMegaBytes = snapshotSizeInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decode(Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decode(Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
    }
}

extension RestoreStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreStatus(currentRestoreRateInMegaBytesPerSecond: \(String(describing: currentRestoreRateInMegaBytesPerSecond)), elapsedTimeInSeconds: \(String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(String(describing: estimatedTimeToCompletionInSeconds)), progressInMegaBytes: \(String(describing: progressInMegaBytes)), snapshotSizeInMegaBytes: \(String(describing: snapshotSizeInMegaBytes)), status: \(String(describing: status)))"}
}

/// <p>Describes the status of a cluster restore action. Returns null if the cluster was
///             not created by restoring a snapshot.</p>
public struct RestoreStatus: Equatable {
    /// <p>The number of megabytes per second being transferred from the backup storage.
    ///             Returns the average rate for a completed backup.
    ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
    public let currentRestoreRateInMegaBytesPerSecond: Double
    /// <p>The amount of time an in-progress restore has been running, or the amount of time
    ///             it took a completed restore to finish.
    ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
    public let elapsedTimeInSeconds: Int
    /// <p>The estimate of the time remaining before the restore will complete. Returns 0 for
    ///             a completed restore.
    ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
    public let estimatedTimeToCompletionInSeconds: Int
    /// <p>The number of megabytes that have been transferred from snapshot storage.
    ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
    public let progressInMegaBytes: Int
    /// <p>The size of the set of snapshot data used to restore the cluster.
    ///             This field is only updated when you restore to DC2 and DS2 node types. </p>
    public let snapshotSizeInMegaBytes: Int
    /// <p>The status of the restore action. Returns starting, restoring, completed, or
    ///             failed.</p>
    public let status: String?

    public init (
        currentRestoreRateInMegaBytesPerSecond: Double = 0.0,
        elapsedTimeInSeconds: Int = 0,
        estimatedTimeToCompletionInSeconds: Int = 0,
        progressInMegaBytes: Int = 0,
        snapshotSizeInMegaBytes: Int = 0,
        status: String? = nil
    )
    {
        self.currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecond
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
        self.progressInMegaBytes = progressInMegaBytes
        self.snapshotSizeInMegaBytes = snapshotSizeInMegaBytes
        self.status = status
    }
}

public struct RestoreTableFromClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "RestoreTableFromClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreTableFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreTableFromClusterSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreTableFromClusterSnapshotOutputError>
}

extension RestoreTableFromClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreTableFromClusterSnapshotInput(clusterIdentifier: \(String(describing: clusterIdentifier)), enableCaseSensitiveIdentifier: \(String(describing: enableCaseSensitiveIdentifier)), newTableName: \(String(describing: newTableName)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), sourceDatabaseName: \(String(describing: sourceDatabaseName)), sourceSchemaName: \(String(describing: sourceSchemaName)), sourceTableName: \(String(describing: sourceTableName)), targetDatabaseName: \(String(describing: targetDatabaseName)), targetSchemaName: \(String(describing: targetSchemaName)))"}
}

extension RestoreTableFromClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let enableCaseSensitiveIdentifier = enableCaseSensitiveIdentifier {
            try container.encode(enableCaseSensitiveIdentifier, forKey: Key("EnableCaseSensitiveIdentifier"))
        }
        if let newTableName = newTableName {
            try container.encode(newTableName, forKey: Key("NewTableName"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let sourceDatabaseName = sourceDatabaseName {
            try container.encode(sourceDatabaseName, forKey: Key("SourceDatabaseName"))
        }
        if let sourceSchemaName = sourceSchemaName {
            try container.encode(sourceSchemaName, forKey: Key("SourceSchemaName"))
        }
        if let sourceTableName = sourceTableName {
            try container.encode(sourceTableName, forKey: Key("SourceTableName"))
        }
        if let targetDatabaseName = targetDatabaseName {
            try container.encode(targetDatabaseName, forKey: Key("TargetDatabaseName"))
        }
        if let targetSchemaName = targetSchemaName {
            try container.encode(targetSchemaName, forKey: Key("TargetSchemaName"))
        }
        try container.encode("RestoreTableFromClusterSnapshot", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct RestoreTableFromClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreTableFromClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreTableFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreTableFromClusterSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreTableFromClusterSnapshotOutputError>
}

public struct RestoreTableFromClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreTableFromClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreTableFromClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreTableFromClusterSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreTableFromClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreTableFromClusterSnapshotOutputError>
}

/// <p></p>
public struct RestoreTableFromClusterSnapshotInput: Equatable {
    /// <p>The identifier of the Amazon Redshift cluster to restore the table to.</p>
    public let clusterIdentifier: String?
    /// <p>Indicates whether name identifiers for database, schema, and table are case sensitive.
    ///             If <code>true</code>, the names are case sensitive.
    ///             If <code>false</code> (default), the names are not case sensitive.</p>
    public let enableCaseSensitiveIdentifier: Bool?
    /// <p>The name of the table to create as a result of the current request.</p>
    public let newTableName: String?
    /// <p>The identifier of the snapshot to restore the table from. This snapshot must have
    ///             been created from the Amazon Redshift cluster specified by the
    ///                 <code>ClusterIdentifier</code> parameter.</p>
    public let snapshotIdentifier: String?
    /// <p>The name of the source database that contains the table to restore from.</p>
    public let sourceDatabaseName: String?
    /// <p>The name of the source schema that contains the table to restore from. If you do
    ///             not specify a <code>SourceSchemaName</code> value, the default is
    ///             <code>public</code>.</p>
    public let sourceSchemaName: String?
    /// <p>The name of the source table to restore from.</p>
    public let sourceTableName: String?
    /// <p>The name of the database to restore the table to.</p>
    public let targetDatabaseName: String?
    /// <p>The name of the schema to restore the table to.</p>
    public let targetSchemaName: String?

    public init (
        clusterIdentifier: String? = nil,
        enableCaseSensitiveIdentifier: Bool? = nil,
        newTableName: String? = nil,
        snapshotIdentifier: String? = nil,
        sourceDatabaseName: String? = nil,
        sourceSchemaName: String? = nil,
        sourceTableName: String? = nil,
        targetDatabaseName: String? = nil,
        targetSchemaName: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.enableCaseSensitiveIdentifier = enableCaseSensitiveIdentifier
        self.newTableName = newTableName
        self.snapshotIdentifier = snapshotIdentifier
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
    }
}

extension RestoreTableFromClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreTableFromClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InProgressTableRestoreQuotaExceededFault" : self = .inProgressTableRestoreQuotaExceededFault(try InProgressTableRestoreQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSnapshotStateFault" : self = .invalidClusterSnapshotStateFault(try InvalidClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTableRestoreArgumentFault" : self = .invalidTableRestoreArgumentFault(try InvalidTableRestoreArgumentFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationFault" : self = .unsupportedOperationFault(try UnsupportedOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreTableFromClusterSnapshotOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case inProgressTableRestoreQuotaExceededFault(InProgressTableRestoreQuotaExceededFault)
    case invalidClusterSnapshotStateFault(InvalidClusterSnapshotStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidTableRestoreArgumentFault(InvalidTableRestoreArgumentFault)
    case unsupportedOperationFault(UnsupportedOperationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreTableFromClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreTableFromClusterSnapshotOutputResponse(tableRestoreStatus: \(String(describing: tableRestoreStatus)))"}
}

extension RestoreTableFromClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreTableFromClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tableRestoreStatus = output.tableRestoreStatus
        } else {
            self.tableRestoreStatus = nil
        }
    }
}

public struct RestoreTableFromClusterSnapshotOutputResponse: Equatable {
    /// <p>Describes the status of a <a>RestoreTableFromClusterSnapshot</a>
    ///             operation.</p>
    public let tableRestoreStatus: TableRestoreStatus?

    public init (
        tableRestoreStatus: TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

struct RestoreTableFromClusterSnapshotOutputResponseBody: Equatable {
    public let tableRestoreStatus: TableRestoreStatus?
}

extension RestoreTableFromClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tableRestoreStatus = "TableRestoreStatus"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreTableFromClusterSnapshotResult"))
        let tableRestoreStatusDecoded = try containerValues.decodeIfPresent(TableRestoreStatus.self, forKey: .tableRestoreStatus)
        tableRestoreStatus = tableRestoreStatusDecoded
    }
}

public struct ResumeClusterInputBodyMiddleware: Middleware {
    public let id: String = "ResumeClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeClusterInput>
    public typealias MOutput = OperationOutput<ResumeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeClusterOutputError>
}

extension ResumeClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeClusterInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension ResumeClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("ResumeCluster", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct ResumeClusterInputHeadersMiddleware: Middleware {
    public let id: String = "ResumeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeClusterInput>
    public typealias MOutput = OperationOutput<ResumeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeClusterOutputError>
}

public struct ResumeClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "ResumeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeClusterInput>
    public typealias MOutput = OperationOutput<ResumeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeClusterOutputError>
}

/// <p>Describes a resume cluster operation. For example, a scheduled action to run the <code>ResumeCluster</code> API operation. </p>
public struct ResumeClusterInput: Equatable {
    /// <p>The identifier of the cluster to be resumed.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension ResumeClusterMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
    }
}

extension ResumeClusterMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeClusterMessage(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

/// <p>Describes a resume cluster operation. For example, a scheduled action to run the <code>ResumeCluster</code> API operation. </p>
public struct ResumeClusterMessage: Equatable {
    /// <p>The identifier of the cluster to be resumed.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension ResumeClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResumeClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeClusterOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ResumeClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResumeClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ResumeClusterOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ResumeClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ResumeClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResumeClusterResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension RevisionTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseRevision = "DatabaseRevision"
        case databaseRevisionReleaseDate = "DatabaseRevisionReleaseDate"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let databaseRevision = databaseRevision {
            try container.encode(databaseRevision, forKey: Key("DatabaseRevision"))
        }
        if let databaseRevisionReleaseDate = databaseRevisionReleaseDate {
            try container.encode(TimestampWrapper(databaseRevisionReleaseDate, format: .dateTime), forKey: Key("databaseRevisionReleaseDate"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseRevision)
        databaseRevision = databaseRevisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let databaseRevisionReleaseDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseRevisionReleaseDate)
        var databaseRevisionReleaseDateBuffer:Date? = nil
        if let databaseRevisionReleaseDateDecoded = databaseRevisionReleaseDateDecoded {
            databaseRevisionReleaseDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(databaseRevisionReleaseDateDecoded, format: .dateTime)
        }
        databaseRevisionReleaseDate = databaseRevisionReleaseDateBuffer
    }
}

extension RevisionTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevisionTarget(databaseRevision: \(String(describing: databaseRevision)), databaseRevisionReleaseDate: \(String(describing: databaseRevisionReleaseDate)), description: \(String(describing: description)))"}
}

/// <p>Describes a <code>RevisionTarget</code>.</p>
public struct RevisionTarget: Equatable {
    /// <p>A unique string that identifies the version to update the cluster to. You can use this
    ///             value in <a>ModifyClusterDbRevision</a>.</p>
    public let databaseRevision: String?
    /// <p>The date on which the database revision was released.</p>
    public let databaseRevisionReleaseDate: Date?
    /// <p>A string that describes the changes and features that will be applied to the cluster
    ///             when it is updated to the corresponding <a>ClusterDbRevision</a>.</p>
    public let description: String?

    public init (
        databaseRevision: String? = nil,
        databaseRevisionReleaseDate: Date? = nil,
        description: String? = nil
    )
    {
        self.databaseRevision = databaseRevision
        self.databaseRevisionReleaseDate = databaseRevisionReleaseDate
        self.description = description
    }
}

public struct RevokeClusterSecurityGroupIngressInputBodyMiddleware: Middleware {
    public let id: String = "RevokeClusterSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeClusterSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeClusterSecurityGroupIngressOutputError>
}

extension RevokeClusterSecurityGroupIngressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeClusterSecurityGroupIngressInput(cIDRIP: \(String(describing: cIDRIP)), clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)), eC2SecurityGroupName: \(String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(String(describing: eC2SecurityGroupOwnerId)))"}
}

extension RevokeClusterSecurityGroupIngressInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: Key("CIDRIP"))
        }
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try container.encode(clusterSecurityGroupName, forKey: Key("ClusterSecurityGroupName"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("RevokeClusterSecurityGroupIngress", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct RevokeClusterSecurityGroupIngressInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeClusterSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeClusterSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeClusterSecurityGroupIngressOutputError>
}

public struct RevokeClusterSecurityGroupIngressInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeClusterSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeClusterSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeClusterSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<RevokeClusterSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeClusterSecurityGroupIngressOutputError>
}

/// <p></p>
public struct RevokeClusterSecurityGroupIngressInput: Equatable {
    /// <p>The IP range for which to revoke access. This range must be a valid Classless
    ///             Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified,
    ///                 <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be
    ///             provided. </p>
    public let cIDRIP: String?
    /// <p>The name of the security Group from which to revoke the ingress rule.</p>
    public let clusterSecurityGroupName: String?
    /// <p>The name of the EC2 Security Group whose access is to be revoked. If
    ///                 <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code>
    ///             must also be provided and <code>CIDRIP</code> cannot be provided. </p>
    public let eC2SecurityGroupName: String?
    /// <p>The AWS account number of the owner of the security group specified in the
    ///                 <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an
    ///             acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified,
    ///                 <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code>
    ///             cannot be provided. </p>
    ///         <p>Example: <code>111122223333</code>
    ///         </p>
    public let eC2SecurityGroupOwnerId: String?

    public init (
        cIDRIP: String? = nil,
        clusterSecurityGroupName: String? = nil,
        eC2SecurityGroupName: String? = nil,
        eC2SecurityGroupOwnerId: String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension RevokeClusterSecurityGroupIngressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeClusterSecurityGroupIngressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSecurityGroupNotFoundFault" : self = .clusterSecurityGroupNotFoundFault(try ClusterSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeClusterSecurityGroupIngressOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case clusterSecurityGroupNotFoundFault(ClusterSecurityGroupNotFoundFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeClusterSecurityGroupIngressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeClusterSecurityGroupIngressOutputResponse(clusterSecurityGroup: \(String(describing: clusterSecurityGroup)))"}
}

extension RevokeClusterSecurityGroupIngressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RevokeClusterSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterSecurityGroup = output.clusterSecurityGroup
        } else {
            self.clusterSecurityGroup = nil
        }
    }
}

public struct RevokeClusterSecurityGroupIngressOutputResponse: Equatable {
    /// <p>Describes a security group.</p>
    public let clusterSecurityGroup: ClusterSecurityGroup?

    public init (
        clusterSecurityGroup: ClusterSecurityGroup? = nil
    )
    {
        self.clusterSecurityGroup = clusterSecurityGroup
    }
}

struct RevokeClusterSecurityGroupIngressOutputResponseBody: Equatable {
    public let clusterSecurityGroup: ClusterSecurityGroup?
}

extension RevokeClusterSecurityGroupIngressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterSecurityGroup = "ClusterSecurityGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RevokeClusterSecurityGroupIngressResult"))
        let clusterSecurityGroupDecoded = try containerValues.decodeIfPresent(ClusterSecurityGroup.self, forKey: .clusterSecurityGroup)
        clusterSecurityGroup = clusterSecurityGroupDecoded
    }
}

public struct RevokeEndpointAccessInputBodyMiddleware: Middleware {
    public let id: String = "RevokeEndpointAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeEndpointAccessInput>
    public typealias MOutput = OperationOutput<RevokeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeEndpointAccessOutputError>
}

extension RevokeEndpointAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeEndpointAccessInput(account: \(String(describing: account)), clusterIdentifier: \(String(describing: clusterIdentifier)), force: \(String(describing: force)), vpcIds: \(String(describing: vpcIds)))"}
}

extension RevokeEndpointAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let account = account {
            try container.encode(account, forKey: Key("Account"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if force != false {
            try container.encode(force, forKey: Key("Force"))
        }
        if let vpcIds = vpcIds {
            var vpcIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcIds"))
            for (index0, string0) in vpcIds.enumerated() {
                try vpcIdsContainer.encode(string0, forKey: Key("VpcIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RevokeEndpointAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct RevokeEndpointAccessInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeEndpointAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeEndpointAccessInput>
    public typealias MOutput = OperationOutput<RevokeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeEndpointAccessOutputError>
}

public struct RevokeEndpointAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeEndpointAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeEndpointAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeEndpointAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeEndpointAccessInput>
    public typealias MOutput = OperationOutput<RevokeEndpointAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeEndpointAccessOutputError>
}

public struct RevokeEndpointAccessInput: Equatable {
    /// <p>The AWS account ID whose access is to be revoked.</p>
    public let account: String?
    /// <p>The cluster to revoke access from.</p>
    public let clusterIdentifier: String?
    /// <p>Indicates whether to force the revoke action.
    ///            If true, the Redshift-managed VPC endpoints associated with the endpoint authorization are also deleted.</p>
    public let force: Bool
    /// <p>The virtual private cloud (VPC) identifiers for which access is to be revoked.</p>
    public let vpcIds: [String]?

    public init (
        account: String? = nil,
        clusterIdentifier: String? = nil,
        force: Bool = false,
        vpcIds: [String]? = nil
    )
    {
        self.account = account
        self.clusterIdentifier = clusterIdentifier
        self.force = force
        self.vpcIds = vpcIds
    }
}

extension RevokeEndpointAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeEndpointAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAuthorizationNotFoundFault" : self = .endpointAuthorizationNotFoundFault(try EndpointAuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundFault" : self = .endpointNotFoundFault(try EndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthorizationStateFault" : self = .invalidAuthorizationStateFault(try InvalidAuthorizationStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterSecurityGroupStateFault" : self = .invalidClusterSecurityGroupStateFault(try InvalidClusterSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointStateFault" : self = .invalidEndpointStateFault(try InvalidEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeEndpointAccessOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case endpointAuthorizationNotFoundFault(EndpointAuthorizationNotFoundFault)
    case endpointNotFoundFault(EndpointNotFoundFault)
    case invalidAuthorizationStateFault(InvalidAuthorizationStateFault)
    case invalidClusterSecurityGroupStateFault(InvalidClusterSecurityGroupStateFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidEndpointStateFault(InvalidEndpointStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeEndpointAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeEndpointAccessOutputResponse(allowedAllVPCs: \(String(describing: allowedAllVPCs)), allowedVPCs: \(String(describing: allowedVPCs)), authorizeTime: \(String(describing: authorizeTime)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterStatus: \(String(describing: clusterStatus)), endpointCount: \(String(describing: endpointCount)), grantee: \(String(describing: grantee)), grantor: \(String(describing: grantor)), status: \(String(describing: status)))"}
}

extension RevokeEndpointAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RevokeEndpointAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowedAllVPCs = output.allowedAllVPCs
            self.allowedVPCs = output.allowedVPCs
            self.authorizeTime = output.authorizeTime
            self.clusterIdentifier = output.clusterIdentifier
            self.clusterStatus = output.clusterStatus
            self.endpointCount = output.endpointCount
            self.grantee = output.grantee
            self.grantor = output.grantor
            self.status = output.status
        } else {
            self.allowedAllVPCs = false
            self.allowedVPCs = nil
            self.authorizeTime = nil
            self.clusterIdentifier = nil
            self.clusterStatus = nil
            self.endpointCount = 0
            self.grantee = nil
            self.grantor = nil
            self.status = nil
        }
    }
}

/// <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across AWS accounts.</p>
public struct RevokeEndpointAccessOutputResponse: Equatable {
    /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
    public let allowedAllVPCs: Bool
    /// <p>The VPCs allowed access to the cluster.</p>
    public let allowedVPCs: [String]?
    /// <p>The time (UTC) when the authorization was created.</p>
    public let authorizeTime: Date?
    /// <p>The cluster identifier.</p>
    public let clusterIdentifier: String?
    /// <p>The status of the cluster.</p>
    public let clusterStatus: String?
    /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
    public let endpointCount: Int
    /// <p>The AWS account ID of the grantee of the cluster.</p>
    public let grantee: String?
    /// <p>The AWS account ID of the cluster owner.</p>
    public let grantor: String?
    /// <p>The status of the authorization action.</p>
    public let status: AuthorizationStatus?

    public init (
        allowedAllVPCs: Bool = false,
        allowedVPCs: [String]? = nil,
        authorizeTime: Date? = nil,
        clusterIdentifier: String? = nil,
        clusterStatus: String? = nil,
        endpointCount: Int = 0,
        grantee: String? = nil,
        grantor: String? = nil,
        status: AuthorizationStatus? = nil
    )
    {
        self.allowedAllVPCs = allowedAllVPCs
        self.allowedVPCs = allowedVPCs
        self.authorizeTime = authorizeTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterStatus = clusterStatus
        self.endpointCount = endpointCount
        self.grantee = grantee
        self.grantor = grantor
        self.status = status
    }
}

struct RevokeEndpointAccessOutputResponseBody: Equatable {
    public let grantor: String?
    public let grantee: String?
    public let clusterIdentifier: String?
    public let authorizeTime: Date?
    public let clusterStatus: String?
    public let status: AuthorizationStatus?
    public let allowedAllVPCs: Bool
    public let allowedVPCs: [String]?
    public let endpointCount: Int
}

extension RevokeEndpointAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowedAllVPCs = "AllowedAllVPCs"
        case allowedVPCs = "AllowedVPCs"
        case authorizeTime = "AuthorizeTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterStatus = "ClusterStatus"
        case endpointCount = "EndpointCount"
        case grantee = "Grantee"
        case grantor = "Grantor"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RevokeEndpointAccessResult"))
        let grantorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantor)
        grantor = grantorDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantee)
        grantee = granteeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let authorizeTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizeTime)
        var authorizeTimeBuffer:Date? = nil
        if let authorizeTimeDecoded = authorizeTimeDecoded {
            authorizeTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(authorizeTimeDecoded, format: .dateTime)
        }
        authorizeTime = authorizeTimeBuffer
        let clusterStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let allowedAllVPCsDecoded = try containerValues.decode(Bool.self, forKey: .allowedAllVPCs)
        allowedAllVPCs = allowedAllVPCsDecoded
        if containerValues.contains(.allowedVPCs) {
            struct KeyVal0{struct VpcIdentifier{}}
            let allowedVPCsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcIdentifier>.CodingKeys.self, forKey: .allowedVPCs)
            if let allowedVPCsWrappedContainer = allowedVPCsWrappedContainer {
                let allowedVPCsContainer = try allowedVPCsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var allowedVPCsBuffer:[String]? = nil
                if let allowedVPCsContainer = allowedVPCsContainer {
                    allowedVPCsBuffer = [String]()
                    for stringContainer0 in allowedVPCsContainer {
                        allowedVPCsBuffer?.append(stringContainer0)
                    }
                }
                allowedVPCs = allowedVPCsBuffer
            } else {
                allowedVPCs = []
            }
        } else {
            allowedVPCs = nil
        }
        let endpointCountDecoded = try containerValues.decode(Int.self, forKey: .endpointCount)
        endpointCount = endpointCountDecoded
    }
}

public struct RevokeSnapshotAccessInputBodyMiddleware: Middleware {
    public let id: String = "RevokeSnapshotAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSnapshotAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSnapshotAccessInput>
    public typealias MOutput = OperationOutput<RevokeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSnapshotAccessOutputError>
}

extension RevokeSnapshotAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeSnapshotAccessInput(accountWithRestoreAccess: \(String(describing: accountWithRestoreAccess)), snapshotClusterIdentifier: \(String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(String(describing: snapshotIdentifier)))"}
}

extension RevokeSnapshotAccessInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountWithRestoreAccess = accountWithRestoreAccess {
            try container.encode(accountWithRestoreAccess, forKey: Key("AccountWithRestoreAccess"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        try container.encode("RevokeSnapshotAccess", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct RevokeSnapshotAccessInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeSnapshotAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSnapshotAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSnapshotAccessInput>
    public typealias MOutput = OperationOutput<RevokeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSnapshotAccessOutputError>
}

public struct RevokeSnapshotAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeSnapshotAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSnapshotAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSnapshotAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSnapshotAccessInput>
    public typealias MOutput = OperationOutput<RevokeSnapshotAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSnapshotAccessOutputError>
}

/// <p></p>
public struct RevokeSnapshotAccessInput: Equatable {
    /// <p>The identifier of the AWS customer account that can no longer restore the specified
    ///             snapshot.</p>
    public let accountWithRestoreAccess: String?
    /// <p>The identifier of the cluster the snapshot was created from. This parameter is
    ///             required if your IAM user has a policy containing a snapshot resource element that
    ///             specifies anything other than * for the cluster name.</p>
    public let snapshotClusterIdentifier: String?
    /// <p>The identifier of the snapshot that the account can no longer access.</p>
    public let snapshotIdentifier: String?

    public init (
        accountWithRestoreAccess: String? = nil,
        snapshotClusterIdentifier: String? = nil,
        snapshotIdentifier: String? = nil
    )
    {
        self.accountWithRestoreAccess = accountWithRestoreAccess
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension RevokeSnapshotAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeSnapshotAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessToSnapshotDeniedFault" : self = .accessToSnapshotDeniedFault(try AccessToSnapshotDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterSnapshotNotFoundFault" : self = .clusterSnapshotNotFoundFault(try ClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeSnapshotAccessOutputError: Equatable {
    case accessToSnapshotDeniedFault(AccessToSnapshotDeniedFault)
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case clusterSnapshotNotFoundFault(ClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeSnapshotAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeSnapshotAccessOutputResponse(snapshot: \(String(describing: snapshot)))"}
}

extension RevokeSnapshotAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RevokeSnapshotAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct RevokeSnapshotAccessOutputResponse: Equatable {
    /// <p>Describes a snapshot.</p>
    public let snapshot: Snapshot?

    public init (
        snapshot: Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct RevokeSnapshotAccessOutputResponseBody: Equatable {
    public let snapshot: Snapshot?
}

extension RevokeSnapshotAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RevokeSnapshotAccessResult"))
        let snapshotDecoded = try containerValues.decodeIfPresent(Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

public struct RotateEncryptionKeyInputBodyMiddleware: Middleware {
    public let id: String = "RotateEncryptionKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateEncryptionKeyInput>
    public typealias MOutput = OperationOutput<RotateEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateEncryptionKeyOutputError>
}

extension RotateEncryptionKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateEncryptionKeyInput(clusterIdentifier: \(String(describing: clusterIdentifier)))"}
}

extension RotateEncryptionKeyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        try container.encode("RotateEncryptionKey", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct RotateEncryptionKeyInputHeadersMiddleware: Middleware {
    public let id: String = "RotateEncryptionKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateEncryptionKeyInput>
    public typealias MOutput = OperationOutput<RotateEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateEncryptionKeyOutputError>
}

public struct RotateEncryptionKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "RotateEncryptionKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateEncryptionKeyInput>
    public typealias MOutput = OperationOutput<RotateEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateEncryptionKeyOutputError>
}

/// <p></p>
public struct RotateEncryptionKeyInput: Equatable {
    /// <p>The unique identifier of the cluster that you want to rotate the encryption keys
    ///             for.</p>
    ///         <p>Constraints: Must be the name of valid cluster that has encryption
    ///             enabled.</p>
    public let clusterIdentifier: String?

    public init (
        clusterIdentifier: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
    }
}

extension RotateEncryptionKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RotateEncryptionKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceRequestThrottlingFault" : self = .dependentServiceRequestThrottlingFault(try DependentServiceRequestThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateEncryptionKeyOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case dependentServiceRequestThrottlingFault(DependentServiceRequestThrottlingFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateEncryptionKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateEncryptionKeyOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension RotateEncryptionKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RotateEncryptionKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RotateEncryptionKeyOutputResponse: Equatable {
    /// <p>Describes a cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RotateEncryptionKeyOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension RotateEncryptionKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RotateEncryptionKeyResult"))
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension SNSInvalidTopicFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSInvalidTopicFault(message: \(String(describing: message)))"}
}

extension SNSInvalidTopicFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSInvalidTopicFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon SNS has responded that there is a problem with the specified Amazon SNS
///             topic.</p>
public struct SNSInvalidTopicFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Equatable {
    public let message: String?
}

extension SNSInvalidTopicFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSNoAuthorizationFault(message: \(String(describing: message)))"}
}

extension SNSNoAuthorizationFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSNoAuthorizationFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have permission to publish to the specified Amazon SNS topic.</p>
public struct SNSNoAuthorizationFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Equatable {
    public let message: String?
}

extension SNSNoAuthorizationFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSTopicArnNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSTopicArnNotFoundFault(message: \(String(describing: message)))"}
}

extension SNSTopicArnNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSTopicArnNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon SNS topic with the specified Amazon Resource Name (ARN) does not
///             exist.</p>
public struct SNSTopicArnNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSTopicArnNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SNSTopicArnNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScheduleDefinitionTypeUnsupportedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleDefinitionTypeUnsupportedFault(message: \(String(describing: message)))"}
}

extension ScheduleDefinitionTypeUnsupportedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ScheduleDefinitionTypeUnsupportedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The definition you submitted is not supported.</p>
public struct ScheduleDefinitionTypeUnsupportedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduleDefinitionTypeUnsupportedFaultBody: Equatable {
    public let message: String?
}

extension ScheduleDefinitionTypeUnsupportedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ScheduleState {
    case active
    case failed
    case modifying
    case sdkUnknown(String)
}

extension ScheduleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScheduleState] {
        return [
            .active,
            .failed,
            .modifying,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .failed: return "FAILED"
        case .modifying: return "MODIFYING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScheduleState(rawValue: rawValue) ?? ScheduleState.sdkUnknown(rawValue)
    }
}

extension ScheduledAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case iamRole = "IamRole"
        case nextInvocations = "NextInvocations"
        case schedule = "Schedule"
        case scheduledActionDescription = "ScheduledActionDescription"
        case scheduledActionName = "ScheduledActionName"
        case startTime = "StartTime"
        case state = "State"
        case targetAction = "TargetAction"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let iamRole = iamRole {
            try container.encode(iamRole, forKey: Key("IamRole"))
        }
        if let nextInvocations = nextInvocations {
            var nextInvocationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NextInvocations"))
            for (index0, tstamp0) in nextInvocations.enumerated() {
                try nextInvocationsContainer.encode(TimestampWrapper(tstamp0, format: .dateTime), forKey: Key("ScheduledActionTime.\(index0.advanced(by: 1))"))
            }
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: Key("Schedule"))
        }
        if let scheduledActionDescription = scheduledActionDescription {
            try container.encode(scheduledActionDescription, forKey: Key("ScheduledActionDescription"))
        }
        if let scheduledActionName = scheduledActionName {
            try container.encode(scheduledActionName, forKey: Key("ScheduledActionName"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let targetAction = targetAction {
            try container.encode(targetAction, forKey: Key("TargetAction"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(ScheduledActionType.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ScheduledActionState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct ScheduledActionTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduledActionTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        var startTimeBuffer:Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        var endTimeBuffer:Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
    }
}

extension ScheduledAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledAction(endTime: \(String(describing: endTime)), iamRole: \(String(describing: iamRole)), nextInvocations: \(String(describing: nextInvocations)), schedule: \(String(describing: schedule)), scheduledActionDescription: \(String(describing: scheduledActionDescription)), scheduledActionName: \(String(describing: scheduledActionName)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), targetAction: \(String(describing: targetAction)))"}
}

/// <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
///             For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
public struct ScheduledAction: Equatable {
    /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
    public let endTime: Date?
    /// <p>The IAM role to assume to run the scheduled action.
    ///             This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
    ///             This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
    ///
    /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    public let iamRole: String?
    /// <p>List of times when the scheduled action will run. </p>
    public let nextInvocations: [Date]?
    /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
    ///             Schedule invocations must be separated by at least one hour.</p>
    ///         <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
    ///         <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
    ///             For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
    ///             in the <i>Amazon CloudWatch Events User Guide</i>.</p>
    public let schedule: String?
    /// <p>The description of the scheduled action. </p>
    public let scheduledActionDescription: String?
    /// <p>The name of the scheduled action. </p>
    public let scheduledActionName: String?
    /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
    public let startTime: Date?
    /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
    public let state: ScheduledActionState?
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
    ///         <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
    public let targetAction: ScheduledActionType?

    public init (
        endTime: Date? = nil,
        iamRole: String? = nil,
        nextInvocations: [Date]? = nil,
        schedule: String? = nil,
        scheduledActionDescription: String? = nil,
        scheduledActionName: String? = nil,
        startTime: Date? = nil,
        state: ScheduledActionState? = nil,
        targetAction: ScheduledActionType? = nil
    )
    {
        self.endTime = endTime
        self.iamRole = iamRole
        self.nextInvocations = nextInvocations
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.state = state
        self.targetAction = targetAction
    }
}

extension ScheduledActionAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledActionAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ScheduledActionAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ScheduledActionAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The scheduled action already exists. </p>
public struct ScheduledActionAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ScheduledActionAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScheduledActionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: Key("item.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ScheduledActionFilterName.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct item{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension ScheduledActionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledActionFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A set of elements to filter the returned scheduled actions. </p>
public struct ScheduledActionFilter: Equatable {
    /// <p>The type of element to filter. </p>
    public let name: ScheduledActionFilterName?
    /// <p>List of values. Compare if the value (of type defined by <code>Name</code>) equals an item in the list of scheduled actions. </p>
    public let values: [String]?

    public init (
        name: ScheduledActionFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum ScheduledActionFilterName {
    case clusterIdentifier
    case iamRole
    case sdkUnknown(String)
}

extension ScheduledActionFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScheduledActionFilterName] {
        return [
            .clusterIdentifier,
            .iamRole,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clusterIdentifier: return "cluster-identifier"
        case .iamRole: return "iam-role"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScheduledActionFilterName(rawValue: rawValue) ?? ScheduledActionFilterName.sdkUnknown(rawValue)
    }
}

extension ScheduledActionNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledActionNotFoundFault(message: \(String(describing: message)))"}
}

extension ScheduledActionNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ScheduledActionNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The scheduled action cannot be found. </p>
public struct ScheduledActionNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ScheduledActionNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScheduledActionQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledActionQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ScheduledActionQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ScheduledActionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for scheduled actions exceeded. </p>
public struct ScheduledActionQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ScheduledActionQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ScheduledActionState {
    case active
    case disabled
    case sdkUnknown(String)
}

extension ScheduledActionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScheduledActionState] {
        return [
            .active,
            .disabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .disabled: return "DISABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScheduledActionState(rawValue: rawValue) ?? ScheduledActionState.sdkUnknown(rawValue)
    }
}

extension ScheduledActionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pauseCluster = "PauseCluster"
        case resizeCluster = "ResizeCluster"
        case resumeCluster = "ResumeCluster"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let pauseCluster = pauseCluster {
            try container.encode(pauseCluster, forKey: Key("PauseCluster"))
        }
        if let resizeCluster = resizeCluster {
            try container.encode(resizeCluster, forKey: Key("ResizeCluster"))
        }
        if let resumeCluster = resumeCluster {
            try container.encode(resumeCluster, forKey: Key("ResumeCluster"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resizeClusterDecoded = try containerValues.decodeIfPresent(ResizeClusterMessage.self, forKey: .resizeCluster)
        resizeCluster = resizeClusterDecoded
        let pauseClusterDecoded = try containerValues.decodeIfPresent(PauseClusterMessage.self, forKey: .pauseCluster)
        pauseCluster = pauseClusterDecoded
        let resumeClusterDecoded = try containerValues.decodeIfPresent(ResumeClusterMessage.self, forKey: .resumeCluster)
        resumeCluster = resumeClusterDecoded
    }
}

extension ScheduledActionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledActionType(pauseCluster: \(String(describing: pauseCluster)), resizeCluster: \(String(describing: resizeCluster)), resumeCluster: \(String(describing: resumeCluster)))"}
}

/// <p>The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. </p>
public struct ScheduledActionType: Equatable {
    /// <p>An action that runs a <code>PauseCluster</code> API operation. </p>
    public let pauseCluster: PauseClusterMessage?
    /// <p>An action that runs a <code>ResizeCluster</code> API operation. </p>
    public let resizeCluster: ResizeClusterMessage?
    /// <p>An action that runs a <code>ResumeCluster</code> API operation. </p>
    public let resumeCluster: ResumeClusterMessage?

    public init (
        pauseCluster: PauseClusterMessage? = nil,
        resizeCluster: ResizeClusterMessage? = nil,
        resumeCluster: ResumeClusterMessage? = nil
    )
    {
        self.pauseCluster = pauseCluster
        self.resizeCluster = resizeCluster
        self.resumeCluster = resumeCluster
    }
}

extension ScheduledActionTypeUnsupportedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledActionTypeUnsupportedFault(message: \(String(describing: message)))"}
}

extension ScheduledActionTypeUnsupportedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ScheduledActionTypeUnsupportedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action type specified for a scheduled action is not supported. </p>
public struct ScheduledActionTypeUnsupportedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ScheduledActionTypeUnsupportedFaultBody: Equatable {
    public let message: String?
}

extension ScheduledActionTypeUnsupportedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ScheduledActionTypeValues {
    case pauseCluster
    case resizeCluster
    case resumeCluster
    case sdkUnknown(String)
}

extension ScheduledActionTypeValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScheduledActionTypeValues] {
        return [
            .pauseCluster,
            .resizeCluster,
            .resumeCluster,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pauseCluster: return "PauseCluster"
        case .resizeCluster: return "ResizeCluster"
        case .resumeCluster: return "ResumeCluster"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScheduledActionTypeValues(rawValue: rawValue) ?? ScheduledActionTypeValues.sdkUnknown(rawValue)
    }
}

extension Snapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountsWithRestoreAccess = "AccountsWithRestoreAccess"
        case actualIncrementalBackupSizeInMegaBytes = "ActualIncrementalBackupSizeInMegaBytes"
        case availabilityZone = "AvailabilityZone"
        case backupProgressInMegaBytes = "BackupProgressInMegaBytes"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterVersion = "ClusterVersion"
        case currentBackupRateInMegaBytesPerSecond = "CurrentBackupRateInMegaBytesPerSecond"
        case dBName = "DBName"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case encrypted = "Encrypted"
        case encryptedWithHSM = "EncryptedWithHSM"
        case engineFullVersion = "EngineFullVersion"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case estimatedSecondsToCompletion = "EstimatedSecondsToCompletion"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRemainingDays = "ManualSnapshotRemainingDays"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case ownerAccount = "OwnerAccount"
        case port = "Port"
        case restorableNodeTypes = "RestorableNodeTypes"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotIdentifier = "SnapshotIdentifier"
        case snapshotRetentionStartTime = "SnapshotRetentionStartTime"
        case snapshotType = "SnapshotType"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case tags = "Tags"
        case totalBackupSizeInMegaBytes = "TotalBackupSizeInMegaBytes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountsWithRestoreAccess = accountsWithRestoreAccess {
            var accountsWithRestoreAccessContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AccountsWithRestoreAccess"))
            for (index0, accountwithrestoreaccess0) in accountsWithRestoreAccess.enumerated() {
                try accountsWithRestoreAccessContainer.encode(accountwithrestoreaccess0, forKey: Key("AccountWithRestoreAccess.\(index0.advanced(by: 1))"))
            }
        }
        if actualIncrementalBackupSizeInMegaBytes != 0.0 {
            try container.encode(String(actualIncrementalBackupSizeInMegaBytes), forKey: Key("ActualIncrementalBackupSizeInMegaBytes"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if backupProgressInMegaBytes != 0.0 {
            try container.encode(String(backupProgressInMegaBytes), forKey: Key("BackupProgressInMegaBytes"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: Key("ClusterVersion"))
        }
        if currentBackupRateInMegaBytesPerSecond != 0.0 {
            try container.encode(String(currentBackupRateInMegaBytesPerSecond), forKey: Key("CurrentBackupRateInMegaBytesPerSecond"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if elapsedTimeInSeconds != 0 {
            try container.encode(elapsedTimeInSeconds, forKey: Key("ElapsedTimeInSeconds"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: Key("Encrypted"))
        }
        if encryptedWithHSM != false {
            try container.encode(encryptedWithHSM, forKey: Key("EncryptedWithHSM"))
        }
        if let engineFullVersion = engineFullVersion {
            try container.encode(engineFullVersion, forKey: Key("EngineFullVersion"))
        }
        if enhancedVpcRouting != false {
            try container.encode(enhancedVpcRouting, forKey: Key("EnhancedVpcRouting"))
        }
        if estimatedSecondsToCompletion != 0 {
            try container.encode(estimatedSecondsToCompletion, forKey: Key("EstimatedSecondsToCompletion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRemainingDays = manualSnapshotRemainingDays {
            try container.encode(manualSnapshotRemainingDays, forKey: Key("ManualSnapshotRemainingDays"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: Key("NumberOfNodes"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: Key("OwnerAccount"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let restorableNodeTypes = restorableNodeTypes {
            var restorableNodeTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RestorableNodeTypes"))
            for (index0, string0) in restorableNodeTypes.enumerated() {
                try restorableNodeTypesContainer.encode(string0, forKey: Key("NodeType.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: Key("snapshotCreateTime"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let snapshotRetentionStartTime = snapshotRetentionStartTime {
            try container.encode(TimestampWrapper(snapshotRetentionStartTime, format: .dateTime), forKey: Key("snapshotRetentionStartTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        if let sourceRegion = sourceRegion {
            try container.encode(sourceRegion, forKey: Key("SourceRegion"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if totalBackupSizeInMegaBytes != 0.0 {
            try container.encode(String(totalBackupSizeInMegaBytes), forKey: Key("TotalBackupSizeInMegaBytes"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let engineFullVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineFullVersion)
        engineFullVersion = engineFullVersionDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedWithHSMDecoded = try containerValues.decode(Bool.self, forKey: .encryptedWithHSM)
        encryptedWithHSM = encryptedWithHSMDecoded
        if containerValues.contains(.accountsWithRestoreAccess) {
            struct KeyVal0{struct AccountWithRestoreAccess{}}
            let accountsWithRestoreAccessWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountWithRestoreAccess>.CodingKeys.self, forKey: .accountsWithRestoreAccess)
            if let accountsWithRestoreAccessWrappedContainer = accountsWithRestoreAccessWrappedContainer {
                let accountsWithRestoreAccessContainer = try accountsWithRestoreAccessWrappedContainer.decodeIfPresent([AccountWithRestoreAccess].self, forKey: .member)
                var accountsWithRestoreAccessBuffer:[AccountWithRestoreAccess]? = nil
                if let accountsWithRestoreAccessContainer = accountsWithRestoreAccessContainer {
                    accountsWithRestoreAccessBuffer = [AccountWithRestoreAccess]()
                    for structureContainer0 in accountsWithRestoreAccessContainer {
                        accountsWithRestoreAccessBuffer?.append(structureContainer0)
                    }
                }
                accountsWithRestoreAccess = accountsWithRestoreAccessBuffer
            } else {
                accountsWithRestoreAccess = []
            }
        } else {
            accountsWithRestoreAccess = nil
        }
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let actualIncrementalBackupSizeInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .actualIncrementalBackupSizeInMegaBytes)
        actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytesDecoded
        let backupProgressInMegaBytesDecoded = try containerValues.decode(Double.self, forKey: .backupProgressInMegaBytes)
        backupProgressInMegaBytes = backupProgressInMegaBytesDecoded
        let currentBackupRateInMegaBytesPerSecondDecoded = try containerValues.decode(Double.self, forKey: .currentBackupRateInMegaBytesPerSecond)
        currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecondDecoded
        let estimatedSecondsToCompletionDecoded = try containerValues.decode(Int.self, forKey: .estimatedSecondsToCompletion)
        estimatedSecondsToCompletion = estimatedSecondsToCompletionDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.restorableNodeTypes) {
            struct KeyVal0{struct NodeType{}}
            let restorableNodeTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeType>.CodingKeys.self, forKey: .restorableNodeTypes)
            if let restorableNodeTypesWrappedContainer = restorableNodeTypesWrappedContainer {
                let restorableNodeTypesContainer = try restorableNodeTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var restorableNodeTypesBuffer:[String]? = nil
                if let restorableNodeTypesContainer = restorableNodeTypesContainer {
                    restorableNodeTypesBuffer = [String]()
                    for stringContainer0 in restorableNodeTypesContainer {
                        restorableNodeTypesBuffer?.append(stringContainer0)
                    }
                }
                restorableNodeTypes = restorableNodeTypesBuffer
            } else {
                restorableNodeTypes = []
            }
        } else {
            restorableNodeTypes = nil
        }
        let enhancedVpcRoutingDecoded = try containerValues.decode(Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let manualSnapshotRemainingDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .manualSnapshotRemainingDays)
        manualSnapshotRemainingDays = manualSnapshotRemainingDaysDecoded
        let snapshotRetentionStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotRetentionStartTime)
        var snapshotRetentionStartTimeBuffer:Date? = nil
        if let snapshotRetentionStartTimeDecoded = snapshotRetentionStartTimeDecoded {
            snapshotRetentionStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotRetentionStartTimeDecoded, format: .dateTime)
        }
        snapshotRetentionStartTime = snapshotRetentionStartTimeBuffer
    }
}

extension Snapshot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Snapshot(accountsWithRestoreAccess: \(String(describing: accountsWithRestoreAccess)), actualIncrementalBackupSizeInMegaBytes: \(String(describing: actualIncrementalBackupSizeInMegaBytes)), availabilityZone: \(String(describing: availabilityZone)), backupProgressInMegaBytes: \(String(describing: backupProgressInMegaBytes)), clusterCreateTime: \(String(describing: clusterCreateTime)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterVersion: \(String(describing: clusterVersion)), currentBackupRateInMegaBytesPerSecond: \(String(describing: currentBackupRateInMegaBytesPerSecond)), dBName: \(String(describing: dBName)), elapsedTimeInSeconds: \(String(describing: elapsedTimeInSeconds)), encrypted: \(String(describing: encrypted)), encryptedWithHSM: \(String(describing: encryptedWithHSM)), engineFullVersion: \(String(describing: engineFullVersion)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), estimatedSecondsToCompletion: \(String(describing: estimatedSecondsToCompletion)), kmsKeyId: \(String(describing: kmsKeyId)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), manualSnapshotRemainingDays: \(String(describing: manualSnapshotRemainingDays)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), masterUsername: \(String(describing: masterUsername)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), ownerAccount: \(String(describing: ownerAccount)), port: \(String(describing: port)), restorableNodeTypes: \(String(describing: restorableNodeTypes)), snapshotCreateTime: \(String(describing: snapshotCreateTime)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), snapshotRetentionStartTime: \(String(describing: snapshotRetentionStartTime)), snapshotType: \(String(describing: snapshotType)), sourceRegion: \(String(describing: sourceRegion)), status: \(String(describing: status)), tags: \(String(describing: tags)), totalBackupSizeInMegaBytes: \(String(describing: totalBackupSizeInMegaBytes)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Describes a snapshot.</p>
public struct Snapshot: Equatable {
    /// <p>A list of the AWS customer accounts authorized to restore the snapshot. Returns
    ///                 <code>null</code> if no accounts are authorized. Visible only to the snapshot owner.
    ///         </p>
    public let accountsWithRestoreAccess: [AccountWithRestoreAccess]?
    /// <p>The size of the incremental backup.</p>
    public let actualIncrementalBackupSizeInMegaBytes: Double
    /// <p>The Availability Zone in which the cluster was created.</p>
    public let availabilityZone: String?
    /// <p>The number of megabytes that have been transferred to the snapshot
    ///             backup.</p>
    public let backupProgressInMegaBytes: Double
    /// <p>The time (UTC) when the cluster was originally created.</p>
    public let clusterCreateTime: Date?
    /// <p>The identifier of the cluster for which the snapshot was taken.</p>
    public let clusterIdentifier: String?
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    public let clusterVersion: String?
    /// <p>The number of megabytes per second being transferred to the snapshot backup.
    ///             Returns <code>0</code> for a completed backup. </p>
    public let currentBackupRateInMegaBytesPerSecond: Double
    /// <p>The name of the database that was created when the cluster was created.</p>
    public let dBName: String?
    /// <p>The amount of time an in-progress snapshot backup has been running, or the amount
    ///             of time it took a completed backup to finish.</p>
    public let elapsedTimeInSeconds: Int
    /// <p>If <code>true</code>, the data in the snapshot is encrypted at rest.</p>
    public let encrypted: Bool
    /// <p>A boolean that indicates whether the snapshot data is encrypted using the HSM keys
    ///             of the source cluster. <code>true</code> indicates that the data is encrypted using HSM
    ///             keys.</p>
    public let encryptedWithHSM: Bool
    /// <p>The cluster version of the cluster used to create the snapshot. For example, 1.0.15503. </p>
    public let engineFullVersion: String?
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    ///             enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    ///             VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    ///             the Amazon Redshift Cluster Management Guide.</p>
    ///         <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    ///         <p>Default: false</p>
    public let enhancedVpcRouting: Bool
    /// <p>The estimate of the time remaining before the snapshot backup will complete.
    ///             Returns <code>0</code> for a completed backup. </p>
    public let estimatedSecondsToCompletion: Int
    /// <p>The AWS Key Management Service (KMS) key ID of the encryption key that was used to
    ///             encrypt data in the cluster from which the snapshot was taken.</p>
    public let kmsKeyId: String?
    /// <p>The name of the maintenance track for the snapshot.</p>
    public let maintenanceTrackName: String?
    /// <p>The number of days until a manual snapshot will pass its retention period.</p>
    public let manualSnapshotRemainingDays: Int?
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    ///             snapshot is retained indefinitely. </p>
    ///
    ///         <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    public let manualSnapshotRetentionPeriod: Int?
    /// <p>The master user name for the cluster.</p>
    public let masterUsername: String?
    /// <p>The node type of the nodes in the cluster.</p>
    public let nodeType: String?
    /// <p>The number of nodes in the cluster.</p>
    public let numberOfNodes: Int
    /// <p>For manual snapshots, the AWS customer account used to create or copy the snapshot.
    ///             For automatic snapshots, the owner of the cluster. The owner can perform all snapshot
    ///             actions, such as sharing a manual snapshot.</p>
    public let ownerAccount: String?
    /// <p>The port that the cluster is listening on.</p>
    public let port: Int
    /// <p>The list of node types that this cluster snapshot is able to restore
    ///             into.</p>
    public let restorableNodeTypes: [String]?
    /// <p>The time (in UTC format) when Amazon Redshift began the snapshot. A snapshot contains a
    ///             copy of the cluster data as of this exact time.</p>
    public let snapshotCreateTime: Date?
    /// <p>The snapshot identifier that is provided in the request.</p>
    public let snapshotIdentifier: String?
    /// <p>A timestamp representing the start of the retention period for the snapshot.</p>
    public let snapshotRetentionStartTime: Date?
    /// <p>The snapshot type. Snapshots created using <a>CreateClusterSnapshot</a>
    ///             and <a>CopyClusterSnapshot</a> are of type "manual". </p>
    public let snapshotType: String?
    /// <p>The source region from which the snapshot was copied.</p>
    public let sourceRegion: String?
    /// <p>The snapshot status. The value of the status depends on the API operation used: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <a>CreateClusterSnapshot</a> and <a>CopyClusterSnapshot</a> returns status as "creating". </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <a>DescribeClusterSnapshots</a> returns status as "creating",
    ///                     "available", "final snapshot", or "failed".</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <a>DeleteClusterSnapshot</a> returns status as "deleted".</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The list of tags for the cluster snapshot.</p>
    public let tags: [Tag]?
    /// <p>The size of the complete set of backup data that would be used to restore the
    ///             cluster.</p>
    public let totalBackupSizeInMegaBytes: Double
    /// <p>The VPC identifier of the cluster if the snapshot is from a cluster in a VPC.
    ///             Otherwise, this field is not in the output.</p>
    public let vpcId: String?

    public init (
        accountsWithRestoreAccess: [AccountWithRestoreAccess]? = nil,
        actualIncrementalBackupSizeInMegaBytes: Double = 0.0,
        availabilityZone: String? = nil,
        backupProgressInMegaBytes: Double = 0.0,
        clusterCreateTime: Date? = nil,
        clusterIdentifier: String? = nil,
        clusterVersion: String? = nil,
        currentBackupRateInMegaBytesPerSecond: Double = 0.0,
        dBName: String? = nil,
        elapsedTimeInSeconds: Int = 0,
        encrypted: Bool = false,
        encryptedWithHSM: Bool = false,
        engineFullVersion: String? = nil,
        enhancedVpcRouting: Bool = false,
        estimatedSecondsToCompletion: Int = 0,
        kmsKeyId: String? = nil,
        maintenanceTrackName: String? = nil,
        manualSnapshotRemainingDays: Int? = nil,
        manualSnapshotRetentionPeriod: Int? = nil,
        masterUsername: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int = 0,
        ownerAccount: String? = nil,
        port: Int = 0,
        restorableNodeTypes: [String]? = nil,
        snapshotCreateTime: Date? = nil,
        snapshotIdentifier: String? = nil,
        snapshotRetentionStartTime: Date? = nil,
        snapshotType: String? = nil,
        sourceRegion: String? = nil,
        status: String? = nil,
        tags: [Tag]? = nil,
        totalBackupSizeInMegaBytes: Double = 0.0,
        vpcId: String? = nil
    )
    {
        self.accountsWithRestoreAccess = accountsWithRestoreAccess
        self.actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytes
        self.availabilityZone = availabilityZone
        self.backupProgressInMegaBytes = backupProgressInMegaBytes
        self.clusterCreateTime = clusterCreateTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterVersion = clusterVersion
        self.currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecond
        self.dBName = dBName
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.encrypted = encrypted
        self.encryptedWithHSM = encryptedWithHSM
        self.engineFullVersion = engineFullVersion
        self.enhancedVpcRouting = enhancedVpcRouting
        self.estimatedSecondsToCompletion = estimatedSecondsToCompletion
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRemainingDays = manualSnapshotRemainingDays
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.masterUsername = masterUsername
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.ownerAccount = ownerAccount
        self.port = port
        self.restorableNodeTypes = restorableNodeTypes
        self.snapshotCreateTime = snapshotCreateTime
        self.snapshotIdentifier = snapshotIdentifier
        self.snapshotRetentionStartTime = snapshotRetentionStartTime
        self.snapshotType = snapshotType
        self.sourceRegion = sourceRegion
        self.status = status
        self.tags = tags
        self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
        self.vpcId = vpcId
    }
}

public enum SnapshotAttributeToSortBy {
    case createTime
    case sourceType
    case totalSize
    case sdkUnknown(String)
}

extension SnapshotAttributeToSortBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SnapshotAttributeToSortBy] {
        return [
            .createTime,
            .sourceType,
            .totalSize,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createTime: return "CREATE_TIME"
        case .sourceType: return "SOURCE_TYPE"
        case .totalSize: return "TOTAL_SIZE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SnapshotAttributeToSortBy(rawValue: rawValue) ?? SnapshotAttributeToSortBy.sdkUnknown(rawValue)
    }
}

extension SnapshotCopyAlreadyDisabledFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotCopyAlreadyDisabledFault(message: \(String(describing: message)))"}
}

extension SnapshotCopyAlreadyDisabledFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotCopyAlreadyDisabledFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster already has cross-region snapshot copy disabled.</p>
public struct SnapshotCopyAlreadyDisabledFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyAlreadyDisabledFaultBody: Equatable {
    public let message: String?
}

extension SnapshotCopyAlreadyDisabledFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyAlreadyEnabledFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotCopyAlreadyEnabledFault(message: \(String(describing: message)))"}
}

extension SnapshotCopyAlreadyEnabledFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotCopyAlreadyEnabledFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster already has cross-region snapshot copy enabled.</p>
public struct SnapshotCopyAlreadyEnabledFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyAlreadyEnabledFaultBody: Equatable {
    public let message: String?
}

extension SnapshotCopyAlreadyEnabledFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyDisabledFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotCopyDisabledFault(message: \(String(describing: message)))"}
}

extension SnapshotCopyDisabledFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotCopyDisabledFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cross-region snapshot copy was temporarily disabled. Try your request
///             again.</p>
public struct SnapshotCopyDisabledFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyDisabledFaultBody: Equatable {
    public let message: String?
}

extension SnapshotCopyDisabledFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyGrant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case snapshotCopyGrantName = "SnapshotCopyGrantName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try container.encode(snapshotCopyGrantName, forKey: Key("SnapshotCopyGrantName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyGrantNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCopyGrantName)
        snapshotCopyGrantName = snapshotCopyGrantNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension SnapshotCopyGrant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotCopyGrant(kmsKeyId: \(String(describing: kmsKeyId)), snapshotCopyGrantName: \(String(describing: snapshotCopyGrantName)), tags: \(String(describing: tags)))"}
}

/// <p>The snapshot copy grant that grants Amazon Redshift permission to encrypt copied
///             snapshots with the specified customer master key (CMK) from AWS KMS in the destination
///             region.</p>
///         <p>
/// For more information about managing snapshot copy grants, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
public struct SnapshotCopyGrant: Equatable {
    /// <p>The unique identifier of the customer master key (CMK) in AWS KMS to which
    ///             Amazon Redshift is granted permission.</p>
    public let kmsKeyId: String?
    /// <p>The name of the snapshot copy grant.</p>
    public let snapshotCopyGrantName: String?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?

    public init (
        kmsKeyId: String? = nil,
        snapshotCopyGrantName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.snapshotCopyGrantName = snapshotCopyGrantName
        self.tags = tags
    }
}

extension SnapshotCopyGrantAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotCopyGrantAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension SnapshotCopyGrantAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotCopyGrantAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The snapshot copy grant can't be created because a grant with the same name already
///             exists.</p>
public struct SnapshotCopyGrantAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyGrantAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension SnapshotCopyGrantAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyGrantNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotCopyGrantNotFoundFault(message: \(String(describing: message)))"}
}

extension SnapshotCopyGrantNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotCopyGrantNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified snapshot copy grant can't be found. Make sure that the name is typed
///             correctly and that the grant exists in the destination region.</p>
public struct SnapshotCopyGrantNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyGrantNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SnapshotCopyGrantNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotCopyGrantQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotCopyGrantQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SnapshotCopyGrantQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotCopyGrantQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS account has exceeded the maximum number of snapshot copy grants in this
///             region.</p>
public struct SnapshotCopyGrantQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotCopyGrantQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SnapshotCopyGrantQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotErrorMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
        case snapshotClusterIdentifier = "SnapshotClusterIdentifier"
        case snapshotIdentifier = "SnapshotIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let failureCode = failureCode {
            try container.encode(failureCode, forKey: Key("FailureCode"))
        }
        if let failureReason = failureReason {
            try container.encode(failureReason, forKey: Key("FailureReason"))
        }
        if let snapshotClusterIdentifier = snapshotClusterIdentifier {
            try container.encode(snapshotClusterIdentifier, forKey: Key("SnapshotClusterIdentifier"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let snapshotClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotClusterIdentifier)
        snapshotClusterIdentifier = snapshotClusterIdentifierDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension SnapshotErrorMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotErrorMessage(failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), snapshotClusterIdentifier: \(String(describing: snapshotClusterIdentifier)), snapshotIdentifier: \(String(describing: snapshotIdentifier)))"}
}

/// <p>Describes the errors returned by a snapshot.</p>
public struct SnapshotErrorMessage: Equatable {
    /// <p>The failure code for the error.</p>
    public let failureCode: String?
    /// <p>The text message describing the error.</p>
    public let failureReason: String?
    /// <p>A unique identifier for the cluster.</p>
    public let snapshotClusterIdentifier: String?
    /// <p>A unique identifier for the snapshot returning the error.</p>
    public let snapshotIdentifier: String?

    public init (
        failureCode: String? = nil,
        failureReason: String? = nil,
        snapshotClusterIdentifier: String? = nil,
        snapshotIdentifier: String? = nil
    )
    {
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.snapshotClusterIdentifier = snapshotClusterIdentifier
        self.snapshotIdentifier = snapshotIdentifier
    }
}

extension SnapshotSchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedClusterCount = "AssociatedClusterCount"
        case associatedClusters = "AssociatedClusters"
        case nextInvocations = "NextInvocations"
        case scheduleDefinitions = "ScheduleDefinitions"
        case scheduleDescription = "ScheduleDescription"
        case scheduleIdentifier = "ScheduleIdentifier"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let associatedClusterCount = associatedClusterCount {
            try container.encode(associatedClusterCount, forKey: Key("AssociatedClusterCount"))
        }
        if let associatedClusters = associatedClusters {
            var associatedClustersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AssociatedClusters"))
            for (index0, clusterassociatedtoschedule0) in associatedClusters.enumerated() {
                try associatedClustersContainer.encode(clusterassociatedtoschedule0, forKey: Key("ClusterAssociatedToSchedule.\(index0.advanced(by: 1))"))
            }
        }
        if let nextInvocations = nextInvocations {
            var nextInvocationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NextInvocations"))
            for (index0, tstamp0) in nextInvocations.enumerated() {
                try nextInvocationsContainer.encode(TimestampWrapper(tstamp0, format: .dateTime), forKey: Key("SnapshotTime.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleDefinitions = scheduleDefinitions {
            var scheduleDefinitionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ScheduleDefinitions"))
            for (index0, string0) in scheduleDefinitions.enumerated() {
                try scheduleDefinitionsContainer.encode(string0, forKey: Key("ScheduleDefinition.\(index0.advanced(by: 1))"))
            }
        }
        if let scheduleDescription = scheduleDescription {
            try container.encode(scheduleDescription, forKey: Key("ScheduleDescription"))
        }
        if let scheduleIdentifier = scheduleIdentifier {
            try container.encode(scheduleIdentifier, forKey: Key("ScheduleIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.scheduleDefinitions) {
            struct KeyVal0{struct ScheduleDefinition{}}
            let scheduleDefinitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ScheduleDefinition>.CodingKeys.self, forKey: .scheduleDefinitions)
            if let scheduleDefinitionsWrappedContainer = scheduleDefinitionsWrappedContainer {
                let scheduleDefinitionsContainer = try scheduleDefinitionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var scheduleDefinitionsBuffer:[String]? = nil
                if let scheduleDefinitionsContainer = scheduleDefinitionsContainer {
                    scheduleDefinitionsBuffer = [String]()
                    for stringContainer0 in scheduleDefinitionsContainer {
                        scheduleDefinitionsBuffer?.append(stringContainer0)
                    }
                }
                scheduleDefinitions = scheduleDefinitionsBuffer
            } else {
                scheduleDefinitions = []
            }
        } else {
            scheduleDefinitions = nil
        }
        let scheduleIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleIdentifier)
        scheduleIdentifier = scheduleIdentifierDecoded
        let scheduleDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleDescription)
        scheduleDescription = scheduleDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.nextInvocations) {
            struct KeyVal0{struct SnapshotTime{}}
            let nextInvocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotTime>.CodingKeys.self, forKey: .nextInvocations)
            if let nextInvocationsWrappedContainer = nextInvocationsWrappedContainer {
                let nextInvocationsContainer = try nextInvocationsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var nextInvocationsBuffer:[Date]? = nil
                if let nextInvocationsContainer = nextInvocationsContainer {
                    nextInvocationsBuffer = [Date]()
                    for timestampContainer0 in nextInvocationsContainer {
                        try nextInvocationsBuffer?.append(TimestampWrapperDecoder.parseDateStringValue(timestampContainer0, format: .dateTime))
                    }
                }
                nextInvocations = nextInvocationsBuffer
            } else {
                nextInvocations = []
            }
        } else {
            nextInvocations = nil
        }
        let associatedClusterCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .associatedClusterCount)
        associatedClusterCount = associatedClusterCountDecoded
        if containerValues.contains(.associatedClusters) {
            struct KeyVal0{struct ClusterAssociatedToSchedule{}}
            let associatedClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterAssociatedToSchedule>.CodingKeys.self, forKey: .associatedClusters)
            if let associatedClustersWrappedContainer = associatedClustersWrappedContainer {
                let associatedClustersContainer = try associatedClustersWrappedContainer.decodeIfPresent([ClusterAssociatedToSchedule].self, forKey: .member)
                var associatedClustersBuffer:[ClusterAssociatedToSchedule]? = nil
                if let associatedClustersContainer = associatedClustersContainer {
                    associatedClustersBuffer = [ClusterAssociatedToSchedule]()
                    for structureContainer0 in associatedClustersContainer {
                        associatedClustersBuffer?.append(structureContainer0)
                    }
                }
                associatedClusters = associatedClustersBuffer
            } else {
                associatedClusters = []
            }
        } else {
            associatedClusters = nil
        }
    }
}

extension SnapshotSchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotSchedule(associatedClusterCount: \(String(describing: associatedClusterCount)), associatedClusters: \(String(describing: associatedClusters)), nextInvocations: \(String(describing: nextInvocations)), scheduleDefinitions: \(String(describing: scheduleDefinitions)), scheduleDescription: \(String(describing: scheduleDescription)), scheduleIdentifier: \(String(describing: scheduleIdentifier)), tags: \(String(describing: tags)))"}
}

/// <p>Describes a snapshot schedule. You can set a regular interval for creating
///             snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
public struct SnapshotSchedule: Equatable {
    /// <p>The number of clusters associated with the schedule.</p>
    public let associatedClusterCount: Int?
    /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
    public let associatedClusters: [ClusterAssociatedToSchedule]?
    /// <p></p>
    public let nextInvocations: [Date]?
    /// <p>A list of ScheduleDefinitions.</p>
    public let scheduleDefinitions: [String]?
    /// <p>The description of the schedule.</p>
    public let scheduleDescription: String?
    /// <p>A unique identifier for the schedule.</p>
    public let scheduleIdentifier: String?
    /// <p>An optional set of tags describing the schedule.</p>
    public let tags: [Tag]?

    public init (
        associatedClusterCount: Int? = nil,
        associatedClusters: [ClusterAssociatedToSchedule]? = nil,
        nextInvocations: [Date]? = nil,
        scheduleDefinitions: [String]? = nil,
        scheduleDescription: String? = nil,
        scheduleIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.associatedClusterCount = associatedClusterCount
        self.associatedClusters = associatedClusters
        self.nextInvocations = nextInvocations
        self.scheduleDefinitions = scheduleDefinitions
        self.scheduleDescription = scheduleDescription
        self.scheduleIdentifier = scheduleIdentifier
        self.tags = tags
    }
}

extension SnapshotScheduleAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotScheduleAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension SnapshotScheduleAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotScheduleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified snapshot schedule already exists. </p>
public struct SnapshotScheduleAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension SnapshotScheduleAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotScheduleNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotScheduleNotFoundFault(message: \(String(describing: message)))"}
}

extension SnapshotScheduleNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotScheduleNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We could not find the specified snapshot schedule. </p>
public struct SnapshotScheduleNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SnapshotScheduleNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotScheduleQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotScheduleQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SnapshotScheduleQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotScheduleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the quota of snapshot schedules. </p>
public struct SnapshotScheduleQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SnapshotScheduleQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotScheduleUpdateInProgressFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotScheduleUpdateInProgressFault(message: \(String(describing: message)))"}
}

extension SnapshotScheduleUpdateInProgressFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotScheduleUpdateInProgressFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified snapshot schedule is already being updated.</p>
public struct SnapshotScheduleUpdateInProgressFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotScheduleUpdateInProgressFaultBody: Equatable {
    public let message: String?
}

extension SnapshotScheduleUpdateInProgressFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotSortingEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attribute = attribute {
            try container.encode(attribute, forKey: Key("Attribute"))
        }
        if let sortOrder = sortOrder {
            try container.encode(sortOrder, forKey: Key("SortOrder"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(SnapshotAttributeToSortBy.self, forKey: .attribute)
        attribute = attributeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortByOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension SnapshotSortingEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotSortingEntity(attribute: \(String(describing: attribute)), sortOrder: \(String(describing: sortOrder)))"}
}

/// <p>Describes a sorting entity</p>
public struct SnapshotSortingEntity: Equatable {
    /// <p>The category for sorting the snapshots.</p>
    public let attribute: SnapshotAttributeToSortBy?
    /// <p>The order for listing the attributes.</p>
    public let sortOrder: SortByOrder?

    public init (
        attribute: SnapshotAttributeToSortBy? = nil,
        sortOrder: SortByOrder? = nil
    )
    {
        self.attribute = attribute
        self.sortOrder = sortOrder
    }
}

public enum SortByOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortByOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortByOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASC"
        case .descending: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortByOrder(rawValue: rawValue) ?? SortByOrder.sdkUnknown(rawValue)
    }
}

extension SourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceNotFoundFault(message: \(String(describing: message)))"}
}

extension SourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon Redshift event source could not be found.</p>
public struct SourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SourceType {
    case cluster
    case clusterParameterGroup
    case clusterSecurityGroup
    case clusterSnapshot
    case scheduledAction
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .cluster,
            .clusterParameterGroup,
            .clusterSecurityGroup,
            .clusterSnapshot,
            .scheduledAction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cluster: return "cluster"
        case .clusterParameterGroup: return "cluster-parameter-group"
        case .clusterSecurityGroup: return "cluster-security-group"
        case .clusterSnapshot: return "cluster-snapshot"
        case .scheduledAction: return "scheduled-action"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

extension Subnet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try container.encode(subnetAvailabilityZone, forKey: Key("SubnetAvailabilityZone"))
        }
        if let subnetIdentifier = subnetIdentifier {
            try container.encode(subnetIdentifier, forKey: Key("SubnetIdentifier"))
        }
        if let subnetStatus = subnetStatus {
            try container.encode(subnetStatus, forKey: Key("SubnetStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension Subnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subnet(subnetAvailabilityZone: \(String(describing: subnetAvailabilityZone)), subnetIdentifier: \(String(describing: subnetIdentifier)), subnetStatus: \(String(describing: subnetStatus)))"}
}

/// <p>Describes a subnet.</p>
public struct Subnet: Equatable {
    /// <p></p>
    public let subnetAvailabilityZone: AvailabilityZone?
    /// <p>The identifier of the subnet.</p>
    public let subnetIdentifier: String?
    /// <p>The status of the subnet.</p>
    public let subnetStatus: String?

    public init (
        subnetAvailabilityZone: AvailabilityZone? = nil,
        subnetIdentifier: String? = nil,
        subnetStatus: String? = nil
    )
    {
        self.subnetAvailabilityZone = subnetAvailabilityZone
        self.subnetIdentifier = subnetIdentifier
        self.subnetStatus = subnetStatus
    }
}

extension SubnetAlreadyInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetAlreadyInUse(message: \(String(describing: message)))"}
}

extension SubnetAlreadyInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubnetAlreadyInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified subnet is already in use by another cluster.</p>
public struct SubnetAlreadyInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Equatable {
    public let message: String?
}

extension SubnetAlreadyInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionAlreadyExistFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionAlreadyExistFault(message: \(String(describing: message)))"}
}

extension SubscriptionAlreadyExistFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionAlreadyExistFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is already an existing event notification subscription with the specified
///             name.</p>
public struct SubscriptionAlreadyExistFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionAlreadyExistFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionAlreadyExistFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionCategoryNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionCategoryNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionCategoryNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionCategoryNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified for the event category was not one of the allowed values, or it
///             specified a category that does not apply to the specified source type. The allowed
///             values are Configuration, Management, Monitoring, and Security.</p>
public struct SubscriptionCategoryNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionCategoryNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionCategoryNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionEventIdNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionEventIdNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionEventIdNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionEventIdNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Redshift event with the specified event ID does not exist.</p>
public struct SubscriptionEventIdNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionEventIdNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionEventIdNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Redshift event notification subscription with the specified name does not
///             exist.</p>
public struct SubscriptionNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionSeverityNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionSeverityNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionSeverityNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionSeverityNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value specified for the event severity was not one of the allowed values, or it
///             specified a severity that does not apply to the specified source type. The allowed
///             values are ERROR and INFO.</p>
public struct SubscriptionSeverityNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionSeverityNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionSeverityNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportedOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operationName = "OperationName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let operationName = operationName {
            try container.encode(operationName, forKey: Key("OperationName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
    }
}

extension SupportedOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SupportedOperation(operationName: \(String(describing: operationName)))"}
}

/// <p>Describes the operations that are allowed on a maintenance track.</p>
public struct SupportedOperation: Equatable {
    /// <p>A list of the supported operations.</p>
    public let operationName: String?

    public init (
        operationName: String? = nil
    )
    {
        self.operationName = operationName
    }
}

extension SupportedPlatform: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SupportedPlatform: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SupportedPlatform(name: \(String(describing: name)))"}
}

/// <p>A list of supported platforms for orderable clusters.</p>
public struct SupportedPlatform: Equatable {
    /// <p></p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension TableLimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableLimitExceededFault(message: \(String(describing: message)))"}
}

extension TableLimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TableLimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of tables in the cluster exceeds the limit for the requested new cluster
///             node type. </p>
public struct TableLimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TableLimitExceededFaultBody: Equatable {
    public let message: String?
}

extension TableLimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TableRestoreNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableRestoreNotFoundFault(message: \(String(describing: message)))"}
}

extension TableRestoreNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TableRestoreNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified <code>TableRestoreRequestId</code> value was not found.</p>
public struct TableRestoreNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TableRestoreNotFoundFaultBody: Equatable {
    public let message: String?
}

extension TableRestoreNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TableRestoreStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case message = "Message"
        case newTableName = "NewTableName"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case requestTime = "RequestTime"
        case snapshotIdentifier = "SnapshotIdentifier"
        case sourceDatabaseName = "SourceDatabaseName"
        case sourceSchemaName = "SourceSchemaName"
        case sourceTableName = "SourceTableName"
        case status = "Status"
        case tableRestoreRequestId = "TableRestoreRequestId"
        case targetDatabaseName = "TargetDatabaseName"
        case targetSchemaName = "TargetSchemaName"
        case totalDataInMegaBytes = "TotalDataInMegaBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let newTableName = newTableName {
            try container.encode(newTableName, forKey: Key("NewTableName"))
        }
        if let progressInMegaBytes = progressInMegaBytes {
            try container.encode(progressInMegaBytes, forKey: Key("ProgressInMegaBytes"))
        }
        if let requestTime = requestTime {
            try container.encode(TimestampWrapper(requestTime, format: .dateTime), forKey: Key("requestTime"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let sourceDatabaseName = sourceDatabaseName {
            try container.encode(sourceDatabaseName, forKey: Key("SourceDatabaseName"))
        }
        if let sourceSchemaName = sourceSchemaName {
            try container.encode(sourceSchemaName, forKey: Key("SourceSchemaName"))
        }
        if let sourceTableName = sourceTableName {
            try container.encode(sourceTableName, forKey: Key("SourceTableName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tableRestoreRequestId = tableRestoreRequestId {
            try container.encode(tableRestoreRequestId, forKey: Key("TableRestoreRequestId"))
        }
        if let targetDatabaseName = targetDatabaseName {
            try container.encode(targetDatabaseName, forKey: Key("TargetDatabaseName"))
        }
        if let targetSchemaName = targetSchemaName {
            try container.encode(targetSchemaName, forKey: Key("TargetSchemaName"))
        }
        if let totalDataInMegaBytes = totalDataInMegaBytes {
            try container.encode(totalDataInMegaBytes, forKey: Key("TotalDataInMegaBytes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableRestoreRequestId)
        tableRestoreRequestId = tableRestoreRequestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TableRestoreStatusType.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestTime)
        var requestTimeBuffer:Date? = nil
        if let requestTimeDecoded = requestTimeDecoded {
            requestTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(requestTimeDecoded, format: .dateTime)
        }
        requestTime = requestTimeBuffer
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let totalDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalDataInMegaBytes)
        totalDataInMegaBytes = totalDataInMegaBytesDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
    }
}

extension TableRestoreStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableRestoreStatus(clusterIdentifier: \(String(describing: clusterIdentifier)), message: \(String(describing: message)), newTableName: \(String(describing: newTableName)), progressInMegaBytes: \(String(describing: progressInMegaBytes)), requestTime: \(String(describing: requestTime)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), sourceDatabaseName: \(String(describing: sourceDatabaseName)), sourceSchemaName: \(String(describing: sourceSchemaName)), sourceTableName: \(String(describing: sourceTableName)), status: \(String(describing: status)), tableRestoreRequestId: \(String(describing: tableRestoreRequestId)), targetDatabaseName: \(String(describing: targetDatabaseName)), targetSchemaName: \(String(describing: targetSchemaName)), totalDataInMegaBytes: \(String(describing: totalDataInMegaBytes)))"}
}

/// <p>Describes the status of a <a>RestoreTableFromClusterSnapshot</a>
///             operation.</p>
public struct TableRestoreStatus: Equatable {
    /// <p>The identifier of the Amazon Redshift cluster that the table is being restored
    ///             to.</p>
    public let clusterIdentifier: String?
    /// <p>A description of the status of the table restore request. Status values include
    ///                 <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
    ///                 <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
    public let message: String?
    /// <p>The name of the table to create as a result of the table restore request.</p>
    public let newTableName: String?
    /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
    public let progressInMegaBytes: Int?
    /// <p>The time that the table restore request was made, in Universal Coordinated Time
    ///             (UTC).</p>
    public let requestTime: Date?
    /// <p>The identifier of the snapshot that the table is being restored from.</p>
    public let snapshotIdentifier: String?
    /// <p>The name of the source database that contains the table being restored.</p>
    public let sourceDatabaseName: String?
    /// <p>The name of the source schema that contains the table being restored.</p>
    public let sourceSchemaName: String?
    /// <p>The name of the source table being restored.</p>
    public let sourceTableName: String?
    /// <p>A value that describes the current state of the table restore request.</p>
    ///         <p>Valid Values: <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
    ///                 <code>PENDING</code>, <code>IN_PROGRESS</code>
    ///         </p>
    public let status: TableRestoreStatusType?
    /// <p>The unique identifier for the table restore request.</p>
    public let tableRestoreRequestId: String?
    /// <p>The name of the database to restore the table to.</p>
    public let targetDatabaseName: String?
    /// <p>The name of the schema to restore the table to.</p>
    public let targetSchemaName: String?
    /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
    public let totalDataInMegaBytes: Int?

    public init (
        clusterIdentifier: String? = nil,
        message: String? = nil,
        newTableName: String? = nil,
        progressInMegaBytes: Int? = nil,
        requestTime: Date? = nil,
        snapshotIdentifier: String? = nil,
        sourceDatabaseName: String? = nil,
        sourceSchemaName: String? = nil,
        sourceTableName: String? = nil,
        status: TableRestoreStatusType? = nil,
        tableRestoreRequestId: String? = nil,
        targetDatabaseName: String? = nil,
        targetSchemaName: String? = nil,
        totalDataInMegaBytes: Int? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.message = message
        self.newTableName = newTableName
        self.progressInMegaBytes = progressInMegaBytes
        self.requestTime = requestTime
        self.snapshotIdentifier = snapshotIdentifier
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.status = status
        self.tableRestoreRequestId = tableRestoreRequestId
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
        self.totalDataInMegaBytes = totalDataInMegaBytes
    }
}

public enum TableRestoreStatusType {
    case canceled
    case failed
    case inProgress
    case pending
    case succeeded
    case sdkUnknown(String)
}

extension TableRestoreStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TableRestoreStatusType] {
        return [
            .canceled,
            .failed,
            .inProgress,
            .pending,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TableRestoreStatusType(rawValue: rawValue) ?? TableRestoreStatusType.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag consisting of a name/value pair for a resource.</p>
public struct Tag: Equatable {
    /// <p>The key, or name, for the resource tag.</p>
    public let key: String?
    /// <p>The value for the resource tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagLimitExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagLimitExceededFault(message: \(String(describing: message)))"}
}

extension TagLimitExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TagLimitExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the number of tags allowed.</p>
public struct TagLimitExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededFaultBody: Equatable {
    public let message: String?
}

extension TagLimitExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TaggedResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case tag = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let tag = tag {
            try container.encode(tag, forKey: Key("Tag"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagDecoded = try containerValues.decodeIfPresent(Tag.self, forKey: .tag)
        tag = tagDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension TaggedResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaggedResource(resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)), tag: \(String(describing: tag)))"}
}

/// <p>A tag and its associated resource.</p>
public struct TaggedResource: Equatable {
    /// <p>The Amazon Resource Name (ARN) with which the tag is associated, for example:
    ///                 <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>.</p>
    public let resourceName: String?
    /// <p>The type of resource with which the tag is associated. Valid resource types are: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cluster</p>
    ///             </li>
    ///             <li>
    ///                 <p>CIDR/IP</p>
    ///             </li>
    ///             <li>
    ///                 <p>EC2 security group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Snapshot</p>
    ///             </li>
    ///             <li>
    ///                 <p>Cluster security group</p>
    ///             </li>
    ///             <li>
    ///                 <p>Subnet group</p>
    ///             </li>
    ///             <li>
    ///                 <p>HSM connection</p>
    ///             </li>
    ///             <li>
    ///                 <p>HSM certificate</p>
    ///             </li>
    ///             <li>
    ///                 <p>Parameter group</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
    ///                 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Constructing an Amazon Redshift Amazon Resource Name (ARN)</a> in the
    ///             Amazon Redshift Cluster Management Guide. </p>
    public let resourceType: String?
    /// <p>The tag for the resource.</p>
    public let tag: Tag?

    public init (
        resourceName: String? = nil,
        resourceType: String? = nil,
        tag: Tag? = nil
    )
    {
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.tag = tag
    }
}

extension UnauthorizedOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedOperation(message: \(String(describing: message)))"}
}

extension UnauthorizedOperation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnauthorizedOperationBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your account is not authorized to perform the requested operation.</p>
public struct UnauthorizedOperation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedOperationBody: Equatable {
    public let message: String?
}

extension UnauthorizedOperationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedPartnerIntegrationFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedPartnerIntegrationFault(message: \(String(describing: message)))"}
}

extension UnauthorizedPartnerIntegrationFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnauthorizedPartnerIntegrationFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The partner integration is not authorized.</p>
public struct UnauthorizedPartnerIntegrationFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedPartnerIntegrationFaultBody: Equatable {
    public let message: String?
}

extension UnauthorizedPartnerIntegrationFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownSnapshotCopyRegionFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnknownSnapshotCopyRegionFault(message: \(String(describing: message)))"}
}

extension UnknownSnapshotCopyRegionFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnknownSnapshotCopyRegionFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified region is incorrect or does not exist.</p>
public struct UnknownSnapshotCopyRegionFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownSnapshotCopyRegionFaultBody: Equatable {
    public let message: String?
}

extension UnknownSnapshotCopyRegionFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationFault(message: \(String(describing: message)))"}
}

extension UnsupportedOperationFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnsupportedOperationFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation isn't supported.</p>
public struct UnsupportedOperationFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationFaultBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOptionFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOptionFault(message: \(String(describing: message)))"}
}

extension UnsupportedOptionFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnsupportedOptionFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A request option was specified that is not supported.</p>
public struct UnsupportedOptionFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOptionFaultBody: Equatable {
    public let message: String?
}

extension UnsupportedOptionFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdatePartnerStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePartnerStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartnerStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartnerStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartnerStatusInput>
    public typealias MOutput = OperationOutput<UpdatePartnerStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartnerStatusOutputError>
}

extension UpdatePartnerStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePartnerStatusInput(accountId: \(String(describing: accountId)), clusterIdentifier: \(String(describing: clusterIdentifier)), databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

extension UpdatePartnerStatusInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountId = accountId {
            try container.encode(accountId, forKey: Key("AccountId"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let partnerName = partnerName {
            try container.encode(partnerName, forKey: Key("PartnerName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusMessage = statusMessage {
            try container.encode(statusMessage, forKey: Key("StatusMessage"))
        }
        try container.encode("UpdatePartnerStatus", forKey:Key("Action"))
        try container.encode("2012-12-01", forKey:Key("Version"))
    }
}

public struct UpdatePartnerStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePartnerStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartnerStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartnerStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartnerStatusInput>
    public typealias MOutput = OperationOutput<UpdatePartnerStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartnerStatusOutputError>
}

public struct UpdatePartnerStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePartnerStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartnerStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartnerStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartnerStatusInput>
    public typealias MOutput = OperationOutput<UpdatePartnerStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartnerStatusOutputError>
}

public struct UpdatePartnerStatusInput: Equatable {
    /// <p>The AWS account ID that owns the cluster.</p>
    public let accountId: String?
    /// <p>The cluster identifier of the cluster whose partner integration status is being updated.</p>
    public let clusterIdentifier: String?
    /// <p>The name of the database whose partner integration status is being updated.</p>
    public let databaseName: String?
    /// <p>The name of the partner whose integration status is being updated.</p>
    public let partnerName: String?
    /// <p>The value of the updated status.</p>
    public let status: PartnerIntegrationStatus?
    /// <p>The status message provided by the partner.</p>
    public let statusMessage: String?

    public init (
        accountId: String? = nil,
        clusterIdentifier: String? = nil,
        databaseName: String? = nil,
        partnerName: String? = nil,
        status: PartnerIntegrationStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.accountId = accountId
        self.clusterIdentifier = clusterIdentifier
        self.databaseName = databaseName
        self.partnerName = partnerName
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension UpdatePartnerStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdatePartnerStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PartnerNotFoundFault" : self = .partnerNotFoundFault(try PartnerNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedPartnerIntegrationFault" : self = .unauthorizedPartnerIntegrationFault(try UnauthorizedPartnerIntegrationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePartnerStatusOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case partnerNotFoundFault(PartnerNotFoundFault)
    case unauthorizedPartnerIntegrationFault(UnauthorizedPartnerIntegrationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePartnerStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePartnerStatusOutputResponse(databaseName: \(String(describing: databaseName)), partnerName: \(String(describing: partnerName)))"}
}

extension UpdatePartnerStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePartnerStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.databaseName = output.databaseName
            self.partnerName = output.partnerName
        } else {
            self.databaseName = nil
            self.partnerName = nil
        }
    }
}

public struct UpdatePartnerStatusOutputResponse: Equatable {
    /// <p>The name of the database that receives data from the partner.</p>
    public let databaseName: String?
    /// <p>The name of the partner that is authorized to send data.</p>
    public let partnerName: String?

    public init (
        databaseName: String? = nil,
        partnerName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.partnerName = partnerName
    }
}

struct UpdatePartnerStatusOutputResponseBody: Equatable {
    public let databaseName: String?
    public let partnerName: String?
}

extension UpdatePartnerStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case partnerName = "PartnerName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdatePartnerStatusResult"))
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
    }
}

extension UpdateTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseVersion = "DatabaseVersion"
        case maintenanceTrackName = "MaintenanceTrackName"
        case supportedOperations = "SupportedOperations"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let databaseVersion = databaseVersion {
            try container.encode(databaseVersion, forKey: Key("DatabaseVersion"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: Key("MaintenanceTrackName"))
        }
        if let supportedOperations = supportedOperations {
            var supportedOperationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedOperations"))
            for (index0, supportedoperation0) in supportedOperations.enumerated() {
                try supportedOperationsContainer.encode(supportedoperation0, forKey: Key("SupportedOperation.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let databaseVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseVersion)
        databaseVersion = databaseVersionDecoded
        if containerValues.contains(.supportedOperations) {
            struct KeyVal0{struct SupportedOperation{}}
            let supportedOperationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SupportedOperation>.CodingKeys.self, forKey: .supportedOperations)
            if let supportedOperationsWrappedContainer = supportedOperationsWrappedContainer {
                let supportedOperationsContainer = try supportedOperationsWrappedContainer.decodeIfPresent([SupportedOperation].self, forKey: .member)
                var supportedOperationsBuffer:[SupportedOperation]? = nil
                if let supportedOperationsContainer = supportedOperationsContainer {
                    supportedOperationsBuffer = [SupportedOperation]()
                    for structureContainer0 in supportedOperationsContainer {
                        supportedOperationsBuffer?.append(structureContainer0)
                    }
                }
                supportedOperations = supportedOperationsBuffer
            } else {
                supportedOperations = []
            }
        } else {
            supportedOperations = nil
        }
    }
}

extension UpdateTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTarget(databaseVersion: \(String(describing: databaseVersion)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), supportedOperations: \(String(describing: supportedOperations)))"}
}

/// <p>A maintenance track that you can switch the current track to.</p>
public struct UpdateTarget: Equatable {
    /// <p>The cluster version for the new maintenance track.</p>
    public let databaseVersion: String?
    /// <p>The name of the new maintenance track.</p>
    public let maintenanceTrackName: String?
    /// <p>A list of operations supported by the maintenance track.</p>
    public let supportedOperations: [SupportedOperation]?

    public init (
        databaseVersion: String? = nil,
        maintenanceTrackName: String? = nil,
        supportedOperations: [SupportedOperation]? = nil
    )
    {
        self.databaseVersion = databaseVersion
        self.maintenanceTrackName = maintenanceTrackName
        self.supportedOperations = supportedOperations
    }
}

extension UsageLimit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amount = "Amount"
        case breachAction = "BreachAction"
        case clusterIdentifier = "ClusterIdentifier"
        case featureType = "FeatureType"
        case limitType = "LimitType"
        case period = "Period"
        case tags = "Tags"
        case usageLimitId = "UsageLimitId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if amount != 0 {
            try container.encode(amount, forKey: Key("Amount"))
        }
        if let breachAction = breachAction {
            try container.encode(breachAction, forKey: Key("BreachAction"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let featureType = featureType {
            try container.encode(featureType, forKey: Key("FeatureType"))
        }
        if let limitType = limitType {
            try container.encode(limitType, forKey: Key("LimitType"))
        }
        if let period = period {
            try container.encode(period, forKey: Key("Period"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let usageLimitId = usageLimitId {
            try container.encode(usageLimitId, forKey: Key("UsageLimitId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let featureTypeDecoded = try containerValues.decodeIfPresent(UsageLimitFeatureType.self, forKey: .featureType)
        featureType = featureTypeDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(UsageLimitLimitType.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let amountDecoded = try containerValues.decode(Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension UsageLimit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageLimit(amount: \(String(describing: amount)), breachAction: \(String(describing: breachAction)), clusterIdentifier: \(String(describing: clusterIdentifier)), featureType: \(String(describing: featureType)), limitType: \(String(describing: limitType)), period: \(String(describing: period)), tags: \(String(describing: tags)), usageLimitId: \(String(describing: usageLimitId)))"}
}

/// <p>Describes a usage limit object for a cluster. </p>
public struct UsageLimit: Equatable {
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
    public let amount: Int
    /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>log</b> - To log an event in a system table. The default is log.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>emit-metric</b> - To emit CloudWatch metrics.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>disable</b> - To disable the feature until the next usage period begins.</p>
    ///             </li>
    ///          </ul>
    public let breachAction: UsageLimitBreachAction?
    /// <p>The identifier of the cluster with a usage limit.</p>
    public let clusterIdentifier: String?
    /// <p>The Amazon Redshift feature to which the limit applies.</p>
    public let featureType: UsageLimitFeatureType?
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
    public let limitType: UsageLimitLimitType?
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
    public let period: UsageLimitPeriod?
    /// <p>A list of tag instances.</p>
    public let tags: [Tag]?
    /// <p>The identifier of the usage limit.</p>
    public let usageLimitId: String?

    public init (
        amount: Int = 0,
        breachAction: UsageLimitBreachAction? = nil,
        clusterIdentifier: String? = nil,
        featureType: UsageLimitFeatureType? = nil,
        limitType: UsageLimitLimitType? = nil,
        period: UsageLimitPeriod? = nil,
        tags: [Tag]? = nil,
        usageLimitId: String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.clusterIdentifier = clusterIdentifier
        self.featureType = featureType
        self.limitType = limitType
        self.period = period
        self.tags = tags
        self.usageLimitId = usageLimitId
    }
}

extension UsageLimitAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageLimitAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension UsageLimitAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UsageLimitAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage limit already exists. </p>
public struct UsageLimitAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UsageLimitAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension UsageLimitAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum UsageLimitBreachAction {
    case disable
    case emitMetric
    case log
    case sdkUnknown(String)
}

extension UsageLimitBreachAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageLimitBreachAction] {
        return [
            .disable,
            .emitMetric,
            .log,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disable: return "disable"
        case .emitMetric: return "emit-metric"
        case .log: return "log"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageLimitBreachAction(rawValue: rawValue) ?? UsageLimitBreachAction.sdkUnknown(rawValue)
    }
}

public enum UsageLimitFeatureType {
    case concurrencyScaling
    case spectrum
    case sdkUnknown(String)
}

extension UsageLimitFeatureType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageLimitFeatureType] {
        return [
            .concurrencyScaling,
            .spectrum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .concurrencyScaling: return "concurrency-scaling"
        case .spectrum: return "spectrum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageLimitFeatureType(rawValue: rawValue) ?? UsageLimitFeatureType.sdkUnknown(rawValue)
    }
}

public enum UsageLimitLimitType {
    case dataScanned
    case time
    case sdkUnknown(String)
}

extension UsageLimitLimitType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageLimitLimitType] {
        return [
            .dataScanned,
            .time,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dataScanned: return "data-scanned"
        case .time: return "time"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageLimitLimitType(rawValue: rawValue) ?? UsageLimitLimitType.sdkUnknown(rawValue)
    }
}

extension UsageLimitNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageLimitNotFoundFault(message: \(String(describing: message)))"}
}

extension UsageLimitNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UsageLimitNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage limit identifier can't be found.</p>
public struct UsageLimitNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UsageLimitNotFoundFaultBody: Equatable {
    public let message: String?
}

extension UsageLimitNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum UsageLimitPeriod {
    case daily
    case monthly
    case weekly
    case sdkUnknown(String)
}

extension UsageLimitPeriod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageLimitPeriod] {
        return [
            .daily,
            .monthly,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "daily"
        case .monthly: return "monthly"
        case .weekly: return "weekly"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageLimitPeriod(rawValue: rawValue) ?? UsageLimitPeriod.sdkUnknown(rawValue)
    }
}

extension VpcEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case networkInterfaces = "NetworkInterfaces"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NetworkInterfaces"))
            for (index0, networkinterface0) in networkInterfaces.enumerated() {
                try networkInterfacesContainer.encode(networkinterface0, forKey: Key("NetworkInterface.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcEndpointId = vpcEndpointId {
            try container.encode(vpcEndpointId, forKey: Key("VpcEndpointId"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct NetworkInterface{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NetworkInterface>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([NetworkInterface].self, forKey: .member)
                var networkInterfacesBuffer:[NetworkInterface]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [NetworkInterface]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
    }
}

extension VpcEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcEndpoint(networkInterfaces: \(String(describing: networkInterfaces)), vpcEndpointId: \(String(describing: vpcEndpointId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
public struct VpcEndpoint: Equatable {
    /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint. </p>
    public let networkInterfaces: [NetworkInterface]?
    /// <p>The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.</p>
    public let vpcEndpointId: String?
    /// <p>The VPC identifier that the endpoint is associated. </p>
    public let vpcId: String?

    public init (
        networkInterfaces: [NetworkInterface]? = nil,
        vpcEndpointId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.networkInterfaces = networkInterfaces
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

extension VpcSecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try container.encode(vpcSecurityGroupId, forKey: Key("VpcSecurityGroupId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension VpcSecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcSecurityGroupMembership(status: \(String(describing: status)), vpcSecurityGroupId: \(String(describing: vpcSecurityGroupId)))"}
}

/// <p>Describes the members of a VPC security group.</p>
public struct VpcSecurityGroupMembership: Equatable {
    /// <p>The status of the VPC security group.</p>
    public let status: String?
    /// <p>The identifier of the VPC security group.</p>
    public let vpcSecurityGroupId: String?

    public init (
        status: String? = nil,
        vpcSecurityGroupId: String? = nil
    )
    {
        self.status = status
        self.vpcSecurityGroupId = vpcSecurityGroupId
    }
}
