// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TableRestoreStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case message = "Message"
        case newTableName = "NewTableName"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case requestTime = "RequestTime"
        case snapshotIdentifier = "SnapshotIdentifier"
        case sourceDatabaseName = "SourceDatabaseName"
        case sourceSchemaName = "SourceSchemaName"
        case sourceTableName = "SourceTableName"
        case status = "Status"
        case tableRestoreRequestId = "TableRestoreRequestId"
        case targetDatabaseName = "TargetDatabaseName"
        case targetSchemaName = "TargetSchemaName"
        case totalDataInMegaBytes = "TotalDataInMegaBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: Key("ClusterIdentifier"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let newTableName = newTableName {
            try container.encode(newTableName, forKey: Key("NewTableName"))
        }
        if let progressInMegaBytes = progressInMegaBytes {
            try container.encode(progressInMegaBytes, forKey: Key("ProgressInMegaBytes"))
        }
        if let requestTime = requestTime {
            try container.encode(TimestampWrapper(requestTime, format: .dateTime), forKey: Key("requestTime"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let sourceDatabaseName = sourceDatabaseName {
            try container.encode(sourceDatabaseName, forKey: Key("SourceDatabaseName"))
        }
        if let sourceSchemaName = sourceSchemaName {
            try container.encode(sourceSchemaName, forKey: Key("SourceSchemaName"))
        }
        if let sourceTableName = sourceTableName {
            try container.encode(sourceTableName, forKey: Key("SourceTableName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tableRestoreRequestId = tableRestoreRequestId {
            try container.encode(tableRestoreRequestId, forKey: Key("TableRestoreRequestId"))
        }
        if let targetDatabaseName = targetDatabaseName {
            try container.encode(targetDatabaseName, forKey: Key("TargetDatabaseName"))
        }
        if let targetSchemaName = targetSchemaName {
            try container.encode(targetSchemaName, forKey: Key("TargetSchemaName"))
        }
        if let totalDataInMegaBytes = totalDataInMegaBytes {
            try container.encode(totalDataInMegaBytes, forKey: Key("TotalDataInMegaBytes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableRestoreRequestId)
        tableRestoreRequestId = tableRestoreRequestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TableRestoreStatusType.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestTime)
        var requestTimeBuffer:Date? = nil
        if let requestTimeDecoded = requestTimeDecoded {
            requestTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(requestTimeDecoded, format: .dateTime)
        }
        requestTime = requestTimeBuffer
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let totalDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalDataInMegaBytes)
        totalDataInMegaBytes = totalDataInMegaBytesDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
    }
}
