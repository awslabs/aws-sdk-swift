// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

extension IdentitystoreClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case country = "Country"
        case formatted = "Formatted"
        case locality = "Locality"
        case postalCode = "PostalCode"
        case primary = "Primary"
        case region = "Region"
        case streetAddress = "StreetAddress"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let formatted = self.formatted {
            try encodeContainer.encode(formatted, forKey: .formatted)
        }
        if let locality = self.locality {
            try encodeContainer.encode(locality, forKey: .locality)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if primary != false {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let streetAddress = self.streetAddress {
            try encodeContainer.encode(streetAddress, forKey: .streetAddress)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetAddress)
        streetAddress = streetAddressDecoded
        let localityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locality)
        locality = localityDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let formattedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatted)
        formatted = formattedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let primaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primary) ?? false
        primary = primaryDecoded
    }
}

extension IdentitystoreClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(country: \"CONTENT_REDACTED\", formatted: \"CONTENT_REDACTED\", locality: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", primary: \"CONTENT_REDACTED\", region: \"CONTENT_REDACTED\", streetAddress: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The address associated with the specified user.
    public struct Address: Swift.Equatable {
        /// The country of the address.
        public var country: Swift.String?
        /// A string containing a formatted version of the address for display.
        public var formatted: Swift.String?
        /// A string of the address locality.
        public var locality: Swift.String?
        /// The postal code of the address.
        public var postalCode: Swift.String?
        /// A Boolean value representing whether this is the primary address for the associated resource.
        public var primary: Swift.Bool
        /// The region of the address.
        public var region: Swift.String?
        /// The street of the address.
        public var streetAddress: Swift.String?
        /// A string representing the type of address. For example, "Home."
        public var type: Swift.String?

        public init (
            country: Swift.String? = nil,
            formatted: Swift.String? = nil,
            locality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            primary: Swift.Bool = false,
            region: Swift.String? = nil,
            streetAddress: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.country = country
            self.formatted = formatted
            self.locality = locality
            self.postalCode = postalCode
            self.primary = primary
            self.region = region
            self.streetAddress = streetAddress
            self.type = type
        }
    }

}

extension IdentitystoreClientTypes.AlternateIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalid = "ExternalId"
        case uniqueattribute = "UniqueAttribute"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .externalid(externalid):
                try container.encode(externalid, forKey: .externalid)
            case let .uniqueattribute(uniqueattribute):
                try container.encode(uniqueattribute, forKey: .uniqueattribute)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let externalidDecoded = try values.decodeIfPresent(IdentitystoreClientTypes.ExternalId.self, forKey: .externalid)
        if let externalid = externalidDecoded {
            self = .externalid(externalid)
            return
        }
        let uniqueattributeDecoded = try values.decodeIfPresent(IdentitystoreClientTypes.UniqueAttribute.self, forKey: .uniqueattribute)
        if let uniqueattribute = uniqueattributeDecoded {
            self = .uniqueattribute(uniqueattribute)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IdentitystoreClientTypes {
    /// A unique identifier for a user or group that is not the primary identifier. This value can be an identifier from an external identity provider (IdP) that is associated with the user, the group, or a unique attribute. For example, a unique GroupDisplayName.
    public enum AlternateIdentifier: Swift.Equatable {
        /// The identifier issued to this resource by an external identity provider.
        case externalid(IdentitystoreClientTypes.ExternalId)
        /// An entity attribute that's unique to a specific entity.
        case uniqueattribute(IdentitystoreClientTypes.UniqueAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension IdentitystoreClientTypes.AttributeOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePath = "AttributePath"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePath = self.attributePath {
            try encodeContainer.encode(attributePath, forKey: .attributePath)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributePath)
        attributePath = attributePathDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension IdentitystoreClientTypes {
    /// An operation that applies to the requested group. This operation might add, replace, or remove an attribute.
    public struct AttributeOperation: Swift.Equatable {
        /// A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.
        /// This member is required.
        public var attributePath: Swift.String?
        /// The value of the attribute. This is a Document type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.
        public var attributeValue: ClientRuntime.Document?

        public init (
            attributePath: Swift.String? = nil,
            attributeValue: ClientRuntime.Document? = nil
        )
        {
            self.attributePath = attributePath
            self.attributeValue = attributeValue
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.reason = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This request cannot be completed for one of the following reasons:
///
/// * Performing the requested operation would violate an existing uniqueness claim in the identity store. Resolve the conflict before retrying this request.
///
/// * The requested resource was being concurrently modified by another request.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// This request cannot be completed for one of the following reasons:
    ///
    /// * Performing the requested operation would violate an existing uniqueness claim in the identity store. Resolve the conflict before retrying this request.
    ///
    /// * The requested resource was being concurrently modified by another request.
    public var reason: IdentitystoreClientTypes.ConflictExceptionReason?
    /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: IdentitystoreClientTypes.ConflictExceptionReason? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
        self.requestId = requestId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
    let reason: IdentitystoreClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IdentitystoreClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentModification
        case uniquenessConstraintViolation
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .concurrentModification,
                .uniquenessConstraintViolation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentModification: return "CONCURRENT_MODIFICATION"
            case .uniquenessConstraintViolation: return "UNIQUENESS_CONSTRAINT_VIOLATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGroupInput(identityStoreId: \(Swift.String(describing: identityStoreId)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// A string containing the description of the group.
    public var description: Swift.String?
    /// A string containing the name of the group. This value is commonly displayed when the group is referenced.
    public var displayName: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.identityStoreId = identityStoreId
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateGroupMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }
}

extension CreateGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupMembershipInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.memberId = memberId
    }
}

struct CreateGroupMembershipInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
}

extension CreateGroupMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension CreateGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.membershipId = output.membershipId
        } else {
            self.identityStoreId = nil
            self.membershipId = nil
        }
    }
}

public struct CreateGroupMembershipOutputResponse: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a newly created GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct CreateGroupMembershipOutputResponseBody: Swift.Equatable {
    let membershipId: Swift.String?
    let identityStoreId: Swift.String?
}

extension CreateGroupMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension CreateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
        } else {
            self.groupId = nil
            self.identityStoreId = nil
        }
    }
}

public struct CreateGroupOutputResponse: Swift.Equatable {
    /// The identifier of the newly created group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct CreateGroupOutputResponseBody: Swift.Equatable {
    let groupId: Swift.String?
    let identityStoreId: Swift.String?
}

extension CreateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(addresses: \(Swift.String(describing: addresses)), emails: \(Swift.String(describing: emails)), identityStoreId: \(Swift.String(describing: identityStoreId)), name: \(Swift.String(describing: name)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), displayName: \"CONTENT_REDACTED\", locale: \"CONTENT_REDACTED\", nickName: \"CONTENT_REDACTED\", preferredLanguage: \"CONTENT_REDACTED\", profileUrl: \"CONTENT_REDACTED\", timezone: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\", userType: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userName = "UserName"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for address0 in addresses {
                try addressesContainer.encode(address0)
            }
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emails = emails {
            var emailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emails)
            for email0 in emails {
                try emailsContainer.encode(email0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nickName = self.nickName {
            try encodeContainer.encode(nickName, forKey: .nickName)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let preferredLanguage = self.preferredLanguage {
            try encodeContainer.encode(preferredLanguage, forKey: .preferredLanguage)
        }
        if let profileUrl = self.profileUrl {
            try encodeContainer.encode(profileUrl, forKey: .profileUrl)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// A list of Address objects containing addresses associated with the user.
    public var addresses: [IdentitystoreClientTypes.Address]?
    /// A string containing the user's name. This value is typically formatted for display when the user is referenced. For example, "John Doe."
    public var displayName: Swift.String?
    /// A list of Email objects containing email addresses associated with the user.
    public var emails: [IdentitystoreClientTypes.Email]?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A string containing the user's geographical region or location.
    public var locale: Swift.String?
    /// An object containing the user's name.
    public var name: IdentitystoreClientTypes.Name?
    /// A string containing an alternate name for the user.
    public var nickName: Swift.String?
    /// A list of PhoneNumber objects containing phone numbers associated with the user.
    public var phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    /// A string containing the preferred language of the user. For example, "American English" or "en-us."
    public var preferredLanguage: Swift.String?
    /// A string containing a URL that may be associated with the user.
    public var profileUrl: Swift.String?
    /// A string containing the user's time zone.
    public var timezone: Swift.String?
    /// A string containing the user's title. Possible values are left unspecified given that they depend on each customer's specific needs.
    public var title: Swift.String?
    /// A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.
    public var userName: Swift.String?
    /// A string indicating the user's type. Possible values depend on each customer's specific needs, so they are left unspecified.
    public var userType: Swift.String?

    public init (
        addresses: [IdentitystoreClientTypes.Address]? = nil,
        displayName: Swift.String? = nil,
        emails: [IdentitystoreClientTypes.Email]? = nil,
        identityStoreId: Swift.String? = nil,
        locale: Swift.String? = nil,
        name: IdentitystoreClientTypes.Name? = nil,
        nickName: Swift.String? = nil,
        phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]? = nil,
        preferredLanguage: Swift.String? = nil,
        profileUrl: Swift.String? = nil,
        timezone: Swift.String? = nil,
        title: Swift.String? = nil,
        userName: Swift.String? = nil,
        userType: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.displayName = displayName
        self.emails = emails
        self.identityStoreId = identityStoreId
        self.locale = locale
        self.name = name
        self.nickName = nickName
        self.phoneNumbers = phoneNumbers
        self.preferredLanguage = preferredLanguage
        self.profileUrl = profileUrl
        self.timezone = timezone
        self.title = title
        self.userName = userName
        self.userType = userType
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userName: Swift.String?
    let name: IdentitystoreClientTypes.Name?
    let displayName: Swift.String?
    let nickName: Swift.String?
    let profileUrl: Swift.String?
    let emails: [IdentitystoreClientTypes.Email]?
    let addresses: [IdentitystoreClientTypes.Address]?
    let phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    let userType: Swift.String?
    let title: Swift.String?
    let preferredLanguage: Swift.String?
    let locale: Swift.String?
    let timezone: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userName = "UserName"
        case userType = "UserType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.Name.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let nickNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nickName)
        nickName = nickNameDecoded
        let profileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileUrl)
        profileUrl = profileUrlDecoded
        let emailsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Email?].self, forKey: .emails)
        var emailsDecoded0:[IdentitystoreClientTypes.Email]? = nil
        if let emailsContainer = emailsContainer {
            emailsDecoded0 = [IdentitystoreClientTypes.Email]()
            for structure0 in emailsContainer {
                if let structure0 = structure0 {
                    emailsDecoded0?.append(structure0)
                }
            }
        }
        emails = emailsDecoded0
        let addressesContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[IdentitystoreClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [IdentitystoreClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let phoneNumbersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[IdentitystoreClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [IdentitystoreClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.userId = output.userId
        } else {
            self.identityStoreId = nil
            self.userId = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier of the newly created user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let identityStoreId: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension DeleteGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteGroupMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
    }
}

extension DeleteGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupMembershipInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct DeleteGroupMembershipInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let membershipId: Swift.String?
}

extension DeleteGroupMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
    }
}

extension DeleteGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupMembershipOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userId: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension DescribeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
}

extension DescribeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DescribeGroupMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
    }
}

extension DescribeGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeGroupMembershipInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct DescribeGroupMembershipInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let membershipId: Swift.String?
}

extension DescribeGroupMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
    }
}

extension DescribeGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
            self.memberId = output.memberId
            self.membershipId = output.membershipId
        } else {
            self.groupId = nil
            self.identityStoreId = nil
            self.memberId = nil
            self.membershipId = nil
        }
    }
}

public struct DescribeGroupMembershipOutputResponse: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object containing the identifier of a group member.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.memberId = memberId
        self.membershipId = membershipId
    }
}

struct DescribeGroupMembershipOutputResponseBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let membershipId: Swift.String?
    let groupId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
}

extension DescribeGroupMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
        case membershipId = "MembershipId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension DescribeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGroupOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupOutputResponse(externalIds: \(Swift.String(describing: externalIds)), groupId: \(Swift.String(describing: groupId)), identityStoreId: \(Swift.String(describing: identityStoreId)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension DescribeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.externalIds = output.externalIds
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
        } else {
            self.description = nil
            self.displayName = nil
            self.externalIds = nil
            self.groupId = nil
            self.identityStoreId = nil
        }
    }
}

public struct DescribeGroupOutputResponse: Swift.Equatable {
    /// A string containing a description of the group.
    public var description: Swift.String?
    /// The group’s display name value. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time that the group is created and stored as an attribute of the group object in the identity store.
    public var displayName: Swift.String?
    /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
    public var externalIds: [IdentitystoreClientTypes.ExternalId]?
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.externalIds = externalIds
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct DescribeGroupOutputResponseBody: Swift.Equatable {
    let groupId: Swift.String?
    let displayName: Swift.String?
    let externalIds: [IdentitystoreClientTypes.ExternalId]?
    let description: Swift.String?
    let identityStoreId: Swift.String?
}

extension DescribeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case externalIds = "ExternalIds"
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension DescribeUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userId: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutputResponse(addresses: \(Swift.String(describing: addresses)), emails: \(Swift.String(describing: emails)), externalIds: \(Swift.String(describing: externalIds)), identityStoreId: \(Swift.String(describing: identityStoreId)), name: \(Swift.String(describing: name)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), userId: \(Swift.String(describing: userId)), displayName: \"CONTENT_REDACTED\", locale: \"CONTENT_REDACTED\", nickName: \"CONTENT_REDACTED\", preferredLanguage: \"CONTENT_REDACTED\", profileUrl: \"CONTENT_REDACTED\", timezone: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\", userType: \"CONTENT_REDACTED\")"}
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addresses = output.addresses
            self.displayName = output.displayName
            self.emails = output.emails
            self.externalIds = output.externalIds
            self.identityStoreId = output.identityStoreId
            self.locale = output.locale
            self.name = output.name
            self.nickName = output.nickName
            self.phoneNumbers = output.phoneNumbers
            self.preferredLanguage = output.preferredLanguage
            self.profileUrl = output.profileUrl
            self.timezone = output.timezone
            self.title = output.title
            self.userId = output.userId
            self.userName = output.userName
            self.userType = output.userType
        } else {
            self.addresses = nil
            self.displayName = nil
            self.emails = nil
            self.externalIds = nil
            self.identityStoreId = nil
            self.locale = nil
            self.name = nil
            self.nickName = nil
            self.phoneNumbers = nil
            self.preferredLanguage = nil
            self.profileUrl = nil
            self.timezone = nil
            self.title = nil
            self.userId = nil
            self.userName = nil
            self.userType = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// The user's physical address.
    public var addresses: [IdentitystoreClientTypes.Address]?
    /// The user's name value for display.
    public var displayName: Swift.String?
    /// The user's email value.
    public var emails: [IdentitystoreClientTypes.Email]?
    /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
    public var externalIds: [IdentitystoreClientTypes.ExternalId]?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A string containing the user's geographical region or location.
    public var locale: Swift.String?
    /// The name of the user.
    public var name: IdentitystoreClientTypes.Name?
    /// An alternative descriptive name for the user.
    public var nickName: Swift.String?
    /// A list of PhoneNumber objects associated with a user.
    public var phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    /// The preferred language of the user.
    public var preferredLanguage: Swift.String?
    /// A URL link for the user's profile.
    public var profileUrl: Swift.String?
    /// The time zone for a user.
    public var timezone: Swift.String?
    /// A string containing the user's title.
    public var title: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?
    /// A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.
    public var userName: Swift.String?
    /// A string indicating the user's type.
    public var userType: Swift.String?

    public init (
        addresses: [IdentitystoreClientTypes.Address]? = nil,
        displayName: Swift.String? = nil,
        emails: [IdentitystoreClientTypes.Email]? = nil,
        externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
        identityStoreId: Swift.String? = nil,
        locale: Swift.String? = nil,
        name: IdentitystoreClientTypes.Name? = nil,
        nickName: Swift.String? = nil,
        phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]? = nil,
        preferredLanguage: Swift.String? = nil,
        profileUrl: Swift.String? = nil,
        timezone: Swift.String? = nil,
        title: Swift.String? = nil,
        userId: Swift.String? = nil,
        userName: Swift.String? = nil,
        userType: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.displayName = displayName
        self.emails = emails
        self.externalIds = externalIds
        self.identityStoreId = identityStoreId
        self.locale = locale
        self.name = name
        self.nickName = nickName
        self.phoneNumbers = phoneNumbers
        self.preferredLanguage = preferredLanguage
        self.profileUrl = profileUrl
        self.timezone = timezone
        self.title = title
        self.userId = userId
        self.userName = userName
        self.userType = userType
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let userName: Swift.String?
    let userId: Swift.String?
    let externalIds: [IdentitystoreClientTypes.ExternalId]?
    let name: IdentitystoreClientTypes.Name?
    let displayName: Swift.String?
    let nickName: Swift.String?
    let profileUrl: Swift.String?
    let emails: [IdentitystoreClientTypes.Email]?
    let addresses: [IdentitystoreClientTypes.Address]?
    let phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    let userType: Swift.String?
    let title: Swift.String?
    let preferredLanguage: Swift.String?
    let locale: Swift.String?
    let timezone: Swift.String?
    let identityStoreId: Swift.String?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case externalIds = "ExternalIds"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userId = "UserId"
        case userName = "UserName"
        case userType = "UserType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.Name.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let nickNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nickName)
        nickName = nickNameDecoded
        let profileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileUrl)
        profileUrl = profileUrlDecoded
        let emailsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Email?].self, forKey: .emails)
        var emailsDecoded0:[IdentitystoreClientTypes.Email]? = nil
        if let emailsContainer = emailsContainer {
            emailsDecoded0 = [IdentitystoreClientTypes.Email]()
            for structure0 in emailsContainer {
                if let structure0 = structure0 {
                    emailsDecoded0?.append(structure0)
                }
            }
        }
        emails = emailsDecoded0
        let addressesContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[IdentitystoreClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [IdentitystoreClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let phoneNumbersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[IdentitystoreClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [IdentitystoreClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension IdentitystoreClientTypes.Email: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primary = "Primary"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if primary != false {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let primaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primary) ?? false
        primary = primaryDecoded
    }
}

extension IdentitystoreClientTypes.Email: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Email(primary: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The email address associated with the user.
    public struct Email: Swift.Equatable {
        /// A Boolean value representing whether this is the primary email address for the associated resource.
        public var primary: Swift.Bool
        /// A string representing the type of address. For example, "Work."
        public var type: Swift.String?
        /// A string containing an email address. For example, "johndoe@amazon.com."
        public var value: Swift.String?

        public init (
            primary: Swift.Bool = false,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.primary = primary
            self.type = type
            self.value = value
        }
    }

}

extension IdentitystoreClientTypes.ExternalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case issuer = "Issuer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IdentitystoreClientTypes.ExternalId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExternalId(id: \"CONTENT_REDACTED\", issuer: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The identifier issued to this resource by an external identity provider.
    public struct ExternalId: Swift.Equatable {
        /// The identifier issued to this resource by an external identity provider.
        /// This member is required.
        public var id: Swift.String?
        /// The issuer for an external identifier.
        /// This member is required.
        public var issuer: Swift.String?

        public init (
            id: Swift.String? = nil,
            issuer: Swift.String? = nil
        )
        {
            self.id = id
            self.issuer = issuer
        }
    }

}

extension IdentitystoreClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePath = "AttributePath"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePath = self.attributePath {
            try encodeContainer.encode(attributePath, forKey: .attributePath)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributePath)
        attributePath = attributePathDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension IdentitystoreClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(attributePath: \(Swift.String(describing: attributePath)), attributeValue: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// A query filter used by ListUsers and ListGroups. This filter object provides the attribute name and attribute value to search users or groups.
    public struct Filter: Swift.Equatable {
        /// The attribute path that is used to specify which attribute name to search. Length limit is 255 characters. For example, UserName is a valid attribute path for the ListUsers API, and DisplayName is a valid attribute path for the ListGroups API.
        /// This member is required.
        public var attributePath: Swift.String?
        /// Represents the data for an attribute. Each attribute value is described as a name-value pair.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init (
            attributePath: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributePath = attributePath
            self.attributeValue = attributeValue
        }
    }

}

extension GetGroupIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateIdentifier = self.alternateIdentifier {
            try encodeContainer.encode(alternateIdentifier, forKey: .alternateIdentifier)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension GetGroupIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupIdInput: Swift.Equatable {
    /// A unique identifier for a user or group that is not the primary identifier. This value can be an identifier from an external identity provider (IdP) that is associated with the user, the group, or a unique attribute. For example, a unique GroupDisplayName.
    /// This member is required.
    public var alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.alternateIdentifier = alternateIdentifier
        self.identityStoreId = identityStoreId
    }
}

struct GetGroupIdInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
}

extension GetGroupIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let alternateIdentifierDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.AlternateIdentifier.self, forKey: .alternateIdentifier)
        alternateIdentifier = alternateIdentifierDecoded
    }
}

extension GetGroupIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupIdOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupIdOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
        } else {
            self.groupId = nil
            self.identityStoreId = nil
        }
    }
}

public struct GetGroupIdOutputResponse: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct GetGroupIdOutputResponseBody: Swift.Equatable {
    let groupId: Swift.String?
    let identityStoreId: Swift.String?
}

extension GetGroupIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension GetGroupMembershipIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }
}

extension GetGroupMembershipIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupMembershipIdInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.memberId = memberId
    }
}

struct GetGroupMembershipIdInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
}

extension GetGroupMembershipIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension GetGroupMembershipIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupMembershipIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupMembershipIdOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupMembershipIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupMembershipIdOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.membershipId = output.membershipId
        } else {
            self.identityStoreId = nil
            self.membershipId = nil
        }
    }
}

public struct GetGroupMembershipIdOutputResponse: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct GetGroupMembershipIdOutputResponseBody: Swift.Equatable {
    let membershipId: Swift.String?
    let identityStoreId: Swift.String?
}

extension GetGroupMembershipIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension GetUserIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateIdentifier = self.alternateIdentifier {
            try encodeContainer.encode(alternateIdentifier, forKey: .alternateIdentifier)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension GetUserIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUserIdInput: Swift.Equatable {
    /// A unique identifier for a user or group that is not the primary identifier. This value can be an identifier from an external identity provider (IdP) that is associated with the user, the group, or a unique attribute. For example, a unique UserDisplayName.
    /// This member is required.
    public var alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.alternateIdentifier = alternateIdentifier
        self.identityStoreId = identityStoreId
    }
}

struct GetUserIdInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
}

extension GetUserIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let alternateIdentifierDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.AlternateIdentifier.self, forKey: .alternateIdentifier)
        alternateIdentifier = alternateIdentifierDecoded
    }
}

extension GetUserIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUserIdOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUserIdOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.userId = output.userId
        } else {
            self.identityStoreId = nil
            self.userId = nil
        }
    }
}

public struct GetUserIdOutputResponse: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct GetUserIdOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let identityStoreId: Swift.String?
}

extension GetUserIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension IdentitystoreClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case externalIds = "ExternalIds"
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let externalIds = externalIds {
            var externalIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalIds)
            for externalid0 in externalIds {
                try externalIdsContainer.encode(externalid0)
            }
        }
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension IdentitystoreClientTypes.Group: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Group(externalIds: \(Swift.String(describing: externalIds)), groupId: \(Swift.String(describing: groupId)), identityStoreId: \(Swift.String(describing: identityStoreId)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// A group object that contains a specified group’s metadata and attributes.
    public struct Group: Swift.Equatable {
        /// A string containing a description of the specified group.
        public var description: Swift.String?
        /// The group’s display name value. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time the group is created and stored as an attribute of the group object in the identity store.
        public var displayName: Swift.String?
        /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
        public var externalIds: [IdentitystoreClientTypes.ExternalId]?
        /// The identifier for a group in the identity store.
        /// This member is required.
        public var groupId: Swift.String?
        /// The globally unique identifier for the identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?

        public init (
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
            groupId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.externalIds = externalIds
            self.groupId = groupId
            self.identityStoreId = identityStoreId
        }
    }

}

extension IdentitystoreClientTypes.GroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
        case membershipId = "MembershipId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension IdentitystoreClientTypes {
    /// Contains the identifiers for a group, a group member, and a GroupMembership object in the identity store.
    public struct GroupMembership: Swift.Equatable {
        /// The identifier for a group in the identity store.
        public var groupId: Swift.String?
        /// The globally unique identifier for the identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
        public var memberId: IdentitystoreClientTypes.MemberId?
        /// The identifier for a GroupMembership object in an identity store.
        public var membershipId: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            memberId: IdentitystoreClientTypes.MemberId? = nil,
            membershipId: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.identityStoreId = identityStoreId
            self.memberId = memberId
            self.membershipId = membershipId
        }
    }

}

extension IdentitystoreClientTypes.GroupMembershipExistenceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case membershipExists = "MembershipExists"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if membershipExists != false {
            try encodeContainer.encode(membershipExists, forKey: .membershipExists)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
        let membershipExistsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .membershipExists) ?? false
        membershipExists = membershipExistsDecoded
    }
}

extension IdentitystoreClientTypes.GroupMembershipExistenceResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupMembershipExistenceResult(groupId: \(Swift.String(describing: groupId)), memberId: \(Swift.String(describing: memberId)), membershipExists: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// Indicates whether a resource is a member of a group in the identity store.
    public struct GroupMembershipExistenceResult: Swift.Equatable {
        /// The identifier for a group in the identity store.
        public var groupId: Swift.String?
        /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
        public var memberId: IdentitystoreClientTypes.MemberId?
        /// Indicates whether a membership relation exists or not.
        public var membershipExists: Swift.Bool

        public init (
            groupId: Swift.String? = nil,
            memberId: IdentitystoreClientTypes.MemberId? = nil,
            membershipExists: Swift.Bool = false
        )
        {
            self.groupId = groupId
            self.memberId = memberId
            self.membershipExists = membershipExists
        }
    }

}

/// The request processing has failed because of an unknown error, exception or failure with an internal server.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?
    /// The number of seconds that you would like to wait before retrying the next request.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.requestId = requestId
        self.retryAfterSeconds = retryAfterSeconds
    }
}

extension IsMemberInGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for resourceid0 in groupIds {
                try groupIdsContainer.encode(resourceid0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }
}

extension IsMemberInGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct IsMemberInGroupsInput: Swift.Equatable {
    /// A list of identifiers for groups in the identity store.
    /// This member is required.
    public var groupIds: [Swift.String]?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object containing the identifier of a group member.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?

    public init (
        groupIds: [Swift.String]? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil
    )
    {
        self.groupIds = groupIds
        self.identityStoreId = identityStoreId
        self.memberId = memberId
    }
}

struct IsMemberInGroupsInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
    let groupIds: [Swift.String]?
}

extension IsMemberInGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension IsMemberInGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IsMemberInGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum IsMemberInGroupsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IsMemberInGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IsMemberInGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
        } else {
            self.results = nil
        }
    }
}

public struct IsMemberInGroupsOutputResponse: Swift.Equatable {
    /// A list containing the results of membership existence checks.
    /// This member is required.
    public var results: [IdentitystoreClientTypes.GroupMembershipExistenceResult]?

    public init (
        results: [IdentitystoreClientTypes.GroupMembershipExistenceResult]? = nil
    )
    {
        self.results = results
    }
}

struct IsMemberInGroupsOutputResponseBody: Swift.Equatable {
    let results: [IdentitystoreClientTypes.GroupMembershipExistenceResult]?
}

extension IsMemberInGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.GroupMembershipExistenceResult?].self, forKey: .results)
        var resultsDecoded0:[IdentitystoreClientTypes.GroupMembershipExistenceResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [IdentitystoreClientTypes.GroupMembershipExistenceResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension ListGroupMembershipsForMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case memberId = "MemberId"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGroupMembershipsForMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupMembershipsForMemberInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the ListUsers and ListGroups requests to specify how many results to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?
    /// The pagination token used for the ListUsers, ListGroups, and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.memberId = memberId
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsForMemberInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsForMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case memberId = "MemberId"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupMembershipsForMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembershipsForMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupMembershipsForMemberOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembershipsForMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupMembershipsForMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupMemberships = output.groupMemberships
            self.nextToken = output.nextToken
        } else {
            self.groupMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembershipsForMemberOutputResponse: Swift.Equatable {
    /// A list of GroupMembership objects in the group for a specified member.
    /// This member is required.
    public var groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    /// The pagination token used for the ListUsers, ListGroups, and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        groupMemberships: [IdentitystoreClientTypes.GroupMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupMemberships = groupMemberships
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsForMemberOutputResponseBody: Swift.Equatable {
    let groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsForMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMemberships = "GroupMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMembershipsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.GroupMembership?].self, forKey: .groupMemberships)
        var groupMembershipsDecoded0:[IdentitystoreClientTypes.GroupMembership]? = nil
        if let groupMembershipsContainer = groupMembershipsContainer {
            groupMembershipsDecoded0 = [IdentitystoreClientTypes.GroupMembership]()
            for structure0 in groupMembershipsContainer {
                if let structure0 = structure0 {
                    groupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        groupMemberships = groupMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupMembershipsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGroupMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupMembershipsInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in all List requests to specify how many results to return in one page.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers, ListGroups and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupMembershipsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupMemberships = output.groupMemberships
            self.nextToken = output.nextToken
        } else {
            self.groupMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembershipsOutputResponse: Swift.Equatable {
    /// A list of GroupMembership objects in the group.
    /// This member is required.
    public var groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    /// The pagination token used for the ListUsers, ListGroups, and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        groupMemberships: [IdentitystoreClientTypes.GroupMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupMemberships = groupMemberships
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsOutputResponseBody: Swift.Equatable {
    let groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMemberships = "GroupMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMembershipsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.GroupMembership?].self, forKey: .groupMemberships)
        var groupMembershipsDecoded0:[IdentitystoreClientTypes.GroupMembership]? = nil
        if let groupMembershipsContainer = groupMembershipsContainer {
            groupMembershipsDecoded0 = [IdentitystoreClientTypes.GroupMembership]()
            for structure0 in groupMembershipsContainer {
                if let structure0 = structure0 {
                    groupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        groupMemberships = groupMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// A list of Filter objects, which is used in the ListUsers and ListGroups requests.
    @available(*, deprecated, message: "Using filters with ListGroups API is deprecated, please use GetGroupId API instead.")
    public var filters: [IdentitystoreClientTypes.Filter]?
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the ListUsers and ListGroups requests to specify how many results to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        filters: [IdentitystoreClientTypes.Filter]? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [IdentitystoreClientTypes.Filter]?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[IdentitystoreClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IdentitystoreClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Swift.Equatable {
    /// A list of Group objects in the identity store.
    /// This member is required.
    public var groups: [IdentitystoreClientTypes.Group]?
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it1 is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        groups: [IdentitystoreClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    let groups: [IdentitystoreClientTypes.Group]?
    let nextToken: Swift.String?
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[IdentitystoreClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [IdentitystoreClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// A list of Filter objects, which is used in the ListUsers and ListGroups requests.
    @available(*, deprecated, message: "Using filters with ListUsers API is deprecated, please use GetGroupId API instead.")
    public var filters: [IdentitystoreClientTypes.Filter]?
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the ListUsers and ListGroups requests to specify how many results to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        filters: [IdentitystoreClientTypes.Filter]? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [IdentitystoreClientTypes.Filter]?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[IdentitystoreClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IdentitystoreClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?
    /// A list of User objects in the identity store.
    /// This member is required.
    public var users: [IdentitystoreClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [IdentitystoreClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let users: [IdentitystoreClientTypes.User]?
    let nextToken: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[IdentitystoreClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [IdentitystoreClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IdentitystoreClientTypes.MemberId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userid = "UserId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .userid(userid):
                try container.encode(userid, forKey: .userid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let useridDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .userid)
        if let userid = useridDecoded {
            self = .userid(userid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IdentitystoreClientTypes {
    /// An object containing the identifier of a group member.
    public enum MemberId: Swift.Equatable, Swift.Hashable {
        /// An object containing the identifiers of resources that can be members.
        case userid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension IdentitystoreClientTypes.Name: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case familyName = "FamilyName"
        case formatted = "Formatted"
        case givenName = "GivenName"
        case honorificPrefix = "HonorificPrefix"
        case honorificSuffix = "HonorificSuffix"
        case middleName = "MiddleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let familyName = self.familyName {
            try encodeContainer.encode(familyName, forKey: .familyName)
        }
        if let formatted = self.formatted {
            try encodeContainer.encode(formatted, forKey: .formatted)
        }
        if let givenName = self.givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let honorificPrefix = self.honorificPrefix {
            try encodeContainer.encode(honorificPrefix, forKey: .honorificPrefix)
        }
        if let honorificSuffix = self.honorificSuffix {
            try encodeContainer.encode(honorificSuffix, forKey: .honorificSuffix)
        }
        if let middleName = self.middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formattedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatted)
        formatted = formattedDecoded
        let familyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .familyName)
        familyName = familyNameDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let honorificPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .honorificPrefix)
        honorificPrefix = honorificPrefixDecoded
        let honorificSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .honorificSuffix)
        honorificSuffix = honorificSuffixDecoded
    }
}

extension IdentitystoreClientTypes.Name: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Name(familyName: \"CONTENT_REDACTED\", formatted: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", honorificPrefix: \"CONTENT_REDACTED\", honorificSuffix: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The full name of the user.
    public struct Name: Swift.Equatable {
        /// The family name of the user.
        public var familyName: Swift.String?
        /// A string containing a formatted version of the name for display.
        public var formatted: Swift.String?
        /// The given name of the user.
        public var givenName: Swift.String?
        /// The honorific prefix of the user. For example, "Dr."
        public var honorificPrefix: Swift.String?
        /// The honorific suffix of the user. For example, "M.D."
        public var honorificSuffix: Swift.String?
        /// The middle name of the user.
        public var middleName: Swift.String?

        public init (
            familyName: Swift.String? = nil,
            formatted: Swift.String? = nil,
            givenName: Swift.String? = nil,
            honorificPrefix: Swift.String? = nil,
            honorificSuffix: Swift.String? = nil,
            middleName: Swift.String? = nil
        )
        {
            self.familyName = familyName
            self.formatted = formatted
            self.givenName = givenName
            self.honorificPrefix = honorificPrefix
            self.honorificSuffix = honorificSuffix
            self.middleName = middleName
        }
    }

}

extension IdentitystoreClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primary = "Primary"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if primary != false {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let primaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primary) ?? false
        primary = primaryDecoded
    }
}

extension IdentitystoreClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(primary: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The phone number associated with the user.
    public struct PhoneNumber: Swift.Equatable {
        /// A Boolean value representing whether this is the primary phone number for the associated resource.
        public var primary: Swift.Bool
        /// A string representing the type of a phone number. For example, "Mobile."
        public var type: Swift.String?
        /// A string containing a phone number. For example, "8675309" or "+1 (800) 123-4567".
        public var value: Swift.String?

        public init (
            primary: Swift.Bool = false,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.primary = primary
            self.type = type
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a requested resource is not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?
    /// The identifier for a resource in the identity store that can be used as UserId or GroupId. The format for ResourceId is either UUID or 1234567890-UUID, where UUID is a randomly generated value for each resource when it is created and 1234567890 represents the IdentityStoreId string value. In the case that the identity store is migrated from a legacy SSO identity store, the ResourceId for that identity store will be in the format of UUID. Otherwise, it will be in the 1234567890-UUID format.
    public var resourceId: Swift.String?
    /// An enum object indicating the type of resource in the identity store service. Valid values include USER, GROUP, and IDENTITY_STORE.
    public var resourceType: IdentitystoreClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IdentitystoreClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let resourceType: IdentitystoreClientTypes.ResourceType?
    let resourceId: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IdentitystoreClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case groupMembership
        case identityStore
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .group,
                .groupMembership,
                .identityStore,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .groupMembership: return "GROUP_MEMBERSHIP"
            case .identityStore: return "IDENTITY_STORE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause the number of users or groups in the identity store to exceed the maximum allowed.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

/// Indicates that the principal has crossed the throttling limits of the API operations.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?
    /// The number of seconds that you would like to wait before retrying the next request.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.requestId = requestId
        self.retryAfterSeconds = retryAfterSeconds
    }
}

extension IdentitystoreClientTypes.UniqueAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePath = "AttributePath"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePath = self.attributePath {
            try encodeContainer.encode(attributePath, forKey: .attributePath)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributePath)
        attributePath = attributePathDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension IdentitystoreClientTypes {
    /// An entity attribute that's unique to a specific entity.
    public struct UniqueAttribute: Swift.Equatable {
        /// A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.
        /// This member is required.
        public var attributePath: Swift.String?
        /// The value of the attribute. This is a Document type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.
        /// This member is required.
        public var attributeValue: ClientRuntime.Document?

        public init (
            attributePath: Swift.String? = nil,
            attributeValue: ClientRuntime.Document? = nil
        )
        {
            self.attributePath = attributePath
            self.attributeValue = attributeValue
        }
    }

}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for attributeoperation0 in operations {
                try operationsContainer.encode(attributeoperation0)
            }
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of AttributeOperation objects to apply to the requested group. These operations might add, replace, or remove an attribute.
    /// This member is required.
    public var operations: [IdentitystoreClientTypes.AttributeOperation]?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        operations: [IdentitystoreClientTypes.AttributeOperation]? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.operations = operations
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let operations: [IdentitystoreClientTypes.AttributeOperation]?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let operationsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.AttributeOperation?].self, forKey: .operations)
        var operationsDecoded0:[IdentitystoreClientTypes.AttributeOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [IdentitystoreClientTypes.AttributeOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension UpdateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for attributeoperation0 in operations {
                try operationsContainer.encode(attributeoperation0)
            }
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of AttributeOperation objects to apply to the requested user. These operations might add, replace, or remove an attribute.
    /// This member is required.
    public var operations: [IdentitystoreClientTypes.AttributeOperation]?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        operations: [IdentitystoreClientTypes.AttributeOperation]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.operations = operations
        self.userId = userId
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userId: Swift.String?
    let operations: [IdentitystoreClientTypes.AttributeOperation]?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let operationsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.AttributeOperation?].self, forKey: .operations)
        var operationsDecoded0:[IdentitystoreClientTypes.AttributeOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [IdentitystoreClientTypes.AttributeOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension IdentitystoreClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case externalIds = "ExternalIds"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userId = "UserId"
        case userName = "UserName"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for address0 in addresses {
                try addressesContainer.encode(address0)
            }
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emails = emails {
            var emailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emails)
            for email0 in emails {
                try emailsContainer.encode(email0)
            }
        }
        if let externalIds = externalIds {
            var externalIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalIds)
            for externalid0 in externalIds {
                try externalIdsContainer.encode(externalid0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nickName = self.nickName {
            try encodeContainer.encode(nickName, forKey: .nickName)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let preferredLanguage = self.preferredLanguage {
            try encodeContainer.encode(preferredLanguage, forKey: .preferredLanguage)
        }
        if let profileUrl = self.profileUrl {
            try encodeContainer.encode(profileUrl, forKey: .profileUrl)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.Name.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let nickNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nickName)
        nickName = nickNameDecoded
        let profileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileUrl)
        profileUrl = profileUrlDecoded
        let emailsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Email?].self, forKey: .emails)
        var emailsDecoded0:[IdentitystoreClientTypes.Email]? = nil
        if let emailsContainer = emailsContainer {
            emailsDecoded0 = [IdentitystoreClientTypes.Email]()
            for structure0 in emailsContainer {
                if let structure0 = structure0 {
                    emailsDecoded0?.append(structure0)
                }
            }
        }
        emails = emailsDecoded0
        let addressesContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[IdentitystoreClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [IdentitystoreClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let phoneNumbersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[IdentitystoreClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [IdentitystoreClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension IdentitystoreClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(addresses: \(Swift.String(describing: addresses)), emails: \(Swift.String(describing: emails)), externalIds: \(Swift.String(describing: externalIds)), identityStoreId: \(Swift.String(describing: identityStoreId)), name: \(Swift.String(describing: name)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), userId: \(Swift.String(describing: userId)), displayName: \"CONTENT_REDACTED\", locale: \"CONTENT_REDACTED\", nickName: \"CONTENT_REDACTED\", preferredLanguage: \"CONTENT_REDACTED\", profileUrl: \"CONTENT_REDACTED\", timezone: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\", userType: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// A user object that contains a specified user’s metadata and attributes.
    public struct User: Swift.Equatable {
        /// A list of Address objects containing addresses associated with the user.
        public var addresses: [IdentitystoreClientTypes.Address]?
        /// A string containing the user's name that's formatted for display when the user is referenced. For example, "John Doe."
        public var displayName: Swift.String?
        /// A list of Email objects containing email addresses associated with the user.
        public var emails: [IdentitystoreClientTypes.Email]?
        /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
        public var externalIds: [IdentitystoreClientTypes.ExternalId]?
        /// The globally unique identifier for the identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// A string containing the user's geographical region or location.
        public var locale: Swift.String?
        /// An object containing the user's name.
        public var name: IdentitystoreClientTypes.Name?
        /// A string containing an alternate name for the user.
        public var nickName: Swift.String?
        /// A list of PhoneNumber objects containing phone numbers associated with the user.
        public var phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
        /// A string containing the preferred language of the user. For example, "American English" or "en-us."
        public var preferredLanguage: Swift.String?
        /// A string containing a URL that may be associated with the user.
        public var profileUrl: Swift.String?
        /// A string containing the user's time zone.
        public var timezone: Swift.String?
        /// A string containing the user's title. Possible values depend on each customer's specific needs, so they are left unspecified.
        public var title: Swift.String?
        /// The identifier for a user in the identity store.
        /// This member is required.
        public var userId: Swift.String?
        /// A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.
        public var userName: Swift.String?
        /// A string indicating the user's type. Possible values depend on each customer's specific needs, so they are left unspecified.
        public var userType: Swift.String?

        public init (
            addresses: [IdentitystoreClientTypes.Address]? = nil,
            displayName: Swift.String? = nil,
            emails: [IdentitystoreClientTypes.Email]? = nil,
            externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
            identityStoreId: Swift.String? = nil,
            locale: Swift.String? = nil,
            name: IdentitystoreClientTypes.Name? = nil,
            nickName: Swift.String? = nil,
            phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]? = nil,
            preferredLanguage: Swift.String? = nil,
            profileUrl: Swift.String? = nil,
            timezone: Swift.String? = nil,
            title: Swift.String? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userType: Swift.String? = nil
        )
        {
            self.addresses = addresses
            self.displayName = displayName
            self.emails = emails
            self.externalIds = externalIds
            self.identityStoreId = identityStoreId
            self.locale = locale
            self.name = name
            self.nickName = nickName
            self.phoneNumbers = phoneNumbers
            self.preferredLanguage = preferredLanguage
            self.profileUrl = profileUrl
            self.timezone = timezone
            self.title = title
            self.userId = userId
            self.userName = userName
            self.userType = userType
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because it contains a syntax error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}
