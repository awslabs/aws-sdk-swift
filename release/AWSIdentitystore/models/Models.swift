// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)), requestId: \(Swift.String(describing: requestId)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the Identity Store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let requestId: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct DescribeGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

extension DescribeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupInput(groupId: \(Swift.String(describing: groupId)), identityStoreId: \(Swift.String(describing: identityStoreId)))"}
}

extension DescribeGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

public struct DescribeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store, such as
    ///          d-1234567890. In this example, d- is a fixed prefix, and
    ///             1234567890 is a randomly generated string that contains number and lower
    ///          case letters. This value is generated at the time that a new identity store is
    ///          created.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
    public let identityStoreId: Swift.String?
    public let groupId: Swift.String?
}

extension DescribeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DescribeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupOutputResponse(displayName: \(Swift.String(describing: displayName)), groupId: \(Swift.String(describing: groupId)))"}
}

extension DescribeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.displayName = output.displayName
            self.groupId = output.groupId
        } else {
            self.displayName = nil
            self.groupId = nil
        }
    }
}

public struct DescribeGroupOutputResponse: Swift.Equatable {
    /// Contains the group’s display name value. The length limit is 1,024 characters. This
    ///          value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new
    ///          line, carriage return, space, and nonbreaking space in this attribute. The characters
    ///             <>;:% are excluded. This value is specified at the time that the
    ///          group is created and stored as an attribute of the group object in the identity
    ///          store.
    /// This member is required.
    public var displayName: Swift.String?
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.groupId = groupId
    }
}

struct DescribeGroupOutputResponseBody: Swift.Equatable {
    public let groupId: Swift.String?
    public let displayName: Swift.String?
}

extension DescribeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

public struct DescribeUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

extension DescribeUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserInput(identityStoreId: \(Swift.String(describing: identityStoreId)), userId: \(Swift.String(describing: userId)))"}
}

extension DescribeUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DescribeUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Swift.Equatable {
    /// The globally unique identifier for the identity store, such as
    ///          d-1234567890. In this example, d- is a fixed prefix, and
    ///             1234567890 is a randomly generated string that contains number and lower
    ///          case letters. This value is generated at the time that a new identity store is
    ///          created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    public let identityStoreId: Swift.String?
    public let userId: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutputResponse(userId: \(Swift.String(describing: userId)), userName: \(Swift.String(describing: userName)))"}
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
            self.userName = output.userName
        } else {
            self.userId = nil
            self.userName = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?
    /// Contains the user’s user name value. The length limit is 128 characters. This value can
    ///          consist of letters, accented characters, symbols, numbers, and punctuation. The characters
    ///             <>;:% are excluded. This value is specified at the time the user is
    ///          created and stored as an attribute of the user object in the identity store.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        userId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.userId = userId
        self.userName = userName
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    public let userName: Swift.String?
    public let userId: Swift.String?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension IdentitystoreClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePath = "AttributePath"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePath = attributePath {
            try encodeContainer.encode(attributePath, forKey: .attributePath)
        }
        if let attributeValue = attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributePath)
        attributePath = attributePathDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension IdentitystoreClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(attributePath: \(Swift.String(describing: attributePath)), attributeValue: \(Swift.String(describing: attributeValue)))"}
}

extension IdentitystoreClientTypes {
    /// A query filter used by ListUsers and ListGroup. This filter object provides the attribute name and attribute value to
    ///          search users or groups.
    public struct Filter: Swift.Equatable {
        /// The attribute path that is used to specify which attribute name to search. Length limit
        ///          is 255 characters. For example, UserName is a valid attribute path for the
        ///             ListUsers API, and DisplayName is a valid attribute path for
        ///          the ListGroups API.
        /// This member is required.
        public var attributePath: Swift.String?
        /// Represents the data for an attribute. Each attribute value is described as a name-value pair.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init (
            attributePath: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributePath = attributePath
            self.attributeValue = attributeValue
        }
    }

}

extension IdentitystoreClientTypes.Group: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case groupId = "GroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension IdentitystoreClientTypes.Group: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Group(displayName: \(Swift.String(describing: displayName)), groupId: \(Swift.String(describing: groupId)))"}
}

extension IdentitystoreClientTypes {
    /// A group object, which contains a specified group’s metadata and attributes.
    public struct Group: Swift.Equatable {
        /// Contains the group’s display name value. The length limit is 1,024 characters. This
        ///          value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new
        ///          line, carriage return, space, and nonbreaking space in this attribute. The characters
        ///             <>;:% are excluded. This value is specified at the time the group
        ///          is created and stored as an attribute of the group object in the identity store.
        /// This member is required.
        public var displayName: Swift.String?
        /// The identifier for a group in the identity store.
        /// This member is required.
        public var groupId: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            groupId: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.groupId = groupId
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), requestId: \(Swift.String(describing: requestId)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure with an internal server.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the Identity Store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let requestId: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct ListGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

extension ListGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroupsInput(filters: \(Swift.String(describing: filters)), identityStoreId: \(Swift.String(describing: identityStoreId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Swift.Equatable {
    /// A list of Filter objects, which is used in the ListUsers and ListGroups request.
    public var filters: [IdentitystoreClientTypes.Filter]?
    /// The globally unique identifier for the identity store, such as
    ///          d-1234567890. In this example, d- is a fixed prefix, and
    ///             1234567890 is a randomly generated string that contains number and lower
    ///          case letters. This value is generated at the time that a new identity store is
    ///          created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the
    ///             ListUsers and ListGroups request to specify how many results
    ///          to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers and ListGroups API
    ///          operations. This value is generated by the identity store service. It is returned in the
    ///          API response if the total results are more than the size of one page. This token is also
    ///          returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        filters: [IdentitystoreClientTypes.Filter]? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    public let identityStoreId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let filters: [IdentitystoreClientTypes.Filter]?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[IdentitystoreClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IdentitystoreClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroupsOutputResponse(groups: \(Swift.String(describing: groups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Swift.Equatable {
    /// A list of Group objects in the identity store.
    /// This member is required.
    public var groups: [IdentitystoreClientTypes.Group]?
    /// The pagination token used for the ListUsers and ListGroups API
    ///          operations. This value is generated by the identity store service. It is returned in the
    ///          API response if the total results are more than the size of one page. This token is also
    ///          returned when it1 is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        groups: [IdentitystoreClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    public let groups: [IdentitystoreClientTypes.Group]?
    public let nextToken: Swift.String?
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[IdentitystoreClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [IdentitystoreClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUsersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(filters: \(Swift.String(describing: filters)), identityStoreId: \(Swift.String(describing: identityStoreId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListUsersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Swift.Equatable {
    /// A list of Filter objects, which is used in the ListUsers and ListGroups request.
    public var filters: [IdentitystoreClientTypes.Filter]?
    /// The globally unique identifier for the identity store, such as
    ///          d-1234567890. In this example, d- is a fixed prefix, and
    ///             1234567890 is a randomly generated string that contains number and lower
    ///          case letters. This value is generated at the time that a new identity store is
    ///          created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the
    ///             ListUsers and ListGroups request to specify how many results
    ///          to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers and ListGroups API
    ///          operations. This value is generated by the identity store service. It is returned in the
    ///          API response if the total results are more than the size of one page. This token is also
    ///          returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init (
        filters: [IdentitystoreClientTypes.Filter]? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
    public let identityStoreId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let filters: [IdentitystoreClientTypes.Filter]?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[IdentitystoreClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IdentitystoreClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), users: \(Swift.String(describing: users)))"}
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// The pagination token used for the ListUsers and ListGroups API
    ///          operations. This value is generated by the identity store service. It is returned in the
    ///          API response if the total results are more than the size of one page. This token is also
    ///          returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?
    /// A list of User objects in the identity store.
    /// This member is required.
    public var users: [IdentitystoreClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [IdentitystoreClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    public let users: [IdentitystoreClientTypes.User]?
    public let nextToken: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[IdentitystoreClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [IdentitystoreClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), requestId: \(Swift.String(describing: requestId)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a requested resource is not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the Identity Store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?
    /// The identifier for a resource in the identity store, which can be used as UserId or GroupId. The format for ResourceId is either UUID or 1234567890-UUID, where UUID is a randomly generated value for each resource when it is created and 1234567890 represents the IdentityStoreId string value. In the case that the identity store is migrated from a legacy SSO identity store, the ResourceId for that identity store will be in the format of UUID. Otherwise, it will be in the 1234567890-UUID format.
    public var resourceId: Swift.String?
    /// The type of resource in the Identity Store service, which is an enum object. Valid values include USER, GROUP, and IDENTITY_STORE.
    public var resourceType: IdentitystoreClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IdentitystoreClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let resourceType: IdentitystoreClientTypes.ResourceType?
    public let resourceId: Swift.String?
    public let message: Swift.String?
    public let requestId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IdentitystoreClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case identityStore
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .group,
                .identityStore,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .identityStore: return "IDENTITY_STORE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the principal has crossed the throttling limits of the API operations.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the Identity Store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let requestId: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IdentitystoreClientTypes.User: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension IdentitystoreClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(userId: \(Swift.String(describing: userId)), userName: \(Swift.String(describing: userName)))"}
}

extension IdentitystoreClientTypes {
    /// A user object, which contains a specified user’s metadata and attributes.
    public struct User: Swift.Equatable {
        /// The identifier for a user in the identity store.
        /// This member is required.
        public var userId: Swift.String?
        /// Contains the user’s user name value. The length limit is 128 characters. This value can
        ///          consist of letters, accented characters, symbols, numbers, and punctuation. The characters
        ///             <>;:% are excluded. This value is specified at the time the user is
        ///          created and stored as an attribute of the user object in the identity store.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.userId = userId
            self.userName = userName
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because it contains a syntax error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for each request. This value is a globally unique ID that is generated by the Identity Store service for each sent request, and is then returned inside the exception if the request fails.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let requestId: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}
