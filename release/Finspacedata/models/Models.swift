// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ChangeType {
    case append
    case modify
    case replace
    case sdkUnknown(String)
}

extension ChangeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeType] {
        return [
            .append,
            .modify,
            .replace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .append: return "APPEND"
        case .modify: return "MODIFY"
        case .replace: return "REPLACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
    }
}

extension ChangesetInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeType
        case changesetArn
        case changesetLabels
        case createTimestamp
        case datasetId
        case errorInfo
        case formatParams
        case formatType
        case id
        case sourceParams
        case sourceType
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let changesetArn = changesetArn {
            try encodeContainer.encode(changesetArn, forKey: .changesetArn)
        }
        if let changesetLabels = changesetLabels {
            var changesetLabelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .changesetLabels)
            for (dictKey0, stringmap0) in changesetLabels {
                try changesetLabelsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
        if let datasetId = datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .formatParams)
            for (dictKey0, stringmap0) in formatParams {
                try formatParamsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let formatType = formatType {
            try encodeContainer.encode(formatType.rawValue, forKey: .formatType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .sourceParams)
            for (dictKey0, stringmap0) in sourceParams {
                try sourceParamsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedByChangesetId = updatedByChangesetId {
            try encodeContainer.encode(updatedByChangesetId, forKey: .updatedByChangesetId)
        }
        if let updatesChangesetId = updatesChangesetId {
            try encodeContainer.encode(updatesChangesetId, forKey: .updatesChangesetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [String:String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [String:String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatTypeDecoded = try containerValues.decodeIfPresent(FormatType.self, forKey: .formatType)
        formatType = formatTypeDecoded
        let formatParamsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [String:String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [String:String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChangesetStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let changesetLabelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .changesetLabels)
        var changesetLabelsDecoded0: [String:String]? = nil
        if let changesetLabelsContainer = changesetLabelsContainer {
            changesetLabelsDecoded0 = [String:String]()
            for (key0, stringmapvalue0) in changesetLabelsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    changesetLabelsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        changesetLabels = changesetLabelsDecoded0
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

extension ChangesetInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangesetInfo(changeType: \(String(describing: changeType)), changesetArn: \(String(describing: changesetArn)), changesetLabels: \(String(describing: changesetLabels)), createTimestamp: \(String(describing: createTimestamp)), datasetId: \(String(describing: datasetId)), errorInfo: \(String(describing: errorInfo)), formatParams: \(String(describing: formatParams)), formatType: \(String(describing: formatType)), id: \(String(describing: id)), sourceParams: \(String(describing: sourceParams)), sourceType: \(String(describing: sourceType)), status: \(String(describing: status)), updatedByChangesetId: \(String(describing: updatedByChangesetId)), updatesChangesetId: \(String(describing: updatesChangesetId)))"}
}

/// <p>A changeset is unit of data in a dataset.</p>
public struct ChangesetInfo: Equatable {
    /// <p>Change type indicates how a changeset is applied to a dataset.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>REPLACE</code> - Changeset is considered as a replacement to all prior loaded
    ///           changesets.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>APPEND</code> - Changeset is considered as an addition to the end of all prior
    ///           loaded changesets.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MODIFY</code> - Changeset is considered as a replacement to a specific prior
    ///           ingested changeset.</p>
    ///             </li>
    ///          </ul>
    public let changeType: ChangeType?
    /// <p>The ARN identifier of the changeset.</p>
    public let changesetArn: String?
    /// <p>Tags associated with the changeset.</p>
    public let changesetLabels: [String:String]?
    /// <p>The timestamp at which the changeset was created in FinSpace.</p>
    public let createTimestamp: Date?
    /// <p>The unique identifier for the FinSpace dataset in which the changeset is created.</p>
    public let datasetId: String?
    /// <p>The structure with error messages.</p>
    public let errorInfo: ErrorInfo?
    /// <p>Structure of the source file(s).</p>
    public let formatParams: [String:String]?
    /// <p>Format type of the input files loaded into the changeset.</p>
    public let formatType: FormatType?
    /// <p>Unique identifier for a changeset.</p>
    public let id: String?
    /// <p>Source path from which the files to create the changeset are sourced.</p>
    public let sourceParams: [String:String]?
    /// <p>Type of the data source from which the files to create the changeset are sourced.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>S3</code> - Amazon S3.</p>
    ///             </li>
    ///          </ul>
    public let sourceType: SourceType?
    /// <p>The status of changeset creation operation.</p>
    public let status: ChangesetStatus?
    /// <p>Unique identifier of the changeset that is updated a changeset.</p>
    public let updatedByChangesetId: String?
    /// <p>Unique identifier of the changeset that is updated.</p>
    public let updatesChangesetId: String?

    public init (
        changeType: ChangeType? = nil,
        changesetArn: String? = nil,
        changesetLabels: [String:String]? = nil,
        createTimestamp: Date? = nil,
        datasetId: String? = nil,
        errorInfo: ErrorInfo? = nil,
        formatParams: [String:String]? = nil,
        formatType: FormatType? = nil,
        id: String? = nil,
        sourceParams: [String:String]? = nil,
        sourceType: SourceType? = nil,
        status: ChangesetStatus? = nil,
        updatedByChangesetId: String? = nil,
        updatesChangesetId: String? = nil
    )
    {
        self.changeType = changeType
        self.changesetArn = changesetArn
        self.changesetLabels = changesetLabels
        self.createTimestamp = createTimestamp
        self.datasetId = datasetId
        self.errorInfo = errorInfo
        self.formatParams = formatParams
        self.formatType = formatType
        self.id = id
        self.sourceParams = sourceParams
        self.sourceType = sourceType
        self.status = status
        self.updatedByChangesetId = updatedByChangesetId
        self.updatesChangesetId = updatesChangesetId
    }
}

public enum ChangesetStatus {
    case failed
    case pending
    case running
    case stopRequested
    case success
    case sdkUnknown(String)
}

extension ChangesetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangesetStatus] {
        return [
            .failed,
            .pending,
            .running,
            .stopRequested,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .stopRequested: return "STOP_REQUESTED"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangesetStatus(rawValue: rawValue) ?? ChangesetStatus.sdkUnknown(rawValue)
    }
}

public struct CreateChangesetInputBodyMiddleware: Middleware {
    public let id: String = "CreateChangesetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChangesetOutputError>
}

extension CreateChangesetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChangesetInput(changeType: \(String(describing: changeType)), datasetId: \(String(describing: datasetId)), formatParams: \(String(describing: formatParams)), formatType: \(String(describing: formatType)), sourceParams: \(String(describing: sourceParams)), sourceType: \(String(describing: sourceType)), tags: \(String(describing: tags)))"}
}

extension CreateChangesetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeType
        case formatParams
        case formatType
        case sourceParams
        case sourceType
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .formatParams)
            for (dictKey0, stringmap0) in formatParams {
                try formatParamsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let formatType = formatType {
            try encodeContainer.encode(formatType.rawValue, forKey: .formatType)
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .sourceParams)
            for (dictKey0, stringmap0) in sourceParams {
                try sourceParamsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, stringmap0) in tags {
                try tagsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateChangesetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateChangesetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateChangesetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInput: Equatable {
    /// <p>Option to indicate how a changeset will be applied to a dataset.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>REPLACE</code> - Changeset will be considered as a replacement to all prior
    ///           loaded changesets.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>APPEND</code> - Changeset will be considered as an addition to the end of all
    ///           prior loaded changesets.</p>
    ///             </li>
    ///          </ul>
    public let changeType: ChangeType?
    /// <p>The unique identifier for the FinSpace dataset in which the changeset will be
    ///       created.</p>
    public let datasetId: String?
    /// <p>Options that define the structure of the source file(s).</p>
    public let formatParams: [String:String]?
    /// <p>Format type of the input files being loaded into the changeset.</p>
    public let formatType: FormatType?
    /// <p>Source path from which the files to create the changeset will be sourced.</p>
    public let sourceParams: [String:String]?
    /// <p>Type of the data source from which the files to create the changeset will be
    ///       sourced.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>S3</code> - Amazon S3.</p>
    ///             </li>
    ///          </ul>
    public let sourceType: SourceType?
    /// <p>Metadata tags to apply to this changeset.</p>
    public let tags: [String:String]?

    public init (
        changeType: ChangeType? = nil,
        datasetId: String? = nil,
        formatParams: [String:String]? = nil,
        formatType: FormatType? = nil,
        sourceParams: [String:String]? = nil,
        sourceType: SourceType? = nil,
        tags: [String:String]? = nil
    )
    {
        self.changeType = changeType
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.formatType = formatType
        self.sourceParams = sourceParams
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateChangesetInputBody: Equatable {
    public let changeType: ChangeType?
    public let sourceType: SourceType?
    public let sourceParams: [String:String]?
    public let formatType: FormatType?
    public let formatParams: [String:String]?
    public let tags: [String:String]?
}

extension CreateChangesetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeType
        case formatParams
        case formatType
        case sourceParams
        case sourceType
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [String:String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [String:String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatTypeDecoded = try containerValues.decodeIfPresent(FormatType.self, forKey: .formatType)
        formatType = formatTypeDecoded
        let formatParamsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [String:String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [String:String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChangesetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChangesetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChangesetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChangesetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChangesetOutputResponse(changeset: \(String(describing: changeset)))"}
}

extension CreateChangesetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateChangesetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeset = output.changeset
        } else {
            self.changeset = nil
        }
    }
}

public struct CreateChangesetOutputResponse: Equatable {
    /// <p>Returns the changeset details.</p>
    public let changeset: ChangesetInfo?

    public init (
        changeset: ChangesetInfo? = nil
    )
    {
        self.changeset = changeset
    }
}

struct CreateChangesetOutputResponseBody: Equatable {
    public let changeset: ChangesetInfo?
}

extension CreateChangesetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeset
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetDecoded = try containerValues.decodeIfPresent(ChangesetInfo.self, forKey: .changeset)
        changeset = changesetDecoded
    }
}

extension Credentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
    }
}

extension Credentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Credentials(accessKeyId: \(String(describing: accessKeyId)), secretAccessKey: \(String(describing: secretAccessKey)), sessionToken: \(String(describing: sessionToken)))"}
}

/// <p>Set short term API credentials.</p>
public struct Credentials: Equatable {
    /// <p>The access key identifier.</p>
    public let accessKeyId: String?
    /// <p>The access key.</p>
    public let secretAccessKey: String?
    /// <p>The session token.</p>
    public let sessionToken: String?

    public init (
        accessKeyId: String? = nil,
        secretAccessKey: String? = nil,
        sessionToken: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

public enum ErrorCategory {
    case accessDenied
    case cancelled
    case internalServiceException
    case resourceNotFound
    case serviceQuotaExceeded
    case throttling
    case userRecoverable
    case validation
    case sdkUnknown(String)
}

extension ErrorCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCategory] {
        return [
            .accessDenied,
            .cancelled,
            .internalServiceException,
            .resourceNotFound,
            .serviceQuotaExceeded,
            .throttling,
            .userRecoverable,
            .validation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "Missing_required_permission_to_perform_this_request"
        case .cancelled: return "Cancelled"
        case .internalServiceException: return "An_internal_error_has_occurred"
        case .resourceNotFound: return "One_or_more_inputs_to_this_request_were_not_found"
        case .serviceQuotaExceeded: return "Service_limits_have_been_exceeded"
        case .throttling: return "The_system_temporarily_lacks_sufficient_resources_to_process_the_request"
        case .userRecoverable: return "A_user_recoverable_error_has_occurred"
        case .validation: return "The_inputs_to_this_request_are_invalid"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCategory(rawValue: rawValue) ?? ErrorCategory.sdkUnknown(rawValue)
    }
}

extension ErrorInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension ErrorInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorInfo(errorCategory: \(String(describing: errorCategory)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Error message.</p>
public struct ErrorInfo: Equatable {
    /// <p>The category of the error.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>VALIDATION</code> -The inputs to this request are invalid.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SERVICE_QUOTA_EXCEEDED</code> - Service quotas have been exceeded. Please
    ///           contact AWS support to increase quotas.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACCESS_DENIED</code> - Missing required permission to perform this
    ///           request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESOURCE_NOT_FOUND</code> - One or more inputs to this request were not
    ///           found.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>THROTTLING</code> - The system temporarily lacks sufficient resources to process
    ///           the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INTERNAL_SERVICE_EXCEPTION</code> - An internal service error has
    ///           occurred.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELLED</code> - A user recoverable error has occurred.</p>
    ///             </li>
    ///          </ul>
    public let errorCategory: ErrorCategory?
    /// <p>The text of the error message.</p>
    public let errorMessage: String?

    public init (
        errorCategory: ErrorCategory? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCategory = errorCategory
        self.errorMessage = errorMessage
    }
}

public enum FormatType {
    case csv
    case json
    case parquet
    case xml
    case sdkUnknown(String)
}

extension FormatType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FormatType] {
        return [
            .csv,
            .json,
            .parquet,
            .xml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .json: return "JSON"
        case .parquet: return "PARQUET"
        case .xml: return "XML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FormatType(rawValue: rawValue) ?? FormatType.sdkUnknown(rawValue)
    }
}

extension GetProgrammaticAccessCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProgrammaticAccessCredentialsInput(durationInMinutes: \(String(describing: durationInMinutes)), environmentId: \(String(describing: environmentId)))"}
}

extension GetProgrammaticAccessCredentialsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetProgrammaticAccessCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "GetProgrammaticAccessCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProgrammaticAccessCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProgrammaticAccessCredentialsInput>
    public typealias MOutput = OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProgrammaticAccessCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProgrammaticAccessCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let environmentId = input.operationInput.environmentId {
            let environmentIdQueryItem = URLQueryItem(name: "environmentId".urlPercentEncoding(), value: String(environmentId).urlPercentEncoding())
            input.builder.withQueryItem(environmentIdQueryItem)
        }
        let durationInMinutesQueryItem = URLQueryItem(name: "durationInMinutes".urlPercentEncoding(), value: String(input.operationInput.durationInMinutes).urlPercentEncoding())
        input.builder.withQueryItem(durationInMinutesQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProgrammaticAccessCredentialsInput>
    public typealias MOutput = OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInput: Equatable {
    /// <p>The time duration in which the credentials remain valid. </p>
    public let durationInMinutes: Int
    /// <p>The habanero environment identifier.</p>
    public let environmentId: String?

    public init (
        durationInMinutes: Int = 0,
        environmentId: String? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.environmentId = environmentId
    }
}

struct GetProgrammaticAccessCredentialsInputBody: Equatable {
}

extension GetProgrammaticAccessCredentialsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetProgrammaticAccessCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProgrammaticAccessCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProgrammaticAccessCredentialsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProgrammaticAccessCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProgrammaticAccessCredentialsOutputResponse(credentials: \(String(describing: credentials)), durationInMinutes: \(String(describing: durationInMinutes)))"}
}

extension GetProgrammaticAccessCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProgrammaticAccessCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.credentials = output.credentials
            self.durationInMinutes = output.durationInMinutes
        } else {
            self.credentials = nil
            self.durationInMinutes = 0
        }
    }
}

public struct GetProgrammaticAccessCredentialsOutputResponse: Equatable {
    /// <p>Returns the programmatic credentials.</p>
    public let credentials: Credentials?
    /// <p>Returns the duration in which the credentials will remain valid.</p>
    public let durationInMinutes: Int

    public init (
        credentials: Credentials? = nil,
        durationInMinutes: Int = 0
    )
    {
        self.credentials = credentials
        self.durationInMinutes = durationInMinutes
    }
}

struct GetProgrammaticAccessCredentialsOutputResponseBody: Equatable {
    public let credentials: Credentials?
    public let durationInMinutes: Int
}

extension GetProgrammaticAccessCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentials
        case durationInMinutes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let durationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
    }
}

public struct GetWorkingLocationInputBodyMiddleware: Middleware {
    public let id: String = "GetWorkingLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkingLocationOutputError>
}

extension GetWorkingLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkingLocationInput(locationType: \(String(describing: locationType)))"}
}

extension GetWorkingLocationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationType = locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }
}

public struct GetWorkingLocationInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorkingLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorkingLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInput: Equatable {
    /// <p>Specify the type of the working location.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SAGEMAKER</code> - Use the Amazon S3 location as a temporary location to store data content when
    ///           working with FinSpace Notebooks that run on SageMaker studio.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INGESTION</code> - Use the Amazon S3 location as a staging location to copy your
    ///           data content and then use the location with the changeset creation operation.</p>
    ///             </li>
    ///          </ul>
    public let locationType: LocationType?

    public init (
        locationType: LocationType? = nil
    )
    {
        self.locationType = locationType
    }
}

struct GetWorkingLocationInputBody: Equatable {
    public let locationType: LocationType?
}

extension GetWorkingLocationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationTypeDecoded = try containerValues.decodeIfPresent(LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
    }
}

extension GetWorkingLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkingLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkingLocationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkingLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkingLocationOutputResponse(s3Bucket: \(String(describing: s3Bucket)), s3Path: \(String(describing: s3Path)), s3Uri: \(String(describing: s3Uri)))"}
}

extension GetWorkingLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWorkingLocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.s3Bucket = output.s3Bucket
            self.s3Path = output.s3Path
            self.s3Uri = output.s3Uri
        } else {
            self.s3Bucket = nil
            self.s3Path = nil
            self.s3Uri = nil
        }
    }
}

public struct GetWorkingLocationOutputResponse: Equatable {
    /// <p>Returns the Amazon S3 bucket name for the working location.</p>
    public let s3Bucket: String?
    /// <p>Returns the Amazon S3 Path for the working location.</p>
    public let s3Path: String?
    /// <p>Returns the Amazon S3 URI for the working location.</p>
    public let s3Uri: String?

    public init (
        s3Bucket: String? = nil,
        s3Path: String? = nil,
        s3Uri: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Path = s3Path
        self.s3Uri = s3Uri
    }
}

struct GetWorkingLocationOutputResponseBody: Equatable {
    public let s3Uri: String?
    public let s3Path: String?
    public let s3Bucket: String?
}

extension GetWorkingLocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3Bucket
        case s3Path
        case s3Uri
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception or
///       failure.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LocationType {
    case ingestion
    case sagemaker
    case sdkUnknown(String)
}

extension LocationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LocationType] {
        return [
            .ingestion,
            .sagemaker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ingestion: return "INGESTION"
        case .sagemaker: return "SAGEMAKER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LocationType(rawValue: rawValue) ?? LocationType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more resources can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SourceType {
    case s3
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException()"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by an AWS service.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
