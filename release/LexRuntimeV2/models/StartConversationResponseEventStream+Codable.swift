// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension StartConversationResponseEventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessDeniedException = "AccessDeniedException"
        case audioResponseEvent = "AudioResponseEvent"
        case badGatewayException = "BadGatewayException"
        case conflictException = "ConflictException"
        case dependencyFailedException = "DependencyFailedException"
        case heartbeatEvent = "HeartbeatEvent"
        case intentResultEvent = "IntentResultEvent"
        case internalServerException = "InternalServerException"
        case playbackInterruptionEvent = "PlaybackInterruptionEvent"
        case resourceNotFoundException = "ResourceNotFoundException"
        case textResponseEvent = "TextResponseEvent"
        case throttlingException = "ThrottlingException"
        case transcriptEvent = "TranscriptEvent"
        case validationException = "ValidationException"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accessDeniedException(accessDeniedException):
                if let accessDeniedException = accessDeniedException {
                    try container.encode(accessDeniedException, forKey: .accessDeniedException)
                }
            case let .audioResponseEvent(audioResponseEvent):
                if let audioResponseEvent = audioResponseEvent {
                    try container.encode(audioResponseEvent, forKey: .audioResponseEvent)
                }
            case let .badGatewayException(badGatewayException):
                if let badGatewayException = badGatewayException {
                    try container.encode(badGatewayException, forKey: .badGatewayException)
                }
            case let .conflictException(conflictException):
                if let conflictException = conflictException {
                    try container.encode(conflictException, forKey: .conflictException)
                }
            case let .dependencyFailedException(dependencyFailedException):
                if let dependencyFailedException = dependencyFailedException {
                    try container.encode(dependencyFailedException, forKey: .dependencyFailedException)
                }
            case let .heartbeatEvent(heartbeatEvent):
                if let heartbeatEvent = heartbeatEvent {
                    try container.encode(heartbeatEvent, forKey: .heartbeatEvent)
                }
            case let .intentResultEvent(intentResultEvent):
                if let intentResultEvent = intentResultEvent {
                    try container.encode(intentResultEvent, forKey: .intentResultEvent)
                }
            case let .internalServerException(internalServerException):
                if let internalServerException = internalServerException {
                    try container.encode(internalServerException, forKey: .internalServerException)
                }
            case let .playbackInterruptionEvent(playbackInterruptionEvent):
                if let playbackInterruptionEvent = playbackInterruptionEvent {
                    try container.encode(playbackInterruptionEvent, forKey: .playbackInterruptionEvent)
                }
            case let .resourceNotFoundException(resourceNotFoundException):
                if let resourceNotFoundException = resourceNotFoundException {
                    try container.encode(resourceNotFoundException, forKey: .resourceNotFoundException)
                }
            case let .textResponseEvent(textResponseEvent):
                if let textResponseEvent = textResponseEvent {
                    try container.encode(textResponseEvent, forKey: .textResponseEvent)
                }
            case let .throttlingException(throttlingException):
                if let throttlingException = throttlingException {
                    try container.encode(throttlingException, forKey: .throttlingException)
                }
            case let .transcriptEvent(transcriptEvent):
                if let transcriptEvent = transcriptEvent {
                    try container.encode(transcriptEvent, forKey: .transcriptEvent)
                }
            case let .validationException(validationException):
                if let validationException = validationException {
                    try container.encode(validationException, forKey: .validationException)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let playbackInterruptionEventDecoded = try values.decodeIfPresent(PlaybackInterruptionEvent.self, forKey: .playbackInterruptionEvent)
        if let playbackInterruptionEvent = playbackInterruptionEventDecoded {
            self = .playbackInterruptionEvent(playbackInterruptionEvent)
            return
        }
        let transcriptEventDecoded = try values.decodeIfPresent(TranscriptEvent.self, forKey: .transcriptEvent)
        if let transcriptEvent = transcriptEventDecoded {
            self = .transcriptEvent(transcriptEvent)
            return
        }
        let intentResultEventDecoded = try values.decodeIfPresent(IntentResultEvent.self, forKey: .intentResultEvent)
        if let intentResultEvent = intentResultEventDecoded {
            self = .intentResultEvent(intentResultEvent)
            return
        }
        let textResponseEventDecoded = try values.decodeIfPresent(TextResponseEvent.self, forKey: .textResponseEvent)
        if let textResponseEvent = textResponseEventDecoded {
            self = .textResponseEvent(textResponseEvent)
            return
        }
        let audioResponseEventDecoded = try values.decodeIfPresent(AudioResponseEvent.self, forKey: .audioResponseEvent)
        if let audioResponseEvent = audioResponseEventDecoded {
            self = .audioResponseEvent(audioResponseEvent)
            return
        }
        let heartbeatEventDecoded = try values.decodeIfPresent(HeartbeatEvent.self, forKey: .heartbeatEvent)
        if let heartbeatEvent = heartbeatEventDecoded {
            self = .heartbeatEvent(heartbeatEvent)
            return
        }
        let accessDeniedExceptionDecoded = try values.decodeIfPresent(AccessDeniedException.self, forKey: .accessDeniedException)
        if let accessDeniedException = accessDeniedExceptionDecoded {
            self = .accessDeniedException(accessDeniedException)
            return
        }
        let resourceNotFoundExceptionDecoded = try values.decodeIfPresent(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
        if let resourceNotFoundException = resourceNotFoundExceptionDecoded {
            self = .resourceNotFoundException(resourceNotFoundException)
            return
        }
        let validationExceptionDecoded = try values.decodeIfPresent(ValidationException.self, forKey: .validationException)
        if let validationException = validationExceptionDecoded {
            self = .validationException(validationException)
            return
        }
        let throttlingExceptionDecoded = try values.decodeIfPresent(ThrottlingException.self, forKey: .throttlingException)
        if let throttlingException = throttlingExceptionDecoded {
            self = .throttlingException(throttlingException)
            return
        }
        let internalServerExceptionDecoded = try values.decodeIfPresent(InternalServerException.self, forKey: .internalServerException)
        if let internalServerException = internalServerExceptionDecoded {
            self = .internalServerException(internalServerException)
            return
        }
        let conflictExceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictException)
        if let conflictException = conflictExceptionDecoded {
            self = .conflictException(conflictException)
            return
        }
        let dependencyFailedExceptionDecoded = try values.decodeIfPresent(DependencyFailedException.self, forKey: .dependencyFailedException)
        if let dependencyFailedException = dependencyFailedExceptionDecoded {
            self = .dependencyFailedException(dependencyFailedException)
            return
        }
        let badGatewayExceptionDecoded = try values.decodeIfPresent(BadGatewayException.self, forKey: .badGatewayException)
        if let badGatewayException = badGatewayExceptionDecoded {
            self = .badGatewayException(badGatewayException)
            return
        }
        self = .sdkUnknown("")
    }
}
