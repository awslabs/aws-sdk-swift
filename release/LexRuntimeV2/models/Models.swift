// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActiveContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contextAttributes
        case name
        case timeToLive
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextAttributes = contextAttributes {
            var contextAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .contextAttributes)
            for (dictKey0, activecontextparametersmap0) in contextAttributes {
                try contextAttributesContainer.encode(activecontextparametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeToLive = timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(ActiveContextTimeToLive.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let contextAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .contextAttributes)
        var contextAttributesDecoded0: [String:String]? = nil
        if let contextAttributesContainer = contextAttributesContainer {
            contextAttributesDecoded0 = [String:String]()
            for (key0, text0) in contextAttributesContainer {
                if let text0 = text0 {
                    contextAttributesDecoded0?[key0] = text0
                }
            }
        }
        contextAttributes = contextAttributesDecoded0
    }
}

extension ActiveContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveContext(contextAttributes: \(String(describing: contextAttributes)), name: \(String(describing: name)), timeToLive: \(String(describing: timeToLive)))"}
}

/// <p>Contains information about the contexts that a user is using in a
///          session. You can configure Amazon Lex to set a context when an intent is
///          fulfilled, or you can set a context using the , , or  operations.</p>
///          <p>Use a context to indicate to Amazon Lex intents that should be used as
///          follow-up intents. For example, if the active context is
///             <code>order-fulfilled</code>, only intents that have
///             <code>order-fulfilled</code> configured as a trigger are considered
///          for follow up.</p>
public struct ActiveContext: Equatable {
    /// <p>A lis tof contexts active for the request. A context can be
    ///          activated when a previous intent is fulfilled, or by including the
    ///          context in the request.</p>
    ///          <p>If you don't specify a list of contexts, Amazon Lex will use the
    ///          current list of contexts for the session. If you specify an empty list,
    ///          all contexts for the session are cleared. </p>
    public let contextAttributes: [String:String]?
    /// <p>The name of the context.</p>
    public let name: String?
    /// <p>Indicates the number of turns or seconds that the context is active.
    ///          Once the time to live expires, the context is no longer returned in a
    ///          response.</p>
    public let timeToLive: ActiveContextTimeToLive?

    public init (
        contextAttributes: [String:String]? = nil,
        name: String? = nil,
        timeToLive: ActiveContextTimeToLive? = nil
    )
    {
        self.contextAttributes = contextAttributes
        self.name = name
        self.timeToLive = timeToLive
    }
}

extension ActiveContextTimeToLive: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timeToLiveInSeconds
        case turnsToLive
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeToLiveInSeconds = timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
        if let turnsToLive = turnsToLive {
            try encodeContainer.encode(turnsToLive, forKey: .turnsToLive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let turnsToLiveDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .turnsToLive)
        turnsToLive = turnsToLiveDecoded
    }
}

extension ActiveContextTimeToLive: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveContextTimeToLive(timeToLiveInSeconds: \(String(describing: timeToLiveInSeconds)), turnsToLive: \(String(describing: turnsToLive)))"}
}

/// <p>The time that a context is active. You can specify the time to live
///          in seconds or in conversation turns.</p>
public struct ActiveContextTimeToLive: Equatable {
    /// <p>The number of seconds that the context is active. You can specify
    ///          between 5 and 86400 seconds (24 hours).</p>
    public let timeToLiveInSeconds: Int?
    /// <p>The number of turns that the context is active. You can specify up
    ///          to 20 turns. Each request and response from the bot is a turn.</p>
    public let turnsToLive: Int?

    public init (
        timeToLiveInSeconds: Int? = nil,
        turnsToLive: Int? = nil
    )
    {
        self.timeToLiveInSeconds = timeToLiveInSeconds
        self.turnsToLive = turnsToLive
    }
}

extension AudioInputEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioChunk
        case clientTimestampMillis
        case contentType
        case eventId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension AudioInputEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AudioInputEvent(audioChunk: \(String(describing: audioChunk)), clientTimestampMillis: \(String(describing: clientTimestampMillis)), contentType: \(String(describing: contentType)), eventId: \(String(describing: eventId)))"}
}

/// <p>Represents a chunk of audio sent from the client application to
///          Amazon Lex. The audio is all or part of an utterance from the user.</p>
///          <p>Amazon Lex accumulates audio chunks until it recognizes a natural pause
///          in speech before processing the input.</p>
public struct AudioInputEvent: Equatable {
    /// <p>An encoded stream of audio.</p>
    public let audioChunk: Data?
    /// <p>A timestamp set by the client of the date and time that the event
    ///          was sent to Amazon Lex.</p>
    public let clientTimestampMillis: Int
    /// <p>The encoding used for the audio chunk. You must use 8 KHz PCM 16-bit
    ///          mono-channel little-endian format. The value of the field should
    ///          be:</p>
    ///          <p>
    ///             <code>audio/lpcm; sample-rate=8000; sample-size-bits=16;
    ///             channel-count=1; is-big-endian=false</code>
    ///          </p>
    public let contentType: String?
    /// <p>A unique identifier that your application assigns to the event. You
    ///          can use this to identify events in logs.</p>
    public let eventId: String?

    public init (
        audioChunk: Data? = nil,
        clientTimestampMillis: Int = 0,
        contentType: String? = nil,
        eventId: String? = nil
    )
    {
        self.audioChunk = audioChunk
        self.clientTimestampMillis = clientTimestampMillis
        self.contentType = contentType
        self.eventId = eventId
    }
}

extension AudioResponseEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioChunk
        case contentType
        case eventId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension AudioResponseEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AudioResponseEvent(audioChunk: \(String(describing: audioChunk)), contentType: \(String(describing: contentType)), eventId: \(String(describing: eventId)))"}
}

/// <p>An event sent from Amazon Lex to your client application containing audio
///          to play to the user. </p>
public struct AudioResponseEvent: Equatable {
    /// <p>A chunk of the audio to play. </p>
    public let audioChunk: Data?
    /// <p>The encoding of the audio chunk. This is the same as the encoding
    ///          configure in the <code>contentType</code> field of the
    ///             <code>ConfigurationEvent</code>.</p>
    public let contentType: String?
    /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
    ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
    ///          and incremented for each event sent by Amazon Lex in the current
    ///          session.</p>
    public let eventId: String?

    public init (
        audioChunk: Data? = nil,
        contentType: String? = nil,
        eventId: String? = nil
    )
    {
        self.audioChunk = audioChunk
        self.contentType = contentType
        self.eventId = eventId
    }
}

extension BadGatewayException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadGatewayException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadGatewayException(message: \(String(describing: message)))"}
}

extension BadGatewayException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadGatewayExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct BadGatewayException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadGatewayExceptionBody: Equatable {
    public let message: String?
}

extension BadGatewayExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Button: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Button: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Button(text: \(String(describing: text)), value: \(String(describing: value)))"}
}

/// <p>A button that appears on a response card show to the user.</p>
public struct Button: Equatable {
    /// <p>The text that is displayed on the button.</p>
    public let text: String?
    /// <p>The value returned to Amazon Lex when a user chooses the button.</p>
    public let value: String?

    public init (
        text: String? = nil,
        value: String? = nil
    )
    {
        self.text = text
        self.value = value
    }
}

extension ConfidenceScore: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case score
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decode(Double.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ConfidenceScore: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfidenceScore(score: \(String(describing: score)))"}
}

/// <p>Provides a score that indicates the confidence that Amazon Lex has that
///          an intent is the one that satisfies the user's intent.</p>
public struct ConfidenceScore: Equatable {
    /// <p>A score that indicates how confident Amazon Lex is that an intent
    ///          satisfies the user's intent. Ranges between 0.00 and 1.00. Higher
    ///          scores indicate higher confidence.</p>
    public let score: Double

    public init (
        score: Double = 0.0
    )
    {
        self.score = score
    }
}

extension ConfigurationEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientTimestampMillis
        case disablePlayback
        case eventId
        case requestAttributes
        case responseContentType
        case sessionState
        case welcomeMessages
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if disablePlayback != false {
            try encodeContainer.encode(disablePlayback, forKey: .disablePlayback)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseContentType = responseContentType {
            try encodeContainer.encode(responseContentType, forKey: .responseContentType)
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
        if let welcomeMessages = welcomeMessages {
            var welcomeMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .welcomeMessages)
            for messages0 in welcomeMessages {
                try welcomeMessagesContainer.encode(messages0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [String:String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [String:String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let responseContentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseContentType)
        responseContentType = responseContentTypeDecoded
        let sessionStateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let welcomeMessagesContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .welcomeMessages)
        var welcomeMessagesDecoded0:[Message]? = nil
        if let welcomeMessagesContainer = welcomeMessagesContainer {
            welcomeMessagesDecoded0 = [Message]()
            for structure0 in welcomeMessagesContainer {
                if let structure0 = structure0 {
                    welcomeMessagesDecoded0?.append(structure0)
                }
            }
        }
        welcomeMessages = welcomeMessagesDecoded0
        let disablePlaybackDecoded = try containerValues.decode(Bool.self, forKey: .disablePlayback)
        disablePlayback = disablePlaybackDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension ConfigurationEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationEvent(clientTimestampMillis: \(String(describing: clientTimestampMillis)), disablePlayback: \(String(describing: disablePlayback)), eventId: \(String(describing: eventId)), requestAttributes: \(String(describing: requestAttributes)), responseContentType: \(String(describing: responseContentType)), sessionState: \(String(describing: sessionState)), welcomeMessages: \(String(describing: welcomeMessages)))"}
}

/// <p>The initial event sent from the application to Amazon Lex to configure
///          the conversation, including session and request attributes and the
///          response content type.</p>
public struct ConfigurationEvent: Equatable {
    /// <p>A timestamp set by the client of the date and time that the event
    ///          was sent to Amazon Lex.</p>
    public let clientTimestampMillis: Int
    /// <p>Determines whether Amazon Lex should send audio responses to the
    ///       client application. When this parameter if <code>false</code>,
    ///       the client application needs to create responses for the user.
    ///
    ///       </p>
    public let disablePlayback: Bool
    /// <p>A unique identifier that your application assigns to the event. You
    ///          can use this to identify events in logs.</p>
    public let eventId: String?
    /// <p>Request-specific information passed between the client application
    ///          and Amazon Lex.</p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///          attributes. Don't create any request attributes for prefix
    ///             <code>x-amz-lex:</code>.</p>
    public let requestAttributes: [String:String]?
    /// <p>The message that Amazon Lex returns in the response can be either text or
    ///          speech based on the <code>responseContentType</code> value.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the value is <code>text/plain;charset=utf-8</code>, Amazon Lex
    ///                returns text in the response.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value begins with <code>audio/</code>, Amazon Lex returns
    ///                speech in the response. Amazon Lex uses Amazon Polly to generate the speech
    ///                using the configuration that you specified in the
    ///                   <code>requestContentType</code> parameter. For example, if you
    ///                specify <code>audio/mpeg</code> as the value, Amazon Lex returns
    ///                speech in the MPEG format.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value is <code>audio/pcm</code>, the speech returned is
    ///                audio/pcm in 16-bit, little-endian format.</p>
    ///             </li>
    ///             <li>
    ///                <p>The following are the accepted values:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/mpeg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/ogg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/pcm</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/* (defaults to mpeg)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>text/plain; charset=utf-8</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let responseContentType: String?
    /// <p>The state of the user's session with Amazon Lex.</p>
    public let sessionState: SessionState?
    /// <p>A list of messages to send to the user.</p>
    public let welcomeMessages: [Message]?

    public init (
        clientTimestampMillis: Int = 0,
        disablePlayback: Bool = false,
        eventId: String? = nil,
        requestAttributes: [String:String]? = nil,
        responseContentType: String? = nil,
        sessionState: SessionState? = nil,
        welcomeMessages: [Message]? = nil
    )
    {
        self.clientTimestampMillis = clientTimestampMillis
        self.disablePlayback = disablePlayback
        self.eventId = eventId
        self.requestAttributes = requestAttributes
        self.responseContentType = responseContentType
        self.sessionState = sessionState
        self.welcomeMessages = welcomeMessages
    }
}

public enum ConfirmationState {
    case confirmed
    case denied
    case `none`
    case sdkUnknown(String)
}

extension ConfirmationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfirmationState] {
        return [
            .confirmed,
            .denied,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .confirmed: return "Confirmed"
        case .denied: return "Denied"
        case .none: return "None"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfirmationState(rawValue: rawValue) ?? ConfirmationState.sdkUnknown(rawValue)
    }
}

extension ConflictException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConversationMode {
    case audio
    case text
    case sdkUnknown(String)
}

extension ConversationMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConversationMode] {
        return [
            .audio,
            .text,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .audio: return "AUDIO"
        case .text: return "TEXT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConversationMode(rawValue: rawValue) ?? ConversationMode.sdkUnknown(rawValue)
    }
}

extension DTMFInputEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientTimestampMillis
        case eventId
        case inputCharacter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let inputCharacter = inputCharacter {
            try encodeContainer.encode(inputCharacter, forKey: .inputCharacter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputCharacter)
        inputCharacter = inputCharacterDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension DTMFInputEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DTMFInputEvent(clientTimestampMillis: \(String(describing: clientTimestampMillis)), eventId: \(String(describing: eventId)), inputCharacter: \(String(describing: inputCharacter)))"}
}

/// <p>A DTMF character sent from the client application. DTMF characters
///          are typically sent from a phone keypad to represent numbers. For
///          example, you can have Amazon Lex process a credit card number input from a
///          phone.</p>
public struct DTMFInputEvent: Equatable {
    /// <p>A timestamp set by the client of the date and time that the event
    ///          was sent to Amazon Lex.</p>
    public let clientTimestampMillis: Int
    /// <p>A unique identifier that your application assigns to the event. You
    ///          can use this to identify events in logs.</p>
    public let eventId: String?
    /// <p>The DTMF character that the user pressed. The allowed characters are
    ///          A - D, 0 - 9, # and *.</p>
    public let inputCharacter: String?

    public init (
        clientTimestampMillis: Int = 0,
        eventId: String? = nil,
        inputCharacter: String? = nil
    )
    {
        self.clientTimestampMillis = clientTimestampMillis
        self.eventId = eventId
        self.inputCharacter = inputCharacter
    }
}

extension DeleteSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSessionInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), localeId: \(String(describing: localeId)), sessionId: \(String(describing: sessionId)))"}
}

extension DeleteSessionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSessionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSessionInput>
    public typealias MOutput = OperationOutput<DeleteSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSessionOutputError>
}

public struct DeleteSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSessionInput>
    public typealias MOutput = OperationOutput<DeleteSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSessionOutputError>
}

public struct DeleteSessionInput: Equatable {
    /// <p>The alias identifier in use for the bot that contains the session
    ///          data.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot that contains the session data.</p>
    public let botId: String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: String?
    /// <p>The identifier of the session to delete.</p>
    public let sessionId: String?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        localeId: String? = nil,
        sessionId: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct DeleteSessionInputBody: Equatable {
}

extension DeleteSessionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSessionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSessionOutputResponse(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), localeId: \(String(describing: localeId)), sessionId: \(String(describing: sessionId)))"}
}

extension DeleteSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botAliasId = output.botAliasId
            self.botId = output.botId
            self.localeId = output.localeId
            self.sessionId = output.sessionId
        } else {
            self.botAliasId = nil
            self.botId = nil
            self.localeId = nil
            self.sessionId = nil
        }
    }
}

public struct DeleteSessionOutputResponse: Equatable {
    /// <p>The alias identifier in use for the bot that contained the session
    ///          data.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot that contained the session data.</p>
    public let botId: String?
    /// <p>The locale where the session was used.</p>
    public let localeId: String?
    /// <p>The identifier of the deleted session.</p>
    public let sessionId: String?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        localeId: String? = nil,
        sessionId: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct DeleteSessionOutputResponseBody: Equatable {
    public let botId: String?
    public let botAliasId: String?
    public let localeId: String?
    public let sessionId: String?
}

extension DeleteSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasId
        case botId
        case localeId
        case sessionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension DependencyFailedException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DependencyFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyFailedException(message: \(String(describing: message)))"}
}

extension DependencyFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependencyFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct DependencyFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyFailedExceptionBody: Equatable {
    public let message: String?
}

extension DependencyFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DialogAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case slotToElicit
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotToElicit = slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DialogActionType.self, forKey: .type)
        type = typeDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
    }
}

extension DialogAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DialogAction(slotToElicit: \(String(describing: slotToElicit)), type: \(String(describing: type)))"}
}

/// <p>The next action that Amazon Lex should take.</p>
public struct DialogAction: Equatable {
    /// <p>The name of the slot that should be elicited from the user.</p>
    public let slotToElicit: String?
    /// <p>The next action that the bot should take in its interaction with the
    ///          user. The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Close</code> - Indicates that there will not be a
    ///                response from the user. For example, the statement "Your order
    ///                has been placed" does not require a response.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ConfirmIntent</code> - The next action is asking the
    ///                user if the intent is complete and ready to be fulfilled. This is
    ///                a yes/no question such as "Place the order?"</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Delegate</code> - The next action is determined by
    ///                Amazon Lex.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitSlot</code> - The next action is to elicit a slot
    ///                value from the user.</p>
    ///             </li>
    ///          </ul>
    public let type: DialogActionType?

    public init (
        slotToElicit: String? = nil,
        type: DialogActionType? = nil
    )
    {
        self.slotToElicit = slotToElicit
        self.type = type
    }
}

public enum DialogActionType {
    case close
    case confirmIntent
    case delegate
    case elicitIntent
    case elicitSlot
    case sdkUnknown(String)
}

extension DialogActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DialogActionType] {
        return [
            .close,
            .confirmIntent,
            .delegate,
            .elicitIntent,
            .elicitSlot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .close: return "Close"
        case .confirmIntent: return "ConfirmIntent"
        case .delegate: return "Delegate"
        case .elicitIntent: return "ElicitIntent"
        case .elicitSlot: return "ElicitSlot"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DialogActionType(rawValue: rawValue) ?? DialogActionType.sdkUnknown(rawValue)
    }
}

extension DisconnectionEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientTimestampMillis
        case eventId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension DisconnectionEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisconnectionEvent(clientTimestampMillis: \(String(describing: clientTimestampMillis)), eventId: \(String(describing: eventId)))"}
}

/// <p>A notification from the client that it is disconnecting from Amazon Lex.
///          Sending a <code>DisconnectionEvent</code> event is optional, but can
///          help identify a conversation in logs.</p>
public struct DisconnectionEvent: Equatable {
    /// <p>A timestamp set by the client of the date and time that the event
    ///          was sent to Amazon Lex.</p>
    public let clientTimestampMillis: Int
    /// <p>A unique identifier that your application assigns to the event. You
    ///          can use this to identify events in logs.</p>
    public let eventId: String?

    public init (
        clientTimestampMillis: Int = 0,
        eventId: String? = nil
    )
    {
        self.clientTimestampMillis = clientTimestampMillis
        self.eventId = eventId
    }
}

extension GetSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), localeId: \(String(describing: localeId)), sessionId: \(String(describing: sessionId)))"}
}

extension GetSessionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSessionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionInput>
    public typealias MOutput = OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionOutputError>
}

public struct GetSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionInput>
    public typealias MOutput = OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionOutputError>
}

public struct GetSessionInput: Equatable {
    /// <p>The alias identifier in use for the bot that contains the session
    ///          data.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot that contains the session data.</p>
    public let botId: String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: String?
    /// <p>The identifier of the session to return.</p>
    public let sessionId: String?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        localeId: String? = nil,
        sessionId: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Equatable {
}

extension GetSessionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionOutputResponse(interpretations: \(String(describing: interpretations)), messages: \(String(describing: messages)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)))"}
}

extension GetSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.interpretations = output.interpretations
            self.messages = output.messages
            self.sessionId = output.sessionId
            self.sessionState = output.sessionState
        } else {
            self.interpretations = nil
            self.messages = nil
            self.sessionId = nil
            self.sessionState = nil
        }
    }
}

public struct GetSessionOutputResponse: Equatable {
    /// <p>A list of intents that Amazon Lex determined might satisfy the user's
    ///          utterance. </p>
    ///          <p>Each interpretation includes the intent, a score that indicates how
    ///          confident Amazon Lex is that the interpretation is the correct one, and an
    ///          optional sentiment response that indicates the sentiment expressed in
    ///          the utterance.</p>
    public let interpretations: [Interpretation]?
    /// <p>A list of messages that were last sent to the user. The messages are
    ///          ordered based on the order that your returned the messages from your
    ///          Lambda function or the order that messages are defined in the bot.
    ///       </p>
    public let messages: [Message]?
    /// <p>The identifier of the returned session.</p>
    public let sessionId: String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot.</p>
    ///          <p>You can use this to determine the progress of the conversation and
    ///          what the next action might be.</p>
    public let sessionState: SessionState?

    public init (
        interpretations: [Interpretation]? = nil,
        messages: [Message]? = nil,
        sessionId: String? = nil,
        sessionState: SessionState? = nil
    )
    {
        self.interpretations = interpretations
        self.messages = messages
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct GetSessionOutputResponseBody: Equatable {
    public let sessionId: String?
    public let messages: [Message]?
    public let interpretations: [Interpretation]?
    public let sessionState: SessionState?
}

extension GetSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interpretations
        case messages
        case sessionId
        case sessionState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let messagesContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .messages)
        var messagesDecoded0:[Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let interpretationsContainer = try containerValues.decodeIfPresent([Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
    }
}

extension HeartbeatEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension HeartbeatEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HeartbeatEvent(eventId: \(String(describing: eventId)))"}
}

/// <p>Event that Amazon Lex sends to indicate that the stream is still open
///          between the client application and Amazon Lex </p>
public struct HeartbeatEvent: Equatable {
    /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
    ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
    ///          and incremented for each event sent by Amazon Lex in the current
    ///          session.</p>
    public let eventId: String?

    public init (
        eventId: String? = nil
    )
    {
        self.eventId = eventId
    }
}

extension ImageResponseCard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case buttons
        case imageUrl
        case subtitle
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buttons = buttons {
            var buttonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buttons)
            for buttonslist0 in buttons {
                try buttonsContainer.encode(buttonslist0)
            }
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let subtitle = subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let buttonsContainer = try containerValues.decodeIfPresent([Button?].self, forKey: .buttons)
        var buttonsDecoded0:[Button]? = nil
        if let buttonsContainer = buttonsContainer {
            buttonsDecoded0 = [Button]()
            for structure0 in buttonsContainer {
                if let structure0 = structure0 {
                    buttonsDecoded0?.append(structure0)
                }
            }
        }
        buttons = buttonsDecoded0
    }
}

extension ImageResponseCard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageResponseCard(buttons: \(String(describing: buttons)), imageUrl: \(String(describing: imageUrl)), subtitle: \(String(describing: subtitle)), title: \(String(describing: title)))"}
}

/// <p>A card that is shown to the user by a messaging platform. You define
///          the contents of the card, the card is displayed by the platform. </p>
///          <p>When you use a response card, the response from the user is
///          constrained to the text associated with a button on the card.</p>
public struct ImageResponseCard: Equatable {
    /// <p>A list of buttons that should be displayed on the response card. The
    ///          arrangement of the buttons is determined by the platform that displays
    ///          the button.</p>
    public let buttons: [Button]?
    /// <p>The URL of an image to display on the response card. The image URL
    ///          must be publicly available so that the platform displaying the response
    ///          card has access to the image.</p>
    public let imageUrl: String?
    /// <p>The subtitle to display on the response card. The format of the
    ///          subtitle is determined by the platform displaying the response
    ///          card.</p>
    public let subtitle: String?
    /// <p>The title to display on the response card. The format of the title
    ///          is determined by the platform displaying the response card.</p>
    public let title: String?

    public init (
        buttons: [Button]? = nil,
        imageUrl: String? = nil,
        subtitle: String? = nil,
        title: String? = nil
    )
    {
        self.buttons = buttons
        self.imageUrl = imageUrl
        self.subtitle = subtitle
        self.title = title
    }
}

public enum InputMode {
    case dtmf
    case speech
    case text
    case sdkUnknown(String)
}

extension InputMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InputMode] {
        return [
            .dtmf,
            .speech,
            .text,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dtmf: return "DTMF"
        case .speech: return "Speech"
        case .text: return "Text"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InputMode(rawValue: rawValue) ?? InputMode.sdkUnknown(rawValue)
    }
}

extension Intent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confirmationState
        case name
        case slots
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationState = confirmationState {
            try encodeContainer.encode(confirmationState.rawValue, forKey: .confirmationState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .slots)
            for (dictKey0, slots0) in slots {
                try slotsContainer.encode(slots0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let slotsContainer = try containerValues.decodeIfPresent([String: Slot?].self, forKey: .slots)
        var slotsDecoded0: [String:Slot]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [String:Slot]()
            for (key0, slot0) in slotsContainer {
                if let slot0 = slot0 {
                    slotsDecoded0?[key0] = slot0
                }
            }
        }
        slots = slotsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(IntentState.self, forKey: .state)
        state = stateDecoded
        let confirmationStateDecoded = try containerValues.decodeIfPresent(ConfirmationState.self, forKey: .confirmationState)
        confirmationState = confirmationStateDecoded
    }
}

extension Intent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Intent(confirmationState: \(String(describing: confirmationState)), name: \(String(describing: name)), slots: \(String(describing: slots)), state: \(String(describing: state)))"}
}

/// <p>The current intent that Amazon Lex is attempting to fulfill.</p>
public struct Intent: Equatable {
    /// <p>Contains information about whether fulfillment of the intent has
    ///          been confirmed.</p>
    public let confirmationState: ConfirmationState?
    /// <p>The name of the intent.</p>
    public let name: String?
    /// <p>A map of all of the slots for the intent. The name of the slot maps
    ///          to the value of the slot. If a slot has not been filled, the value is
    ///          null.</p>
    public let slots: [String:Slot]?
    /// <p>Contains fulfillment information for the intent. </p>
    public let state: IntentState?

    public init (
        confirmationState: ConfirmationState? = nil,
        name: String? = nil,
        slots: [String:Slot]? = nil,
        state: IntentState? = nil
    )
    {
        self.confirmationState = confirmationState
        self.name = name
        self.slots = slots
        self.state = state
    }
}

extension IntentResultEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
        case inputMode
        case interpretations
        case requestAttributes
        case sessionId
        case sessionState
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let inputMode = inputMode {
            try encodeContainer.encode(inputMode.rawValue, forKey: .inputMode)
        }
        if let interpretations = interpretations {
            var interpretationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .interpretations)
            for interpretations0 in interpretations {
                try interpretationsContainer.encode(interpretations0)
            }
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputModeDecoded = try containerValues.decodeIfPresent(InputMode.self, forKey: .inputMode)
        inputMode = inputModeDecoded
        let interpretationsContainer = try containerValues.decodeIfPresent([Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [String:String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [String:String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension IntentResultEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentResultEvent(eventId: \(String(describing: eventId)), inputMode: \(String(describing: inputMode)), interpretations: \(String(describing: interpretations)), requestAttributes: \(String(describing: requestAttributes)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)))"}
}

/// <p>Contains the current state of the conversation between the client
///          application and Amazon Lex.</p>
public struct IntentResultEvent: Equatable {
    /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
    ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
    ///          and incremented for each event sent by Amazon Lex in the current
    ///          session.</p>
    public let eventId: String?
    /// <p>Indicates whether the input to the operation was text or speech.</p>
    public let inputMode: InputMode?
    /// <p>A list of intents that Amazon Lex determined might satisfy the user's
    ///          utterance.</p>
    ///
    ///          <p>Each interpretation includes the intent, a score that indicates how
    ///          confident Amazon Lex is that the interpretation is the correct one, and an
    ///          optional sentiment response that indicates the sentiment expressed in
    ///          the utterance.</p>
    public let interpretations: [Interpretation]?
    /// <p>The attributes sent in the request.</p>
    public let requestAttributes: [String:String]?
    /// <p>The identifier of the session in use.</p>
    public let sessionId: String?
    /// <p>The state of the user's session with Amazon Lex.</p>
    public let sessionState: SessionState?

    public init (
        eventId: String? = nil,
        inputMode: InputMode? = nil,
        interpretations: [Interpretation]? = nil,
        requestAttributes: [String:String]? = nil,
        sessionId: String? = nil,
        sessionState: SessionState? = nil
    )
    {
        self.eventId = eventId
        self.inputMode = inputMode
        self.interpretations = interpretations
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

public enum IntentState {
    case failed
    case fulfilled
    case inProgress
    case readyForFulfillment
    case waiting
    case sdkUnknown(String)
}

extension IntentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntentState] {
        return [
            .failed,
            .fulfilled,
            .inProgress,
            .readyForFulfillment,
            .waiting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .fulfilled: return "Fulfilled"
        case .inProgress: return "InProgress"
        case .readyForFulfillment: return "ReadyForFulfillment"
        case .waiting: return "Waiting"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntentState(rawValue: rawValue) ?? IntentState.sdkUnknown(rawValue)
    }
}

extension InternalServerException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Interpretation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case intent
        case nluConfidence
        case sentimentResponse
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intent = intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let nluConfidence = nluConfidence {
            try encodeContainer.encode(nluConfidence, forKey: .nluConfidence)
        }
        if let sentimentResponse = sentimentResponse {
            try encodeContainer.encode(sentimentResponse, forKey: .sentimentResponse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nluConfidenceDecoded = try containerValues.decodeIfPresent(ConfidenceScore.self, forKey: .nluConfidence)
        nluConfidence = nluConfidenceDecoded
        let sentimentResponseDecoded = try containerValues.decodeIfPresent(SentimentResponse.self, forKey: .sentimentResponse)
        sentimentResponse = sentimentResponseDecoded
        let intentDecoded = try containerValues.decodeIfPresent(Intent.self, forKey: .intent)
        intent = intentDecoded
    }
}

extension Interpretation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Interpretation(intent: \(String(describing: intent)), nluConfidence: \(String(describing: nluConfidence)), sentimentResponse: \(String(describing: sentimentResponse)))"}
}

/// <p>An intent that Amazon Lex determined might satisfy the user's utterance.
///          The intents are ordered by the confidence score. </p>
public struct Interpretation: Equatable {
    /// <p>A list of intents that might satisfy the user's utterance. The
    ///          intents are ordered by the confidence score.</p>
    public let intent: Intent?
    /// <p>Determines the threshold where Amazon Lex will insert the
    ///             <code>AMAZON.FallbackIntent</code>,
    ///             <code>AMAZON.KendraSearchIntent</code>, or both when returning
    ///          alternative intents in a response. <code>AMAZON.FallbackIntent</code>
    ///          and <code>AMAZON.KendraSearchIntent</code> are only inserted if they
    ///          are configured for the bot.</p>
    public let nluConfidence: ConfidenceScore?
    /// <p>The sentiment expressed in an utterance. </p>
    ///          <p>When the bot is configured to send utterances to Amazon Comprehend
    ///          for sentiment analysis, this field contains the result of the
    ///          analysis.</p>
    public let sentimentResponse: SentimentResponse?

    public init (
        intent: Intent? = nil,
        nluConfidence: ConfidenceScore? = nil,
        sentimentResponse: SentimentResponse? = nil
    )
    {
        self.intent = intent
        self.nluConfidence = nluConfidence
        self.sentimentResponse = sentimentResponse
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content
        case contentType
        case imageResponseCard
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let imageResponseCard = imageResponseCard {
            try encodeContainer.encode(imageResponseCard, forKey: .imageResponseCard)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(MessageContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let imageResponseCardDecoded = try containerValues.decodeIfPresent(ImageResponseCard.self, forKey: .imageResponseCard)
        imageResponseCard = imageResponseCardDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(content: \(String(describing: content)), contentType: \(String(describing: contentType)), imageResponseCard: \(String(describing: imageResponseCard)))"}
}

/// <p>Container for text that is returned to the customer..</p>
public struct Message: Equatable {
    /// <p>The text of the message.</p>
    public let content: String?
    /// <p>Indicates the type of response.</p>
    public let contentType: MessageContentType?
    /// <p>A card that is shown to the user by a messaging platform. You define
    ///          the contents of the card, the card is displayed by the platform. </p>
    ///          <p>When you use a response card, the response from the user is
    ///          constrained to the text associated with a button on the card.</p>
    public let imageResponseCard: ImageResponseCard?

    public init (
        content: String? = nil,
        contentType: MessageContentType? = nil,
        imageResponseCard: ImageResponseCard? = nil
    )
    {
        self.content = content
        self.contentType = contentType
        self.imageResponseCard = imageResponseCard
    }
}

public enum MessageContentType {
    case customPayload
    case imageResponseCard
    case plainText
    case ssml
    case sdkUnknown(String)
}

extension MessageContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageContentType] {
        return [
            .customPayload,
            .imageResponseCard,
            .plainText,
            .ssml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customPayload: return "CustomPayload"
        case .imageResponseCard: return "ImageResponseCard"
        case .plainText: return "PlainText"
        case .ssml: return "SSML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageContentType(rawValue: rawValue) ?? MessageContentType.sdkUnknown(rawValue)
    }
}

extension PlaybackCompletionEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientTimestampMillis
        case eventId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension PlaybackCompletionEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlaybackCompletionEvent(clientTimestampMillis: \(String(describing: clientTimestampMillis)), eventId: \(String(describing: eventId)))"}
}

/// <p>Event sent from the client application to Amazon Lex to indicate that
///          playback of audio is complete and that Amazon Lex should start processing
///          the user's input.</p>
public struct PlaybackCompletionEvent: Equatable {
    /// <p>A timestamp set by the client of the date and time that the event
    ///          was sent to Amazon Lex.</p>
    public let clientTimestampMillis: Int
    /// <p>A unique identifier that your application assigns to the event. You
    ///          can use this to identify events in logs.</p>
    public let eventId: String?

    public init (
        clientTimestampMillis: Int = 0,
        eventId: String? = nil
    )
    {
        self.clientTimestampMillis = clientTimestampMillis
        self.eventId = eventId
    }
}

extension PlaybackInterruptionEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case causedByEventId
        case eventId
        case eventReason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causedByEventId = causedByEventId {
            try encodeContainer.encode(causedByEventId, forKey: .causedByEventId)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventReason = eventReason {
            try encodeContainer.encode(eventReason.rawValue, forKey: .eventReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventReasonDecoded = try containerValues.decodeIfPresent(PlaybackInterruptionReason.self, forKey: .eventReason)
        eventReason = eventReasonDecoded
        let causedByEventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .causedByEventId)
        causedByEventId = causedByEventIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension PlaybackInterruptionEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlaybackInterruptionEvent(causedByEventId: \(String(describing: causedByEventId)), eventId: \(String(describing: eventId)), eventReason: \(String(describing: eventReason)))"}
}

/// <p>Event sent from Amazon Lex to indicate to the client application should
///          stop playback of audio. For example, if the client is playing a prompt
///          that asks for the user's telephone number, the user might start to say
///          the phone number before the prompt is complete. Amazon Lex sends this event
///          to the client application to indicate that the user is responding and
///          that Amazon Lex is processing their input.</p>
public struct PlaybackInterruptionEvent: Equatable {
    /// <p>The identifier of the event that contained the audio, DTMF, or text
    ///          that caused the interruption.</p>
    public let causedByEventId: String?
    /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
    ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
    ///          and incremented for each event sent by Amazon Lex in the current
    ///          session.</p>
    public let eventId: String?
    /// <p>Indicates the type of user input that Amazon Lex detected.</p>
    public let eventReason: PlaybackInterruptionReason?

    public init (
        causedByEventId: String? = nil,
        eventId: String? = nil,
        eventReason: PlaybackInterruptionReason? = nil
    )
    {
        self.causedByEventId = causedByEventId
        self.eventId = eventId
        self.eventReason = eventReason
    }
}

public enum PlaybackInterruptionReason {
    case dtmfStartDetected
    case textDetected
    case voiceStartDetected
    case sdkUnknown(String)
}

extension PlaybackInterruptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlaybackInterruptionReason] {
        return [
            .dtmfStartDetected,
            .textDetected,
            .voiceStartDetected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dtmfStartDetected: return "DTMF_START_DETECTED"
        case .textDetected: return "TEXT_DETECTED"
        case .voiceStartDetected: return "VOICE_START_DETECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlaybackInterruptionReason(rawValue: rawValue) ?? PlaybackInterruptionReason.sdkUnknown(rawValue)
    }
}

public struct PutSessionInputBodyMiddleware: Middleware {
    public let id: String = "PutSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSessionInput>
    public typealias MOutput = OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSessionOutputError>
}

extension PutSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSessionInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), localeId: \(String(describing: localeId)), messages: \(String(describing: messages)), requestAttributes: \(String(describing: requestAttributes)), responseContentType: \(String(describing: responseContentType)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)))"}
}

extension PutSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messages
        case requestAttributes
        case sessionState
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }
}

public struct PutSessionInputHeadersMiddleware: Middleware {
    public let id: String = "PutSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let responseContentType = input.operationInput.responseContentType {
            input.builder.withHeader(name: "ResponseContentType", value: String(responseContentType))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSessionInput>
    public typealias MOutput = OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSessionOutputError>
}

public struct PutSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSessionInput>
    public typealias MOutput = OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSessionOutputError>
}

public struct PutSessionInput: Equatable {
    /// <p>The alias identifier of the bot that receives the session
    ///          data.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot that receives the session data.</p>
    public let botId: String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: String?
    /// <p>A list of messages to send to the user. Messages are sent in the
    ///          order that they are defined in the list.</p>
    public let messages: [Message]?
    /// <p>Request-specific information passed between Amazon Lex and the client
    ///          application.</p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///          attributes. Don't create any request attributes with the prefix
    ///             <code>x-amz-lex:</code>.</p>
    public let requestAttributes: [String:String]?
    /// <p>The message that Amazon Lex returns in the response can be either text or
    ///          speech depending on the value of this parameter. </p>
    ///          <ul>
    ///             <li>
    ///                <p>If the value is <code>text/plain; charset=utf-8</code>, Amazon Lex
    ///                returns text in the response.</p>
    ///             </li>
    ///          </ul>
    public let responseContentType: String?
    /// <p>The identifier of the session that receives the session data.</p>
    public let sessionId: String?
    /// <p>Sets the state of the session with the user. You can use this to set
    ///          the current intent, attributes, context, and dialog action. Use the
    ///          dialog action to determine the next step that Amazon Lex should use in the
    ///          conversation with the user.</p>
    public let sessionState: SessionState?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        localeId: String? = nil,
        messages: [Message]? = nil,
        requestAttributes: [String:String]? = nil,
        responseContentType: String? = nil,
        sessionId: String? = nil,
        sessionState: SessionState? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.responseContentType = responseContentType
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct PutSessionInputBody: Equatable {
    public let messages: [Message]?
    public let sessionState: SessionState?
    public let requestAttributes: [String:String]?
}

extension PutSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messages
        case requestAttributes
        case sessionState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .messages)
        var messagesDecoded0:[Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [String:String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [String:String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
    }
}

extension PutSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSessionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSessionOutputResponse(audioStream: \(String(describing: audioStream)), contentType: \(String(describing: contentType)), messages: \(String(describing: messages)), requestAttributes: \(String(describing: requestAttributes)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)))"}
}

extension PutSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let messagesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-messages") {
            self.messages = messagesHeaderValue
        } else {
            self.messages = nil
        }
        if let requestAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-request-attributes") {
            self.requestAttributes = requestAttributesHeaderValue
        } else {
            self.requestAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let sessionStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-state") {
            self.sessionState = sessionStateHeaderValue
        } else {
            self.sessionState = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.audioStream = unwrappedData
        } else {
            self.audioStream = nil
        }
    }
}

public struct PutSessionOutputResponse: Equatable {
    /// <p>If the requested content type was audio, the audio version of the
    ///          message to convey to the user.</p>
    public let audioStream: Data?
    /// <p>The type of response. Same as the type specified in the
    ///             <code>responseContentType</code> field in the request.</p>
    public let contentType: String?
    /// <p>A list of messages that were last sent to the user. The messages are
    ///          ordered based on how you return the messages from you Lambda function
    ///          or the order that the messages are defined in the bot.</p>
    public let messages: String?
    /// <p>Request-specific information passed between the client application
    ///          and Amazon Lex. These are the same as the <code>requestAttribute</code>
    ///          parameter in the call to the <code>PutSession</code> operation.</p>
    public let requestAttributes: String?
    /// <p>The identifier of the session that received the data.</p>
    public let sessionId: String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot.</p>
    ///          <p>Use this to determine the progress of the conversation and what the
    ///          next action may be.</p>
    public let sessionState: String?

    public init (
        audioStream: Data? = nil,
        contentType: String? = nil,
        messages: String? = nil,
        requestAttributes: String? = nil,
        sessionId: String? = nil,
        sessionState: String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct PutSessionOutputResponseBody: Equatable {
    public let audioStream: Data?
}

extension PutSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audioStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

public struct RecognizeTextInputBodyMiddleware: Middleware {
    public let id: String = "RecognizeTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecognizeTextInput>,
                  next: H) -> Swift.Result<OperationOutput<RecognizeTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecognizeTextInput>
    public typealias MOutput = OperationOutput<RecognizeTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecognizeTextOutputError>
}

extension RecognizeTextInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecognizeTextInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), localeId: \(String(describing: localeId)), requestAttributes: \(String(describing: requestAttributes)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)), text: \(String(describing: text)))"}
}

extension RecognizeTextInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case requestAttributes
        case sessionState
        case text
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct RecognizeTextInputHeadersMiddleware: Middleware {
    public let id: String = "RecognizeTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecognizeTextInput>,
                  next: H) -> Swift.Result<OperationOutput<RecognizeTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecognizeTextInput>
    public typealias MOutput = OperationOutput<RecognizeTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecognizeTextOutputError>
}

public struct RecognizeTextInputQueryItemMiddleware: Middleware {
    public let id: String = "RecognizeTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecognizeTextInput>,
                  next: H) -> Swift.Result<OperationOutput<RecognizeTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecognizeTextInput>
    public typealias MOutput = OperationOutput<RecognizeTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecognizeTextOutputError>
}

public struct RecognizeTextInput: Equatable {
    /// <p>The alias identifier in use for the bot that processes the
    ///          request.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot that processes the request.</p>
    public let botId: String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: String?
    /// <p>Request-specific information passed between the client application
    ///          and Amazon Lex </p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///          attributes. Don't create any request attributes with the prefix
    ///             <code>x-amz-lex:</code>.</p>
    public let requestAttributes: [String:String]?
    /// <p>The identifier of the user session that is having the
    ///          conversation.</p>
    public let sessionId: String?
    /// <p>The current state of the dialog between the user and the bot.</p>
    public let sessionState: SessionState?
    /// <p>The text that the user entered. Amazon Lex interprets this text.</p>
    public let text: String?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        localeId: String? = nil,
        requestAttributes: [String:String]? = nil,
        sessionId: String? = nil,
        sessionState: SessionState? = nil,
        text: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
        self.text = text
    }
}

struct RecognizeTextInputBody: Equatable {
    public let text: String?
    public let sessionState: SessionState?
    public let requestAttributes: [String:String]?
}

extension RecognizeTextInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestAttributes
        case sessionState
        case text
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let sessionStateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [String:String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [String:String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
    }
}

extension RecognizeTextOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RecognizeTextOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RecognizeTextOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RecognizeTextOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecognizeTextOutputResponse(interpretations: \(String(describing: interpretations)), messages: \(String(describing: messages)), requestAttributes: \(String(describing: requestAttributes)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)))"}
}

extension RecognizeTextOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RecognizeTextOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.interpretations = output.interpretations
            self.messages = output.messages
            self.requestAttributes = output.requestAttributes
            self.sessionId = output.sessionId
            self.sessionState = output.sessionState
        } else {
            self.interpretations = nil
            self.messages = nil
            self.requestAttributes = nil
            self.sessionId = nil
            self.sessionState = nil
        }
    }
}

public struct RecognizeTextOutputResponse: Equatable {
    /// <p>A list of intents that Amazon Lex determined might satisfy the user's
    ///          utterance. </p>
    ///          <p>Each interpretation includes the intent, a score that indicates now
    ///          confident Amazon Lex is that the interpretation is the correct one, and an
    ///          optional sentiment response that indicates the sentiment expressed in
    ///          the utterance.</p>
    public let interpretations: [Interpretation]?
    /// <p>A list of messages last sent to the user. The messages are ordered
    ///          based on the order that you returned the messages from your Lambda
    ///          function or the order that the messages are defined in the bot.</p>
    public let messages: [Message]?
    /// <p>The attributes sent in the request.</p>
    public let requestAttributes: [String:String]?
    /// <p>The identifier of the session in use.</p>
    public let sessionId: String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot. </p>
    ///          <p>Use this to determine the progress of the conversation and what the
    ///          next action may be.</p>
    public let sessionState: SessionState?

    public init (
        interpretations: [Interpretation]? = nil,
        messages: [Message]? = nil,
        requestAttributes: [String:String]? = nil,
        sessionId: String? = nil,
        sessionState: SessionState? = nil
    )
    {
        self.interpretations = interpretations
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeTextOutputResponseBody: Equatable {
    public let messages: [Message]?
    public let sessionState: SessionState?
    public let interpretations: [Interpretation]?
    public let requestAttributes: [String:String]?
    public let sessionId: String?
}

extension RecognizeTextOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interpretations
        case messages
        case requestAttributes
        case sessionId
        case sessionState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .messages)
        var messagesDecoded0:[Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let interpretationsContainer = try containerValues.decodeIfPresent([Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let requestAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [String:String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [String:String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

public struct RecognizeUtteranceInputBodyMiddleware: Middleware {
    public let id: String = "RecognizeUtteranceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecognizeUtteranceInput>,
                  next: H) -> Swift.Result<OperationOutput<RecognizeUtteranceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let inputStream = input.operationInput.inputStream {
            let data = inputStream
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecognizeUtteranceInput>
    public typealias MOutput = OperationOutput<RecognizeUtteranceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecognizeUtteranceOutputError>
}

extension RecognizeUtteranceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecognizeUtteranceInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), inputStream: \(String(describing: inputStream)), localeId: \(String(describing: localeId)), requestAttributes: \(String(describing: requestAttributes)), requestContentType: \(String(describing: requestContentType)), responseContentType: \(String(describing: responseContentType)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)))"}
}

extension RecognizeUtteranceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputStream
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStream = inputStream {
            try encodeContainer.encode(inputStream.base64EncodedString(), forKey: .inputStream)
        }
    }
}

public struct RecognizeUtteranceInputHeadersMiddleware: Middleware {
    public let id: String = "RecognizeUtteranceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecognizeUtteranceInput>,
                  next: H) -> Swift.Result<OperationOutput<RecognizeUtteranceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let requestAttributes = input.operationInput.requestAttributes {
            input.builder.withHeader(name: "x-amz-lex-request-attributes", value: String(requestAttributes))
        }
        if let requestContentType = input.operationInput.requestContentType {
            input.builder.withHeader(name: "Content-Type", value: String(requestContentType))
        }
        if let responseContentType = input.operationInput.responseContentType {
            input.builder.withHeader(name: "Response-Content-Type", value: String(responseContentType))
        }
        if let sessionState = input.operationInput.sessionState {
            input.builder.withHeader(name: "x-amz-lex-session-state", value: String(sessionState))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecognizeUtteranceInput>
    public typealias MOutput = OperationOutput<RecognizeUtteranceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecognizeUtteranceOutputError>
}

public struct RecognizeUtteranceInputQueryItemMiddleware: Middleware {
    public let id: String = "RecognizeUtteranceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecognizeUtteranceInput>,
                  next: H) -> Swift.Result<OperationOutput<RecognizeUtteranceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecognizeUtteranceInput>
    public typealias MOutput = OperationOutput<RecognizeUtteranceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecognizeUtteranceOutputError>
}

public struct RecognizeUtteranceInput: Equatable {
    /// <p>The alias identifier in use for the bot that should receive the
    ///          request.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot that should receive the request.</p>
    public let botId: String?
    /// <p>User input in PCM or Opus audio format or text format as described
    ///          in the <code>requestContentType</code> parameter.</p>
    public let inputStream: Data?
    /// <p>The locale where the session is in use.</p>
    public let localeId: String?
    /// <p>Request-specific information passed between the client application
    ///          and Amazon Lex </p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///          attributes. Don't create any request attributes for prefix
    ///             <code>x-amz-lex:</code>.</p>
    public let requestAttributes: String?
    /// <p>Indicates the format for audio input or that the content is text.
    ///          The header must start with one of the following prefixes:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PCM format, audio data must be in little-endian byte
    ///                order.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/l16; rate=16000; channels=1</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/x-l16; sample-rate=16000; channel-count=1</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/lpcm; sample-rate=8000; sample-size-bits=16;
    ///                      channel-count=1; is-big-endian=false</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Opus format</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Text format</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>text/plain; charset=utf-8</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let requestContentType: String?
    /// <p>The message that Amazon Lex returns in the response can be either text or
    ///          speech based on the <code>responseContentType</code> value.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the value is <code>text/plain;charset=utf-8</code>, Amazon Lex
    ///                returns text in the response.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value begins with <code>audio/</code>, Amazon Lex returns
    ///                speech in the response. Amazon Lex uses Amazon Polly to generate the speech
    ///                using the configuration that you specified in the
    ///                   <code>requestContentType</code> parameter. For example, if you
    ///                specify <code>audio/mpeg</code> as the value, Amazon Lex returns
    ///                speech in the MPEG format.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value is <code>audio/pcm</code>, the speech returned is
    ///                   <code>audio/pcm</code> at 16 KHz in 16-bit, little-endian
    ///                format.</p>
    ///             </li>
    ///             <li>
    ///                <p>The following are the accepted values:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/mpeg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/ogg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/pcm (16 KHz)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/* (defaults to mpeg)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>text/plain; charset=utf-8</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let responseContentType: String?
    /// <p>The identifier of the session in use.</p>
    public let sessionId: String?
    /// <p>Sets the state of the session with the user. You can use this to set
    ///          the current intent, attributes, context, and dialog action. Use the
    ///          dialog action to determine the next step that Amazon Lex should use in the
    ///          conversation with the user.</p>
    public let sessionState: String?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        inputStream: Data? = nil,
        localeId: String? = nil,
        requestAttributes: String? = nil,
        requestContentType: String? = nil,
        responseContentType: String? = nil,
        sessionId: String? = nil,
        sessionState: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.inputStream = inputStream
        self.localeId = localeId
        self.requestAttributes = requestAttributes
        self.requestContentType = requestContentType
        self.responseContentType = responseContentType
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeUtteranceInputBody: Equatable {
    public let inputStream: Data?
}

extension RecognizeUtteranceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStreamDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .inputStream)
        inputStream = inputStreamDecoded
    }
}

extension RecognizeUtteranceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RecognizeUtteranceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RecognizeUtteranceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RecognizeUtteranceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecognizeUtteranceOutputResponse(audioStream: \(String(describing: audioStream)), contentType: \(String(describing: contentType)), inputMode: \(String(describing: inputMode)), inputTranscript: \(String(describing: inputTranscript)), interpretations: \(String(describing: interpretations)), messages: \(String(describing: messages)), requestAttributes: \(String(describing: requestAttributes)), sessionId: \(String(describing: sessionId)), sessionState: \(String(describing: sessionState)))"}
}

extension RecognizeUtteranceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let inputModeHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-mode") {
            self.inputMode = inputModeHeaderValue
        } else {
            self.inputMode = nil
        }
        if let inputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-transcript") {
            self.inputTranscript = inputTranscriptHeaderValue
        } else {
            self.inputTranscript = nil
        }
        if let interpretationsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-interpretations") {
            self.interpretations = interpretationsHeaderValue
        } else {
            self.interpretations = nil
        }
        if let messagesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-messages") {
            self.messages = messagesHeaderValue
        } else {
            self.messages = nil
        }
        if let requestAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-request-attributes") {
            self.requestAttributes = requestAttributesHeaderValue
        } else {
            self.requestAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let sessionStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-state") {
            self.sessionState = sessionStateHeaderValue
        } else {
            self.sessionState = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.audioStream = unwrappedData
        } else {
            self.audioStream = nil
        }
    }
}

public struct RecognizeUtteranceOutputResponse: Equatable {
    /// <p>The prompt or statement to send to the user. This is based on the
    ///          bot configuration and context. For example, if Amazon Lex did not understand
    ///          the user intent, it sends the <code>clarificationPrompt</code>
    ///          configured for the bot. If the intent requires confirmation before
    ///          taking the fulfillment action, it sends the
    ///             <code>confirmationPrompt</code>. Another example: Suppose that the
    ///          Lambda function successfully fulfilled the intent, and sent a message
    ///          to convey to the user. Then Amazon Lex sends that message in the
    ///          response.</p>
    public let audioStream: Data?
    /// <p>Content type as specified in the <code>responseContentType</code> in
    ///          the request.</p>
    public let contentType: String?
    /// <p>Indicates whether the input mode to the operation was text or
    ///          speech.
    ///       </p>
    public let inputMode: String?
    /// <p>The text used to process the request.</p>
    ///          <p>If the input was an audio stream, the <code>inputTranscript</code>
    ///          field contains the text extracted from the audio stream. This is the
    ///          text that is actually processed to recognize intents and slot values.
    ///          You can use this information to determine if Amazon Lex is correctly
    ///          processing the audio that you send.</p>
    public let inputTranscript: String?
    /// <p>A list of intents that Amazon Lex determined might satisfy the user's
    ///          utterance.</p>
    ///          <p>Each interpretation includes the intent, a score that indicates how
    ///          confident Amazon Lex is that the interpretation is the correct one, and an
    ///          optional sentiment response that indicates the sentiment expressed in
    ///          the utterance.</p>
    public let interpretations: String?
    /// <p>A list of messages that were last sent to the user. The messages are
    ///          ordered based on the order that you returned the messages from your
    ///          Lambda function or the order that the messages are defined in the
    ///          bot.</p>
    public let messages: String?
    /// <p>The attributes sent in the request.</p>
    public let requestAttributes: String?
    /// <p>The identifier of the session in use.</p>
    public let sessionId: String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot.</p>
    ///          <p>Use this to determine the progress of the conversation and what the
    ///          next action might be.</p>
    public let sessionState: String?

    public init (
        audioStream: Data? = nil,
        contentType: String? = nil,
        inputMode: String? = nil,
        inputTranscript: String? = nil,
        interpretations: String? = nil,
        messages: String? = nil,
        requestAttributes: String? = nil,
        sessionId: String? = nil,
        sessionState: String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.inputMode = inputMode
        self.inputTranscript = inputTranscript
        self.interpretations = interpretations
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeUtteranceOutputResponseBody: Equatable {
    public let audioStream: Data?
}

extension RecognizeUtteranceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audioStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension ResourceNotFoundException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SentimentResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sentiment
        case sentimentScore
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sentiment = sentiment {
            try encodeContainer.encode(sentiment.rawValue, forKey: .sentiment)
        }
        if let sentimentScore = sentimentScore {
            try encodeContainer.encode(sentimentScore, forKey: .sentimentScore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentDecoded = try containerValues.decodeIfPresent(SentimentType.self, forKey: .sentiment)
        sentiment = sentimentDecoded
        let sentimentScoreDecoded = try containerValues.decodeIfPresent(SentimentScore.self, forKey: .sentimentScore)
        sentimentScore = sentimentScoreDecoded
    }
}

extension SentimentResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SentimentResponse(sentiment: \(String(describing: sentiment)), sentimentScore: \(String(describing: sentimentScore)))"}
}

/// <p>Provides information about the sentiment expressed in a user's
///          response in a conversation. Sentiments are determined using Amazon
///          Comprehend. Sentiments are only returned if they are enabled for the
///          bot.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-sentiment.html">
///             Determine Sentiment </a> in the <i>Amazon Comprehend
///             developer guide</i>.</p>
public struct SentimentResponse: Equatable {
    /// <p>The overall sentiment expressed in the user's response. This is the
    ///          sentiment most likely expressed by the user based on the analysis by
    ///          Amazon Comprehend.</p>
    public let sentiment: SentimentType?
    /// <p>The individual sentiment responses for the utterance.</p>
    public let sentimentScore: SentimentScore?

    public init (
        sentiment: SentimentType? = nil,
        sentimentScore: SentimentScore? = nil
    )
    {
        self.sentiment = sentiment
        self.sentimentScore = sentimentScore
    }
}

extension SentimentScore: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mixed
        case negative
        case neutral
        case positive
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if mixed != 0.0 {
            try encodeContainer.encode(mixed, forKey: .mixed)
        }
        if negative != 0.0 {
            try encodeContainer.encode(negative, forKey: .negative)
        }
        if neutral != 0.0 {
            try encodeContainer.encode(neutral, forKey: .neutral)
        }
        if positive != 0.0 {
            try encodeContainer.encode(positive, forKey: .positive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positiveDecoded = try containerValues.decode(Double.self, forKey: .positive)
        positive = positiveDecoded
        let negativeDecoded = try containerValues.decode(Double.self, forKey: .negative)
        negative = negativeDecoded
        let neutralDecoded = try containerValues.decode(Double.self, forKey: .neutral)
        neutral = neutralDecoded
        let mixedDecoded = try containerValues.decode(Double.self, forKey: .mixed)
        mixed = mixedDecoded
    }
}

extension SentimentScore: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SentimentScore(mixed: \(String(describing: mixed)), negative: \(String(describing: negative)), neutral: \(String(describing: neutral)), positive: \(String(describing: positive)))"}
}

/// <p>The individual sentiment responses for the utterance.</p>
public struct SentimentScore: Equatable {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy
    ///          of its detection of the <code>MIXED</code> sentiment.</p>
    public let mixed: Double
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy
    ///          of its detection of the <code>NEGATIVE</code> sentiment.</p>
    public let negative: Double
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy
    ///          of its detection of the <code>NEUTRAL</code> sentiment.</p>
    public let neutral: Double
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy
    ///          of its detection of the <code>POSITIVE</code> sentiment.</p>
    public let positive: Double

    public init (
        mixed: Double = 0.0,
        negative: Double = 0.0,
        neutral: Double = 0.0,
        positive: Double = 0.0
    )
    {
        self.mixed = mixed
        self.negative = negative
        self.neutral = neutral
        self.positive = positive
    }
}

public enum SentimentType {
    case mixed
    case negative
    case neutral
    case positive
    case sdkUnknown(String)
}

extension SentimentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SentimentType] {
        return [
            .mixed,
            .negative,
            .neutral,
            .positive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mixed: return "MIXED"
        case .negative: return "NEGATIVE"
        case .neutral: return "NEUTRAL"
        case .positive: return "POSITIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SentimentType(rawValue: rawValue) ?? SentimentType.sdkUnknown(rawValue)
    }
}

extension SessionState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeContexts
        case dialogAction
        case intent
        case originatingRequestId
        case sessionAttributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontextslist0 in activeContexts {
                try activeContextsContainer.encode(activecontextslist0)
            }
        }
        if let dialogAction = dialogAction {
            try encodeContainer.encode(dialogAction, forKey: .dialogAction)
        }
        if let intent = intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let originatingRequestId = originatingRequestId {
            try encodeContainer.encode(originatingRequestId, forKey: .originatingRequestId)
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringmap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dialogActionDecoded = try containerValues.decodeIfPresent(DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let intentDecoded = try containerValues.decodeIfPresent(Intent.self, forKey: .intent)
        intent = intentDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
        let sessionAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [String:String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [String:String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let originatingRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originatingRequestId)
        originatingRequestId = originatingRequestIdDecoded
    }
}

extension SessionState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionState(activeContexts: \(String(describing: activeContexts)), dialogAction: \(String(describing: dialogAction)), intent: \(String(describing: intent)), originatingRequestId: \(String(describing: originatingRequestId)), sessionAttributes: \(String(describing: sessionAttributes)))"}
}

/// <p>The state of the user's session with Amazon Lex.</p>
public struct SessionState: Equatable {
    /// <p>One or more contexts that indicate to Amazon Lex the context of a
    ///          request. When a context is active, Amazon Lex considers intents with the
    ///          matching context as a trigger as the next intent in a session.</p>
    public let activeContexts: [ActiveContext]?
    /// <p>The next step that Amazon Lex should take in the conversation with a
    ///          user.</p>
    public let dialogAction: DialogAction?
    /// <p>The active intent that Amazon Lex is processing.</p>
    public let intent: Intent?
    /// <p></p>
    public let originatingRequestId: String?
    /// <p>Map of key/value pairs representing session-specific context
    ///          information. It contains application information passed between Amazon Lex
    ///          and a client application.</p>
    public let sessionAttributes: [String:String]?

    public init (
        activeContexts: [ActiveContext]? = nil,
        dialogAction: DialogAction? = nil,
        intent: Intent? = nil,
        originatingRequestId: String? = nil,
        sessionAttributes: [String:String]? = nil
    )
    {
        self.activeContexts = activeContexts
        self.dialogAction = dialogAction
        self.intent = intent
        self.originatingRequestId = originatingRequestId
        self.sessionAttributes = sessionAttributes
    }
}

extension Slot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Value.self, forKey: .value)
        value = valueDecoded
    }
}

extension Slot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Slot(value: \(String(describing: value)))"}
}

/// <p>A value that Amazon Lex uses to fulfill an intent. </p>
public struct Slot: Equatable {
    /// <p>The current value of the slot.</p>
    public let value: Value?

    public init (
        value: Value? = nil
    )
    {
        self.value = value
    }
}

public struct StartConversationInputBodyMiddleware: Middleware {
    public let id: String = "StartConversationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConversationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConversationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let requestEventStream = input.operationInput.requestEventStream {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(requestEventStream)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConversationInput>
    public typealias MOutput = OperationOutput<StartConversationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConversationOutputError>
}

extension StartConversationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartConversationInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), conversationMode: \(String(describing: conversationMode)), localeId: \(String(describing: localeId)), requestEventStream: \(String(describing: requestEventStream)), sessionId: \(String(describing: sessionId)))"}
}

extension StartConversationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case requestEventStream
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestEventStream = requestEventStream {
            try encodeContainer.encode(requestEventStream, forKey: .requestEventStream)
        }
    }
}

public struct StartConversationInputHeadersMiddleware: Middleware {
    public let id: String = "StartConversationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConversationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConversationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let conversationMode = input.operationInput.conversationMode {
            input.builder.withHeader(name: "x-amz-lex-conversation-mode", value: String(conversationMode.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConversationInput>
    public typealias MOutput = OperationOutput<StartConversationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConversationOutputError>
}

public struct StartConversationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartConversationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConversationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConversationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConversationInput>
    public typealias MOutput = OperationOutput<StartConversationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConversationOutputError>
}

public struct StartConversationInput: Equatable {
    /// <p>The alias identifier in use for the bot that processes the
    ///          request.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot to process the request.</p>
    public let botId: String?
    /// <p>The conversation type that you are using the Amazon Lex. If the
    ///          conversation mode is <code>AUDIO</code> you can send both audio and
    ///          DTMF information. If the mode is <code>TEXT</code> you can only send
    ///          text.</p>
    public let conversationMode: ConversationMode?
    /// <p>The locale where the session is in use.</p>
    public let localeId: String?
    /// <p>Represents the stream of events to Amazon Lex from your application. The
    ///          events are encoded as HTTP/2 data frames.</p>
    public let requestEventStream: StartConversationRequestEventStream?
    /// <p>The identifier of the user session that is having the
    ///          conversation.</p>
    public let sessionId: String?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        conversationMode: ConversationMode? = nil,
        localeId: String? = nil,
        requestEventStream: StartConversationRequestEventStream? = nil,
        sessionId: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.conversationMode = conversationMode
        self.localeId = localeId
        self.requestEventStream = requestEventStream
        self.sessionId = sessionId
    }
}

struct StartConversationInputBody: Equatable {
    public let requestEventStream: StartConversationRequestEventStream?
}

extension StartConversationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestEventStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestEventStreamDecoded = try containerValues.decodeIfPresent(StartConversationRequestEventStream.self, forKey: .requestEventStream)
        requestEventStream = requestEventStreamDecoded
    }
}

extension StartConversationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConversationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartConversationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConversationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartConversationOutputResponse(responseEventStream: \(String(describing: responseEventStream)))"}
}

extension StartConversationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StartConversationResponseEventStream = try responseDecoder.decode(responseBody: unwrappedData)
                self.responseEventStream = output
            } else {
                self.responseEventStream = nil
            }
        } else {
            self.responseEventStream = nil
        }
    }
}

public struct StartConversationOutputResponse: Equatable {
    /// <p>Represents the stream of events from Amazon Lex to your application. The
    ///          events are encoded as HTTP/2 data frames.</p>
    public let responseEventStream: StartConversationResponseEventStream?

    public init (
        responseEventStream: StartConversationResponseEventStream? = nil
    )
    {
        self.responseEventStream = responseEventStream
    }
}

struct StartConversationOutputResponseBody: Equatable {
    public let responseEventStream: StartConversationResponseEventStream?
}

extension StartConversationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responseEventStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseEventStreamDecoded = try containerValues.decodeIfPresent(StartConversationResponseEventStream.self, forKey: .responseEventStream)
        responseEventStream = responseEventStreamDecoded
    }
}

extension StartConversationRequestEventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioInputEvent = "AudioInputEvent"
        case configurationEvent = "ConfigurationEvent"
        case dTMFInputEvent = "DTMFInputEvent"
        case disconnectionEvent = "DisconnectionEvent"
        case playbackCompletionEvent = "PlaybackCompletionEvent"
        case textInputEvent = "TextInputEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .audioInputEvent(audioInputEvent):
                if let audioInputEvent = audioInputEvent {
                    try container.encode(audioInputEvent, forKey: .audioInputEvent)
                }
            case let .configurationEvent(configurationEvent):
                if let configurationEvent = configurationEvent {
                    try container.encode(configurationEvent, forKey: .configurationEvent)
                }
            case let .dTMFInputEvent(dTMFInputEvent):
                if let dTMFInputEvent = dTMFInputEvent {
                    try container.encode(dTMFInputEvent, forKey: .dTMFInputEvent)
                }
            case let .disconnectionEvent(disconnectionEvent):
                if let disconnectionEvent = disconnectionEvent {
                    try container.encode(disconnectionEvent, forKey: .disconnectionEvent)
                }
            case let .playbackCompletionEvent(playbackCompletionEvent):
                if let playbackCompletionEvent = playbackCompletionEvent {
                    try container.encode(playbackCompletionEvent, forKey: .playbackCompletionEvent)
                }
            case let .textInputEvent(textInputEvent):
                if let textInputEvent = textInputEvent {
                    try container.encode(textInputEvent, forKey: .textInputEvent)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let configurationEventDecoded = try values.decodeIfPresent(ConfigurationEvent.self, forKey: .configurationEvent)
        if let configurationEvent = configurationEventDecoded {
            self = .configurationEvent(configurationEvent)
            return
        }
        let audioInputEventDecoded = try values.decodeIfPresent(AudioInputEvent.self, forKey: .audioInputEvent)
        if let audioInputEvent = audioInputEventDecoded {
            self = .audioInputEvent(audioInputEvent)
            return
        }
        let dTMFInputEventDecoded = try values.decodeIfPresent(DTMFInputEvent.self, forKey: .dTMFInputEvent)
        if let dTMFInputEvent = dTMFInputEventDecoded {
            self = .dTMFInputEvent(dTMFInputEvent)
            return
        }
        let textInputEventDecoded = try values.decodeIfPresent(TextInputEvent.self, forKey: .textInputEvent)
        if let textInputEvent = textInputEventDecoded {
            self = .textInputEvent(textInputEvent)
            return
        }
        let playbackCompletionEventDecoded = try values.decodeIfPresent(PlaybackCompletionEvent.self, forKey: .playbackCompletionEvent)
        if let playbackCompletionEvent = playbackCompletionEventDecoded {
            self = .playbackCompletionEvent(playbackCompletionEvent)
            return
        }
        let disconnectionEventDecoded = try values.decodeIfPresent(DisconnectionEvent.self, forKey: .disconnectionEvent)
        if let disconnectionEvent = disconnectionEventDecoded {
            self = .disconnectionEvent(disconnectionEvent)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Represents a stream of events between your application and
///          Amazon Lex.</p>
public enum StartConversationRequestEventStream: Equatable {
    /// <p>Configuration information sent from your client application to
    ///          Amazon Lex</p>
    case configurationEvent(ConfigurationEvent?)
    /// <p>Speech audio sent from your client application to Amazon Lex. Audio
    ///          starts accumulating when Amazon Lex identifies a voice and continues until a
    ///          natural pause in the speech is found before processing.</p>
    case audioInputEvent(AudioInputEvent?)
    /// <p>DTMF information sent to Amazon Lex by your application. Amazon Lex
    ///          accumulates the DMTF information from when the user sends the first
    ///          character and ends</p>
    ///          <ul>
    ///             <li>
    ///                <p>when there's a pause longer that the value configured for the
    ///                end timeout.</p>
    ///             </li>
    ///             <li>
    ///                <p>when there's a digit that is the configured end
    ///                character.</p>
    ///             </li>
    ///             <li>
    ///                <p>when Amazon Lex accumulates characters equal to the maximum DTMF
    ///                character configuration.</p>
    ///             </li>
    ///          </ul>
    case dTMFInputEvent(DTMFInputEvent?)
    /// <p>Text sent from your client application to Amazon Lex. Each
    ///             <code>TextInputEvent</code> is processed individually.</p>
    case textInputEvent(TextInputEvent?)
    /// <p>Event sent from the client application to Amazon Lex to indicate that it
    ///          has finished playing audio and that Amazon Lex should start listening for
    ///          user input.</p>
    case playbackCompletionEvent(PlaybackCompletionEvent?)
    /// <p>Event sent from the client application to indicate to Amazon Lex that the
    ///          conversation is over.</p>
    case disconnectionEvent(DisconnectionEvent?)
    case sdkUnknown(String?)
}

extension StartConversationResponseEventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessDeniedException = "AccessDeniedException"
        case audioResponseEvent = "AudioResponseEvent"
        case badGatewayException = "BadGatewayException"
        case conflictException = "ConflictException"
        case dependencyFailedException = "DependencyFailedException"
        case heartbeatEvent = "HeartbeatEvent"
        case intentResultEvent = "IntentResultEvent"
        case internalServerException = "InternalServerException"
        case playbackInterruptionEvent = "PlaybackInterruptionEvent"
        case resourceNotFoundException = "ResourceNotFoundException"
        case textResponseEvent = "TextResponseEvent"
        case throttlingException = "ThrottlingException"
        case transcriptEvent = "TranscriptEvent"
        case validationException = "ValidationException"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accessDeniedException(accessDeniedException):
                if let accessDeniedException = accessDeniedException {
                    try container.encode(accessDeniedException, forKey: .accessDeniedException)
                }
            case let .audioResponseEvent(audioResponseEvent):
                if let audioResponseEvent = audioResponseEvent {
                    try container.encode(audioResponseEvent, forKey: .audioResponseEvent)
                }
            case let .badGatewayException(badGatewayException):
                if let badGatewayException = badGatewayException {
                    try container.encode(badGatewayException, forKey: .badGatewayException)
                }
            case let .conflictException(conflictException):
                if let conflictException = conflictException {
                    try container.encode(conflictException, forKey: .conflictException)
                }
            case let .dependencyFailedException(dependencyFailedException):
                if let dependencyFailedException = dependencyFailedException {
                    try container.encode(dependencyFailedException, forKey: .dependencyFailedException)
                }
            case let .heartbeatEvent(heartbeatEvent):
                if let heartbeatEvent = heartbeatEvent {
                    try container.encode(heartbeatEvent, forKey: .heartbeatEvent)
                }
            case let .intentResultEvent(intentResultEvent):
                if let intentResultEvent = intentResultEvent {
                    try container.encode(intentResultEvent, forKey: .intentResultEvent)
                }
            case let .internalServerException(internalServerException):
                if let internalServerException = internalServerException {
                    try container.encode(internalServerException, forKey: .internalServerException)
                }
            case let .playbackInterruptionEvent(playbackInterruptionEvent):
                if let playbackInterruptionEvent = playbackInterruptionEvent {
                    try container.encode(playbackInterruptionEvent, forKey: .playbackInterruptionEvent)
                }
            case let .resourceNotFoundException(resourceNotFoundException):
                if let resourceNotFoundException = resourceNotFoundException {
                    try container.encode(resourceNotFoundException, forKey: .resourceNotFoundException)
                }
            case let .textResponseEvent(textResponseEvent):
                if let textResponseEvent = textResponseEvent {
                    try container.encode(textResponseEvent, forKey: .textResponseEvent)
                }
            case let .throttlingException(throttlingException):
                if let throttlingException = throttlingException {
                    try container.encode(throttlingException, forKey: .throttlingException)
                }
            case let .transcriptEvent(transcriptEvent):
                if let transcriptEvent = transcriptEvent {
                    try container.encode(transcriptEvent, forKey: .transcriptEvent)
                }
            case let .validationException(validationException):
                if let validationException = validationException {
                    try container.encode(validationException, forKey: .validationException)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let playbackInterruptionEventDecoded = try values.decodeIfPresent(PlaybackInterruptionEvent.self, forKey: .playbackInterruptionEvent)
        if let playbackInterruptionEvent = playbackInterruptionEventDecoded {
            self = .playbackInterruptionEvent(playbackInterruptionEvent)
            return
        }
        let transcriptEventDecoded = try values.decodeIfPresent(TranscriptEvent.self, forKey: .transcriptEvent)
        if let transcriptEvent = transcriptEventDecoded {
            self = .transcriptEvent(transcriptEvent)
            return
        }
        let intentResultEventDecoded = try values.decodeIfPresent(IntentResultEvent.self, forKey: .intentResultEvent)
        if let intentResultEvent = intentResultEventDecoded {
            self = .intentResultEvent(intentResultEvent)
            return
        }
        let textResponseEventDecoded = try values.decodeIfPresent(TextResponseEvent.self, forKey: .textResponseEvent)
        if let textResponseEvent = textResponseEventDecoded {
            self = .textResponseEvent(textResponseEvent)
            return
        }
        let audioResponseEventDecoded = try values.decodeIfPresent(AudioResponseEvent.self, forKey: .audioResponseEvent)
        if let audioResponseEvent = audioResponseEventDecoded {
            self = .audioResponseEvent(audioResponseEvent)
            return
        }
        let heartbeatEventDecoded = try values.decodeIfPresent(HeartbeatEvent.self, forKey: .heartbeatEvent)
        if let heartbeatEvent = heartbeatEventDecoded {
            self = .heartbeatEvent(heartbeatEvent)
            return
        }
        let accessDeniedExceptionDecoded = try values.decodeIfPresent(AccessDeniedException.self, forKey: .accessDeniedException)
        if let accessDeniedException = accessDeniedExceptionDecoded {
            self = .accessDeniedException(accessDeniedException)
            return
        }
        let resourceNotFoundExceptionDecoded = try values.decodeIfPresent(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
        if let resourceNotFoundException = resourceNotFoundExceptionDecoded {
            self = .resourceNotFoundException(resourceNotFoundException)
            return
        }
        let validationExceptionDecoded = try values.decodeIfPresent(ValidationException.self, forKey: .validationException)
        if let validationException = validationExceptionDecoded {
            self = .validationException(validationException)
            return
        }
        let throttlingExceptionDecoded = try values.decodeIfPresent(ThrottlingException.self, forKey: .throttlingException)
        if let throttlingException = throttlingExceptionDecoded {
            self = .throttlingException(throttlingException)
            return
        }
        let internalServerExceptionDecoded = try values.decodeIfPresent(InternalServerException.self, forKey: .internalServerException)
        if let internalServerException = internalServerExceptionDecoded {
            self = .internalServerException(internalServerException)
            return
        }
        let conflictExceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictException)
        if let conflictException = conflictExceptionDecoded {
            self = .conflictException(conflictException)
            return
        }
        let dependencyFailedExceptionDecoded = try values.decodeIfPresent(DependencyFailedException.self, forKey: .dependencyFailedException)
        if let dependencyFailedException = dependencyFailedExceptionDecoded {
            self = .dependencyFailedException(dependencyFailedException)
            return
        }
        let badGatewayExceptionDecoded = try values.decodeIfPresent(BadGatewayException.self, forKey: .badGatewayException)
        if let badGatewayException = badGatewayExceptionDecoded {
            self = .badGatewayException(badGatewayException)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Represents a stream of events between Amazon Lex and your
///          application.</p>
public enum StartConversationResponseEventStream: Equatable {
    /// <p>Event sent from Amazon Lex to indicate to the client application should
    ///          stop playback of audio. For example, if the client is playing a prompt
    ///          that asks for the user's telephone number, the user might start to say
    ///          the phone number before the prompt is complete. Amazon Lex sends this event
    ///          to the client application to indicate that the user is responding and
    ///          that Amazon Lex is processing their input.</p>
    case playbackInterruptionEvent(PlaybackInterruptionEvent?)
    /// <p>Event sent from Amazon Lex to your client application that contains a
    ///          transcript of voice audio. </p>
    case transcriptEvent(TranscriptEvent?)
    /// <p>Event sent from Amazon Lex to the client application containing the
    ///          current state of the conversation between the user and Amazon Lex.</p>
    case intentResultEvent(IntentResultEvent?)
    /// <p>The event sent from Amazon Lex to your application with text to present
    ///          to the user.</p>
    case textResponseEvent(TextResponseEvent?)
    /// <p>An event sent from Amazon Lex to your client application containing audio
    ///          to play to the user. </p>
    case audioResponseEvent(AudioResponseEvent?)
    /// <p>Event that Amazon Lex sends to indicate that the stream is still open
    ///          between the client application and Amazon Lex </p>
    case heartbeatEvent(HeartbeatEvent?)
    /// <p>Exception thrown when the credentials passed with the request are
    ///          invalid or expired. Also thrown when the credentials in the request do
    ///          not have permission to access the <code>StartConversation</code>
    ///          operation.</p>
    case accessDeniedException(AccessDeniedException?)
    /// <p>Exception thrown if one of the input parameters points to a resource
    ///          that does not exist. For example, if the bot ID specified does not
    ///          exist.</p>
    case resourceNotFoundException(ResourceNotFoundException?)
    /// <p>Exception thrown when one or more parameters could not be validated.
    ///          The <code>message</code> contains the name of the field that isn't
    ///          valid.</p>
    case validationException(ValidationException?)
    /// <p>Exception thrown when your application exceeds the maximum number of
    ///          concurrent requests. </p>
    case throttlingException(ThrottlingException?)
    /// <p>An error occurred with Amazon Lex.</p>
    case internalServerException(InternalServerException?)
    /// <p>Exception thrown when two clients are using the same AWS account,
    ///          Amazon Lex bot, and session ID.</p>
    case conflictException(ConflictException?)
    /// <p></p>
    case dependencyFailedException(DependencyFailedException?)
    /// <p></p>
    case badGatewayException(BadGatewayException?)
    case sdkUnknown(String?)
}

extension TextInputEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientTimestampMillis
        case eventId
        case text
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension TextInputEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextInputEvent(clientTimestampMillis: \(String(describing: clientTimestampMillis)), eventId: \(String(describing: eventId)), text: \(String(describing: text)))"}
}

/// <p>The event sent from your client application to Amazon Lex with text input
///          from the user.</p>
public struct TextInputEvent: Equatable {
    /// <p>A timestamp set by the client of the date and time that the event
    ///          was sent to Amazon Lex.</p>
    public let clientTimestampMillis: Int
    /// <p>A unique identifier that your application assigns to the event. You
    ///          can use this to identify events in logs.</p>
    public let eventId: String?
    /// <p>The text from the user. Amazon Lex processes this as a complete
    ///          statement.</p>
    public let text: String?

    public init (
        clientTimestampMillis: Int = 0,
        eventId: String? = nil,
        text: String? = nil
    )
    {
        self.clientTimestampMillis = clientTimestampMillis
        self.eventId = eventId
        self.text = text
    }
}

extension TextResponseEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
        case messages
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .messages)
        var messagesDecoded0:[Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension TextResponseEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextResponseEvent(eventId: \(String(describing: eventId)), messages: \(String(describing: messages)))"}
}

/// <p>The event sent from Amazon Lex to your application with text to present
///          to the user.</p>
public struct TextResponseEvent: Equatable {
    /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
    ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
    ///          and incremented for each event sent by Amazon Lex in the current
    ///          session.</p>
    public let eventId: String?
    /// <p>A list of messages to send to the user. Messages are ordered based
    ///          on the order that you returned the messages from your Lambda function
    ///          or the order that the messages are defined in the bot.</p>
    public let messages: [Message]?

    public init (
        eventId: String? = nil,
        messages: [Message]? = nil
    )
    {
        self.eventId = eventId
        self.messages = messages
    }
}

extension ThrottlingException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscriptEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
        case transcript
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transcript)
        transcript = transcriptDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension TranscriptEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TranscriptEvent(eventId: \(String(describing: eventId)), transcript: \(String(describing: transcript)))"}
}

/// <p>Event sent from Amazon Lex to your client application that contains a
///          transcript of voice audio. </p>
public struct TranscriptEvent: Equatable {
    /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
    ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
    ///          and incremented for each event sent by Amazon Lex in the current
    ///          session.</p>
    public let eventId: String?
    /// <p>The transcript of the voice audio from the user.</p>
    public let transcript: String?

    public init (
        eventId: String? = nil,
        transcript: String? = nil
    )
    {
        self.eventId = eventId
        self.transcript = transcript
    }
}

extension ValidationException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Value: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interpretedValue
        case originalValue
        case resolvedValues
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interpretedValue = interpretedValue {
            try encodeContainer.encode(interpretedValue, forKey: .interpretedValue)
        }
        if let originalValue = originalValue {
            try encodeContainer.encode(originalValue, forKey: .originalValue)
        }
        if let resolvedValues = resolvedValues {
            var resolvedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resolvedValues)
            for stringlist0 in resolvedValues {
                try resolvedValuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originalValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originalValue)
        originalValue = originalValueDecoded
        let interpretedValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interpretedValue)
        interpretedValue = interpretedValueDecoded
        let resolvedValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resolvedValues)
        var resolvedValuesDecoded0:[String]? = nil
        if let resolvedValuesContainer = resolvedValuesContainer {
            resolvedValuesDecoded0 = [String]()
            for string0 in resolvedValuesContainer {
                if let string0 = string0 {
                    resolvedValuesDecoded0?.append(string0)
                }
            }
        }
        resolvedValues = resolvedValuesDecoded0
    }
}

extension Value: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Value(interpretedValue: \(String(describing: interpretedValue)), originalValue: \(String(describing: originalValue)), resolvedValues: \(String(describing: resolvedValues)))"}
}

/// <p>The value of a slot.</p>
public struct Value: Equatable {
    /// <p>The value that Amazon Lex determines for the slot. The actual value
    ///          depends on the setting of the value selection strategy for the bot. You
    ///          can choose to use the value entered by the user, or you can have Amazon Lex
    ///          choose the first value in the <code>resolvedValues</code> list.</p>
    public let interpretedValue: String?
    /// <p>The text of the utterance from the user that was entered for the
    ///          slot.</p>
    public let originalValue: String?
    /// <p>A list of additional values that have been recognized for the
    ///          slot.</p>
    public let resolvedValues: [String]?

    public init (
        interpretedValue: String? = nil,
        originalValue: String? = nil,
        resolvedValues: [String]? = nil
    )
    {
        self.interpretedValue = interpretedValue
        self.originalValue = originalValue
        self.resolvedValues = resolvedValues
    }
}
