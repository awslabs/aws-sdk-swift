// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class SecretsManagerClient {
    let client: SdkHttpClient
    let config: SecretsManagerClientConfiguration
    let serviceName = "Secrets Manager"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: SecretsManagerClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class SecretsManagerClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> SecretsManagerClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try SecretsManagerClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension SecretsManagerClient: SecretsManagerClientProtocol {
    /// <p>Disables automatic scheduled rotation and cancels the rotation of a secret if currently in
    ///       progress.</p>
    ///          <p>To re-enable scheduled rotation, call <a>RotateSecret</a> with
    ///         <code>AutomaticallyRotateAfterDays</code> set to a value greater than 0. This immediately
    ///       rotates your secret and then enables the automatic schedule.</p>
    ///          <note>
    ///             <p>If you cancel a rotation while in progress, it can leave the <code>VersionStage</code>
    ///         labels in an unexpected state. Depending on the step of the rotation in progress, you might
    ///         need to remove the staging label <code>AWSPENDING</code> from the partially created version, specified
    ///         by the <code>VersionId</code> response value. You should also evaluate the partially rotated
    ///         new version to see if it should be deleted, which you can do by removing all staging labels
    ///         from the new version <code>VersionStage</code> field.</p>
    ///          </note>
    ///          <p>To successfully start a rotation, the staging label <code>AWSPENDING</code> must be in one of the
    ///       following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Not attached to any version at all</p>
    ///             </li>
    ///             <li>
    ///                <p>Attached to the same version as the staging label <code>AWSCURRENT</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>If the staging label <code>AWSPENDING</code> attached to a different version than the version with
    ///       <code>AWSCURRENT</code> then the attempt to rotate fails.</p>
    ///
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:CancelRotateSecret</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To configure rotation for a secret or to manually trigger a rotation, use <a>RotateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To get the rotation configuration details for a secret, use <a>DescribeSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list all of the versions currently associated with a secret, use <a>ListSecretVersionIds</a>.</p>
    ///             </li>
    ///          </ul>
    public func cancelRotateSecret(input: CancelRotateSecretInput, completion: @escaping (SdkResult<CancelRotateSecretOutputResponse, CancelRotateSecretOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelRotateSecret")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelRotateSecretInput, CancelRotateSecretOutputResponse, CancelRotateSecretOutputError>(id: "cancelRotateSecret")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelRotateSecretInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelRotateSecretInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelRotateSecretInput, CancelRotateSecretOutputResponse, CancelRotateSecretOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CancelRotateSecretInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CancelRotateSecretInput, CancelRotateSecretOutputResponse, CancelRotateSecretOutputError>(xAmzTarget: "secretsmanager.CancelRotateSecret"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new secret. A secret in Secrets Manager consists of both the protected secret data and the
    ///       important information needed to manage the secret.</p>
    ///          <p>Secrets Manager stores the encrypted secret data in one of a collection of "versions"
    ///       associated with the secret. Each version contains a copy of the encrypted secret data. Each
    ///       version is associated with one or more "staging labels" that identify where the version is in
    ///       the rotation cycle. The <code>SecretVersionsToStages</code> field of the secret contains the
    ///       mapping of staging labels to the active versions of the secret. Versions without a staging
    ///       label are considered deprecated and not included in the list.</p>
    ///          <p>You provide the secret data to be encrypted by putting text in either the
    ///         <code>SecretString</code> parameter or binary data in the <code>SecretBinary</code>
    ///       parameter, but not both. If you include <code>SecretString</code> or <code>SecretBinary</code>
    ///       then Secrets Manager also creates an initial secret version and automatically attaches the staging
    ///       label <code>AWSCURRENT</code> to the new version.</p>
    ///          <note>
    ///             <ul>
    ///                <li>
    ///                   <p>If you call an operation to encrypt or decrypt the <code>SecretString</code>
    ///           or <code>SecretBinary</code> for a secret in the same account as the calling user and that
    ///           secret doesn't specify a AWS KMS encryption key, Secrets Manager uses the account's default
    ///           AWS managed customer master key (CMK) with the alias <code>aws/secretsmanager</code>. If this key
    ///           doesn't already exist in your account then Secrets Manager creates it for you automatically. All
    ///           users and roles in the same AWS account automatically have access to use the default CMK.
    ///           Note that if an Secrets Manager API call results in AWS creating the account's
    ///           AWS-managed CMK, it can result in a one-time significant delay in returning the
    ///           result.</p>
    ///                </li>
    ///                <li>
    ///                   <p>If the secret resides in a different AWS account from the credentials calling an API that
    ///           requires encryption or decryption of the secret value then you must create and use a custom
    ///           AWS KMS CMK because you can't access the default CMK for the account using credentials
    ///           from a different AWS account. Store the ARN of the CMK in the secret when you create the
    ///           secret or when you update it by including it in the <code>KMSKeyId</code>. If you call an
    ///           API that must encrypt or decrypt <code>SecretString</code> or <code>SecretBinary</code>
    ///           using credentials from a different account then the AWS KMS key policy must grant cross-account
    ///           access to that other account's user or role for both the kms:GenerateDataKey and
    ///           kms:Decrypt operations.</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    ///          <p> </p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:CreateSecret</p>
    ///             </li>
    ///             <li>
    ///                <p>kms:GenerateDataKey - needed only if you use a customer-managed AWS KMS key to encrypt
    ///           the secret. You do not need this permission to use the account default AWS managed CMK
    ///           for Secrets Manager.</p>
    ///             </li>
    ///             <li>
    ///                <p>kms:Decrypt - needed only if you use a customer-managed AWS KMS key to encrypt the
    ///           secret. You do not need this permission to use the account default AWS managed CMK for
    ///           Secrets Manager.</p>
    ///             </li>
    ///             <li>
    ///                <p>secretsmanager:TagResource - needed only if you include the <code>Tags</code>
    ///           parameter. </p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To delete a secret, use <a>DeleteSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To modify an existing secret, use <a>UpdateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To create a new version of a secret, use <a>PutSecretValue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To retrieve the encrypted secure string and secure binary values, use <a>GetSecretValue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To retrieve all other details for a secret, use <a>DescribeSecret</a>. This
    ///           does not include the encrypted secure string and secure binary values.</p>
    ///             </li>
    ///             <li>
    ///                <p>To retrieve the list of secret versions associated with the current secret, use <a>DescribeSecret</a> and examine the <code>SecretVersionsToStages</code> response
    ///           value.</p>
    ///             </li>
    ///          </ul>
    public func createSecret(input: CreateSecretInput, completion: @escaping (SdkResult<CreateSecretOutputResponse, CreateSecretOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSecret")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSecretInput, CreateSecretOutputResponse, CreateSecretOutputError>(id: "createSecret")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateSecretOutputResponse>, SdkError<CreateSecretOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateSecretInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSecretInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSecretInput, CreateSecretOutputResponse, CreateSecretOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSecretInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateSecretInput, CreateSecretOutputResponse, CreateSecretOutputError>(xAmzTarget: "secretsmanager.CreateSecret"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the resource-based permission policy attached to the secret.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:DeleteResourcePolicy</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To attach a resource policy to a secret, use <a>PutResourcePolicy</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To retrieve the current resource-based policy attached to a secret, use <a>GetResourcePolicy</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
    ///             </li>
    ///          </ul>
    public func deleteResourcePolicy(input: DeleteResourcePolicyInput, completion: @escaping (SdkResult<DeleteResourcePolicyOutputResponse, DeleteResourcePolicyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteResourcePolicyInput, DeleteResourcePolicyOutputResponse, DeleteResourcePolicyOutputError>(id: "deleteResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteResourcePolicyInput, DeleteResourcePolicyOutputResponse, DeleteResourcePolicyOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourcePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteResourcePolicyInput, DeleteResourcePolicyOutputResponse, DeleteResourcePolicyOutputError>(xAmzTarget: "secretsmanager.DeleteResourcePolicy"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an entire secret and all of the versions. You can optionally include a recovery
    ///       window during which you can restore the secret. If you don't specify a recovery window value,
    ///       the operation defaults to 30 days. Secrets Manager attaches a <code>DeletionDate</code> stamp to
    ///       the secret that specifies the end of the recovery window. At the end of the recovery window,
    ///       Secrets Manager deletes the secret permanently.</p>
    ///          <p>At any time before recovery window ends, you can use <a>RestoreSecret</a> to
    ///       remove the <code>DeletionDate</code> and cancel the deletion of the secret.</p>
    ///          <p>You cannot access the encrypted secret information in any secret scheduled for deletion.
    ///       If you need to access that information, you must cancel the deletion with <a>RestoreSecret</a> and then retrieve the information.</p>
    ///          <note>
    ///             <ul>
    ///                <li>
    ///                   <p>There is no explicit operation to delete a version of a secret. Instead, remove all
    ///             staging labels from the <code>VersionStage</code> field of a version. That marks the
    ///             version as deprecated and allows Secrets Manager to delete it as needed. Versions without any
    ///             staging labels do not show up in <a>ListSecretVersionIds</a> unless you
    ///             specify <code>IncludeDeprecated</code>.</p>
    ///                </li>
    ///                <li>
    ///                   <p>The permanent secret deletion at the end of the waiting period is performed as a
    ///             background task with low priority. There is no guarantee of a specific time after the
    ///             recovery window for the actual delete operation to occur.</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:DeleteSecret</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To create a secret, use <a>CreateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To cancel deletion of a version of a secret before the recovery window has expired,
    ///           use <a>RestoreSecret</a>.</p>
    ///             </li>
    ///          </ul>
    public func deleteSecret(input: DeleteSecretInput, completion: @escaping (SdkResult<DeleteSecretOutputResponse, DeleteSecretOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSecret")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSecretInput, DeleteSecretOutputResponse, DeleteSecretOutputError>(id: "deleteSecret")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSecretInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSecretInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSecretInput, DeleteSecretOutputResponse, DeleteSecretOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteSecretInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteSecretInput, DeleteSecretOutputResponse, DeleteSecretOutputError>(xAmzTarget: "secretsmanager.DeleteSecret"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the details of a secret. It does not include the encrypted fields. Secrets
    ///       Manager only returns fields populated with a value in the response. </p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:DescribeSecret</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To create a secret, use <a>CreateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To modify a secret, use <a>UpdateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To retrieve the encrypted secret information in a version of the secret, use <a>GetSecretValue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list all of the secrets in the AWS account, use <a>ListSecrets</a>.</p>
    ///             </li>
    ///          </ul>
    public func describeSecret(input: DescribeSecretInput, completion: @escaping (SdkResult<DescribeSecretOutputResponse, DescribeSecretOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSecret")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSecretInput, DescribeSecretOutputResponse, DescribeSecretOutputError>(id: "describeSecret")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSecretInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSecretInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSecretInput, DescribeSecretOutputResponse, DescribeSecretOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeSecretInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeSecretInput, DescribeSecretOutputResponse, DescribeSecretOutputError>(xAmzTarget: "secretsmanager.DescribeSecret"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Generates a random password of the specified complexity. This operation is intended for
    ///       use in the Lambda rotation function. Per best practice, we recommend that you specify the
    ///       maximum length and include every character type that the system you are generating a password
    ///       for can support.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:GetRandomPassword</p>
    ///             </li>
    ///          </ul>
    public func getRandomPassword(input: GetRandomPasswordInput, completion: @escaping (SdkResult<GetRandomPasswordOutputResponse, GetRandomPasswordOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRandomPassword")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRandomPasswordInput, GetRandomPasswordOutputResponse, GetRandomPasswordOutputError>(id: "getRandomPassword")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRandomPasswordInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRandomPasswordInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetRandomPasswordInput, GetRandomPasswordOutputResponse, GetRandomPasswordOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetRandomPasswordInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetRandomPasswordInput, GetRandomPasswordOutputResponse, GetRandomPasswordOutputError>(xAmzTarget: "secretsmanager.GetRandomPassword"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the JSON text of the resource-based policy document attached to the specified
    ///       secret. The JSON request string input and response output displays formatted code
    ///       with white space and line breaks for better readability. Submit your input as a single line
    ///       JSON string.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:GetResourcePolicy</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To attach a resource policy to a secret, use <a>PutResourcePolicy</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To delete the resource-based policy attached to a secret, use <a>DeleteResourcePolicy</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
    ///             </li>
    ///          </ul>
    public func getResourcePolicy(input: GetResourcePolicyInput, completion: @escaping (SdkResult<GetResourcePolicyOutputResponse, GetResourcePolicyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResourcePolicyInput, GetResourcePolicyOutputResponse, GetResourcePolicyOutputError>(id: "getResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetResourcePolicyInput, GetResourcePolicyOutputResponse, GetResourcePolicyOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetResourcePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetResourcePolicyInput, GetResourcePolicyOutputResponse, GetResourcePolicyOutputError>(xAmzTarget: "secretsmanager.GetResourcePolicy"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the contents of the encrypted fields <code>SecretString</code> or
    ///         <code>SecretBinary</code> from the specified version of a secret, whichever contains
    ///       content.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:GetSecretValue</p>
    ///             </li>
    ///             <li>
    ///                <p>kms:Decrypt - required only if you use a customer-managed AWS KMS key to encrypt the
    ///           secret. You do not need this permission to use the account's default AWS managed CMK for
    ///           Secrets Manager.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To create a new version of the secret with different encrypted information, use <a>PutSecretValue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To retrieve the non-encrypted details for the secret, use <a>DescribeSecret</a>.</p>
    ///             </li>
    ///          </ul>
    public func getSecretValue(input: GetSecretValueInput, completion: @escaping (SdkResult<GetSecretValueOutputResponse, GetSecretValueOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSecretValue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSecretValueInput, GetSecretValueOutputResponse, GetSecretValueOutputError>(id: "getSecretValue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSecretValueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSecretValueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSecretValueInput, GetSecretValueOutputResponse, GetSecretValueOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetSecretValueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetSecretValueInput, GetSecretValueOutputResponse, GetSecretValueOutputError>(xAmzTarget: "secretsmanager.GetSecretValue"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the versions attached to the specified secret. The output does not include
    ///       the <code>SecretString</code> or <code>SecretBinary</code> fields. By default, the list
    ///       includes only versions that have at least one staging label in <code>VersionStage</code>
    ///       attached.</p>
    ///          <note>
    ///             <p>Always check the <code>NextToken</code> response parameter
    ///     when calling any of the <code>List*</code> operations. These operations can occasionally return
    ///     an empty or shorter than expected list of results even when there more results become available.
    ///     When this happens, the <code>NextToken</code> response parameter contains a value to pass to the
    ///     next call to the same API to request the next part of the list.</p>
    ///          </note>
    ///          <p>
    ///             <b>Minimum
    ///       permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:ListSecretVersionIds</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To list the secrets in an account, use <a>ListSecrets</a>.</p>
    ///             </li>
    ///          </ul>
    public func listSecretVersionIds(input: ListSecretVersionIdsInput, completion: @escaping (SdkResult<ListSecretVersionIdsOutputResponse, ListSecretVersionIdsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecretVersionIds")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecretVersionIdsInput, ListSecretVersionIdsOutputResponse, ListSecretVersionIdsOutputError>(id: "listSecretVersionIds")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecretVersionIdsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecretVersionIdsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecretVersionIdsInput, ListSecretVersionIdsOutputResponse, ListSecretVersionIdsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListSecretVersionIdsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListSecretVersionIdsInput, ListSecretVersionIdsOutputResponse, ListSecretVersionIdsOutputError>(xAmzTarget: "secretsmanager.ListSecretVersionIds"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the secrets that are stored by Secrets Manager in the AWS account. To list the
    ///       versions currently stored for a specific secret, use <a>ListSecretVersionIds</a>.
    ///       The encrypted fields <code>SecretString</code> and <code>SecretBinary</code> are not included
    ///       in the output. To get that information, call the <a>GetSecretValue</a>
    ///       operation.</p>
    ///          <note>
    ///             <p>Always check the <code>NextToken</code> response parameter
    ///     when calling any of the <code>List*</code> operations. These operations can occasionally return
    ///     an empty or shorter than expected list of results even when there more results become available.
    ///     When this happens, the <code>NextToken</code> response parameter contains a value to pass to the
    ///     next call to the same API to request the next part of the list.</p>
    ///          </note>
    ///          <p>
    ///             <b>Minimum
    ///         permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:ListSecrets</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To list the versions attached to a secret, use <a>ListSecretVersionIds</a>.</p>
    ///             </li>
    ///          </ul>
    public func listSecrets(input: ListSecretsInput, completion: @escaping (SdkResult<ListSecretsOutputResponse, ListSecretsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecrets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecretsInput, ListSecretsOutputResponse, ListSecretsOutputError>(id: "listSecrets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecretsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecretsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecretsInput, ListSecretsOutputResponse, ListSecretsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListSecretsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListSecretsInput, ListSecretsOutputResponse, ListSecretsOutputError>(xAmzTarget: "secretsmanager.ListSecrets"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Attaches the contents of the specified resource-based permission policy to a secret. A
    ///       resource-based policy is optional. Alternatively, you can use IAM identity-based policies
    ///       that specify the secret's Amazon Resource Name (ARN) in the policy statement's
    ///         <code>Resources</code> element. You can also use a combination of both identity-based and
    ///       resource-based policies. The affected users and roles receive the permissions that are
    ///       permitted by all of the relevant policies. For more information, see <a href="http://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_resource-based-policies.html">Using Resource-Based
    ///         Policies for AWS Secrets Manager</a>. For the complete description of the AWS policy syntax and
    ///       grammar, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html">IAM JSON
    ///         Policy Reference</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:PutResourcePolicy</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To retrieve the resource policy attached to a secret, use <a>GetResourcePolicy</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To delete the resource-based policy attached to a secret, use <a>DeleteResourcePolicy</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
    ///             </li>
    ///          </ul>
    public func putResourcePolicy(input: PutResourcePolicyInput, completion: @escaping (SdkResult<PutResourcePolicyOutputResponse, PutResourcePolicyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutResourcePolicyInput, PutResourcePolicyOutputResponse, PutResourcePolicyOutputError>(id: "putResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutResourcePolicyInput, PutResourcePolicyOutputResponse, PutResourcePolicyOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutResourcePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutResourcePolicyInput, PutResourcePolicyOutputResponse, PutResourcePolicyOutputError>(xAmzTarget: "secretsmanager.PutResourcePolicy"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Stores a new encrypted secret value in the specified secret. To do this, the operation
    ///       creates a new version and attaches it to the secret. The version can contain a new
    ///         <code>SecretString</code> value or a new <code>SecretBinary</code> value. You can also
    ///       specify the staging labels that are initially attached to the new version.</p>
    ///          <note>
    ///             <p>The Secrets Manager console uses only the <code>SecretString</code> field. To add binary data to a
    ///         secret with the <code>SecretBinary</code> field you must use the AWS CLI or one of the
    ///         AWS SDKs.</p>
    ///          </note>
    ///          <ul>
    ///             <li>
    ///                <p>If this operation creates the first version for the secret then Secrets Manager
    ///           automatically attaches the staging label <code>AWSCURRENT</code> to the new version.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you do not specify a value for VersionStages then Secrets Manager automatically
    ///           moves the staging label <code>AWSCURRENT</code> to this new version.</p>
    ///             </li>
    ///             <li>
    ///                <p>If this operation moves the staging label <code>AWSCURRENT</code> from another version to this
    ///           version, then Secrets Manager also automatically moves the staging label <code>AWSPREVIOUS</code> to
    ///           the version that <code>AWSCURRENT</code> was removed from.</p>
    ///             </li>
    ///             <li>
    ///                <p>This operation is idempotent. If a version with a <code>VersionId</code> with the same
    ///           value as the <code>ClientRequestToken</code> parameter already exists and you specify the
    ///           same secret data, the operation succeeds but does nothing. However, if the secret data is
    ///           different, then the operation fails because you cannot modify an existing version; you can
    ///           only create new ones.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <ul>
    ///                <li>
    ///                   <p>If you call an operation to encrypt or decrypt the <code>SecretString</code>
    ///           or <code>SecretBinary</code> for a secret in the same account as the calling user and that
    ///           secret doesn't specify a AWS KMS encryption key, Secrets Manager uses the account's default
    ///           AWS managed customer master key (CMK) with the alias <code>aws/secretsmanager</code>. If this key
    ///           doesn't already exist in your account then Secrets Manager creates it for you automatically. All
    ///           users and roles in the same AWS account automatically have access to use the default CMK.
    ///           Note that if an Secrets Manager API call results in AWS creating the account's
    ///           AWS-managed CMK, it can result in a one-time significant delay in returning the
    ///           result.</p>
    ///                </li>
    ///                <li>
    ///                   <p>If the secret resides in a different AWS account from the credentials calling an API that
    ///           requires encryption or decryption of the secret value then you must create and use a custom
    ///           AWS KMS CMK because you can't access the default CMK for the account using credentials
    ///           from a different AWS account. Store the ARN of the CMK in the secret when you create the
    ///           secret or when you update it by including it in the <code>KMSKeyId</code>. If you call an
    ///           API that must encrypt or decrypt <code>SecretString</code> or <code>SecretBinary</code>
    ///           using credentials from a different account then the AWS KMS key policy must grant cross-account
    ///           access to that other account's user or role for both the kms:GenerateDataKey and
    ///           kms:Decrypt operations.</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:PutSecretValue</p>
    ///             </li>
    ///             <li>
    ///                <p>kms:GenerateDataKey - needed only if you use a customer-managed AWS KMS key to encrypt
    ///           the secret. You do not need this permission to use the account's default AWS managed CMK
    ///           for Secrets Manager.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To retrieve the encrypted value you store in the version of a secret, use <a>GetSecretValue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To create a secret, use <a>CreateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To get the details for a secret, use <a>DescribeSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list the versions attached to a secret, use <a>ListSecretVersionIds</a>.</p>
    ///             </li>
    ///          </ul>
    public func putSecretValue(input: PutSecretValueInput, completion: @escaping (SdkResult<PutSecretValueOutputResponse, PutSecretValueOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putSecretValue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutSecretValueInput, PutSecretValueOutputResponse, PutSecretValueOutputError>(id: "putSecretValue")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<PutSecretValueOutputResponse>, SdkError<PutSecretValueOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: PutSecretValueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutSecretValueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutSecretValueInput, PutSecretValueOutputResponse, PutSecretValueOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutSecretValueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutSecretValueInput, PutSecretValueOutputResponse, PutSecretValueOutputError>(xAmzTarget: "secretsmanager.PutSecretValue"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Remove regions from replication.</p>
    public func removeRegionsFromReplication(input: RemoveRegionsFromReplicationInput, completion: @escaping (SdkResult<RemoveRegionsFromReplicationOutputResponse, RemoveRegionsFromReplicationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeRegionsFromReplication")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RemoveRegionsFromReplicationInput, RemoveRegionsFromReplicationOutputResponse, RemoveRegionsFromReplicationOutputError>(id: "removeRegionsFromReplication")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RemoveRegionsFromReplicationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RemoveRegionsFromReplicationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RemoveRegionsFromReplicationInput, RemoveRegionsFromReplicationOutputResponse, RemoveRegionsFromReplicationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RemoveRegionsFromReplicationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RemoveRegionsFromReplicationInput, RemoveRegionsFromReplicationOutputResponse, RemoveRegionsFromReplicationOutputError>(xAmzTarget: "secretsmanager.RemoveRegionsFromReplication"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Converts an existing secret to a multi-Region secret and begins replication the secret to a
    ///       list of new regions. </p>
    public func replicateSecretToRegions(input: ReplicateSecretToRegionsInput, completion: @escaping (SdkResult<ReplicateSecretToRegionsOutputResponse, ReplicateSecretToRegionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "replicateSecretToRegions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ReplicateSecretToRegionsInput, ReplicateSecretToRegionsOutputResponse, ReplicateSecretToRegionsOutputError>(id: "replicateSecretToRegions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ReplicateSecretToRegionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ReplicateSecretToRegionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ReplicateSecretToRegionsInput, ReplicateSecretToRegionsOutputResponse, ReplicateSecretToRegionsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ReplicateSecretToRegionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ReplicateSecretToRegionsInput, ReplicateSecretToRegionsOutputResponse, ReplicateSecretToRegionsOutputError>(xAmzTarget: "secretsmanager.ReplicateSecretToRegions"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels the scheduled deletion of a secret by removing the <code>DeletedDate</code> time
    ///       stamp. This makes the secret accessible to query once again.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:RestoreSecret</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To delete a secret, use <a>DeleteSecret</a>.</p>
    ///             </li>
    ///          </ul>
    public func restoreSecret(input: RestoreSecretInput, completion: @escaping (SdkResult<RestoreSecretOutputResponse, RestoreSecretOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "restoreSecret")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RestoreSecretInput, RestoreSecretOutputResponse, RestoreSecretOutputError>(id: "restoreSecret")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RestoreSecretInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RestoreSecretInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RestoreSecretInput, RestoreSecretOutputResponse, RestoreSecretOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RestoreSecretInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RestoreSecretInput, RestoreSecretOutputResponse, RestoreSecretOutputError>(xAmzTarget: "secretsmanager.RestoreSecret"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Configures and starts the asynchronous process of rotating this secret. If you include the
    ///       configuration parameters, the operation sets those values for the secret and then immediately
    ///       starts a rotation. If you do not include the configuration parameters, the operation starts a
    ///       rotation with the values already stored in the secret. After the rotation completes, the
    ///       protected service and its clients all use the new version of the secret. </p>
    ///          <p>This required configuration information includes the ARN of an AWS Lambda function and
    ///       the time between scheduled rotations. The Lambda rotation function creates a new version of
    ///       the secret and creates or updates the credentials on the protected service to match. After
    ///       testing the new credentials, the function marks the new secret with the staging label
    ///       <code>AWSCURRENT</code> so that your clients all immediately begin to use the new version. For more
    ///       information about rotating secrets and how to configure a Lambda function to rotate the
    ///       secrets for your protected service, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html">Rotating Secrets in AWS Secrets Manager</a> in the
    ///         <i>AWS Secrets Manager User Guide</i>.</p>
    ///          <p>Secrets Manager schedules the next rotation when the previous
    ///     one completes. Secrets Manager schedules the date by adding the rotation interval (number of days) to the
    ///     actual date of the last rotation. The service chooses the hour within that 24-hour date window
    ///     randomly. The minute is also chosen somewhat randomly, but weighted towards the top of the hour
    ///     and influenced by a variety of factors that help distribute load.</p>
    ///          <p>The
    ///       rotation function must end with the versions of the secret in one of two states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The <code>AWSPENDING</code> and <code>AWSCURRENT</code> staging labels are attached to the same version of
    ///           the secret, or</p>
    ///             </li>
    ///             <li>
    ///                <p>The <code>AWSPENDING</code> staging label is not attached to any version of the secret.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the <code>AWSPENDING</code> staging label is present but not attached to the same version as
    ///       <code>AWSCURRENT</code> then any later invocation of <code>RotateSecret</code> assumes that a previous
    ///       rotation request is still in progress and returns an error.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:RotateSecret</p>
    ///             </li>
    ///             <li>
    ///                <p>lambda:InvokeFunction (on the function specified in the secret's metadata)</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To list the secrets in your account, use <a>ListSecrets</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To get the details for a version of a secret, use <a>DescribeSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To create a new version of a secret, use <a>CreateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To attach staging labels to or remove staging labels from a version of a secret, use
    ///             <a>UpdateSecretVersionStage</a>.</p>
    ///             </li>
    ///          </ul>
    public func rotateSecret(input: RotateSecretInput, completion: @escaping (SdkResult<RotateSecretOutputResponse, RotateSecretOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "rotateSecret")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RotateSecretInput, RotateSecretOutputResponse, RotateSecretOutputError>(id: "rotateSecret")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<RotateSecretOutputResponse>, SdkError<RotateSecretOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: RotateSecretInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RotateSecretInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RotateSecretInput, RotateSecretOutputResponse, RotateSecretOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RotateSecretInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RotateSecretInput, RotateSecretOutputResponse, RotateSecretOutputError>(xAmzTarget: "secretsmanager.RotateSecret"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the secret from replication and promotes the secret to a regional secret in the replica Region.</p>
    public func stopReplicationToReplica(input: StopReplicationToReplicaInput, completion: @escaping (SdkResult<StopReplicationToReplicaOutputResponse, StopReplicationToReplicaOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopReplicationToReplica")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopReplicationToReplicaInput, StopReplicationToReplicaOutputResponse, StopReplicationToReplicaOutputError>(id: "stopReplicationToReplica")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopReplicationToReplicaInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopReplicationToReplicaInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopReplicationToReplicaInput, StopReplicationToReplicaOutputResponse, StopReplicationToReplicaOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StopReplicationToReplicaInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StopReplicationToReplicaInput, StopReplicationToReplicaOutputResponse, StopReplicationToReplicaOutputError>(xAmzTarget: "secretsmanager.StopReplicationToReplica"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Attaches one or more tags, each consisting of a key name and a value, to the specified
    ///       secret. Tags are part of the secret's overall metadata, and are not associated with any
    ///       specific version of the secret. This operation only appends tags to the existing list of tags.
    ///       To remove tags, you must use <a>UntagResource</a>.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Maximum number of tags per secret—50</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length—127 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length—255 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use the <code>aws:</code> prefix in your tag names or values because AWS reserves it
    ///             for AWS use. You can't edit or delete tag names or values with this
    ///               prefix. Tags with this prefix do not count against your tags per secret limit.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you use your tagging schema across multiple services and resources,
    ///               remember other services might have restrictions on allowed characters. Generally
    ///               allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
    ///               following special characters: + - = . _ : / @.</p>
    ///             </li>
    ///          </ul>
    ///          <important>
    ///             <p>If you use tags as part of your security strategy, then adding or removing a tag can
    ///         change permissions. If successfully completing this operation would result in you losing
    ///         your permissions for this secret, then the operation is blocked and returns an Access Denied
    ///         error.</p>
    ///          </important>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:TagResource</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To remove one or more tags from the collection attached to a secret, use <a>UntagResource</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To view the list of tags attached to a secret, use <a>DescribeSecret</a>.</p>
    ///             </li>
    ///          </ul>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(xAmzTarget: "secretsmanager.TagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes one or more tags from the specified secret.</p>
    ///          <p>This operation is idempotent. If a requested tag is not attached to the secret, no error
    ///       is returned and the secret metadata is unchanged.</p>
    ///          <important>
    ///             <p>If you use tags as part of your security strategy, then removing a tag can change
    ///         permissions. If successfully completing this operation would result in you losing your
    ///         permissions for this secret, then the operation is blocked and returns an Access Denied
    ///         error.</p>
    ///          </important>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:UntagResource</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To add one or more tags to the collection attached to a secret, use <a>TagResource</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To view the list of tags attached to a secret, use <a>DescribeSecret</a>.</p>
    ///             </li>
    ///          </ul>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(xAmzTarget: "secretsmanager.UntagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies many of the details of the specified secret. If you include a
    ///         <code>ClientRequestToken</code> and <i>either</i>
    ///             <code>SecretString</code> or <code>SecretBinary</code> then it also creates a new version
    ///       attached to the secret.</p>
    ///          <p>To modify the rotation configuration of a secret, use <a>RotateSecret</a>
    ///       instead.</p>
    ///          <note>
    ///             <p>The Secrets Manager console uses only the <code>SecretString</code> parameter and therefore limits
    ///         you to encrypting and storing only a text string. To encrypt and store binary data as part
    ///         of the version of a secret, you must use either the AWS CLI or one of the AWS
    ///         SDKs.</p>
    ///          </note>
    ///          <ul>
    ///             <li>
    ///                <p>If a version with a <code>VersionId</code> with the same value as the
    ///             <code>ClientRequestToken</code> parameter already exists, the operation results in an
    ///           error. You cannot modify an existing version, you can only create a new version.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you include <code>SecretString</code> or <code>SecretBinary</code> to create a new
    ///           secret version, Secrets Manager automatically attaches the staging label <code>AWSCURRENT</code> to the new
    ///           version. </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <ul>
    ///                <li>
    ///                   <p>If you call an operation to encrypt or decrypt the <code>SecretString</code>
    ///           or <code>SecretBinary</code> for a secret in the same account as the calling user and that
    ///           secret doesn't specify a AWS KMS encryption key, Secrets Manager uses the account's default
    ///           AWS managed customer master key (CMK) with the alias <code>aws/secretsmanager</code>. If this key
    ///           doesn't already exist in your account then Secrets Manager creates it for you automatically. All
    ///           users and roles in the same AWS account automatically have access to use the default CMK.
    ///           Note that if an Secrets Manager API call results in AWS creating the account's
    ///           AWS-managed CMK, it can result in a one-time significant delay in returning the
    ///           result.</p>
    ///                </li>
    ///                <li>
    ///                   <p>If the secret resides in a different AWS account from the credentials calling an API that
    ///           requires encryption or decryption of the secret value then you must create and use a custom
    ///           AWS KMS CMK because you can't access the default CMK for the account using credentials
    ///           from a different AWS account. Store the ARN of the CMK in the secret when you create the
    ///           secret or when you update it by including it in the <code>KMSKeyId</code>. If you call an
    ///           API that must encrypt or decrypt <code>SecretString</code> or <code>SecretBinary</code>
    ///           using credentials from a different account then the AWS KMS key policy must grant cross-account
    ///           access to that other account's user or role for both the kms:GenerateDataKey and
    ///           kms:Decrypt operations.</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:UpdateSecret</p>
    ///             </li>
    ///             <li>
    ///                <p>kms:GenerateDataKey - needed only if you use a custom AWS KMS key to encrypt the secret.
    ///           You do not need this permission to use the account's AWS managed CMK for
    ///           Secrets Manager.</p>
    ///             </li>
    ///             <li>
    ///                <p>kms:Decrypt - needed only if you use a custom AWS KMS key to encrypt the secret. You do
    ///           not need this permission to use the account's AWS managed CMK for Secrets Manager.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To create a new secret, use <a>CreateSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To add only a new version to an existing secret, use <a>PutSecretValue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To get the details for a secret, use <a>DescribeSecret</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To list the versions contained in a secret, use <a>ListSecretVersionIds</a>.</p>
    ///             </li>
    ///          </ul>
    public func updateSecret(input: UpdateSecretInput, completion: @escaping (SdkResult<UpdateSecretOutputResponse, UpdateSecretOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSecret")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSecretInput, UpdateSecretOutputResponse, UpdateSecretOutputError>(id: "updateSecret")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateSecretOutputResponse>, SdkError<UpdateSecretOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecretInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecretInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSecretInput, UpdateSecretOutputResponse, UpdateSecretOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecretInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateSecretInput, UpdateSecretOutputResponse, UpdateSecretOutputError>(xAmzTarget: "secretsmanager.UpdateSecret"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the staging labels attached to a version of a secret. Staging labels are used to
    ///       track a version as it progresses through the secret rotation process. You can attach a staging
    ///       label to only one version of a secret at a time. If a staging label to be added is already
    ///       attached to another version, then it is moved--removed from the other version first and
    ///       then attached to this one. For more information about staging labels, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/terms-concepts.html#term_staging-label">Staging
    ///         Labels</a> in the <i>AWS Secrets Manager User Guide</i>. </p>
    ///          <p>The staging labels that you specify in the <code>VersionStage</code> parameter are added
    ///       to the existing list of staging labels--they don't replace it.</p>
    ///          <p>You can move the <code>AWSCURRENT</code> staging label to this version by including it in this
    ///       call.</p>
    ///          <note>
    ///             <p>Whenever you move <code>AWSCURRENT</code>, Secrets Manager automatically moves the label <code>AWSPREVIOUS</code>
    ///         to the version that <code>AWSCURRENT</code> was removed from.</p>
    ///          </note>
    ///          <p>If this action results in the last label being removed from a version, then the version is
    ///       considered to be 'deprecated' and can be deleted by Secrets Manager.</p>
    ///          <p>
    ///             <b>Minimum permissions</b>
    ///          </p>
    ///          <p>To run this command, you must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>secretsmanager:UpdateSecretVersionStage</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Related operations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>To get the list of staging labels that are currently associated with a version of a
    ///           secret, use <code>
    ///                      <a>DescribeSecret</a>
    ///                   </code> and examine the
    ///             <code>SecretVersionsToStages</code> response value. </p>
    ///             </li>
    ///          </ul>
    public func updateSecretVersionStage(input: UpdateSecretVersionStageInput, completion: @escaping (SdkResult<UpdateSecretVersionStageOutputResponse, UpdateSecretVersionStageOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSecretVersionStage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSecretVersionStageInput, UpdateSecretVersionStageOutputResponse, UpdateSecretVersionStageOutputError>(id: "updateSecretVersionStage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecretVersionStageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecretVersionStageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSecretVersionStageInput, UpdateSecretVersionStageOutputResponse, UpdateSecretVersionStageOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecretVersionStageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateSecretVersionStageInput, UpdateSecretVersionStageOutputResponse, UpdateSecretVersionStageOutputError>(xAmzTarget: "secretsmanager.UpdateSecretVersionStage"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Validates that the resource policy does not grant a wide range of IAM principals access to
    ///       your secret. The JSON request string input and response output displays formatted code
    ///       with white space and line breaks for better readability. Submit your input as a single line
    ///       JSON string. A resource-based policy is optional for secrets.</p>
    ///          <p>The API performs three checks when validating the secret:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Sends a call to <a href="https://aws.amazon.com/blogs/security/protect-sensitive-data-in-the-cloud-with-automated-reasoning-zelkova/">Zelkova</a>, an automated reasoning engine, to ensure your Resource Policy does not
    ///           allow broad access to your secret.</p>
    ///             </li>
    ///             <li>
    ///                <p>Checks for correct syntax in a policy.</p>
    ///             </li>
    ///             <li>
    ///                <p>Verifies the policy does not lock out a caller.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///          <p>
    ///             <b>Minimum Permissions</b>
    ///          </p>
    ///          <p>You must have the permissions required to access the following APIs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>secretsmanager:PutResourcePolicy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>secretsmanager:ValidateResourcePolicy</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public func validateResourcePolicy(input: ValidateResourcePolicyInput, completion: @escaping (SdkResult<ValidateResourcePolicyOutputResponse, ValidateResourcePolicyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "validateResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "secretsmanager.\(config.region).amazonaws.com")
                      .withSigningName(value: "secretsmanager")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ValidateResourcePolicyInput, ValidateResourcePolicyOutputResponse, ValidateResourcePolicyOutputError>(id: "validateResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ValidateResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ValidateResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ValidateResourcePolicyInput, ValidateResourcePolicyOutputResponse, ValidateResourcePolicyOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ValidateResourcePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ValidateResourcePolicyInput, ValidateResourcePolicyOutputResponse, ValidateResourcePolicyOutputError>(xAmzTarget: "secretsmanager.ValidateResourcePolicy"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
