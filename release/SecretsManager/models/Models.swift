// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct CancelRotateSecretInputBodyMiddleware: Middleware {
    public let id: String = "CancelRotateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelRotateSecretOutputError>
}

extension CancelRotateSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelRotateSecretInput(secretId: \(String(describing: secretId)))"}
}

extension CancelRotateSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct CancelRotateSecretInputHeadersMiddleware: Middleware {
    public let id: String = "CancelRotateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelRotateSecretOutputError>
}

public struct CancelRotateSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelRotateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelRotateSecretOutputError>
}

public struct CancelRotateSecretInput: Equatable {
    /// <p>Specifies the secret to cancel a rotation request. You can specify either the Amazon
    ///       Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        secretId: String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct CancelRotateSecretInputBody: Equatable {
    public let secretId: String?
}

extension CancelRotateSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension CancelRotateSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelRotateSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelRotateSecretOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelRotateSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelRotateSecretOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)), versionId: \(String(describing: versionId)))"}
}

extension CancelRotateSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelRotateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct CancelRotateSecretOutputResponse: Equatable {
    /// <p>The ARN of the secret for which rotation was canceled.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret for which rotation was canceled.</p>
    public let name: String?
    /// <p>The unique identifier of the version of the secret created during the rotation. This
    ///       version might not be complete, and should be evaluated for possible deletion. At the very
    ///       least, you should remove the <code>VersionStage</code> value <code>AWSPENDING</code> to enable this
    ///       version to be deleted. Failing to clean up a cancelled rotation can block you from
    ///       successfully starting future rotations.</p>
    public let versionId: String?

    public init (
        aRN: String? = nil,
        name: String? = nil,
        versionId: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct CancelRotateSecretOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let versionId: String?
}

extension CancelRotateSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct CreateSecretInputBodyMiddleware: Middleware {
    public let id: String = "CreateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecretInput>
    public typealias MOutput = OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecretOutputError>
}

extension CreateSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSecretInput(addReplicaRegions: \(String(describing: addReplicaRegions)), clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), forceOverwriteReplicaSecret: \(String(describing: forceOverwriteReplicaSecret)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), secretBinary: \(String(describing: secretBinary)), secretString: \(String(describing: secretString)), tags: \(String(describing: tags)))"}
}

extension CreateSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addReplicaRegions = addReplicaRegions {
            var addReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addReplicaRegions)
            for addreplicaregionlisttype0 in addReplicaRegions {
                try addReplicaRegionsContainer.encode(addreplicaregionlisttype0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if forceOverwriteReplicaSecret != false {
            try encodeContainer.encode(forceOverwriteReplicaSecret, forKey: .forceOverwriteReplicaSecret)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }
}

public struct CreateSecretInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecretInput>
    public typealias MOutput = OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecretOutputError>
}

public struct CreateSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecretInput>
    public typealias MOutput = OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecretOutputError>
}

public struct CreateSecretInput: Equatable {
    /// <p>(Optional) Add a list of regions to replicate secrets. Secrets Manager replicates the KMSKeyID objects to the list of regions specified in
    ///       the parameter.</p>
    public let addReplicaRegions: [ReplicaRegionType]?
    /// <p>(Optional) If you include <code>SecretString</code> or <code>SecretBinary</code>, then an
    ///       initial version is created as part of the secret, and this parameter specifies a unique
    ///       identifier for the new version. </p>
    ///          <note>
    ///             <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///         leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
    ///         as the value for this parameter in the request. If you don't use the SDK and instead
    ///         generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
    ///           <code>ClientRequestToken</code> yourself for the new version and include the value in the
    ///         request.</p>
    ///          </note>
    ///          <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    ///       creation of duplicate versions if there are failures and retries during a rotation. We
    ///       recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    ///       ensure uniqueness of your versions within the specified secret. </p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    ///           of the secret then a new version of the secret is created. </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and the version <code>SecretString</code>
    ///           and <code>SecretBinary</code> values are the same as those in the request, then the
    ///           request is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    ///           in the request, then the request fails because you cannot modify an existing version.
    ///           Instead, use <a>PutSecretValue</a> to create a new version.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This value becomes the <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: String?
    /// <p>(Optional) Specifies a user-provided description of the secret.</p>
    public let description: String?
    /// <p>(Optional) If set, the replication overwrites a secret with the same name in the
    ///       destination region.</p>
    public let forceOverwriteReplicaSecret: Bool
    /// <p>(Optional) Specifies the ARN, Key ID, or alias of the AWS KMS customer master key (CMK) to
    ///       be used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values in the
    ///       versions stored in this secret.</p>
    ///          <p>You can specify any of the supported ways to identify a AWS KMS key ID. If you need to
    ///       reference a CMK in a different account, you can use only the key ARN or the alias ARN.</p>
    ///          <p>If you don't specify this value, then Secrets Manager defaults to using the AWS account's
    ///       default CMK (the one named <code>aws/secretsmanager</code>). If a AWS KMS CMK with that name doesn't yet
    ///       exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
    ///       version's <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
    ///          <important>
    ///             <p>You can use the account default CMK to encrypt and decrypt only if you call this
    ///         operation using credentials from the same account that owns the secret. If the secret
    ///         resides in a different account, then you must create a custom CMK and specify the ARN in
    ///         this field. </p>
    ///          </important>
    public let kmsKeyId: String?
    /// <p>Specifies the friendly name of the new secret.</p>
    ///          <p>The secret name must be ASCII letters, digits, or the following characters :
    ///       /_+=.@-</p>
    ///          <note>
    ///             <p>Do not end your secret name with a hyphen followed by six characters. If you do so, you
    ///         risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
    ///         automatically adds a hyphen and six random characters at the end of the ARN.</p>
    ///          </note>
    public let name: String?
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    ///       the secret. To use this parameter in the command-line tools, we recommend that you store your
    ///       binary data in a file and then use the appropriate technique for your tool to pass the
    ///       contents of the file as a parameter.</p>
    ///          <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    ///       both. They cannot both be empty.</p>
    ///          <p>This parameter is not available using the Secrets Manager console. It can be accessed only by
    ///       using the AWS CLI or one of the AWS SDKs.</p>
    public let secretBinary: Data?
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    ///       the secret.</p>
    ///          <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    ///       both. They cannot both be empty.</p>
    ///          <p>If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
    ///       secret text in only the <code>SecretString</code> parameter. The Secrets Manager console stores the
    ///       information as a JSON structure of key/value pairs that the Lambda rotation function knows how
    ///       to parse.</p>
    ///          <p>For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    ///          <p>
    ///             <code>{"username":"bob","password":"abc123xyz456"}</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    public let secretString: String?
    /// <p>(Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag
    ///       is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list
    ///       of tags. To remove tags, you must use <a>UntagResource</a>.</p>
    ///          <important>
    ///             <ul>
    ///                <li>
    ///                   <p>Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag
    ///             from one with key "abc".</p>
    ///                </li>
    ///                <li>
    ///                   <p>If you check tags in IAM policy <code>Condition</code> elements as part of your
    ///             security strategy, then adding or removing a tag can change permissions. If the
    ///             successful completion of this operation would result in you losing your permissions for
    ///             this secret, then this operation is blocked and returns an <code>Access Denied</code>
    ///             error.</p>
    ///                </li>
    ///             </ul>
    ///          </important>
    ///          <p>This parameter requires a JSON text string argument. For information on how to format a
    ///       JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    ///          <p>
    ///             <code>[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    ///             <p>The following basic restrictions apply to tags:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Maximum number of tags per secret—50</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length—127 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length—255 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use the <code>aws:</code> prefix in your tag names or values because AWS reserves it
    ///             for AWS use. You can't edit or delete tag names or values with this
    ///               prefix. Tags with this prefix do not count against your tags per secret limit.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you use your tagging schema across multiple services and resources,
    ///               remember other services might have restrictions on allowed characters. Generally
    ///               allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
    ///               following special characters: + - = . _ : / @.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        addReplicaRegions: [ReplicaRegionType]? = nil,
        clientRequestToken: String? = nil,
        description: String? = nil,
        forceOverwriteReplicaSecret: Bool = false,
        kmsKeyId: String? = nil,
        name: String? = nil,
        secretBinary: Data? = nil,
        secretString: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.addReplicaRegions = addReplicaRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.forceOverwriteReplicaSecret = forceOverwriteReplicaSecret
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.secretBinary = secretBinary
        self.secretString = secretString
        self.tags = tags
    }
}

struct CreateSecretInputBody: Equatable {
    public let name: String?
    public let clientRequestToken: String?
    public let description: String?
    public let kmsKeyId: String?
    public let secretBinary: Data?
    public let secretString: String?
    public let tags: [Tag]?
    public let addReplicaRegions: [ReplicaRegionType]?
    public let forceOverwriteReplicaSecret: Bool
}

extension CreateSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let addReplicaRegionsContainer = try containerValues.decodeIfPresent([ReplicaRegionType?].self, forKey: .addReplicaRegions)
        var addReplicaRegionsDecoded0:[ReplicaRegionType]? = nil
        if let addReplicaRegionsContainer = addReplicaRegionsContainer {
            addReplicaRegionsDecoded0 = [ReplicaRegionType]()
            for structure0 in addReplicaRegionsContainer {
                if let structure0 = structure0 {
                    addReplicaRegionsDecoded0?.append(structure0)
                }
            }
        }
        addReplicaRegions = addReplicaRegionsDecoded0
        let forceOverwriteReplicaSecretDecoded = try containerValues.decode(Bool.self, forKey: .forceOverwriteReplicaSecret)
        forceOverwriteReplicaSecret = forceOverwriteReplicaSecretDecoded
    }
}

extension CreateSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSecretOutputError: Swift.Error, Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSecretOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)), replicationStatus: \(String(describing: replicationStatus)), versionId: \(String(describing: versionId)))"}
}

extension CreateSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.replicationStatus = output.replicationStatus
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.replicationStatus = nil
            self.versionId = nil
        }
    }
}

public struct CreateSecretOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the secret that you just created.</p>
    ///          <note>
    ///             <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret <i>don't</i>
    ///         automatically get access to the new secret because the ARNs are different.</p>
    ///          </note>
    public let aRN: String?
    /// <p>The friendly name of the secret that you just created.</p>
    public let name: String?
    /// <p>Describes a list of replication status objects as <code>InProgress</code>, <code>Failed</code> or <code>InSync</code>.</p>
    public let replicationStatus: [ReplicationStatusType]?
    /// <p>The unique identifier associated with the version of the secret you just created.</p>
    public let versionId: String?

    public init (
        aRN: String? = nil,
        name: String? = nil,
        replicationStatus: [ReplicationStatusType]? = nil,
        versionId: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.replicationStatus = replicationStatus
        self.versionId = versionId
    }
}

struct CreateSecretOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let versionId: String?
    public let replicationStatus: [ReplicationStatusType]?
}

extension CreateSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case replicationStatus = "ReplicationStatus"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension DecryptionFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecryptionFailure(message: \(String(describing: message)))"}
}

extension DecryptionFailure: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DecryptionFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Secrets Manager can't decrypt the protected secret text using the provided KMS key. </p>
public struct DecryptionFailure: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DecryptionFailureBody: Equatable {
    public let message: String?
}

extension DecryptionFailureBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

extension DeleteResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyInput(secretId: \(String(describing: secretId)))"}
}

extension DeleteResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Equatable {
    /// <p>Specifies the secret that you want to delete the attached resource-based policy for. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        secretId: String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct DeleteResourcePolicyInputBody: Equatable {
    public let secretId: String?
}

extension DeleteResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension DeleteResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)))"}
}

extension DeleteResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct DeleteResourcePolicyOutputResponse: Equatable {
    /// <p>The ARN of the secret that the resource-based policy was deleted for.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret that the resource-based policy was deleted for.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct DeleteResourcePolicyOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
}

extension DeleteResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct DeleteSecretInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecretOutputError>
}

extension DeleteSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSecretInput(forceDeleteWithoutRecovery: \(String(describing: forceDeleteWithoutRecovery)), recoveryWindowInDays: \(String(describing: recoveryWindowInDays)), secretId: \(String(describing: secretId)))"}
}

extension DeleteSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forceDeleteWithoutRecovery = "ForceDeleteWithoutRecovery"
        case recoveryWindowInDays = "RecoveryWindowInDays"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if forceDeleteWithoutRecovery != false {
            try encodeContainer.encode(forceDeleteWithoutRecovery, forKey: .forceDeleteWithoutRecovery)
        }
        if recoveryWindowInDays != 0 {
            try encodeContainer.encode(recoveryWindowInDays, forKey: .recoveryWindowInDays)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DeleteSecretInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecretOutputError>
}

public struct DeleteSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecretOutputError>
}

public struct DeleteSecretInput: Equatable {
    /// <p>(Optional) Specifies that the secret is to be deleted without any recovery window. You
    ///       can't use both this parameter and the <code>RecoveryWindowInDays</code> parameter in the same
    ///       API call.</p>
    ///          <p>An asynchronous background process performs the actual deletion, so there can be a short
    ///       delay before the operation completes. If you write code to delete and then immediately
    ///       recreate a secret with the same name, ensure that your code includes appropriate back off and
    ///       retry logic.</p>
    ///          <important>
    ///             <p>Use this parameter with caution. This parameter causes the operation to skip the normal
    ///         waiting period before the permanent deletion that AWS would normally impose with the
    ///           <code>RecoveryWindowInDays</code> parameter. If you delete a secret with the
    ///           <code>ForceDeleteWithouRecovery</code> parameter, then you have no opportunity to recover
    ///         the secret. You lose the secret permanently.</p>
    ///          </important>
    ///          <important>
    ///             <p>If you use this parameter and include a previously deleted or nonexistent secret, the
    ///         operation does not return the error <code>ResourceNotFoundException</code> in order to
    ///         correctly handle retries.</p>
    ///          </important>
    public let forceDeleteWithoutRecovery: Bool
    /// <p>(Optional) Specifies the number of days that Secrets Manager waits before Secrets Manager can delete the
    ///       secret. You can't use both this parameter and the <code>ForceDeleteWithoutRecovery</code>
    ///       parameter in the same API call.</p>
    ///          <p>This value can range from 7 to 30 days with a default value of 30.</p>
    public let recoveryWindowInDays: Int
    /// <p>Specifies the secret to delete. You can specify either the Amazon Resource Name (ARN) or
    ///       the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        forceDeleteWithoutRecovery: Bool = false,
        recoveryWindowInDays: Int = 0,
        secretId: String? = nil
    )
    {
        self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
        self.recoveryWindowInDays = recoveryWindowInDays
        self.secretId = secretId
    }
}

struct DeleteSecretInputBody: Equatable {
    public let secretId: String?
    public let recoveryWindowInDays: Int
    public let forceDeleteWithoutRecovery: Bool
}

extension DeleteSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forceDeleteWithoutRecovery = "ForceDeleteWithoutRecovery"
        case recoveryWindowInDays = "RecoveryWindowInDays"
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let recoveryWindowInDaysDecoded = try containerValues.decode(Int.self, forKey: .recoveryWindowInDays)
        recoveryWindowInDays = recoveryWindowInDaysDecoded
        let forceDeleteWithoutRecoveryDecoded = try containerValues.decode(Bool.self, forKey: .forceDeleteWithoutRecovery)
        forceDeleteWithoutRecovery = forceDeleteWithoutRecoveryDecoded
    }
}

extension DeleteSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSecretOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSecretOutputResponse(aRN: \(String(describing: aRN)), deletionDate: \(String(describing: deletionDate)), name: \(String(describing: name)))"}
}

extension DeleteSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.deletionDate = output.deletionDate
            self.name = output.name
        } else {
            self.aRN = nil
            self.deletionDate = nil
            self.name = nil
        }
    }
}

public struct DeleteSecretOutputResponse: Equatable {
    /// <p>The ARN of the secret that is now scheduled for deletion.</p>
    public let aRN: String?
    /// <p>The date and time after which this secret can be deleted by Secrets Manager and can no longer be
    ///       restored. This value is the date and time of the delete request plus the number of days
    ///       specified in <code>RecoveryWindowInDays</code>.</p>
    public let deletionDate: Date?
    /// <p>The friendly name of the secret currently scheduled for deletion.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        deletionDate: Date? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.deletionDate = deletionDate
        self.name = name
    }
}

struct DeleteSecretOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let deletionDate: Date?
}

extension DeleteSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case deletionDate = "DeletionDate"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
    }
}

public struct DescribeSecretInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecretOutputError>
}

extension DescribeSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSecretInput(secretId: \(String(describing: secretId)))"}
}

extension DescribeSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DescribeSecretInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecretOutputError>
}

public struct DescribeSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecretOutputError>
}

public struct DescribeSecretInput: Equatable {
    /// <p>The identifier of the secret whose details you want to retrieve. You can specify either
    ///       the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        secretId: String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct DescribeSecretInputBody: Equatable {
    public let secretId: String?
}

extension DescribeSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension DescribeSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecretOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSecretOutputResponse(aRN: \(String(describing: aRN)), createdDate: \(String(describing: createdDate)), deletedDate: \(String(describing: deletedDate)), description: \(String(describing: description)), kmsKeyId: \(String(describing: kmsKeyId)), lastAccessedDate: \(String(describing: lastAccessedDate)), lastChangedDate: \(String(describing: lastChangedDate)), lastRotatedDate: \(String(describing: lastRotatedDate)), name: \(String(describing: name)), owningService: \(String(describing: owningService)), primaryRegion: \(String(describing: primaryRegion)), replicationStatus: \(String(describing: replicationStatus)), rotationEnabled: \(String(describing: rotationEnabled)), rotationLambdaARN: \(String(describing: rotationLambdaARN)), rotationRules: \(String(describing: rotationRules)), tags: \(String(describing: tags)), versionIdsToStages: \(String(describing: versionIdsToStages)))"}
}

extension DescribeSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.createdDate = output.createdDate
            self.deletedDate = output.deletedDate
            self.description = output.description
            self.kmsKeyId = output.kmsKeyId
            self.lastAccessedDate = output.lastAccessedDate
            self.lastChangedDate = output.lastChangedDate
            self.lastRotatedDate = output.lastRotatedDate
            self.name = output.name
            self.owningService = output.owningService
            self.primaryRegion = output.primaryRegion
            self.replicationStatus = output.replicationStatus
            self.rotationEnabled = output.rotationEnabled
            self.rotationLambdaARN = output.rotationLambdaARN
            self.rotationRules = output.rotationRules
            self.tags = output.tags
            self.versionIdsToStages = output.versionIdsToStages
        } else {
            self.aRN = nil
            self.createdDate = nil
            self.deletedDate = nil
            self.description = nil
            self.kmsKeyId = nil
            self.lastAccessedDate = nil
            self.lastChangedDate = nil
            self.lastRotatedDate = nil
            self.name = nil
            self.owningService = nil
            self.primaryRegion = nil
            self.replicationStatus = nil
            self.rotationEnabled = false
            self.rotationLambdaARN = nil
            self.rotationRules = nil
            self.tags = nil
            self.versionIdsToStages = nil
        }
    }
}

public struct DescribeSecretOutputResponse: Equatable {
    /// <p>The ARN of the secret.</p>
    public let aRN: String?
    /// <p>The date you created the secret.</p>
    public let createdDate: Date?
    /// <p>This value exists if the secret is scheduled for deletion. Some time after the specified
    ///       date and time, Secrets Manager deletes the secret and all of its versions.</p>
    ///          <p>If a secret is scheduled for deletion, then its details, including the encrypted secret
    ///       information, is not accessible. To cancel a scheduled deletion and restore access, use <a>RestoreSecret</a>.</p>
    public let deletedDate: Date?
    /// <p>The user-provided description of the secret.</p>
    public let description: String?
    /// <p>The ARN or alias of the AWS KMS customer master key (CMK) that's used to encrypt the
    ///         <code>SecretString</code> or <code>SecretBinary</code> fields in each version of the secret.
    ///       If you don't provide a key, then Secrets Manager defaults to encrypting the secret fields with the
    ///       default AWS KMS CMK (the one named <code>awssecretsmanager</code>) for this account.</p>
    public let kmsKeyId: String?
    /// <p>The last date that this secret was accessed. This value is truncated to midnight of the
    ///       date and therefore shows only the date, not the time.</p>
    public let lastAccessedDate: Date?
    /// <p>The last date and time that this secret was modified in any way.</p>
    public let lastChangedDate: Date?
    /// <p>The last date and time that the rotation process for this secret was invoked.</p>
    ///          <p>The most recent date and time that the Secrets Manager rotation process successfully
    ///       completed. If the secret doesn't rotate, Secrets Manager returns a null value.</p>
    public let lastRotatedDate: Date?
    /// <p>The user-provided friendly name of the secret.</p>
    public let name: String?
    /// <p>Returns the name of the service that created this secret.</p>
    public let owningService: String?
    /// <p>Specifies the primary region for secret replication. </p>
    public let primaryRegion: String?
    /// <p>Describes a list of replication status objects as <code>InProgress</code>, <code>Failed</code> or <code>InSync</code>.<code>P</code>
    ///          </p>
    public let replicationStatus: [ReplicationStatusType]?
    /// <p>Specifies whether automatic rotation is enabled for this secret.</p>
    ///          <p>To enable rotation, use <a>RotateSecret</a> with
    ///         <code>AutomaticallyRotateAfterDays</code> set to a value greater than 0. To disable
    ///       rotation, use <a>CancelRotateSecret</a>.</p>
    public let rotationEnabled: Bool
    /// <p>The ARN of a Lambda function that's invoked by Secrets Manager to rotate the
    ///       secret either automatically per the schedule or manually by a call to
    ///         <code>RotateSecret</code>.</p>
    public let rotationLambdaARN: String?
    /// <p>A structure with the rotation configuration for this secret.</p>
    public let rotationRules: RotationRulesType?
    /// <p>The list of user-defined tags that are associated with the secret. To add tags to a
    ///       secret, use <a>TagResource</a>. To remove tags, use <a>UntagResource</a>.</p>
    public let tags: [Tag]?
    /// <p>A list of all of the currently assigned <code>VersionStage</code> staging labels and the
    ///         <code>VersionId</code> that each is attached to. Staging labels are used to keep track of
    ///       the different versions during the rotation process.</p>
    ///          <note>
    ///             <p>A version that does not have any staging labels attached is considered deprecated and
    ///         subject to deletion. Such versions are not included in this list.</p>
    ///          </note>
    public let versionIdsToStages: [String:[String]]?

    public init (
        aRN: String? = nil,
        createdDate: Date? = nil,
        deletedDate: Date? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        lastAccessedDate: Date? = nil,
        lastChangedDate: Date? = nil,
        lastRotatedDate: Date? = nil,
        name: String? = nil,
        owningService: String? = nil,
        primaryRegion: String? = nil,
        replicationStatus: [ReplicationStatusType]? = nil,
        rotationEnabled: Bool = false,
        rotationLambdaARN: String? = nil,
        rotationRules: RotationRulesType? = nil,
        tags: [Tag]? = nil,
        versionIdsToStages: [String:[String]]? = nil
    )
    {
        self.aRN = aRN
        self.createdDate = createdDate
        self.deletedDate = deletedDate
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.lastAccessedDate = lastAccessedDate
        self.lastChangedDate = lastChangedDate
        self.lastRotatedDate = lastRotatedDate
        self.name = name
        self.owningService = owningService
        self.primaryRegion = primaryRegion
        self.replicationStatus = replicationStatus
        self.rotationEnabled = rotationEnabled
        self.rotationLambdaARN = rotationLambdaARN
        self.rotationRules = rotationRules
        self.tags = tags
        self.versionIdsToStages = versionIdsToStages
    }
}

struct DescribeSecretOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let description: String?
    public let kmsKeyId: String?
    public let rotationEnabled: Bool
    public let rotationLambdaARN: String?
    public let rotationRules: RotationRulesType?
    public let lastRotatedDate: Date?
    public let lastChangedDate: Date?
    public let lastAccessedDate: Date?
    public let deletedDate: Date?
    public let tags: [Tag]?
    public let versionIdsToStages: [String:[String]]?
    public let owningService: String?
    public let createdDate: Date?
    public let primaryRegion: String?
    public let replicationStatus: [ReplicationStatusType]?
}

extension DescribeSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case deletedDate = "DeletedDate"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case lastChangedDate = "LastChangedDate"
        case lastRotatedDate = "LastRotatedDate"
        case name = "Name"
        case owningService = "OwningService"
        case primaryRegion = "PrimaryRegion"
        case replicationStatus = "ReplicationStatus"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case tags = "Tags"
        case versionIdsToStages = "VersionIdsToStages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .rotationEnabled)
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let lastRotatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRotatedDate)
        lastRotatedDate = lastRotatedDateDecoded
        let lastChangedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastChangedDate)
        lastChangedDate = lastChangedDateDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let deletedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletedDate)
        deletedDate = deletedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionIdsToStagesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .versionIdsToStages)
        var versionIdsToStagesDecoded0: [String:[String]]? = nil
        if let versionIdsToStagesContainer = versionIdsToStagesContainer {
            versionIdsToStagesDecoded0 = [String:[String]]()
            for (key0, secretversionstagestype0) in versionIdsToStagesContainer {
                var secretversionstagestype0Decoded0: [String]? = nil
                if let secretversionstagestype0 = secretversionstagestype0 {
                    secretversionstagestype0Decoded0 = [String]()
                    for string1 in secretversionstagestype0 {
                        if let string1 = string1 {
                            secretversionstagestype0Decoded0?.append(string1)
                        }
                    }
                }
                versionIdsToStagesDecoded0?[key0] = secretversionstagestype0Decoded0
            }
        }
        versionIdsToStages = versionIdsToStagesDecoded0
        let owningServiceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owningService)
        owningService = owningServiceDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let primaryRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension EncryptionFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionFailure(message: \(String(describing: message)))"}
}

extension EncryptionFailure: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EncryptionFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Secrets Manager can't encrypt the protected secret text using the provided KMS key. Check that the
///       customer master key (CMK) is available, enabled, and not in an invalid state. For more
///       information, see <a href="http://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///         Customer Master Key</a>.</p>
public struct EncryptionFailure: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionFailureBody: Equatable {
    public let message: String?
}

extension EncryptionFailureBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervaluesstringlist0 in values {
                try valuesContainer.encode(filtervaluesstringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(FilterNameStringType.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Allows you to add filters when you use the search function in Secrets Manager.</p>
public struct Filter: Equatable {
    /// <p>Filters your list of secrets by a specific key.</p>
    public let key: FilterNameStringType?
    /// <p>Filters your list of secrets by a specific value.</p>
    ///          <p>You can prefix your search value with an exclamation mark (<code>!</code>) in order to perform negation filters. </p>
    public let values: [String]?

    public init (
        key: FilterNameStringType? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public enum FilterNameStringType {
    case all
    case description
    case name
    case primaryRegion
    case tagKey
    case tagValue
    case sdkUnknown(String)
}

extension FilterNameStringType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterNameStringType] {
        return [
            .all,
            .description,
            .name,
            .primaryRegion,
            .tagKey,
            .tagValue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "all"
        case .description: return "description"
        case .name: return "name"
        case .primaryRegion: return "primary-region"
        case .tagKey: return "tag-key"
        case .tagValue: return "tag-value"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterNameStringType(rawValue: rawValue) ?? FilterNameStringType.sdkUnknown(rawValue)
    }
}

public struct GetRandomPasswordInputBodyMiddleware: Middleware {
    public let id: String = "GetRandomPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRandomPasswordOutputError>
}

extension GetRandomPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRandomPasswordInput(excludeCharacters: \(String(describing: excludeCharacters)), excludeLowercase: \(String(describing: excludeLowercase)), excludeNumbers: \(String(describing: excludeNumbers)), excludePunctuation: \(String(describing: excludePunctuation)), excludeUppercase: \(String(describing: excludeUppercase)), includeSpace: \(String(describing: includeSpace)), passwordLength: \(String(describing: passwordLength)), requireEachIncludedType: \(String(describing: requireEachIncludedType)))"}
}

extension GetRandomPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludeCharacters = "ExcludeCharacters"
        case excludeLowercase = "ExcludeLowercase"
        case excludeNumbers = "ExcludeNumbers"
        case excludePunctuation = "ExcludePunctuation"
        case excludeUppercase = "ExcludeUppercase"
        case includeSpace = "IncludeSpace"
        case passwordLength = "PasswordLength"
        case requireEachIncludedType = "RequireEachIncludedType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeCharacters = excludeCharacters {
            try encodeContainer.encode(excludeCharacters, forKey: .excludeCharacters)
        }
        if excludeLowercase != false {
            try encodeContainer.encode(excludeLowercase, forKey: .excludeLowercase)
        }
        if excludeNumbers != false {
            try encodeContainer.encode(excludeNumbers, forKey: .excludeNumbers)
        }
        if excludePunctuation != false {
            try encodeContainer.encode(excludePunctuation, forKey: .excludePunctuation)
        }
        if excludeUppercase != false {
            try encodeContainer.encode(excludeUppercase, forKey: .excludeUppercase)
        }
        if includeSpace != false {
            try encodeContainer.encode(includeSpace, forKey: .includeSpace)
        }
        if passwordLength != 0 {
            try encodeContainer.encode(passwordLength, forKey: .passwordLength)
        }
        if requireEachIncludedType != false {
            try encodeContainer.encode(requireEachIncludedType, forKey: .requireEachIncludedType)
        }
    }
}

public struct GetRandomPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "GetRandomPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRandomPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInput: Equatable {
    /// <p>A string that includes characters that should not be included in the generated password.
    ///       The default is that all characters from the included sets can be used.</p>
    public let excludeCharacters: String?
    /// <p>Specifies that the generated password should not include lowercase letters. The default if
    ///       you do not include this switch parameter is that lowercase letters can be included.</p>
    public let excludeLowercase: Bool
    /// <p>Specifies that the generated password should not include digits. The default if you do not
    ///       include this switch parameter is that digits can be included.</p>
    public let excludeNumbers: Bool
    /// <p>Specifies that the generated password should not include punctuation characters. The
    ///       default if you do not include this switch parameter is that punctuation characters can be
    ///       included.</p>
    ///          <p>The following are the punctuation characters that <i>can</i> be included in
    ///       the generated password if you don't explicitly exclude them with
    ///         <code>ExcludeCharacters</code> or <code>ExcludePunctuation</code>:</p>
    ///          <p>
    ///             <code>! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
    ///       ~</code>
    ///          </p>
    public let excludePunctuation: Bool
    /// <p>Specifies that the generated password should not include uppercase letters. The default if
    ///       you do not include this switch parameter is that uppercase letters can be included.</p>
    public let excludeUppercase: Bool
    /// <p>Specifies that the generated password can include the space character. The default if you
    ///       do not include this switch parameter is that the space character is not included.</p>
    public let includeSpace: Bool
    /// <p>The desired length of the generated password. The default value if you do not include this
    ///       parameter is 32 characters.</p>
    public let passwordLength: Int
    /// <p>A boolean value that specifies whether the generated password must include at least one of
    ///       every allowed character type. The default value is <code>True</code> and the operation
    ///       requires at least one of every character type.</p>
    public let requireEachIncludedType: Bool

    public init (
        excludeCharacters: String? = nil,
        excludeLowercase: Bool = false,
        excludeNumbers: Bool = false,
        excludePunctuation: Bool = false,
        excludeUppercase: Bool = false,
        includeSpace: Bool = false,
        passwordLength: Int = 0,
        requireEachIncludedType: Bool = false
    )
    {
        self.excludeCharacters = excludeCharacters
        self.excludeLowercase = excludeLowercase
        self.excludeNumbers = excludeNumbers
        self.excludePunctuation = excludePunctuation
        self.excludeUppercase = excludeUppercase
        self.includeSpace = includeSpace
        self.passwordLength = passwordLength
        self.requireEachIncludedType = requireEachIncludedType
    }
}

struct GetRandomPasswordInputBody: Equatable {
    public let passwordLength: Int
    public let excludeCharacters: String?
    public let excludeNumbers: Bool
    public let excludePunctuation: Bool
    public let excludeUppercase: Bool
    public let excludeLowercase: Bool
    public let includeSpace: Bool
    public let requireEachIncludedType: Bool
}

extension GetRandomPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case excludeCharacters = "ExcludeCharacters"
        case excludeLowercase = "ExcludeLowercase"
        case excludeNumbers = "ExcludeNumbers"
        case excludePunctuation = "ExcludePunctuation"
        case excludeUppercase = "ExcludeUppercase"
        case includeSpace = "IncludeSpace"
        case passwordLength = "PasswordLength"
        case requireEachIncludedType = "RequireEachIncludedType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passwordLengthDecoded = try containerValues.decode(Int.self, forKey: .passwordLength)
        passwordLength = passwordLengthDecoded
        let excludeCharactersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .excludeCharacters)
        excludeCharacters = excludeCharactersDecoded
        let excludeNumbersDecoded = try containerValues.decode(Bool.self, forKey: .excludeNumbers)
        excludeNumbers = excludeNumbersDecoded
        let excludePunctuationDecoded = try containerValues.decode(Bool.self, forKey: .excludePunctuation)
        excludePunctuation = excludePunctuationDecoded
        let excludeUppercaseDecoded = try containerValues.decode(Bool.self, forKey: .excludeUppercase)
        excludeUppercase = excludeUppercaseDecoded
        let excludeLowercaseDecoded = try containerValues.decode(Bool.self, forKey: .excludeLowercase)
        excludeLowercase = excludeLowercaseDecoded
        let includeSpaceDecoded = try containerValues.decode(Bool.self, forKey: .includeSpace)
        includeSpace = includeSpaceDecoded
        let requireEachIncludedTypeDecoded = try containerValues.decode(Bool.self, forKey: .requireEachIncludedType)
        requireEachIncludedType = requireEachIncludedTypeDecoded
    }
}

extension GetRandomPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRandomPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRandomPasswordOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRandomPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRandomPasswordOutputResponse(randomPassword: \(String(describing: randomPassword)))"}
}

extension GetRandomPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRandomPasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.randomPassword = output.randomPassword
        } else {
            self.randomPassword = nil
        }
    }
}

public struct GetRandomPasswordOutputResponse: Equatable {
    /// <p>A string with the generated password.</p>
    public let randomPassword: String?

    public init (
        randomPassword: String? = nil
    )
    {
        self.randomPassword = randomPassword
    }
}

struct GetRandomPasswordOutputResponseBody: Equatable {
    public let randomPassword: String?
}

extension GetRandomPasswordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case randomPassword = "RandomPassword"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let randomPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .randomPassword)
        randomPassword = randomPasswordDecoded
    }
}

public struct GetResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

extension GetResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyInput(secretId: \(String(describing: secretId)))"}
}

extension GetResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct GetResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInput: Equatable {
    /// <p>Specifies the secret that you want to retrieve the attached resource-based policy for. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        secretId: String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct GetResourcePolicyInputBody: Equatable {
    public let secretId: String?
}

extension GetResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension GetResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)), resourcePolicy: \(String(describing: resourcePolicy)))"}
}

extension GetResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.aRN = nil
            self.name = nil
            self.resourcePolicy = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Equatable {
    /// <p>The ARN of the secret that the resource-based policy was retrieved for.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret that the resource-based policy was retrieved for.</p>
    public let name: String?
    /// <p>A JSON-formatted string that describes the permissions that are associated with the
    ///       attached secret. These permissions are combined with any permissions that are associated with
    ///       the user or role that attempts to access this secret. The combined permissions specify who can
    ///       access the secret and what actions they can perform. For more information, see <a href="http://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication and Access Control for
    ///         AWS Secrets Manager</a> in the <i>AWS Secrets Manager User Guide</i>.</p>
    public let resourcePolicy: String?

    public init (
        aRN: String? = nil,
        name: String? = nil,
        resourcePolicy: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.resourcePolicy = resourcePolicy
    }
}

struct GetResourcePolicyOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let resourcePolicy: String?
}

extension GetResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case resourcePolicy = "ResourcePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

public struct GetSecretValueInputBodyMiddleware: Middleware {
    public let id: String = "GetSecretValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecretValueOutputError>
}

extension GetSecretValueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSecretValueInput(secretId: \(String(describing: secretId)), versionId: \(String(describing: versionId)), versionStage: \(String(describing: versionStage)))"}
}

extension GetSecretValueInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
        case versionId = "VersionId"
        case versionStage = "VersionStage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
        if let versionStage = versionStage {
            try encodeContainer.encode(versionStage, forKey: .versionStage)
        }
    }
}

public struct GetSecretValueInputHeadersMiddleware: Middleware {
    public let id: String = "GetSecretValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecretValueOutputError>
}

public struct GetSecretValueInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSecretValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecretValueOutputError>
}

public struct GetSecretValueInput: Equatable {
    /// <p>Specifies the secret containing the version that you want to retrieve. You can specify
    ///       either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?
    /// <p>Specifies the unique identifier of the version of the secret that you want to retrieve. If
    ///       you specify both this parameter and <code>VersionStage</code>,  the two parameters must refer
    ///       to the same secret version. If you don't specify either a <code>VersionStage</code> or
    ///         <code>VersionId</code> then the default is to perform the operation on the version with the
    ///         <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
    ///          <p>This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value with
    ///       32 hexadecimal digits.</p>
    public let versionId: String?
    /// <p>Specifies the secret version that you want to retrieve by the staging label attached to
    ///       the version.</p>
    ///          <p>Staging labels are used to keep track of different versions during the rotation process.
    ///       If you specify both this parameter and <code>VersionId</code>,  the two parameters must refer
    ///       to the same secret version . If you don't specify either a <code>VersionStage</code> or
    ///         <code>VersionId</code>, then the default is to perform the operation on the version with the
    ///         <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
    public let versionStage: String?

    public init (
        secretId: String? = nil,
        versionId: String? = nil,
        versionStage: String? = nil
    )
    {
        self.secretId = secretId
        self.versionId = versionId
        self.versionStage = versionStage
    }
}

struct GetSecretValueInputBody: Equatable {
    public let secretId: String?
    public let versionId: String?
    public let versionStage: String?
}

extension GetSecretValueInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
        case versionId = "VersionId"
        case versionStage = "VersionStage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionStage)
        versionStage = versionStageDecoded
    }
}

extension GetSecretValueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSecretValueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DecryptionFailure" : self = .decryptionFailure(try DecryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSecretValueOutputError: Swift.Error, Equatable {
    case decryptionFailure(DecryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSecretValueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSecretValueOutputResponse(aRN: \(String(describing: aRN)), createdDate: \(String(describing: createdDate)), name: \(String(describing: name)), secretBinary: \(String(describing: secretBinary)), secretString: \(String(describing: secretString)), versionId: \(String(describing: versionId)), versionStages: \(String(describing: versionStages)))"}
}

extension GetSecretValueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSecretValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.createdDate = output.createdDate
            self.name = output.name
            self.secretBinary = output.secretBinary
            self.secretString = output.secretString
            self.versionId = output.versionId
            self.versionStages = output.versionStages
        } else {
            self.aRN = nil
            self.createdDate = nil
            self.name = nil
            self.secretBinary = nil
            self.secretString = nil
            self.versionId = nil
            self.versionStages = nil
        }
    }
}

public struct GetSecretValueOutputResponse: Equatable {
    /// <p>The ARN of the secret.</p>
    public let aRN: String?
    /// <p>The date and time that this version of the secret was created.</p>
    public let createdDate: Date?
    /// <p>The friendly name of the secret.</p>
    public let name: String?
    /// <p>The decrypted part of the protected secret information that was originally provided as
    ///       binary data in the form of a byte array. The response parameter represents the binary data as
    ///       a <a href="https://tools.ietf.org/html/rfc4648#section-4">base64-encoded</a>
    ///       string.</p>
    ///          <p>This parameter is not used if the secret is created by the Secrets Manager console.</p>
    ///          <p>If you store custom information in this field of the secret, then you must code your
    ///       Lambda rotation function to parse and interpret whatever you store in the
    ///         <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
    public let secretBinary: Data?
    /// <p>The decrypted part of the protected secret information that was originally provided as a
    ///       string.</p>
    ///          <p>If you create this secret by using the Secrets Manager console then only the
    ///         <code>SecretString</code> parameter contains data. Secrets Manager stores the information as a
    ///       JSON structure of key/value pairs that the Lambda rotation function knows how to parse.</p>
    ///          <p>If you store custom information in the secret by using the <a>CreateSecret</a>,
    ///         <a>UpdateSecret</a>, or <a>PutSecretValue</a> API operations instead
    ///       of the Secrets Manager console, or by using the <b>Other secret type</b> in
    ///       the console, then you must code your Lambda rotation function to parse and interpret those
    ///       values.</p>
    public let secretString: String?
    /// <p>The unique identifier of this version of the secret.</p>
    public let versionId: String?
    /// <p>A list of all of the staging labels currently attached to this version of the
    ///       secret.</p>
    public let versionStages: [String]?

    public init (
        aRN: String? = nil,
        createdDate: Date? = nil,
        name: String? = nil,
        secretBinary: Data? = nil,
        secretString: String? = nil,
        versionId: String? = nil,
        versionStages: [String]? = nil
    )
    {
        self.aRN = aRN
        self.createdDate = createdDate
        self.name = name
        self.secretBinary = secretBinary
        self.secretString = secretString
        self.versionId = versionId
        self.versionStages = versionStages
    }
}

struct GetSecretValueOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let versionId: String?
    public let secretBinary: Data?
    public let secretString: String?
    public let versionStages: [String]?
    public let createdDate: Date?
}

extension GetSecretValueOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension InternalServiceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceError(message: \(String(describing: message)))"}
}

extension InternalServiceError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred on the server side.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided an invalid <code>NextToken</code> value.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided an invalid value for a parameter.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided a parameter value that is not valid for the current state of the
///       resource.</p>
///          <p>Possible causes:</p>
///          <ul>
///             <li>
///                <p>You tried to perform the operation on a secret that's currently marked deleted.</p>
///             </li>
///             <li>
///                <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
///           ARN configured and you didn't include such an ARN as a parameter in this call. </p>
///             </li>
///          </ul>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because it would exceed one of the Secrets Manager internal limits.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListSecretVersionIdsInputBodyMiddleware: Middleware {
    public let id: String = "ListSecretVersionIdsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecretVersionIdsOutputError>
}

extension ListSecretVersionIdsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecretVersionIdsInput(includeDeprecated: \(String(describing: includeDeprecated)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), secretId: \(String(describing: secretId)))"}
}

extension ListSecretVersionIdsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeDeprecated = "IncludeDeprecated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeDeprecated != false {
            try encodeContainer.encode(includeDeprecated, forKey: .includeDeprecated)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ListSecretVersionIdsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSecretVersionIdsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecretVersionIdsOutputError>
}

public struct ListSecretVersionIdsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSecretVersionIdsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecretVersionIdsOutputError>
}

public struct ListSecretVersionIdsInput: Equatable {
    /// <p>(Optional) Specifies that you want the results to include versions that do not have any
    ///       staging labels attached to them. Such versions are considered deprecated and are subject to
    ///       deletion by Secrets Manager as needed.</p>
    public let includeDeprecated: Bool
    /// <p>(Optional) Limits the number of results you want to include in
    ///     the response. If you don't include this parameter, it defaults to a value that's
    ///     specific to the operation. If additional items exist beyond the maximum you specify, the
    ///     <code>NextToken</code> response element is present and has a value (isn't null). Include
    ///     that value as the <code>NextToken</code> request parameter in the next call to the operation to
    ///     get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    ///     even when there are more results available. You should check <code>NextToken</code> after every
    ///     operation to ensure that you receive all of the results.</p>
    public let maxResults: Int
    /// <p>(Optional) Use this parameter in a request if you receive a
    ///     <code>NextToken</code> response in a previous request indicating there's more
    ///     output available. In a subsequent call, set it to the value of the previous call
    ///     <code>NextToken</code> response to indicate where the output should continue from.</p>
    public let nextToken: String?
    /// <p>The identifier for the secret containing the versions you want to list. You can specify
    ///       either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        includeDeprecated: Bool = false,
        maxResults: Int = 0,
        nextToken: String? = nil,
        secretId: String? = nil
    )
    {
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secretId = secretId
    }
}

struct ListSecretVersionIdsInputBody: Equatable {
    public let secretId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let includeDeprecated: Bool
}

extension ListSecretVersionIdsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeDeprecated = "IncludeDeprecated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeDeprecatedDecoded = try containerValues.decode(Bool.self, forKey: .includeDeprecated)
        includeDeprecated = includeDeprecatedDecoded
    }
}

extension ListSecretVersionIdsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecretVersionIdsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecretVersionIdsOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecretVersionIdsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecretVersionIdsOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListSecretVersionIdsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecretVersionIdsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.aRN = nil
            self.name = nil
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListSecretVersionIdsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the secret.</p>
    ///          <note>
    ///             <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret <i>don't</i>
    ///         automatically get access to the new secret because the ARNs are different.</p>
    ///          </note>
    public let aRN: String?
    /// <p>The friendly name of the secret.</p>
    public let name: String?
    /// <p>If present in the response, this value indicates that
    ///     there's more output available than included in the current response. This can
    ///     occur even when the response includes no values at all, such as when you ask for a filtered view
    ///     of a very long list. Use this value in the <code>NextToken</code> request parameter in a
    ///     subsequent call to the operation to continue processing and get the next part of the output. You
    ///     should repeat this until the <code>NextToken</code> response element comes back empty (as
    ///     <code>null</code>).</p>
    public let nextToken: String?
    /// <p>The list of the currently available versions of the specified secret.</p>
    public let versions: [SecretVersionsListEntry]?

    public init (
        aRN: String? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        versions: [SecretVersionsListEntry]? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListSecretVersionIdsOutputResponseBody: Equatable {
    public let versions: [SecretVersionsListEntry]?
    public let nextToken: String?
    public let aRN: String?
    public let name: String?
}

extension ListSecretVersionIdsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([SecretVersionsListEntry?].self, forKey: .versions)
        var versionsDecoded0:[SecretVersionsListEntry]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [SecretVersionsListEntry]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct ListSecretsInputBodyMiddleware: Middleware {
    public let id: String = "ListSecretsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecretsInput>
    public typealias MOutput = OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecretsOutputError>
}

extension ListSecretsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecretsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListSecretsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterslisttype0 in filters {
                try filtersContainer.encode(filterslisttype0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListSecretsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSecretsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecretsInput>
    public typealias MOutput = OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecretsOutputError>
}

public struct ListSecretsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSecretsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecretsInput>
    public typealias MOutput = OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecretsOutputError>
}

public struct ListSecretsInput: Equatable {
    /// <p>Lists the secret request filters.</p>
    public let filters: [Filter]?
    /// <p>(Optional) Limits the number of results you want to include in
    ///     the response. If you don't include this parameter, it defaults to a value that's
    ///     specific to the operation. If additional items exist beyond the maximum you specify, the
    ///     <code>NextToken</code> response element is present and has a value (isn't null). Include
    ///     that value as the <code>NextToken</code> request parameter in the next call to the operation to
    ///     get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    ///     even when there are more results available. You should check <code>NextToken</code> after every
    ///     operation to ensure that you receive all of the results.</p>
    public let maxResults: Int
    /// <p>(Optional) Use this parameter in a request if you receive a
    ///     <code>NextToken</code> response in a previous request indicating there's more
    ///     output available. In a subsequent call, set it to the value of the previous call
    ///     <code>NextToken</code> response to indicate where the output should continue from.</p>
    public let nextToken: String?
    /// <p>Lists secrets in the requested order. </p>
    public let sortOrder: SortOrderType?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListSecretsInputBody: Equatable {
    public let maxResults: Int
    public let nextToken: String?
    public let filters: [Filter]?
    public let sortOrder: SortOrderType?
}

extension ListSecretsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListSecretsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecretsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecretsOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecretsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecretsOutputResponse(nextToken: \(String(describing: nextToken)), secretList: \(String(describing: secretList)))"}
}

extension ListSecretsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecretsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.secretList = output.secretList
        } else {
            self.nextToken = nil
            self.secretList = nil
        }
    }
}

public struct ListSecretsOutputResponse: Equatable {
    /// <p>If present in the response, this value indicates that
    ///     there's more output available than included in the current response. This can
    ///     occur even when the response includes no values at all, such as when you ask for a filtered view
    ///     of a very long list. Use this value in the <code>NextToken</code> request parameter in a
    ///     subsequent call to the operation to continue processing and get the next part of the output. You
    ///     should repeat this until the <code>NextToken</code> response element comes back empty (as
    ///     <code>null</code>).</p>
    public let nextToken: String?
    /// <p>A list of the secrets in the account.</p>
    public let secretList: [SecretListEntry]?

    public init (
        nextToken: String? = nil,
        secretList: [SecretListEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.secretList = secretList
    }
}

struct ListSecretsOutputResponseBody: Equatable {
    public let secretList: [SecretListEntry]?
    public let nextToken: String?
}

extension ListSecretsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case secretList = "SecretList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretListContainer = try containerValues.decodeIfPresent([SecretListEntry?].self, forKey: .secretList)
        var secretListDecoded0:[SecretListEntry]? = nil
        if let secretListContainer = secretListContainer {
            secretListDecoded0 = [SecretListEntry]()
            for structure0 in secretListContainer {
                if let structure0 = structure0 {
                    secretListDecoded0?.append(structure0)
                }
            }
        }
        secretList = secretListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedPolicyDocumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedPolicyDocumentException(message: \(String(describing: message)))"}
}

extension MalformedPolicyDocumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MalformedPolicyDocumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided a resource-based policy with syntax errors.</p>
public struct MalformedPolicyDocumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Equatable {
    public let message: String?
}

extension MalformedPolicyDocumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionNotMetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreconditionNotMetException(message: \(String(describing: message)))"}
}

extension PreconditionNotMetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because you did not complete all the prerequisite steps.</p>
public struct PreconditionNotMetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionNotMetExceptionBody: Equatable {
    public let message: String?
}

extension PreconditionNotMetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PublicPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicPolicyException(message: \(String(describing: message)))"}
}

extension PublicPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublicPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The BlockPublicPolicy parameter is set to true and the resource policy did not prevent broad access to the secret.</p>
public struct PublicPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PublicPolicyExceptionBody: Equatable {
    public let message: String?
}

extension PublicPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyInput(blockPublicPolicy: \(String(describing: blockPublicPolicy)), resourcePolicy: \(String(describing: resourcePolicy)), secretId: \(String(describing: secretId)))"}
}

extension PutResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicPolicy = "BlockPublicPolicy"
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if let resourcePolicy = resourcePolicy {
            try encodeContainer.encode(resourcePolicy, forKey: .resourcePolicy)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Equatable {
    /// <p>(Optional) If you set the parameter, <code>BlockPublicPolicy</code> to true, then you
    ///       block resource-based policies that allow broad access to the secret.</p>
    public let blockPublicPolicy: Bool
    /// <p>A JSON-formatted string constructed according to the grammar and syntax for an AWS
    ///       resource-based policy. The policy in the string identifies who can access or manage this
    ///       secret and its versions. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    ///         JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    public let resourcePolicy: String?
    /// <p>Specifies the secret that you want to attach the resource-based policy. You can specify
    ///       either the ARN or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        blockPublicPolicy: Bool = false,
        resourcePolicy: String? = nil,
        secretId: String? = nil
    )
    {
        self.blockPublicPolicy = blockPublicPolicy
        self.resourcePolicy = resourcePolicy
        self.secretId = secretId
    }
}

struct PutResourcePolicyInputBody: Equatable {
    public let secretId: String?
    public let resourcePolicy: String?
    public let blockPublicPolicy: Bool
}

extension PutResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockPublicPolicy = "BlockPublicPolicy"
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
    }
}

extension PutResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicPolicyException" : self = .publicPolicyException(try PublicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case publicPolicyException(PublicPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)))"}
}

extension PutResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Equatable {
    /// <p>The ARN of the secret retrieved by the resource-based policy.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret retrieved by the resource-based policy.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct PutResourcePolicyOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
}

extension PutResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct PutSecretValueInputBodyMiddleware: Middleware {
    public let id: String = "PutSecretValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSecretValueOutputError>
}

extension PutSecretValueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSecretValueInput(clientRequestToken: \(String(describing: clientRequestToken)), secretBinary: \(String(describing: secretBinary)), secretId: \(String(describing: secretId)), secretString: \(String(describing: secretString)), versionStages: \(String(describing: versionStages)))"}
}

extension PutSecretValueInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
        case versionStages = "VersionStages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
        if let versionStages = versionStages {
            var versionStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionStages)
            for secretversionstagestype0 in versionStages {
                try versionStagesContainer.encode(secretversionstagestype0)
            }
        }
    }
}

public struct PutSecretValueInputHeadersMiddleware: Middleware {
    public let id: String = "PutSecretValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSecretValueOutputError>
}

public struct PutSecretValueInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSecretValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSecretValueOutputError>
}

public struct PutSecretValueInput: Equatable {
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret. </p>
    ///          <note>
    ///             <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///         leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///         in the request. If you don't use the SDK and instead generate a raw HTTP request to the
    ///         Secrets Manager service endpoint, then you must generate a <code>ClientRequestToken</code> yourself
    ///         for new versions and include that value in the request. </p>
    ///          </note>
    ///          <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    ///       creation of duplicate versions if there are failures and retries during the Lambda rotation
    ///       function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    ///       ensure uniqueness within the specified secret. </p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    ///           of the secret then a new version of the secret is created. </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> or <code>SecretBinary</code> values are the same as those in
    ///           the request then the request is ignored (the operation is idempotent). </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and the version of the
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    ///           in the request then the request fails because you cannot modify an existing secret
    ///           version. You can only create new versions to store new secret values.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This value becomes the <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: String?
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    ///       the secret. To use this parameter in the command-line tools, we recommend that you store your
    ///       binary data in a file and then use the appropriate technique for your tool to pass the
    ///       contents of the file as a parameter. Either <code>SecretBinary</code> or
    ///         <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    ///
    ///          <p>This parameter is not accessible if the secret using the Secrets Manager console.</p>
    ///          <p></p>
    public let secretBinary: Data?
    /// <p>Specifies the secret to which you want to add a new version. You can specify either the
    ///       Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
    ///       exist.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    ///       the secret. Either <code>SecretString</code> or <code>SecretBinary</code> must have a value,
    ///       but not both. They cannot both be empty.</p>
    ///
    ///          <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    ///       protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    ///       stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    ///       function knows how to parse.</p>
    ///          <p>For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    ///          <p> For example:</p>
    ///          <p>
    ///             <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text.</p>
    public let secretString: String?
    /// <p>(Optional) Specifies a list of staging labels that are attached to this version of the
    ///       secret. These staging labels are used to track the versions through the rotation process by
    ///       the Lambda rotation function.</p>
    ///          <p>A staging label must be unique to a single version of the secret. If you specify a staging
    ///       label that's already associated with a different version of the same secret then that staging
    ///       label is automatically removed from the other version and attached to this version.</p>
    ///          <p>If you do not specify a value for <code>VersionStages</code> then Secrets Manager automatically
    ///       moves the staging label <code>AWSCURRENT</code> to this new version.</p>
    public let versionStages: [String]?

    public init (
        clientRequestToken: String? = nil,
        secretBinary: Data? = nil,
        secretId: String? = nil,
        secretString: String? = nil,
        versionStages: [String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.secretBinary = secretBinary
        self.secretId = secretId
        self.secretString = secretString
        self.versionStages = versionStages
    }
}

struct PutSecretValueInputBody: Equatable {
    public let secretId: String?
    public let clientRequestToken: String?
    public let secretBinary: Data?
    public let secretString: String?
    public let versionStages: [String]?
}

extension PutSecretValueInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
    }
}

extension PutSecretValueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSecretValueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSecretValueOutputError: Swift.Error, Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSecretValueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSecretValueOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)), versionId: \(String(describing: versionId)), versionStages: \(String(describing: versionStages)))"}
}

extension PutSecretValueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutSecretValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
            self.versionStages = output.versionStages
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
            self.versionStages = nil
        }
    }
}

public struct PutSecretValueOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the secret for which you just created a version.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret for which you just created or updated a version.</p>
    public let name: String?
    /// <p>The unique identifier of the version of the secret you just created or updated.</p>
    public let versionId: String?
    /// <p>The list of staging labels that are currently attached to this version of the secret.
    ///       Staging labels are used to track a version as it progresses through the secret rotation
    ///       process.</p>
    public let versionStages: [String]?

    public init (
        aRN: String? = nil,
        name: String? = nil,
        versionId: String? = nil,
        versionStages: [String]? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
        self.versionStages = versionStages
    }
}

struct PutSecretValueOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let versionId: String?
    public let versionStages: [String]?
}

extension PutSecretValueOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
    }
}

public struct RemoveRegionsFromReplicationInputBodyMiddleware: Middleware {
    public let id: String = "RemoveRegionsFromReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRegionsFromReplicationOutputError>
}

extension RemoveRegionsFromReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRegionsFromReplicationInput(removeReplicaRegions: \(String(describing: removeReplicaRegions)), secretId: \(String(describing: secretId)))"}
}

extension RemoveRegionsFromReplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case removeReplicaRegions = "RemoveReplicaRegions"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let removeReplicaRegions = removeReplicaRegions {
            var removeReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeReplicaRegions)
            for removereplicaregionlisttype0 in removeReplicaRegions {
                try removeReplicaRegionsContainer.encode(removereplicaregionlisttype0)
            }
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RemoveRegionsFromReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveRegionsFromReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRegionsFromReplicationOutputError>
}

public struct RemoveRegionsFromReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveRegionsFromReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRegionsFromReplicationOutputError>
}

public struct RemoveRegionsFromReplicationInput: Equatable {
    /// <p>Remove replication from specific Regions.</p>
    public let removeReplicaRegions: [String]?
    /// <p>Remove a secret by <code>SecretId</code> from replica Regions.</p>
    public let secretId: String?

    public init (
        removeReplicaRegions: [String]? = nil,
        secretId: String? = nil
    )
    {
        self.removeReplicaRegions = removeReplicaRegions
        self.secretId = secretId
    }
}

struct RemoveRegionsFromReplicationInputBody: Equatable {
    public let secretId: String?
    public let removeReplicaRegions: [String]?
}

extension RemoveRegionsFromReplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case removeReplicaRegions = "RemoveReplicaRegions"
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let removeReplicaRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .removeReplicaRegions)
        var removeReplicaRegionsDecoded0:[String]? = nil
        if let removeReplicaRegionsContainer = removeReplicaRegionsContainer {
            removeReplicaRegionsDecoded0 = [String]()
            for string0 in removeReplicaRegionsContainer {
                if let string0 = string0 {
                    removeReplicaRegionsDecoded0?.append(string0)
                }
            }
        }
        removeReplicaRegions = removeReplicaRegionsDecoded0
    }
}

extension RemoveRegionsFromReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveRegionsFromReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRegionsFromReplicationOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRegionsFromReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRegionsFromReplicationOutputResponse(aRN: \(String(describing: aRN)), replicationStatus: \(String(describing: replicationStatus)))"}
}

extension RemoveRegionsFromReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveRegionsFromReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.replicationStatus = output.replicationStatus
        } else {
            self.aRN = nil
            self.replicationStatus = nil
        }
    }
}

public struct RemoveRegionsFromReplicationOutputResponse: Equatable {
    /// <p>The secret <code>ARN</code> removed from replication regions.</p>
    public let aRN: String?
    /// <p>Describes the remaining replication status after you remove regions from the replication list.</p>
    public let replicationStatus: [ReplicationStatusType]?

    public init (
        aRN: String? = nil,
        replicationStatus: [ReplicationStatusType]? = nil
    )
    {
        self.aRN = aRN
        self.replicationStatus = replicationStatus
    }
}

struct RemoveRegionsFromReplicationOutputResponseBody: Equatable {
    public let aRN: String?
    public let replicationStatus: [ReplicationStatusType]?
}

extension RemoveRegionsFromReplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case replicationStatus = "ReplicationStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension ReplicaRegionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case region = "Region"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension ReplicaRegionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicaRegionType(kmsKeyId: \(String(describing: kmsKeyId)), region: \(String(describing: region)))"}
}

/// <p>(Optional) Custom type consisting of a <code>Region</code> (required) and the <code>KmsKeyId</code> which can be an <code>ARN</code>, <code>Key ID</code>, or <code>Alias</code>.</p>
public struct ReplicaRegionType: Equatable {
    /// <p>Can be an <code>ARN</code>, <code>Key ID</code>, or <code>Alias</code>. </p>
    public let kmsKeyId: String?
    /// <p>Describes a single instance of Region objects.</p>
    public let region: String?

    public init (
        kmsKeyId: String? = nil,
        region: String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.region = region
    }
}

public struct ReplicateSecretToRegionsInputBodyMiddleware: Middleware {
    public let id: String = "ReplicateSecretToRegionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReplicateSecretToRegionsOutputError>
}

extension ReplicateSecretToRegionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicateSecretToRegionsInput(addReplicaRegions: \(String(describing: addReplicaRegions)), forceOverwriteReplicaSecret: \(String(describing: forceOverwriteReplicaSecret)), secretId: \(String(describing: secretId)))"}
}

extension ReplicateSecretToRegionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addReplicaRegions = addReplicaRegions {
            var addReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addReplicaRegions)
            for addreplicaregionlisttype0 in addReplicaRegions {
                try addReplicaRegionsContainer.encode(addreplicaregionlisttype0)
            }
        }
        if forceOverwriteReplicaSecret != false {
            try encodeContainer.encode(forceOverwriteReplicaSecret, forKey: .forceOverwriteReplicaSecret)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ReplicateSecretToRegionsInputHeadersMiddleware: Middleware {
    public let id: String = "ReplicateSecretToRegionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReplicateSecretToRegionsOutputError>
}

public struct ReplicateSecretToRegionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ReplicateSecretToRegionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReplicateSecretToRegionsOutputError>
}

public struct ReplicateSecretToRegionsInput: Equatable {
    /// <p>Add Regions to replicate the secret.</p>
    public let addReplicaRegions: [ReplicaRegionType]?
    /// <p>(Optional) If set, Secrets Manager replication overwrites a secret with the same name in the
    ///       destination region.</p>
    public let forceOverwriteReplicaSecret: Bool
    /// <p>Use the <code>Secret Id</code> to replicate a secret to regions.</p>
    public let secretId: String?

    public init (
        addReplicaRegions: [ReplicaRegionType]? = nil,
        forceOverwriteReplicaSecret: Bool = false,
        secretId: String? = nil
    )
    {
        self.addReplicaRegions = addReplicaRegions
        self.forceOverwriteReplicaSecret = forceOverwriteReplicaSecret
        self.secretId = secretId
    }
}

struct ReplicateSecretToRegionsInputBody: Equatable {
    public let secretId: String?
    public let addReplicaRegions: [ReplicaRegionType]?
    public let forceOverwriteReplicaSecret: Bool
}

extension ReplicateSecretToRegionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let addReplicaRegionsContainer = try containerValues.decodeIfPresent([ReplicaRegionType?].self, forKey: .addReplicaRegions)
        var addReplicaRegionsDecoded0:[ReplicaRegionType]? = nil
        if let addReplicaRegionsContainer = addReplicaRegionsContainer {
            addReplicaRegionsDecoded0 = [ReplicaRegionType]()
            for structure0 in addReplicaRegionsContainer {
                if let structure0 = structure0 {
                    addReplicaRegionsDecoded0?.append(structure0)
                }
            }
        }
        addReplicaRegions = addReplicaRegionsDecoded0
        let forceOverwriteReplicaSecretDecoded = try containerValues.decode(Bool.self, forKey: .forceOverwriteReplicaSecret)
        forceOverwriteReplicaSecret = forceOverwriteReplicaSecretDecoded
    }
}

extension ReplicateSecretToRegionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReplicateSecretToRegionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReplicateSecretToRegionsOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReplicateSecretToRegionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicateSecretToRegionsOutputResponse(aRN: \(String(describing: aRN)), replicationStatus: \(String(describing: replicationStatus)))"}
}

extension ReplicateSecretToRegionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReplicateSecretToRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.replicationStatus = output.replicationStatus
        } else {
            self.aRN = nil
            self.replicationStatus = nil
        }
    }
}

public struct ReplicateSecretToRegionsOutputResponse: Equatable {
    /// <p>Replicate a secret based on the <code>ReplicaRegionType</code>> consisting of a
    ///       Region(required) and a KMSKeyId (optional) which can be the ARN, KeyID, or Alias. </p>
    public let aRN: String?
    /// <p>Describes the secret replication status as <code>PENDING</code>, <code>SUCCESS</code> or <code>FAIL</code>.</p>
    public let replicationStatus: [ReplicationStatusType]?

    public init (
        aRN: String? = nil,
        replicationStatus: [ReplicationStatusType]? = nil
    )
    {
        self.aRN = aRN
        self.replicationStatus = replicationStatus
    }
}

struct ReplicateSecretToRegionsOutputResponseBody: Equatable {
    public let aRN: String?
    public let replicationStatus: [ReplicationStatusType]?
}

extension ReplicateSecretToRegionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case replicationStatus = "ReplicationStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension ReplicationStatusType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case region = "Region"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
    }
}

extension ReplicationStatusType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationStatusType(kmsKeyId: \(String(describing: kmsKeyId)), lastAccessedDate: \(String(describing: lastAccessedDate)), region: \(String(describing: region)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>A replication object consisting of a <code>RegionReplicationStatus</code> object and includes a Region, KMSKeyId, status, and status message.</p>
public struct ReplicationStatusType: Equatable {
    /// <p>Can be an <code>ARN</code>, <code>Key ID</code>, or <code>Alias</code>. </p>
    public let kmsKeyId: String?
    /// <p>The date that you last accessed the secret in the Region. </p>
    public let lastAccessedDate: Date?
    /// <p>The Region where replication occurs.</p>
    public let region: String?
    /// <p>The status can be <code>InProgress</code>, <code>Failed</code>, or <code>InSync</code>.</p>
    public let status: StatusType?
    /// <p>Status message such as "<i>Secret with this name already exists in this
    ///         region</i>".</p>
    public let statusMessage: String?

    public init (
        kmsKeyId: String? = nil,
        lastAccessedDate: Date? = nil,
        region: String? = nil,
        status: StatusType? = nil,
        statusMessage: String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.lastAccessedDate = lastAccessedDate
        self.region = region
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension ResourceExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceExistsException(message: \(String(describing: message)))"}
}

extension ResourceExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the ID you requested already exists.</p>
public struct ResourceExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We can't find the resource that you asked for.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreSecretInputBodyMiddleware: Middleware {
    public let id: String = "RestoreSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreSecretOutputError>
}

extension RestoreSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreSecretInput(secretId: \(String(describing: secretId)))"}
}

extension RestoreSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RestoreSecretInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreSecretOutputError>
}

public struct RestoreSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreSecretOutputError>
}

public struct RestoreSecretInput: Equatable {
    /// <p>Specifies the secret that you want to restore from a previously scheduled deletion. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        secretId: String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct RestoreSecretInputBody: Equatable {
    public let secretId: String?
}

extension RestoreSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension RestoreSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreSecretOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreSecretOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)))"}
}

extension RestoreSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct RestoreSecretOutputResponse: Equatable {
    /// <p>The ARN of the secret that was restored.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret that was restored.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct RestoreSecretOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
}

extension RestoreSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct RotateSecretInputBodyMiddleware: Middleware {
    public let id: String = "RotateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateSecretInput>
    public typealias MOutput = OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateSecretOutputError>
}

extension RotateSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateSecretInput(clientRequestToken: \(String(describing: clientRequestToken)), rotationLambdaARN: \(String(describing: rotationLambdaARN)), rotationRules: \(String(describing: rotationRules)), secretId: \(String(describing: secretId)))"}
}

extension RotateSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rotationLambdaARN = rotationLambdaARN {
            try encodeContainer.encode(rotationLambdaARN, forKey: .rotationLambdaARN)
        }
        if let rotationRules = rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RotateSecretInputHeadersMiddleware: Middleware {
    public let id: String = "RotateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateSecretInput>
    public typealias MOutput = OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateSecretOutputError>
}

public struct RotateSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "RotateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateSecretInput>
    public typealias MOutput = OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateSecretOutputError>
}

public struct RotateSecretInput: Equatable {
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret that helps
    ///       ensure idempotency. </p>
    ///          <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///       leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///       in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
    ///       request to the Secrets Manager service endpoint, then you must generate a
    ///         <code>ClientRequestToken</code> yourself for new versions and include that value in the
    ///       request.</p>
    ///          <p>You only need to specify your own value if you implement your own retry logic and want to
    ///       ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    ///       ensure uniqueness within the specified secret. </p>
    ///          <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    ///       there are failures and retries during the function's processing. This value becomes the
    ///         <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: String?
    /// <p>(Optional) Specifies the ARN of the Lambda function that can rotate the secret.</p>
    public let rotationLambdaARN: String?
    /// <p>A structure that defines the rotation configuration for this secret.</p>
    public let rotationRules: RotationRulesType?
    /// <p>Specifies the secret that you want to rotate. You can specify either the Amazon Resource
    ///       Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        clientRequestToken: String? = nil,
        rotationLambdaARN: String? = nil,
        rotationRules: RotationRulesType? = nil,
        secretId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rotationLambdaARN = rotationLambdaARN
        self.rotationRules = rotationRules
        self.secretId = secretId
    }
}

struct RotateSecretInputBody: Equatable {
    public let secretId: String?
    public let clientRequestToken: String?
    public let rotationLambdaARN: String?
    public let rotationRules: RotationRulesType?
}

extension RotateSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
    }
}

extension RotateSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RotateSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateSecretOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateSecretOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)), versionId: \(String(describing: versionId)))"}
}

extension RotateSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RotateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct RotateSecretOutputResponse: Equatable {
    /// <p>The ARN of the secret.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret.</p>
    public let name: String?
    /// <p>The ID of the new version of the secret created by the rotation started by this
    ///       request.</p>
    public let versionId: String?

    public init (
        aRN: String? = nil,
        name: String? = nil,
        versionId: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct RotateSecretOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let versionId: String?
}

extension RotateSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension RotationRulesType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automaticallyAfterDays = "AutomaticallyAfterDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticallyAfterDays != 0 {
            try encodeContainer.encode(automaticallyAfterDays, forKey: .automaticallyAfterDays)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticallyAfterDaysDecoded = try containerValues.decode(Int.self, forKey: .automaticallyAfterDays)
        automaticallyAfterDays = automaticallyAfterDaysDecoded
    }
}

extension RotationRulesType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotationRulesType(automaticallyAfterDays: \(String(describing: automaticallyAfterDays)))"}
}

/// <p>A structure that defines the rotation configuration for the secret.</p>
public struct RotationRulesType: Equatable {
    /// <p>Specifies the number of days between automatic scheduled rotations of the secret.</p>
    ///          <p>Secrets Manager schedules the next rotation when the previous
    ///     one is complete. Secrets Manager schedules the date by adding the rotation interval (number of days) to the
    ///     actual date of the last rotation. The service chooses the hour within that 24-hour date window
    ///     randomly. The minute is also chosen somewhat randomly, but weighted towards the top of the hour
    ///     and influenced by a variety of factors that help distribute load.</p>
    public let automaticallyAfterDays: Int

    public init (
        automaticallyAfterDays: Int = 0
    )
    {
        self.automaticallyAfterDays = automaticallyAfterDays
    }
}

extension SecretListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case deletedDate = "DeletedDate"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case lastChangedDate = "LastChangedDate"
        case lastRotatedDate = "LastRotatedDate"
        case name = "Name"
        case owningService = "OwningService"
        case primaryRegion = "PrimaryRegion"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretVersionsToStages = "SecretVersionsToStages"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let deletedDate = deletedDate {
            try encodeContainer.encode(deletedDate.timeIntervalSince1970, forKey: .deletedDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let lastChangedDate = lastChangedDate {
            try encodeContainer.encode(lastChangedDate.timeIntervalSince1970, forKey: .lastChangedDate)
        }
        if let lastRotatedDate = lastRotatedDate {
            try encodeContainer.encode(lastRotatedDate.timeIntervalSince1970, forKey: .lastRotatedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningService = owningService {
            try encodeContainer.encode(owningService, forKey: .owningService)
        }
        if let primaryRegion = primaryRegion {
            try encodeContainer.encode(primaryRegion, forKey: .primaryRegion)
        }
        if rotationEnabled != false {
            try encodeContainer.encode(rotationEnabled, forKey: .rotationEnabled)
        }
        if let rotationLambdaARN = rotationLambdaARN {
            try encodeContainer.encode(rotationLambdaARN, forKey: .rotationLambdaARN)
        }
        if let rotationRules = rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
        if let secretVersionsToStages = secretVersionsToStages {
            var secretVersionsToStagesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .secretVersionsToStages)
            for (dictKey0, secretversionstostagesmaptype0) in secretVersionsToStages {
                try secretVersionsToStagesContainer.encode(secretversionstostagesmaptype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .rotationEnabled)
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let lastRotatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRotatedDate)
        lastRotatedDate = lastRotatedDateDecoded
        let lastChangedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastChangedDate)
        lastChangedDate = lastChangedDateDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let deletedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletedDate)
        deletedDate = deletedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let secretVersionsToStagesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .secretVersionsToStages)
        var secretVersionsToStagesDecoded0: [String:[String]]? = nil
        if let secretVersionsToStagesContainer = secretVersionsToStagesContainer {
            secretVersionsToStagesDecoded0 = [String:[String]]()
            for (key0, secretversionstagestype0) in secretVersionsToStagesContainer {
                var secretversionstagestype0Decoded0: [String]? = nil
                if let secretversionstagestype0 = secretversionstagestype0 {
                    secretversionstagestype0Decoded0 = [String]()
                    for string1 in secretversionstagestype0 {
                        if let string1 = string1 {
                            secretversionstagestype0Decoded0?.append(string1)
                        }
                    }
                }
                secretVersionsToStagesDecoded0?[key0] = secretversionstagestype0Decoded0
            }
        }
        secretVersionsToStages = secretVersionsToStagesDecoded0
        let owningServiceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owningService)
        owningService = owningServiceDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let primaryRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
    }
}

extension SecretListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecretListEntry(aRN: \(String(describing: aRN)), createdDate: \(String(describing: createdDate)), deletedDate: \(String(describing: deletedDate)), description: \(String(describing: description)), kmsKeyId: \(String(describing: kmsKeyId)), lastAccessedDate: \(String(describing: lastAccessedDate)), lastChangedDate: \(String(describing: lastChangedDate)), lastRotatedDate: \(String(describing: lastRotatedDate)), name: \(String(describing: name)), owningService: \(String(describing: owningService)), primaryRegion: \(String(describing: primaryRegion)), rotationEnabled: \(String(describing: rotationEnabled)), rotationLambdaARN: \(String(describing: rotationLambdaARN)), rotationRules: \(String(describing: rotationRules)), secretVersionsToStages: \(String(describing: secretVersionsToStages)), tags: \(String(describing: tags)))"}
}

/// <p>A structure that contains the details about a secret. It does not include the encrypted
///         <code>SecretString</code> and <code>SecretBinary</code> values. To get those values, use the
///         <a>GetSecretValue</a> operation.</p>
public struct SecretListEntry: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the secret.</p>
    ///          <p>For more information about ARNs in Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#iam-resources">Policy Resources</a> in the
    ///     <i>AWS Secrets Manager User Guide</i>.</p>
    public let aRN: String?
    /// <p>The date and time when a secret was created.</p>
    public let createdDate: Date?
    /// <p>The date and time the deletion of the secret occurred. Not present on active secrets. The
    ///       secret can be recovered until the number of days in the recovery window has passed, as
    ///       specified in the <code>RecoveryWindowInDays</code> parameter of the <a>DeleteSecret</a> operation.</p>
    public let deletedDate: Date?
    /// <p>The user-provided description of the secret.</p>
    public let description: String?
    /// <p>The ARN or alias of the AWS KMS customer master key (CMK) used to encrypt the
    ///         <code>SecretString</code> and <code>SecretBinary</code> fields in each version of the
    ///       secret. If you don't provide a key, then Secrets Manager defaults to encrypting the secret fields with
    ///       the default KMS CMK, the key named <code>awssecretsmanager</code>, for this account.</p>
    public let kmsKeyId: String?
    /// <p>The last date that this secret was accessed. This value is truncated to midnight of the
    ///       date and therefore shows only the date, not the time.</p>
    public let lastAccessedDate: Date?
    /// <p>The last date and time that this secret was modified in any way.</p>
    public let lastChangedDate: Date?
    /// <p>The most recent date and time that the Secrets Manager rotation process was successfully completed. This value is null if the secret hasn't ever rotated.</p>
    public let lastRotatedDate: Date?
    /// <p>The friendly name of the secret. You can use forward slashes in the name to represent a
    ///       path hierarchy. For example, <code>/prod/databases/dbserver1</code> could represent the secret
    ///       for a server named <code>dbserver1</code> in the folder <code>databases</code> in the folder
    ///         <code>prod</code>. </p>
    public let name: String?
    /// <p>Returns the name of the service that created the secret.</p>
    public let owningService: String?
    /// <p>The Region where Secrets Manager originated the secret.</p>
    public let primaryRegion: String?
    /// <p>Indicates whether automatic, scheduled rotation is enabled for this secret.</p>
    public let rotationEnabled: Bool
    /// <p>The ARN of an AWS Lambda function invoked by Secrets Manager to rotate and expire the
    ///       secret either automatically per the schedule or manually by a call to <a>RotateSecret</a>.</p>
    public let rotationLambdaARN: String?
    /// <p>A structure that defines the rotation configuration for the secret.</p>
    public let rotationRules: RotationRulesType?
    /// <p>A list of all of the currently assigned <code>SecretVersionStage</code> staging labels and
    ///       the <code>SecretVersionId</code> attached to each one. Staging labels are used to keep
    ///       track of the different versions during the rotation process.</p>
    ///          <note>
    ///             <p>A version that does not have any <code>SecretVersionStage</code> is considered
    ///         deprecated and subject to deletion. Such versions are not included in this list.</p>
    ///          </note>
    public let secretVersionsToStages: [String:[String]]?
    /// <p>The list of user-defined tags associated with the secret. To add tags to a
    ///       secret, use <a>TagResource</a>. To remove tags, use <a>UntagResource</a>.</p>
    public let tags: [Tag]?

    public init (
        aRN: String? = nil,
        createdDate: Date? = nil,
        deletedDate: Date? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        lastAccessedDate: Date? = nil,
        lastChangedDate: Date? = nil,
        lastRotatedDate: Date? = nil,
        name: String? = nil,
        owningService: String? = nil,
        primaryRegion: String? = nil,
        rotationEnabled: Bool = false,
        rotationLambdaARN: String? = nil,
        rotationRules: RotationRulesType? = nil,
        secretVersionsToStages: [String:[String]]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.aRN = aRN
        self.createdDate = createdDate
        self.deletedDate = deletedDate
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.lastAccessedDate = lastAccessedDate
        self.lastChangedDate = lastChangedDate
        self.lastRotatedDate = lastRotatedDate
        self.name = name
        self.owningService = owningService
        self.primaryRegion = primaryRegion
        self.rotationEnabled = rotationEnabled
        self.rotationLambdaARN = rotationLambdaARN
        self.rotationRules = rotationRules
        self.secretVersionsToStages = secretVersionsToStages
        self.tags = tags
    }
}

extension SecretVersionsListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case lastAccessedDate = "LastAccessedDate"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
        if let versionStages = versionStages {
            var versionStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionStages)
            for secretversionstagestype0 in versionStages {
                try versionStagesContainer.encode(secretversionstagestype0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SecretVersionsListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecretVersionsListEntry(createdDate: \(String(describing: createdDate)), lastAccessedDate: \(String(describing: lastAccessedDate)), versionId: \(String(describing: versionId)), versionStages: \(String(describing: versionStages)))"}
}

/// <p>A structure that contains information about one version of a secret.</p>
public struct SecretVersionsListEntry: Equatable {
    /// <p>The date and time this version of the secret was created.</p>
    public let createdDate: Date?
    /// <p>The date that this version of the secret was last accessed. Note that the resolution of
    ///       this field is at the date level and does not include the time.</p>
    public let lastAccessedDate: Date?
    /// <p>The unique version identifier of this version of the secret.</p>
    public let versionId: String?
    /// <p>An array of staging labels that are currently associated with this version of the
    ///       secret.</p>
    public let versionStages: [String]?

    public init (
        createdDate: Date? = nil,
        lastAccessedDate: Date? = nil,
        versionId: String? = nil,
        versionStages: [String]? = nil
    )
    {
        self.createdDate = createdDate
        self.lastAccessedDate = lastAccessedDate
        self.versionId = versionId
        self.versionStages = versionStages
    }
}

public enum SortOrderType {
    case asc
    case desc
    case sdkUnknown(String)
}

extension SortOrderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrderType] {
        return [
            .asc,
            .desc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asc: return "asc"
        case .desc: return "desc"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrderType(rawValue: rawValue) ?? SortOrderType.sdkUnknown(rawValue)
    }
}

public enum StatusType {
    case failed
    case inprogress
    case insync
    case sdkUnknown(String)
}

extension StatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatusType] {
        return [
            .failed,
            .inprogress,
            .insync,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .insync: return "InSync"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
    }
}

public struct StopReplicationToReplicaInputBodyMiddleware: Middleware {
    public let id: String = "StopReplicationToReplicaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopReplicationToReplicaOutputError>
}

extension StopReplicationToReplicaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopReplicationToReplicaInput(secretId: \(String(describing: secretId)))"}
}

extension StopReplicationToReplicaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct StopReplicationToReplicaInputHeadersMiddleware: Middleware {
    public let id: String = "StopReplicationToReplicaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopReplicationToReplicaOutputError>
}

public struct StopReplicationToReplicaInputQueryItemMiddleware: Middleware {
    public let id: String = "StopReplicationToReplicaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopReplicationToReplicaOutputError>
}

public struct StopReplicationToReplicaInput: Equatable {
    /// <p>Response to <code>StopReplicationToReplica</code> of a secret, based on the <code>SecretId</code>.</p>
    public let secretId: String?

    public init (
        secretId: String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct StopReplicationToReplicaInputBody: Equatable {
    public let secretId: String?
}

extension StopReplicationToReplicaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension StopReplicationToReplicaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopReplicationToReplicaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopReplicationToReplicaOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopReplicationToReplicaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopReplicationToReplicaOutputResponse(aRN: \(String(describing: aRN)))"}
}

extension StopReplicationToReplicaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopReplicationToReplicaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
        } else {
            self.aRN = nil
        }
    }
}

public struct StopReplicationToReplicaOutputResponse: Equatable {
    /// <p>Response <code>StopReplicationToReplica</code> of a secret, based on the <code>ARN,</code>.</p>
    public let aRN: String?

    public init (
        aRN: String? = nil
    )
    {
        self.aRN = aRN
    }
}

struct StopReplicationToReplicaOutputResponseBody: Equatable {
    public let aRN: String?
}

extension StopReplicationToReplicaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A structure that contains information about a tag.</p>
public struct Tag: Equatable {
    /// <p>The key identifier, or name, of the tag.</p>
    public let key: String?
    /// <p>The string value associated with the key of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(secretId: \(String(describing: secretId)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The identifier for the secret that you want to attach tags to. You can specify either the
    ///       Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?
    /// <p>The tags to attach to the secret. Each element in the list consists of a <code>Key</code>
    ///       and a <code>Value</code>.</p>
    ///          <p>This parameter to the API requires a JSON text string argument. For information on how to
    ///       format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>. For the
    ///       AWS CLI, you can also use the syntax: <code>--Tags Key="Key1",Value="Value1"
    ///         Key="Key2",Value="Value2"[,…]</code>
    ///          </p>
    public let tags: [Tag]?

    public init (
        secretId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.secretId = secretId
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let secretId: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(secretId: \(String(describing: secretId)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylisttype0 in tagKeys {
                try tagKeysContainer.encode(tagkeylisttype0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The identifier for the secret that you want to remove tags from. You can specify either
    ///       the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?
    /// <p>A list of tag key names to remove from the secret. You don't specify the value. Both the
    ///       key and its associated value are removed.</p>
    ///          <p>This parameter to the API requires a JSON text string argument. For information on how to
    ///       format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    public let tagKeys: [String]?

    public init (
        secretId: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.secretId = secretId
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let secretId: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretId = "SecretId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSecretInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecretOutputError>
}

extension UpdateSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecretInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), kmsKeyId: \(String(describing: kmsKeyId)), secretBinary: \(String(describing: secretBinary)), secretId: \(String(describing: secretId)), secretString: \(String(describing: secretString)))"}
}

extension UpdateSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
    }
}

public struct UpdateSecretInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecretOutputError>
}

public struct UpdateSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecretOutputError>
}

public struct UpdateSecretInput: Equatable {
    /// <p>(Optional) If you want to add a new version to the secret, this parameter specifies a
    ///       unique identifier for the new version that helps ensure idempotency. </p>
    ///          <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///       leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///       in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
    ///       service endpoint, then you must generate a <code>ClientRequestToken</code> yourself for new
    ///       versions and include that value in the request.</p>
    ///          <p>You typically only need to interact with this value if you implement your own retry logic
    ///       and want to ensure that a given secret is not created twice. We recommend that you generate a
    ///         <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a>
    ///       value to ensure uniqueness within the specified secret. </p>
    ///          <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    ///       there are failures and retries during the Lambda rotation function's processing.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    ///           of the secret then a new version of the secret is created. </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are the same as those in
    ///           the request then the request is ignored (the operation is idempotent). </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are different from the
    ///           request then an error occurs because you cannot modify an existing secret value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This value becomes the <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: String?
    /// <p>(Optional) Specifies an updated user-provided description of the secret.</p>
    public let description: String?
    /// <p>(Optional) Specifies an updated ARN or alias of the AWS KMS customer master key (CMK) to be
    ///       used to encrypt the protected text in new versions of this secret.</p>
    ///          <important>
    ///             <p>You can only use the account's default CMK to encrypt and decrypt if you call this
    ///         operation using credentials from the same account that owns the secret. If the secret is in
    ///         a different account, then you must create a custom CMK and provide the ARN of that CMK in
    ///         this field. The user making the call must have permissions to both the secret and the CMK in
    ///         their respective accounts.</p>
    ///          </important>
    public let kmsKeyId: String?
    /// <p>(Optional) Specifies updated binary data that you want to encrypt and store in the new
    ///       version of the secret. To use this parameter in the command-line tools, we recommend that you
    ///       store your binary data in a file and then use the appropriate technique for your tool to pass
    ///       the contents of the file as a parameter. Either <code>SecretBinary</code> or
    ///         <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    ///          <p>This parameter is not accessible using the Secrets Manager console.</p>
    public let secretBinary: Data?
    /// <p>Specifies the secret that you want to modify or to which you want to add a new version.
    ///       You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?
    /// <p>(Optional) Specifies updated text data that you want to encrypt and store in this new
    ///       version of the secret. Either <code>SecretBinary</code> or <code>SecretString</code> must have
    ///       a value, but not both. They cannot both be empty.</p>
    ///          <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    ///       protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    ///       stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    ///       function knows how to parse.</p>
    ///          <p>For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    ///          <p>
    ///             <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text. You can
    ///       also 'escape' the double quote character in the embedded JSON text by prefacing each with a
    ///       backslash. For example, the following string is surrounded by double-quotes. All of the
    ///       embedded double quotes are escaped:</p>
    ///          <p>
    ///             <code>"[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"</code>
    ///          </p>
    public let secretString: String?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        secretBinary: Data? = nil,
        secretId: String? = nil,
        secretString: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.secretBinary = secretBinary
        self.secretId = secretId
        self.secretString = secretString
    }
}

struct UpdateSecretInputBody: Equatable {
    public let secretId: String?
    public let clientRequestToken: String?
    public let description: String?
    public let kmsKeyId: String?
    public let secretBinary: Data?
    public let secretString: String?
}

extension UpdateSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretString)
        secretString = secretStringDecoded
    }
}

extension UpdateSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecretOutputError: Swift.Error, Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecretOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)), versionId: \(String(describing: versionId)))"}
}

extension UpdateSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct UpdateSecretOutputResponse: Equatable {
    /// <p>The ARN of the secret that was updated.</p>
    ///          <note>
    ///             <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret <i>don't</i>
    ///         automatically get access to the new secret because the ARNs are different.</p>
    ///          </note>
    public let aRN: String?
    /// <p>The friendly name of the secret that was updated.</p>
    public let name: String?
    /// <p>If a new version of the secret was created by this operation, then <code>VersionId</code>
    ///       contains the unique identifier of the new version.</p>
    public let versionId: String?

    public init (
        aRN: String? = nil,
        name: String? = nil,
        versionId: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct UpdateSecretOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
    public let versionId: String?
}

extension UpdateSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct UpdateSecretVersionStageInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSecretVersionStageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecretVersionStageOutputError>
}

extension UpdateSecretVersionStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecretVersionStageInput(moveToVersionId: \(String(describing: moveToVersionId)), removeFromVersionId: \(String(describing: removeFromVersionId)), secretId: \(String(describing: secretId)), versionStage: \(String(describing: versionStage)))"}
}

extension UpdateSecretVersionStageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case moveToVersionId = "MoveToVersionId"
        case removeFromVersionId = "RemoveFromVersionId"
        case secretId = "SecretId"
        case versionStage = "VersionStage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moveToVersionId = moveToVersionId {
            try encodeContainer.encode(moveToVersionId, forKey: .moveToVersionId)
        }
        if let removeFromVersionId = removeFromVersionId {
            try encodeContainer.encode(removeFromVersionId, forKey: .removeFromVersionId)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let versionStage = versionStage {
            try encodeContainer.encode(versionStage, forKey: .versionStage)
        }
    }
}

public struct UpdateSecretVersionStageInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSecretVersionStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecretVersionStageOutputError>
}

public struct UpdateSecretVersionStageInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSecretVersionStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecretVersionStageOutputError>
}

public struct UpdateSecretVersionStageInput: Equatable {
    /// <p>(Optional) The secret version ID that you want to add the staging label. If you want to
    ///       remove a label from a version, then do not specify this parameter.</p>
    ///          <p>If the staging label is already attached to a different version of the secret, then you
    ///       must also specify the <code>RemoveFromVersionId</code> parameter. </p>
    public let moveToVersionId: String?
    /// <p>Specifies the secret version ID of the version that the staging label is to be removed
    ///       from. If the staging label you are trying to attach to one version is already attached to a
    ///       different version, then you must include this parameter and specify the version that the label
    ///       is to be removed from. If the label is attached and you either do not specify this parameter,
    ///       or the version ID does not match, then the operation fails.</p>
    public let removeFromVersionId: String?
    /// <p>Specifies the secret with the version with the list of staging labels you want to modify.
    ///       You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?
    /// <p>The staging label to add to this version.</p>
    public let versionStage: String?

    public init (
        moveToVersionId: String? = nil,
        removeFromVersionId: String? = nil,
        secretId: String? = nil,
        versionStage: String? = nil
    )
    {
        self.moveToVersionId = moveToVersionId
        self.removeFromVersionId = removeFromVersionId
        self.secretId = secretId
        self.versionStage = versionStage
    }
}

struct UpdateSecretVersionStageInputBody: Equatable {
    public let secretId: String?
    public let versionStage: String?
    public let removeFromVersionId: String?
    public let moveToVersionId: String?
}

extension UpdateSecretVersionStageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case moveToVersionId = "MoveToVersionId"
        case removeFromVersionId = "RemoveFromVersionId"
        case secretId = "SecretId"
        case versionStage = "VersionStage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let versionStageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionStage)
        versionStage = versionStageDecoded
        let removeFromVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .removeFromVersionId)
        removeFromVersionId = removeFromVersionIdDecoded
        let moveToVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .moveToVersionId)
        moveToVersionId = moveToVersionIdDecoded
    }
}

extension UpdateSecretVersionStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecretVersionStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecretVersionStageOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecretVersionStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecretVersionStageOutputResponse(aRN: \(String(describing: aRN)), name: \(String(describing: name)))"}
}

extension UpdateSecretVersionStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSecretVersionStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct UpdateSecretVersionStageOutputResponse: Equatable {
    /// <p>The ARN of the secret with the modified staging label.</p>
    public let aRN: String?
    /// <p>The friendly name of the secret with the modified staging label.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct UpdateSecretVersionStageOutputResponseBody: Equatable {
    public let aRN: String?
    public let name: String?
}

extension UpdateSecretVersionStageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct ValidateResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "ValidateResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateResourcePolicyOutputError>
}

extension ValidateResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateResourcePolicyInput(resourcePolicy: \(String(describing: resourcePolicy)), secretId: \(String(describing: secretId)))"}
}

extension ValidateResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourcePolicy = resourcePolicy {
            try encodeContainer.encode(resourcePolicy, forKey: .resourcePolicy)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ValidateResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "ValidateResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateResourcePolicyOutputError>
}

public struct ValidateResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidateResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateResourcePolicyOutputError>
}

public struct ValidateResourcePolicyInput: Equatable {
    /// <p>A JSON-formatted string constructed according to the grammar and syntax for an AWS
    ///       resource-based policy. The policy in the string identifies who can access or manage this
    ///       secret and its versions. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    ///         JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.publi</p>
    public let resourcePolicy: String?
    /// <p> (Optional) The identifier of the secret with the resource-based policy you want to
    ///       validate. You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: String?

    public init (
        resourcePolicy: String? = nil,
        secretId: String? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
        self.secretId = secretId
    }
}

struct ValidateResourcePolicyInputBody: Equatable {
    public let secretId: String?
    public let resourcePolicy: String?
}

extension ValidateResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

extension ValidateResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateResourcePolicyOutputError: Swift.Error, Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateResourcePolicyOutputResponse(policyValidationPassed: \(String(describing: policyValidationPassed)), validationErrors: \(String(describing: validationErrors)))"}
}

extension ValidateResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidateResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyValidationPassed = output.policyValidationPassed
            self.validationErrors = output.validationErrors
        } else {
            self.policyValidationPassed = false
            self.validationErrors = nil
        }
    }
}

public struct ValidateResourcePolicyOutputResponse: Equatable {
    /// <p>Returns a message stating that your Reource Policy passed validation. </p>
    public let policyValidationPassed: Bool
    /// <p>Returns an error message if your policy doesn't pass validatation.</p>
    public let validationErrors: [ValidationErrorsEntry]?

    public init (
        policyValidationPassed: Bool = false,
        validationErrors: [ValidationErrorsEntry]? = nil
    )
    {
        self.policyValidationPassed = policyValidationPassed
        self.validationErrors = validationErrors
    }
}

struct ValidateResourcePolicyOutputResponseBody: Equatable {
    public let policyValidationPassed: Bool
    public let validationErrors: [ValidationErrorsEntry]?
}

extension ValidateResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyValidationPassed = "PolicyValidationPassed"
        case validationErrors = "ValidationErrors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyValidationPassedDecoded = try containerValues.decode(Bool.self, forKey: .policyValidationPassed)
        policyValidationPassed = policyValidationPassedDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([ValidationErrorsEntry?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[ValidationErrorsEntry]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [ValidationErrorsEntry]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

extension ValidationErrorsEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName = "CheckName"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ValidationErrorsEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationErrorsEntry(checkName: \(String(describing: checkName)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Displays errors that occurred during validation of the resource policy.</p>
public struct ValidationErrorsEntry: Equatable {
    /// <p>Checks the name of the policy.</p>
    public let checkName: String?
    /// <p>Displays error messages if validation encounters problems during validation of the resource policy.</p>
    public let errorMessage: String?

    public init (
        checkName: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.checkName = checkName
        self.errorMessage = errorMessage
    }
}
