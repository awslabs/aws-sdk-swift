// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListTableColumnsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTableColumnsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTableColumnsOutputResponse`
extension HoneycodeClient {
    public func listTableColumnsPaginated(input: ListTableColumnsInput) -> ClientRuntime.PaginatorSequence<ListTableColumnsInput, ListTableColumnsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTableColumnsInput, ListTableColumnsOutputResponse>(input: input, inputKey: \ListTableColumnsInput.nextToken, outputKey: \ListTableColumnsOutputResponse.nextToken, paginationFunction: self.listTableColumns(input:))
    }
}

extension ListTableColumnsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTableColumnsInput {
        return ListTableColumnsInput(
            nextToken: token,
            tableId: self.tableId,
            workbookId: self.workbookId
        )}
}

/// Paginate over `[ListTableRowsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTableRowsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTableRowsOutputResponse`
extension HoneycodeClient {
    public func listTableRowsPaginated(input: ListTableRowsInput) -> ClientRuntime.PaginatorSequence<ListTableRowsInput, ListTableRowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTableRowsInput, ListTableRowsOutputResponse>(input: input, inputKey: \ListTableRowsInput.nextToken, outputKey: \ListTableRowsOutputResponse.nextToken, paginationFunction: self.listTableRows(input:))
    }
}

extension ListTableRowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTableRowsInput {
        return ListTableRowsInput(
            maxResults: self.maxResults,
            nextToken: token,
            rowIds: self.rowIds,
            tableId: self.tableId,
            workbookId: self.workbookId
        )}
}

/// Paginate over `[ListTablesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTablesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTablesOutputResponse`
extension HoneycodeClient {
    public func listTablesPaginated(input: ListTablesInput) -> ClientRuntime.PaginatorSequence<ListTablesInput, ListTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTablesInput, ListTablesOutputResponse>(input: input, inputKey: \ListTablesInput.nextToken, outputKey: \ListTablesOutputResponse.nextToken, paginationFunction: self.listTables(input:))
    }
}

extension ListTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTablesInput {
        return ListTablesInput(
            maxResults: self.maxResults,
            nextToken: token,
            workbookId: self.workbookId
        )}
}

/// Paginate over `[QueryTableRowsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[QueryTableRowsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `QueryTableRowsOutputResponse`
extension HoneycodeClient {
    public func queryTableRowsPaginated(input: QueryTableRowsInput) -> ClientRuntime.PaginatorSequence<QueryTableRowsInput, QueryTableRowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<QueryTableRowsInput, QueryTableRowsOutputResponse>(input: input, inputKey: \QueryTableRowsInput.nextToken, outputKey: \QueryTableRowsOutputResponse.nextToken, paginationFunction: self.queryTableRows(input:))
    }
}

extension QueryTableRowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> QueryTableRowsInput {
        return QueryTableRowsInput(
            filterFormula: self.filterFormula,
            maxResults: self.maxResults,
            nextToken: token,
            tableId: self.tableId,
            workbookId: self.workbookId
        )}
}
