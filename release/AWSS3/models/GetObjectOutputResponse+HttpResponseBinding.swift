// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension GetObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "accept-ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let checksumCRC32HeaderValue = httpResponse.headers.value(for: "x-amz-checksum-crc32") {
            self.checksumCRC32 = checksumCRC32HeaderValue
        } else {
            self.checksumCRC32 = nil
        }
        if let checksumCRC32CHeaderValue = httpResponse.headers.value(for: "x-amz-checksum-crc32c") {
            self.checksumCRC32C = checksumCRC32CHeaderValue
        } else {
            self.checksumCRC32C = nil
        }
        if let checksumSHA1HeaderValue = httpResponse.headers.value(for: "x-amz-checksum-sha1") {
            self.checksumSHA1 = checksumSHA1HeaderValue
        } else {
            self.checksumSHA1 = nil
        }
        if let checksumSHA256HeaderValue = httpResponse.headers.value(for: "x-amz-checksum-sha256") {
            self.checksumSHA256 = checksumSHA256HeaderValue
        } else {
            self.checksumSHA256 = nil
        }
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentLanguageHeaderValue = httpResponse.headers.value(for: "Content-Language") {
            self.contentLanguage = contentLanguageHeaderValue
        } else {
            self.contentLanguage = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Swift.Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = 0
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let deleteMarkerHeaderValue = httpResponse.headers.value(for: "x-amz-delete-marker") {
            self.deleteMarker = Swift.Bool(deleteMarkerHeaderValue) ?? false
        } else {
            self.deleteMarker = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let expiresHeaderValue = httpResponse.headers.value(for: "Expires") {
            self.expires = DateFormatter.rfc5322DateFormatter.date(from: expiresHeaderValue)
        } else {
            self.expires = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = DateFormatter.rfc5322DateFormatter.date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        if let missingMetaHeaderValue = httpResponse.headers.value(for: "x-amz-missing-meta") {
            self.missingMeta = Swift.Int(missingMetaHeaderValue) ?? 0
        } else {
            self.missingMeta = 0
        }
        if let objectLockLegalHoldStatusHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-legal-hold") {
            self.objectLockLegalHoldStatus = S3ClientTypes.ObjectLockLegalHoldStatus(rawValue: objectLockLegalHoldStatusHeaderValue)
        } else {
            self.objectLockLegalHoldStatus = nil
        }
        if let objectLockModeHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-mode") {
            self.objectLockMode = S3ClientTypes.ObjectLockMode(rawValue: objectLockModeHeaderValue)
        } else {
            self.objectLockMode = nil
        }
        if let objectLockRetainUntilDateHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-retain-until-date") {
            self.objectLockRetainUntilDate = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds.date(from: objectLockRetainUntilDateHeaderValue)
        } else {
            self.objectLockRetainUntilDate = nil
        }
        if let partsCountHeaderValue = httpResponse.headers.value(for: "x-amz-mp-parts-count") {
            self.partsCount = Swift.Int(partsCountHeaderValue) ?? 0
        } else {
            self.partsCount = 0
        }
        if let replicationStatusHeaderValue = httpResponse.headers.value(for: "x-amz-replication-status") {
            self.replicationStatus = S3ClientTypes.ReplicationStatus(rawValue: replicationStatusHeaderValue)
        } else {
            self.replicationStatus = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let restoreHeaderValue = httpResponse.headers.value(for: "x-amz-restore") {
            self.restore = restoreHeaderValue
        } else {
            self.restore = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let storageClassHeaderValue = httpResponse.headers.value(for: "x-amz-storage-class") {
            self.storageClass = S3ClientTypes.StorageClass(rawValue: storageClassHeaderValue)
        } else {
            self.storageClass = nil
        }
        if let tagCountHeaderValue = httpResponse.headers.value(for: "x-amz-tagging-count") {
            self.tagCount = Swift.Int(tagCountHeaderValue) ?? 0
        } else {
            self.tagCount = 0
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if let websiteRedirectLocationHeaderValue = httpResponse.headers.value(for: "x-amz-website-redirect-location") {
            self.websiteRedirectLocation = websiteRedirectLocationHeaderValue
        } else {
            self.websiteRedirectLocation = nil
        }
        let keysForMetadata = httpResponse.headers.dictionary.keys.filter({ $0.starts(with: "x-amz-meta-") })
        if (!keysForMetadata.isEmpty) {
            var mapMember = [Swift.String: String]()
            for headerKey in keysForMetadata {
                let mapMemberValue = httpResponse.headers.dictionary[headerKey]?[0]
                let mapMemberKey = headerKey.removePrefix("x-amz-meta-")
                mapMember[mapMemberKey] = mapMemberValue
            }
            self.metadata = mapMember
        } else {
            self.metadata = [:]
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.body = data
        } else {
            self.body = nil
        }
    }
}
