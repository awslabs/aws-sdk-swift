// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension S3ClientTypes.AbortIncompleteMultipartUpload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case daysAfterInitiation = "DaysAfterInitiation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if daysAfterInitiation != 0 {
            try container.encode(daysAfterInitiation, forKey: ClientRuntime.Key("DaysAfterInitiation"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysAfterInitiationDecoded = try containerValues.decode(Swift.Int.self, forKey: .daysAfterInitiation)
        daysAfterInitiation = daysAfterInitiationDecoded
    }
}

extension S3ClientTypes.AbortIncompleteMultipartUpload: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see [ Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide.
    public struct AbortIncompleteMultipartUpload: Swift.Equatable {
        /// Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload.
        public var daysAfterInitiation: Swift.Int

        public init (
            daysAfterInitiation: Swift.Int = 0
        )
        {
            self.daysAfterInitiation = daysAfterInitiation
        }
    }

}

extension AbortMultipartUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension AbortMultipartUploadInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "AbortMultipartUpload"))
        if let uploadId = uploadId {
            let uploadIdQueryItem = ClientRuntime.URLQueryItem(name: "uploadId".urlPercentEncoding(), value: Swift.String(uploadId).urlPercentEncoding())
            items.append(uploadIdQueryItem)
        }
        return items
    }
}

extension AbortMultipartUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct AbortMultipartUploadInput: Swift.Equatable {
    /// The bucket name to which the upload was taking place. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Key of the object for which the multipart upload was initiated.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Upload ID that identifies the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.uploadId = uploadId
    }
}

struct AbortMultipartUploadInputBody: Swift.Equatable {
}

extension AbortMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AbortMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = AbortMultipartUploadOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? AbortMultipartUploadOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = AbortMultipartUploadOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension AbortMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchUpload" : self = .noSuchUpload(try NoSuchUpload(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension AbortMultipartUploadOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum AbortMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case noSuchUpload(NoSuchUpload)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct AbortMultipartUploadOutputResponse: Swift.Equatable {
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

extension S3ClientTypes.AccelerateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketAccelerateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ClientTypes.AccelerateConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Configures the transfer acceleration state for an Amazon S3 bucket. For more information, see [Amazon S3 Transfer Acceleration](https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the Amazon S3 User Guide.
    public struct AccelerateConfiguration: Swift.Equatable {
        /// Specifies the transfer acceleration status of the bucket.
        public var status: S3ClientTypes.BucketAccelerateStatus?

        public init (
            status: S3ClientTypes.BucketAccelerateStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ClientTypes.AccessControlPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "AccessControlList"
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let grants = grants {
            var grantsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AccessControlList"))
            for grant0 in grants {
                try grantsContainer.encode(grant0, forKey: ClientRuntime.Key("Grant"))
            }
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.grants) {
            struct KeyVal0{struct Grant{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([S3ClientTypes.Grant].self, forKey: .member)
                var grantsBuffer:[S3ClientTypes.Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [S3ClientTypes.Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension S3ClientTypes.AccessControlPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Contains the elements that set the ACL permissions for an object per grantee.
    public struct AccessControlPolicy: Swift.Equatable {
        /// A list of grants.
        public var grants: [S3ClientTypes.Grant]?
        /// Container for the bucket owner's display name and ID.
        public var owner: S3ClientTypes.Owner?

        public init (
            grants: [S3ClientTypes.Grant]? = nil,
            owner: S3ClientTypes.Owner? = nil
        )
        {
            self.grants = grants
            self.owner = owner
        }
    }

}

extension S3ClientTypes.AccessControlTranslation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.OwnerOverride.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension S3ClientTypes.AccessControlTranslation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for information about access control for replicas.
    public struct AccessControlTranslation: Swift.Equatable {
        /// Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the Amazon S3 API Reference.
        /// This member is required.
        public var owner: S3ClientTypes.OwnerOverride?

        public init (
            owner: S3ClientTypes.OwnerOverride? = nil
        )
        {
            self.owner = owner
        }
    }

}

extension S3ClientTypes.AnalyticsAndOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .tags)
                var tagsBuffer:[S3ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension S3ClientTypes.AnalyticsAndOperator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates in any combination, and an object must match all of the predicates for the filter to apply.
    public struct AnalyticsAndOperator: Swift.Equatable {
        /// The prefix to use when evaluating an AND predicate: The prefix that an object must have to be included in the metrics results.
        public var `prefix`: Swift.String?
        /// The list of tags to use when evaluating an AND predicate.
        public var tags: [S3ClientTypes.Tag]?

        public init (
            `prefix`: Swift.String? = nil,
            tags: [S3ClientTypes.Tag]? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ClientTypes.AnalyticsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case id = "Id"
        case storageClassAnalysis = "StorageClassAnalysis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let storageClassAnalysis = storageClassAnalysis {
            try container.encode(storageClassAnalysis, forKey: ClientRuntime.Key("StorageClassAnalysis"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AnalyticsFilter.self, forKey: .filter)
        filter = filterDecoded
        let storageClassAnalysisDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClassAnalysis.self, forKey: .storageClassAnalysis)
        storageClassAnalysis = storageClassAnalysisDecoded
    }
}

extension S3ClientTypes.AnalyticsConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
    public struct AnalyticsConfiguration: Swift.Equatable {
        /// The filter used to describe a set of objects for analyses. A filter must have exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided, all objects will be considered in any analysis.
        public var filter: S3ClientTypes.AnalyticsFilter?
        /// The ID that identifies the analytics configuration.
        /// This member is required.
        public var id: Swift.String?
        /// Contains data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes.
        /// This member is required.
        public var storageClassAnalysis: S3ClientTypes.StorageClassAnalysis?

        public init (
            filter: S3ClientTypes.AnalyticsFilter? = nil,
            id: Swift.String? = nil,
            storageClassAnalysis: S3ClientTypes.StorageClassAnalysis? = nil
        )
        {
            self.filter = filter
            self.id = id
            self.storageClassAnalysis = storageClassAnalysis
        }
    }

}

extension S3ClientTypes.AnalyticsExportDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketDestination = "S3BucketDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let s3BucketDestination = s3BucketDestination {
            try container.encode(s3BucketDestination, forKey: ClientRuntime.Key("S3BucketDestination"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDestinationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AnalyticsS3BucketDestination.self, forKey: .s3BucketDestination)
        s3BucketDestination = s3BucketDestinationDecoded
    }
}

extension S3ClientTypes.AnalyticsExportDestination: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Where to publish the analytics results.
    public struct AnalyticsExportDestination: Swift.Equatable {
        /// A destination signifying output to an S3 bucket.
        /// This member is required.
        public var s3BucketDestination: S3ClientTypes.AnalyticsS3BucketDestination?

        public init (
            s3BucketDestination: S3ClientTypes.AnalyticsS3BucketDestination? = nil
        )
        {
            self.s3BucketDestination = s3BucketDestination
        }
    }

}

extension S3ClientTypes.AnalyticsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        switch self {
            case let .and(and):
                try container.encode(and, forKey: ClientRuntime.Key("And"))
            case let .prefix(prefix):
                try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
            case let .tag(tag):
                try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: ClientRuntime.Key("sdkUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .prefix:
                let prefixDecoded = try containerValues.decode(Swift.String.self, forKey: .prefix)
                self = .prefix(prefixDecoded)
            case .tag:
                let tagDecoded = try containerValues.decode(S3ClientTypes.Tag.self, forKey: .tag)
                self = .tag(tagDecoded)
            case .and:
                let andDecoded = try containerValues.decode(S3ClientTypes.AnalyticsAndOperator.self, forKey: .and)
                self = .and(andDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ClientTypes {
    /// The filter used to describe a set of objects for analyses. A filter must have exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided, all objects will be considered in any analysis.
    public enum AnalyticsFilter: Swift.Equatable {
        /// The prefix to use when evaluating an analytics filter.
        case prefix(Swift.String)
        /// The tag to use when evaluating an analytics filter.
        case tag(S3ClientTypes.Tag)
        /// A conjunction (logical AND) of predicates, which is used in evaluating an analytics filter. The operator must have at least two predicates.
        case and(S3ClientTypes.AnalyticsAndOperator)
        case sdkUnknown(Swift.String)
    }

}

extension S3ClientTypes.AnalyticsS3BucketDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case format = "Format"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let bucketAccountId = bucketAccountId {
            try container.encode(bucketAccountId, forKey: ClientRuntime.Key("BucketAccountId"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AnalyticsS3ExportFileFormat.self, forKey: .format)
        format = formatDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension S3ClientTypes.AnalyticsS3BucketDestination: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Contains information about where to publish the analytics results.
    public struct AnalyticsS3BucketDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the bucket to which data is exported.
        /// This member is required.
        public var bucket: Swift.String?
        /// The account ID that owns the destination S3 bucket. If no account ID is provided, the owner is not validated before exporting data. Although this value is optional, we strongly recommend that you set it to help prevent problems if the destination bucket ownership changes.
        public var bucketAccountId: Swift.String?
        /// Specifies the file format used when exporting data to Amazon S3.
        /// This member is required.
        public var format: S3ClientTypes.AnalyticsS3ExportFileFormat?
        /// The prefix to use when exporting data. The prefix is prepended to all results.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            format: S3ClientTypes.AnalyticsS3ExportFileFormat? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.format = format
            self.`prefix` = `prefix`
        }
    }

}

extension S3ClientTypes {
    public enum AnalyticsS3ExportFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsS3ExportFileFormat] {
            return [
                .csv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsS3ExportFileFormat(rawValue: rawValue) ?? AnalyticsS3ExportFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum ArchiveStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archiveAccess
        case deepArchiveAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveStatus] {
            return [
                .archiveAccess,
                .deepArchiveAccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archiveAccess: return "ARCHIVE_ACCESS"
            case .deepArchiveAccess: return "DEEP_ARCHIVE_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArchiveStatus(rawValue: rawValue) ?? ArchiveStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.Bucket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let creationDate = creationDate {
            try container.encode(ClientRuntime.TimestampWrapper(creationDate, format: .dateTime), forKey: ClientRuntime.Key("CreationDate"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        var creationDateBuffer:ClientRuntime.Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
    }
}

extension S3ClientTypes.Bucket: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// In terms of implementation, a Bucket is a resource. An Amazon S3 bucket name is globally unique, and the namespace is shared by all Amazon Web Services accounts.
    public struct Bucket: Swift.Equatable {
        /// Date the bucket was created. This date can change when making changes to your bucket, such as editing its bucket policy.
        public var creationDate: ClientRuntime.Date?
        /// The name of the bucket.
        public var name: Swift.String?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.name = name
        }
    }

}

extension S3ClientTypes {
    public enum BucketAccelerateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketAccelerateStatus] {
            return [
                .enabled,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketAccelerateStatus(rawValue: rawValue) ?? BucketAccelerateStatus.sdkUnknown(rawValue)
        }
    }
}

extension BucketAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// The requested bucket name is not available. The bucket namespace is shared by all users of the system. Select a different name and try again.
public struct BucketAlreadyExists: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension BucketAlreadyOwnedByYou {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// The bucket you tried to create already exists, and you own it. Amazon S3 returns this error in all Amazon Web Services Regions except in the North Virginia Region. For legacy compatibility, if you re-create an existing bucket that you already own in the North Virginia Region, Amazon S3 returns 200 OK and resets the bucket access control lists (ACLs).
public struct BucketAlreadyOwnedByYou: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension S3ClientTypes {
    public enum BucketCannedACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketCannedACL] {
            return [
                .authenticatedRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketCannedACL(rawValue: rawValue) ?? BucketCannedACL.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.BucketLifecycleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for lifecyclerule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Rule"))
                    try rulesContainer0.encode(lifecyclerule0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.LifecycleRule].self, forKey: .rules)
                var rulesBuffer:[S3ClientTypes.LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ClientTypes.LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ClientTypes.BucketLifecycleConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For more information, see [Object Lifecycle Management](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) in the Amazon S3 User Guide.
    public struct BucketLifecycleConfiguration: Swift.Equatable {
        /// A lifecycle rule for individual objects in an Amazon S3 bucket.
        /// This member is required.
        public var rules: [S3ClientTypes.LifecycleRule]?

        public init (
            rules: [S3ClientTypes.LifecycleRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension S3ClientTypes {
    public enum BucketLocationConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eu
        case afSouth1
        case apEast1
        case apNortheast1
        case apNortheast2
        case apNortheast3
        case apSouth1
        case apSoutheast1
        case apSoutheast2
        case caCentral1
        case cnNorth1
        case cnNorthwest1
        case euCentral1
        case euNorth1
        case euSouth1
        case euWest1
        case euWest2
        case euWest3
        case meSouth1
        case saEast1
        case usEast2
        case usGovEast1
        case usGovWest1
        case usWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketLocationConstraint] {
            return [
                .eu,
                .afSouth1,
                .apEast1,
                .apNortheast1,
                .apNortheast2,
                .apNortheast3,
                .apSouth1,
                .apSoutheast1,
                .apSoutheast2,
                .caCentral1,
                .cnNorth1,
                .cnNorthwest1,
                .euCentral1,
                .euNorth1,
                .euSouth1,
                .euWest1,
                .euWest2,
                .euWest3,
                .meSouth1,
                .saEast1,
                .usEast2,
                .usGovEast1,
                .usGovWest1,
                .usWest1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eu: return "EU"
            case .afSouth1: return "af-south-1"
            case .apEast1: return "ap-east-1"
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apNortheast3: return "ap-northeast-3"
            case .apSouth1: return "ap-south-1"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .caCentral1: return "ca-central-1"
            case .cnNorth1: return "cn-north-1"
            case .cnNorthwest1: return "cn-northwest-1"
            case .euCentral1: return "eu-central-1"
            case .euNorth1: return "eu-north-1"
            case .euSouth1: return "eu-south-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .euWest3: return "eu-west-3"
            case .meSouth1: return "me-south-1"
            case .saEast1: return "sa-east-1"
            case .usEast2: return "us-east-2"
            case .usGovEast1: return "us-gov-east-1"
            case .usGovWest1: return "us-gov-west-1"
            case .usWest1: return "us-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketLocationConstraint(rawValue: rawValue) ?? BucketLocationConstraint.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.BucketLoggingStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingEnabled = "LoggingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let loggingEnabled = loggingEnabled {
            try container.encode(loggingEnabled, forKey: ClientRuntime.Key("LoggingEnabled"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingEnabledDecoded = try containerValues.decodeIfPresent(S3ClientTypes.LoggingEnabled.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
    }
}

extension S3ClientTypes.BucketLoggingStatus: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for logging status information.
    public struct BucketLoggingStatus: Swift.Equatable {
        /// Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For more information, see [PUT Bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the Amazon S3 API Reference.
        public var loggingEnabled: S3ClientTypes.LoggingEnabled?

        public init (
            loggingEnabled: S3ClientTypes.LoggingEnabled? = nil
        )
        {
            self.loggingEnabled = loggingEnabled
        }
    }

}

extension S3ClientTypes {
    public enum BucketLogsPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case write
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketLogsPermission] {
            return [
                .fullControl,
                .read,
                .write,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .write: return "WRITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketLogsPermission(rawValue: rawValue) ?? BucketLogsPermission.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum BucketVersioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketVersioningStatus] {
            return [
                .enabled,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketVersioningStatus(rawValue: rawValue) ?? BucketVersioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.CORSConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cORSRules = "CORSRule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cORSRules = cORSRules {
            if cORSRules.isEmpty {
                var cORSRulesContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("CORSRule"))
                try cORSRulesContainer.encodeNil()
            } else {
                for corsrule0 in cORSRules {
                    var cORSRulesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CORSRule"))
                    try cORSRulesContainer0.encode(corsrule0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.cORSRules) {
            let cORSRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .cORSRules)
            if cORSRulesWrappedContainer != nil {
                let cORSRulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.CORSRule].self, forKey: .cORSRules)
                var cORSRulesBuffer:[S3ClientTypes.CORSRule]? = nil
                if let cORSRulesContainer = cORSRulesContainer {
                    cORSRulesBuffer = [S3ClientTypes.CORSRule]()
                    for structureContainer0 in cORSRulesContainer {
                        cORSRulesBuffer?.append(structureContainer0)
                    }
                }
                cORSRules = cORSRulesBuffer
            } else {
                cORSRules = []
            }
        } else {
            cORSRules = nil
        }
    }
}

extension S3ClientTypes.CORSConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon S3 User Guide.
    public struct CORSConfiguration: Swift.Equatable {
        /// A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
        /// This member is required.
        public var cORSRules: [S3ClientTypes.CORSRule]?

        public init (
            cORSRules: [S3ClientTypes.CORSRule]? = nil
        )
        {
            self.cORSRules = cORSRules
        }
    }

}

extension S3ClientTypes.CORSRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedHeaders = "AllowedHeader"
        case allowedMethods = "AllowedMethod"
        case allowedOrigins = "AllowedOrigin"
        case exposeHeaders = "ExposeHeader"
        case iD = "ID"
        case maxAgeSeconds = "MaxAgeSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedHeaders = allowedHeaders {
            if allowedHeaders.isEmpty {
                var allowedHeadersContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("AllowedHeader"))
                try allowedHeadersContainer.encodeNil()
            } else {
                for allowedheader0 in allowedHeaders {
                    var allowedHeadersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedHeader"))
                    try allowedHeadersContainer0.encode(allowedheader0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let allowedMethods = allowedMethods {
            if allowedMethods.isEmpty {
                var allowedMethodsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("AllowedMethod"))
                try allowedMethodsContainer.encodeNil()
            } else {
                for allowedmethod0 in allowedMethods {
                    var allowedMethodsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedMethod"))
                    try allowedMethodsContainer0.encode(allowedmethod0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let allowedOrigins = allowedOrigins {
            if allowedOrigins.isEmpty {
                var allowedOriginsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("AllowedOrigin"))
                try allowedOriginsContainer.encodeNil()
            } else {
                for allowedorigin0 in allowedOrigins {
                    var allowedOriginsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedOrigin"))
                    try allowedOriginsContainer0.encode(allowedorigin0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let exposeHeaders = exposeHeaders {
            if exposeHeaders.isEmpty {
                var exposeHeadersContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("ExposeHeader"))
                try exposeHeadersContainer.encodeNil()
            } else {
                for exposeheader0 in exposeHeaders {
                    var exposeHeadersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExposeHeader"))
                    try exposeHeadersContainer0.encode(exposeheader0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let iD = iD {
            try container.encode(iD, forKey: ClientRuntime.Key("ID"))
        }
        if maxAgeSeconds != 0 {
            try container.encode(maxAgeSeconds, forKey: ClientRuntime.Key("MaxAgeSeconds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
        if containerValues.contains(.allowedHeaders) {
            let allowedHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedHeaders)
            if allowedHeadersWrappedContainer != nil {
                let allowedHeadersContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .allowedHeaders)
                var allowedHeadersBuffer:[Swift.String]? = nil
                if let allowedHeadersContainer = allowedHeadersContainer {
                    allowedHeadersBuffer = [Swift.String]()
                    for stringContainer0 in allowedHeadersContainer {
                        allowedHeadersBuffer?.append(stringContainer0)
                    }
                }
                allowedHeaders = allowedHeadersBuffer
            } else {
                allowedHeaders = []
            }
        } else {
            allowedHeaders = nil
        }
        if containerValues.contains(.allowedMethods) {
            let allowedMethodsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedMethods)
            if allowedMethodsWrappedContainer != nil {
                let allowedMethodsContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .allowedMethods)
                var allowedMethodsBuffer:[Swift.String]? = nil
                if let allowedMethodsContainer = allowedMethodsContainer {
                    allowedMethodsBuffer = [Swift.String]()
                    for stringContainer0 in allowedMethodsContainer {
                        allowedMethodsBuffer?.append(stringContainer0)
                    }
                }
                allowedMethods = allowedMethodsBuffer
            } else {
                allowedMethods = []
            }
        } else {
            allowedMethods = nil
        }
        if containerValues.contains(.allowedOrigins) {
            let allowedOriginsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedOrigins)
            if allowedOriginsWrappedContainer != nil {
                let allowedOriginsContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .allowedOrigins)
                var allowedOriginsBuffer:[Swift.String]? = nil
                if let allowedOriginsContainer = allowedOriginsContainer {
                    allowedOriginsBuffer = [Swift.String]()
                    for stringContainer0 in allowedOriginsContainer {
                        allowedOriginsBuffer?.append(stringContainer0)
                    }
                }
                allowedOrigins = allowedOriginsBuffer
            } else {
                allowedOrigins = []
            }
        } else {
            allowedOrigins = nil
        }
        if containerValues.contains(.exposeHeaders) {
            let exposeHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .exposeHeaders)
            if exposeHeadersWrappedContainer != nil {
                let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .exposeHeaders)
                var exposeHeadersBuffer:[Swift.String]? = nil
                if let exposeHeadersContainer = exposeHeadersContainer {
                    exposeHeadersBuffer = [Swift.String]()
                    for stringContainer0 in exposeHeadersContainer {
                        exposeHeadersBuffer?.append(stringContainer0)
                    }
                }
                exposeHeaders = exposeHeadersBuffer
            } else {
                exposeHeaders = []
            }
        } else {
            exposeHeaders = nil
        }
        let maxAgeSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxAgeSeconds)
        maxAgeSeconds = maxAgeSecondsDecoded
    }
}

extension S3ClientTypes.CORSRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies a cross-origin access rule for an Amazon S3 bucket.
    public struct CORSRule: Swift.Equatable {
        /// Headers that are specified in the Access-Control-Request-Headers header. These headers are allowed in a preflight OPTIONS request. In response to any preflight OPTIONS request, Amazon S3 returns any requested headers that are allowed.
        public var allowedHeaders: [Swift.String]?
        /// An HTTP method that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        /// This member is required.
        public var allowedMethods: [Swift.String]?
        /// One or more origins you want customers to be able to access the bucket from.
        /// This member is required.
        public var allowedOrigins: [Swift.String]?
        /// One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        public var exposeHeaders: [Swift.String]?
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        public var iD: Swift.String?
        /// The time in seconds that your browser is to cache the preflight response for the specified resource.
        public var maxAgeSeconds: Swift.Int

        public init (
            allowedHeaders: [Swift.String]? = nil,
            allowedMethods: [Swift.String]? = nil,
            allowedOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            iD: Swift.String? = nil,
            maxAgeSeconds: Swift.Int = 0
        )
        {
            self.allowedHeaders = allowedHeaders
            self.allowedMethods = allowedMethods
            self.allowedOrigins = allowedOrigins
            self.exposeHeaders = exposeHeaders
            self.iD = iD
            self.maxAgeSeconds = maxAgeSeconds
        }
    }

}

extension S3ClientTypes.CSVInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowQuotedRecordDelimiter = "AllowQuotedRecordDelimiter"
        case comments = "Comments"
        case fieldDelimiter = "FieldDelimiter"
        case fileHeaderInfo = "FileHeaderInfo"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if allowQuotedRecordDelimiter != false {
            try container.encode(allowQuotedRecordDelimiter, forKey: ClientRuntime.Key("AllowQuotedRecordDelimiter"))
        }
        if let comments = comments {
            try container.encode(comments, forKey: ClientRuntime.Key("Comments"))
        }
        if let fieldDelimiter = fieldDelimiter {
            try container.encode(fieldDelimiter, forKey: ClientRuntime.Key("FieldDelimiter"))
        }
        if let fileHeaderInfo = fileHeaderInfo {
            try container.encode(fileHeaderInfo, forKey: ClientRuntime.Key("FileHeaderInfo"))
        }
        if let quoteCharacter = quoteCharacter {
            try container.encode(quoteCharacter, forKey: ClientRuntime.Key("QuoteCharacter"))
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try container.encode(quoteEscapeCharacter, forKey: ClientRuntime.Key("QuoteEscapeCharacter"))
        }
        if let recordDelimiter = recordDelimiter {
            try container.encode(recordDelimiter, forKey: ClientRuntime.Key("RecordDelimiter"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileHeaderInfoDecoded = try containerValues.decodeIfPresent(S3ClientTypes.FileHeaderInfo.self, forKey: .fileHeaderInfo)
        fileHeaderInfo = fileHeaderInfoDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comments)
        comments = commentsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
        let allowQuotedRecordDelimiterDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowQuotedRecordDelimiter)
        allowQuotedRecordDelimiter = allowQuotedRecordDelimiterDecoded
    }
}

extension S3ClientTypes.CSVInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes how an uncompressed comma-separated values (CSV)-formatted input object is formatted.
    public struct CSVInput: Swift.Equatable {
        /// Specifies that CSV field values may contain quoted record delimiters and such records should be allowed. Default value is FALSE. Setting this value to TRUE may lower performance.
        public var allowQuotedRecordDelimiter: Swift.Bool
        /// A single character used to indicate that a row should be ignored when the character is present at the start of that row. You can specify any character to indicate a comment line.
        public var comments: Swift.String?
        /// A single character used to separate individual fields in a record. You can specify an arbitrary delimiter.
        public var fieldDelimiter: Swift.String?
        /// Describes the first line of input. Valid values are:
        ///
        /// * NONE: First line is not a header.
        ///
        /// * IGNORE: First line is a header, but you can't use the header values to indicate the column in an expression. You can use column position (such as _1, _2, ) to indicate the column (SELECT s._1 FROM OBJECT s).
        ///
        /// * Use: First line is a header, and you can use the header value to identify a column in an expression (SELECT "name" FROM OBJECT).
        public var fileHeaderInfo: S3ClientTypes.FileHeaderInfo?
        /// A single character used for escaping when the field delimiter is part of the value. For example, if the value is a, b, Amazon S3 wraps this field value in quotation marks, as follows: " a , b ". Type: String Default: " Ancestors: CSV
        public var quoteCharacter: Swift.String?
        /// A single character used for escaping the quotation mark character inside an already escaped value. For example, the value """ a , b """ is parsed as " a , b ".
        public var quoteEscapeCharacter: Swift.String?
        /// A single character used to separate individual records in the input. Instead of the default value, you can specify an arbitrary delimiter.
        public var recordDelimiter: Swift.String?

        public init (
            allowQuotedRecordDelimiter: Swift.Bool = false,
            comments: Swift.String? = nil,
            fieldDelimiter: Swift.String? = nil,
            fileHeaderInfo: S3ClientTypes.FileHeaderInfo? = nil,
            quoteCharacter: Swift.String? = nil,
            quoteEscapeCharacter: Swift.String? = nil,
            recordDelimiter: Swift.String? = nil
        )
        {
            self.allowQuotedRecordDelimiter = allowQuotedRecordDelimiter
            self.comments = comments
            self.fieldDelimiter = fieldDelimiter
            self.fileHeaderInfo = fileHeaderInfo
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.recordDelimiter = recordDelimiter
        }
    }

}

extension S3ClientTypes.CSVOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldDelimiter = "FieldDelimiter"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case quoteFields = "QuoteFields"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldDelimiter = fieldDelimiter {
            try container.encode(fieldDelimiter, forKey: ClientRuntime.Key("FieldDelimiter"))
        }
        if let quoteCharacter = quoteCharacter {
            try container.encode(quoteCharacter, forKey: ClientRuntime.Key("QuoteCharacter"))
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try container.encode(quoteEscapeCharacter, forKey: ClientRuntime.Key("QuoteEscapeCharacter"))
        }
        if let quoteFields = quoteFields {
            try container.encode(quoteFields, forKey: ClientRuntime.Key("QuoteFields"))
        }
        if let recordDelimiter = recordDelimiter {
            try container.encode(recordDelimiter, forKey: ClientRuntime.Key("RecordDelimiter"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quoteFieldsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.QuoteFields.self, forKey: .quoteFields)
        quoteFields = quoteFieldsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension S3ClientTypes.CSVOutput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes how uncompressed comma-separated values (CSV)-formatted results are formatted.
    public struct CSVOutput: Swift.Equatable {
        /// The value used to separate individual fields in a record. You can specify an arbitrary delimiter.
        public var fieldDelimiter: Swift.String?
        /// A single character used for escaping when the field delimiter is part of the value. For example, if the value is a, b, Amazon S3 wraps this field value in quotation marks, as follows: " a , b ".
        public var quoteCharacter: Swift.String?
        /// The single character used for escaping the quote character inside an already escaped value.
        public var quoteEscapeCharacter: Swift.String?
        /// Indicates whether to use quotation marks around output fields.
        ///
        /// * ALWAYS: Always use quotation marks for output fields.
        ///
        /// * ASNEEDED: Use quotation marks for output fields when needed.
        public var quoteFields: S3ClientTypes.QuoteFields?
        /// A single character used to separate individual records in the output. Instead of the default value, you can specify an arbitrary delimiter.
        public var recordDelimiter: Swift.String?

        public init (
            fieldDelimiter: Swift.String? = nil,
            quoteCharacter: Swift.String? = nil,
            quoteEscapeCharacter: Swift.String? = nil,
            quoteFields: S3ClientTypes.QuoteFields? = nil,
            recordDelimiter: Swift.String? = nil
        )
        {
            self.fieldDelimiter = fieldDelimiter
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.quoteFields = quoteFields
            self.recordDelimiter = recordDelimiter
        }
    }

}

extension S3ClientTypes.CommonPrefix: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension S3ClientTypes.CommonPrefix: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for all (if there are any) keys between Prefix and the next occurrence of the string specified by a delimiter. CommonPrefixes lists keys that act like subdirectories in the directory specified by Prefix. For example, if the prefix is notes/ and the delimiter is a slash (/) as in notes/summer/july, the common prefix is notes/summer/.
    public struct CommonPrefix: Swift.Equatable {
        /// Container for the specified common prefix.
        public var `prefix`: Swift.String?

        public init (
            `prefix`: Swift.String? = nil
        )
        {
            self.`prefix` = `prefix`
        }
    }

}

public struct CompleteMultipartUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteMultipartUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CompleteMultipartUploadOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let multipartUpload = input.operationInput.multipartUpload {
                let multipartUploaddata = try encoder.encode(multipartUpload)
                let multipartUploadbody = ClientRuntime.HttpBody.data(multipartUploaddata)
                input.builder.withBody(multipartUploadbody)
            } else {
                let multipartUploaddata = try encoder.encode(input.operationInput)
                let multipartUploadbody = ClientRuntime.HttpBody.data(multipartUploaddata)
                input.builder.withBody(multipartUploadbody)
            }
        } catch let err {
            throw SdkError<CompleteMultipartUploadOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CompleteMultipartUploadInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CompleteMultipartUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multipartUpload = "CompleteMultipartUpload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let multipartUpload = multipartUpload {
            try container.encode(multipartUpload, forKey: ClientRuntime.Key("CompleteMultipartUpload"))
        }
    }
}

extension CompleteMultipartUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension CompleteMultipartUploadInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "CompleteMultipartUpload"))
        if let uploadId = uploadId {
            let uploadIdQueryItem = ClientRuntime.URLQueryItem(name: "uploadId".urlPercentEncoding(), value: Swift.String(uploadId).urlPercentEncoding())
            items.append(uploadIdQueryItem)
        }
        return items
    }
}

extension CompleteMultipartUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct CompleteMultipartUploadInput: Swift.Equatable {
    /// Name of the bucket to which the multipart upload was initiated. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Object key for which the multipart upload was initiated.
    /// This member is required.
    public var key: Swift.String?
    /// The container for the multipart upload request information.
    public var multipartUpload: S3ClientTypes.CompletedMultipartUpload?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// ID for the initiated multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        multipartUpload: S3ClientTypes.CompletedMultipartUpload? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.multipartUpload = multipartUpload
        self.requestPayer = requestPayer
        self.uploadId = uploadId
    }
}

struct CompleteMultipartUploadInputBody: Swift.Equatable {
    let multipartUpload: S3ClientTypes.CompletedMultipartUpload?
}

extension CompleteMultipartUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multipartUpload = "CompleteMultipartUpload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CompletedMultipartUpload.self, forKey: .multipartUpload)
        multipartUpload = multipartUploadDecoded
    }
}

extension CompleteMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = CompleteMultipartUploadOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? CompleteMultipartUploadOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = CompleteMultipartUploadOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension CompleteMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension CompleteMultipartUploadOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum CompleteMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CompleteMultipartUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucket = output.bucket
            self.eTag = output.eTag
            self.key = output.key
            self.location = output.location
        } else {
            self.bucket = nil
            self.eTag = nil
            self.key = nil
            self.location = nil
        }
    }
}

public struct CompleteMultipartUploadOutputResponse: Swift.Equatable {
    /// The name of the bucket that contains the newly created object. Does not return the access point ARN or access point alias if used. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    public var bucket: Swift.String?
    /// Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Entity tag that identifies the newly created object's data. Objects with different object data will have different entity tags. The entity tag is an opaque string. The entity tag may or may not be an MD5 digest of the object data. If the entity tag is not an MD5 digest of the object data, it will contain one or more nonhexadecimal characters and/or will consist of less than 32 or more than 32 hexadecimal digits.
    public var eTag: Swift.String?
    /// If the object expiration is configured, this will contain the expiration date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.
    public var expiration: Swift.String?
    /// The object key of the newly created object.
    public var key: Swift.String?
    /// The URI that identifies the newly created object.
    public var location: Swift.String?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// If you specified server-side encryption either with an Amazon S3-managed encryption key or an Amazon Web Services KMS key in your initiate multipart upload request, the response includes this header. It confirms the encryption algorithm that Amazon S3 used to encrypt the object.
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// Version ID of the newly created object, in case the bucket has versioning turned on.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        eTag: Swift.String? = nil,
        expiration: Swift.String? = nil,
        key: Swift.String? = nil,
        location: Swift.String? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.eTag = eTag
        self.expiration = expiration
        self.key = key
        self.location = location
        self.requestCharged = requestCharged
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.versionId = versionId
    }
}

struct CompleteMultipartUploadOutputResponseBody: Swift.Equatable {
    let location: Swift.String?
    let bucket: Swift.String?
    let key: Swift.String?
    let eTag: Swift.String?
}

extension CompleteMultipartUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case eTag = "ETag"
        case key = "Key"
        case location = "Location"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
    }
}

extension S3ClientTypes.CompletedMultipartUpload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parts = "Part"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let parts = parts {
            if parts.isEmpty {
                var partsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Part"))
                try partsContainer.encodeNil()
            } else {
                for completedpart0 in parts {
                    var partsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Part"))
                    try partsContainer0.encode(completedpart0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.parts) {
            let partsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .parts)
            if partsWrappedContainer != nil {
                let partsContainer = try containerValues.decodeIfPresent([S3ClientTypes.CompletedPart].self, forKey: .parts)
                var partsBuffer:[S3ClientTypes.CompletedPart]? = nil
                if let partsContainer = partsContainer {
                    partsBuffer = [S3ClientTypes.CompletedPart]()
                    for structureContainer0 in partsContainer {
                        partsBuffer?.append(structureContainer0)
                    }
                }
                parts = partsBuffer
            } else {
                parts = []
            }
        } else {
            parts = nil
        }
    }
}

extension S3ClientTypes.CompletedMultipartUpload: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container for the completed multipart upload details.
    public struct CompletedMultipartUpload: Swift.Equatable {
        /// Array of CompletedPart data types. If you do not supply a valid Part with your request, the service sends back an HTTP 400 response.
        public var parts: [S3ClientTypes.CompletedPart]?

        public init (
            parts: [S3ClientTypes.CompletedPart]? = nil
        )
        {
            self.parts = parts
        }
    }

}

extension S3ClientTypes.CompletedPart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case partNumber = "PartNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: ClientRuntime.Key("ETag"))
        }
        if partNumber != 0 {
            try container.encode(partNumber, forKey: ClientRuntime.Key("PartNumber"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let partNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .partNumber)
        partNumber = partNumberDecoded
    }
}

extension S3ClientTypes.CompletedPart: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Details of the parts that were uploaded.
    public struct CompletedPart: Swift.Equatable {
        /// Entity tag returned when the part was uploaded.
        public var eTag: Swift.String?
        /// Part number that identifies the part. This is a positive integer between 1 and 10,000.
        public var partNumber: Swift.Int

        public init (
            eTag: Swift.String? = nil,
            partNumber: Swift.Int = 0
        )
        {
            self.eTag = eTag
            self.partNumber = partNumber
        }
    }

}

extension S3ClientTypes {
    public enum CompressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bzip2
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionType] {
            return [
                .bzip2,
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bzip2: return "BZIP2"
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionType(rawValue: rawValue) ?? CompressionType.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpErrorCodeReturnedEquals = "HttpErrorCodeReturnedEquals"
        case keyPrefixEquals = "KeyPrefixEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals {
            try container.encode(httpErrorCodeReturnedEquals, forKey: ClientRuntime.Key("HttpErrorCodeReturnedEquals"))
        }
        if let keyPrefixEquals = keyPrefixEquals {
            try container.encode(keyPrefixEquals, forKey: ClientRuntime.Key("KeyPrefixEquals"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpErrorCodeReturnedEqualsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpErrorCodeReturnedEquals)
        httpErrorCodeReturnedEquals = httpErrorCodeReturnedEqualsDecoded
        let keyPrefixEqualsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefixEquals)
        keyPrefixEquals = keyPrefixEqualsDecoded
    }
}

extension S3ClientTypes.Condition: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
    public struct Condition: Swift.Equatable {
        /// The HTTP error code when the redirect is applied. In the event of an error, if the error code equals this value, then the specified redirect is applied. Required when parent element Condition is specified and sibling KeyPrefixEquals is not specified. If both are specified, then both must be true for the redirect to be applied.
        public var httpErrorCodeReturnedEquals: Swift.String?
        /// The object key name prefix when the redirect is applied. For example, to redirect requests for ExamplePage.html, the key prefix will be ExamplePage.html. To redirect request for all pages with the prefix docs/, the key prefix will be /docs, which identifies all objects in the docs/ folder. Required when the parent element Condition is specified and sibling HttpErrorCodeReturnedEquals is not specified. If both conditions are specified, both must be true for the redirect to be applied. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        public var keyPrefixEquals: Swift.String?

        public init (
            httpErrorCodeReturnedEquals: Swift.String? = nil,
            keyPrefixEquals: Swift.String? = nil
        )
        {
            self.httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals
            self.keyPrefixEquals = keyPrefixEquals
        }
    }

}

extension S3ClientTypes.ContinuationEvent: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension S3ClientTypes {
    ///
    public struct ContinuationEvent: Swift.Equatable {

    }

}

extension CopyObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let aCL = aCL {
            items.add(Header(name: "x-amz-acl", value: Swift.String(aCL.rawValue)))
        }
        if bucketKeyEnabled != false {
            items.add(Header(name: "x-amz-server-side-encryption-bucket-key-enabled", value: Swift.String(bucketKeyEnabled)))
        }
        if let cacheControl = cacheControl {
            items.add(Header(name: "Cache-Control", value: Swift.String(cacheControl)))
        }
        if let contentDisposition = contentDisposition {
            items.add(Header(name: "Content-Disposition", value: Swift.String(contentDisposition)))
        }
        if let contentEncoding = contentEncoding {
            items.add(Header(name: "Content-Encoding", value: Swift.String(contentEncoding)))
        }
        if let contentLanguage = contentLanguage {
            items.add(Header(name: "Content-Language", value: Swift.String(contentLanguage)))
        }
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let copySource = copySource {
            items.add(Header(name: "x-amz-copy-source", value: Swift.String(copySource)))
        }
        if let copySourceIfMatch = copySourceIfMatch {
            items.add(Header(name: "x-amz-copy-source-if-match", value: Swift.String(copySourceIfMatch)))
        }
        if let copySourceIfModifiedSince = copySourceIfModifiedSince {
            items.add(Header(name: "x-amz-copy-source-if-modified-since", value: Swift.String(copySourceIfModifiedSince.rfc5322())))
        }
        if let copySourceIfNoneMatch = copySourceIfNoneMatch {
            items.add(Header(name: "x-amz-copy-source-if-none-match", value: Swift.String(copySourceIfNoneMatch)))
        }
        if let copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince {
            items.add(Header(name: "x-amz-copy-source-if-unmodified-since", value: Swift.String(copySourceIfUnmodifiedSince.rfc5322())))
        }
        if let copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm {
            items.add(Header(name: "x-amz-copy-source-server-side-encryption-customer-algorithm", value: Swift.String(copySourceSSECustomerAlgorithm)))
        }
        if let copySourceSSECustomerKey = copySourceSSECustomerKey {
            items.add(Header(name: "x-amz-copy-source-server-side-encryption-customer-key", value: Swift.String(copySourceSSECustomerKey)))
        }
        if let copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-copy-source-server-side-encryption-customer-key-MD5", value: Swift.String(copySourceSSECustomerKeyMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let expectedSourceBucketOwner = expectedSourceBucketOwner {
            items.add(Header(name: "x-amz-source-expected-bucket-owner", value: Swift.String(expectedSourceBucketOwner)))
        }
        if let expires = expires {
            items.add(Header(name: "Expires", value: Swift.String(expires.rfc5322())))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if let metadataDirective = metadataDirective {
            items.add(Header(name: "x-amz-metadata-directive", value: Swift.String(metadataDirective.rawValue)))
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            items.add(Header(name: "x-amz-object-lock-legal-hold", value: Swift.String(objectLockLegalHoldStatus.rawValue)))
        }
        if let objectLockMode = objectLockMode {
            items.add(Header(name: "x-amz-object-lock-mode", value: Swift.String(objectLockMode.rawValue)))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            items.add(Header(name: "x-amz-object-lock-retain-until-date", value: Swift.String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds())))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        if let sSEKMSEncryptionContext = sSEKMSEncryptionContext {
            items.add(Header(name: "x-amz-server-side-encryption-context", value: Swift.String(sSEKMSEncryptionContext)))
        }
        if let sSEKMSKeyId = sSEKMSKeyId {
            items.add(Header(name: "x-amz-server-side-encryption-aws-kms-key-id", value: Swift.String(sSEKMSKeyId)))
        }
        if let serverSideEncryption = serverSideEncryption {
            items.add(Header(name: "x-amz-server-side-encryption", value: Swift.String(serverSideEncryption.rawValue)))
        }
        if let storageClass = storageClass {
            items.add(Header(name: "x-amz-storage-class", value: Swift.String(storageClass.rawValue)))
        }
        if let tagging = tagging {
            items.add(Header(name: "x-amz-tagging", value: Swift.String(tagging)))
        }
        if let taggingDirective = taggingDirective {
            items.add(Header(name: "x-amz-tagging-directive", value: Swift.String(taggingDirective.rawValue)))
        }
        if let websiteRedirectLocation = websiteRedirectLocation {
            items.add(Header(name: "x-amz-website-redirect-location", value: Swift.String(websiteRedirectLocation)))
        }
        if let metadata = metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                items.add(Header(name: "x-amz-meta-\(prefixHeaderMapKey)", value: Swift.String(prefixHeaderMapValue)))
            }
        }
        return items
    }
}

extension CopyObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "CopyObject"))
        return items
    }
}

extension CopyObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct CopyObjectInput: Swift.Equatable {
    /// The canned ACL to apply to the object. This action is not supported by Amazon S3 on Outposts.
    public var aCL: S3ClientTypes.ObjectCannedACL?
    /// The name of the destination bucket. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to true causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. Specifying this header with a COPY action doesnt affect bucket-level settings for S3 Bucket Key.
    public var bucketKeyEnabled: Swift.Bool
    /// Specifies caching behavior along the request/reply chain.
    public var cacheControl: Swift.String?
    /// Specifies presentational information for the object.
    public var contentDisposition: Swift.String?
    /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
    public var contentEncoding: Swift.String?
    /// The language the content is in.
    public var contentLanguage: Swift.String?
    /// A standard MIME type describing the format of the object data.
    public var contentType: Swift.String?
    /// Specifies the source object for the copy operation. You specify the value in one of two formats, depending on whether you want to access the source object through an [access point](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html):
    ///
    /// * For objects not accessed through an access point, specify the name of the source bucket and the key of the source object, separated by a slash (/). For example, to copy the object reports/january.pdf from the bucket awsexamplebucket, use awsexamplebucket/reports/january.pdf. The value must be URL encoded.
    ///
    /// * For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format arn:aws:s3:::accesspoint//object/. For example, to copy the object reports/january.pdf through access point my-access-point owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf. The value must be URL encoded. Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same Amazon Web Services Region. Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format arn:aws:s3-outposts:::outpost//object/. For example, to copy the object reports/january.pdf through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf. The value must be URL encoded.
    ///
    ///
    /// To copy a specific version of an object, append ?versionId= to the value (for example, awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893). If you don't specify a version ID, Amazon S3 copies the latest version of the source object.
    /// This member is required.
    public var copySource: Swift.String?
    /// Copies the object if its entity tag (ETag) matches the specified tag.
    public var copySourceIfMatch: Swift.String?
    /// Copies the object if it has been modified since the specified time.
    public var copySourceIfModifiedSince: ClientRuntime.Date?
    /// Copies the object if its entity tag (ETag) is different than the specified ETag.
    public var copySourceIfNoneMatch: Swift.String?
    /// Copies the object if it hasn't been modified since the specified time.
    public var copySourceIfUnmodifiedSince: ClientRuntime.Date?
    /// Specifies the algorithm to use when decrypting the source object (for example, AES256).
    public var copySourceSSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.
    public var copySourceSSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var copySourceSSECustomerKeyMD5: Swift.String?
    /// The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedSourceBucketOwner: Swift.String?
    /// The date and time at which the object is no longer cacheable.
    public var expires: ClientRuntime.Date?
    /// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object. This action is not supported by Amazon S3 on Outposts.
    public var grantFullControl: Swift.String?
    /// Allows grantee to read the object data and its metadata. This action is not supported by Amazon S3 on Outposts.
    public var grantRead: Swift.String?
    /// Allows grantee to read the object ACL. This action is not supported by Amazon S3 on Outposts.
    public var grantReadACP: Swift.String?
    /// Allows grantee to write the ACL for the applicable object. This action is not supported by Amazon S3 on Outposts.
    public var grantWriteACP: Swift.String?
    /// The key of the destination object.
    /// This member is required.
    public var key: Swift.String?
    /// A map of metadata to store with the object in S3.
    public var metadata: [Swift.String:Swift.String]?
    /// Specifies whether the metadata is copied from the source object or replaced with metadata provided in the request.
    public var metadataDirective: S3ClientTypes.MetadataDirective?
    /// Specifies whether you want to apply a Legal Hold to the copied object.
    public var objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus?
    /// The Object Lock mode that you want to apply to the copied object.
    public var objectLockMode: S3ClientTypes.ObjectLockMode?
    /// The date and time when you want the copied object's Object Lock to expire.
    public var objectLockRetainUntilDate: ClientRuntime.Date?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Specifies the algorithm to use to when encrypting the object (for example, AES256).
    public var sSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
    public var sSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var sSECustomerKeyMD5: Swift.String?
    /// Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
    public var sSEKMSEncryptionContext: Swift.String?
    /// Specifies the Amazon Web Services KMS key ID to use for object encryption. All GET and PUT requests for an object protected by Amazon Web Services KMS will fail if not made via SSL or using SigV4. For information about configuring using any of the officially supported Amazon Web Services SDKs and Amazon Web Services CLI, see [Specifying the Signature Version in Request Authentication](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version) in the Amazon S3 User Guide.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The STANDARD storage class provides high durability and high availability. Depending on performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses the OUTPOSTS Storage Class. For more information, see [Storage Classes](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html) in the Amazon S3 User Guide.
    public var storageClass: S3ClientTypes.StorageClass?
    /// The tag-set for the object destination object this value must be used in conjunction with the TaggingDirective. The tag-set must be encoded as URL Query parameters.
    public var tagging: Swift.String?
    /// Specifies whether the object tag-set are copied from the source object or replaced with tag-set provided in the request.
    public var taggingDirective: S3ClientTypes.TaggingDirective?
    /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
    public var websiteRedirectLocation: Swift.String?

    public init (
        aCL: S3ClientTypes.ObjectCannedACL? = nil,
        bucket: Swift.String? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        cacheControl: Swift.String? = nil,
        contentDisposition: Swift.String? = nil,
        contentEncoding: Swift.String? = nil,
        contentLanguage: Swift.String? = nil,
        contentType: Swift.String? = nil,
        copySource: Swift.String? = nil,
        copySourceIfMatch: Swift.String? = nil,
        copySourceIfModifiedSince: ClientRuntime.Date? = nil,
        copySourceIfNoneMatch: Swift.String? = nil,
        copySourceIfUnmodifiedSince: ClientRuntime.Date? = nil,
        copySourceSSECustomerAlgorithm: Swift.String? = nil,
        copySourceSSECustomerKey: Swift.String? = nil,
        copySourceSSECustomerKeyMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        expectedSourceBucketOwner: Swift.String? = nil,
        expires: ClientRuntime.Date? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        key: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        metadataDirective: S3ClientTypes.MetadataDirective? = nil,
        objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus? = nil,
        objectLockMode: S3ClientTypes.ObjectLockMode? = nil,
        objectLockRetainUntilDate: ClientRuntime.Date? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSEncryptionContext: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        storageClass: S3ClientTypes.StorageClass? = nil,
        tagging: Swift.String? = nil,
        taggingDirective: S3ClientTypes.TaggingDirective? = nil,
        websiteRedirectLocation: Swift.String? = nil
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentType = contentType
        self.copySource = copySource
        self.copySourceIfMatch = copySourceIfMatch
        self.copySourceIfModifiedSince = copySourceIfModifiedSince
        self.copySourceIfNoneMatch = copySourceIfNoneMatch
        self.copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince
        self.copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm
        self.copySourceSSECustomerKey = copySourceSSECustomerKey
        self.copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.expectedSourceBucketOwner = expectedSourceBucketOwner
        self.expires = expires
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.metadata = metadata
        self.metadataDirective = metadataDirective
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagging = tagging
        self.taggingDirective = taggingDirective
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct CopyObjectInputBody: Swift.Equatable {
}

extension CopyObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CopyObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = CopyObjectOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? CopyObjectOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = CopyObjectOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension CopyObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "ObjectNotInActiveTierError" : self = .objectNotInActiveTierError(try ObjectNotInActiveTierError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension CopyObjectOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum CopyObjectOutputError: Swift.Error, Swift.Equatable {
    case objectNotInActiveTierError(ObjectNotInActiveTierError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let copySourceVersionIdHeaderValue = httpResponse.headers.value(for: "x-amz-copy-source-version-id") {
            self.copySourceVersionId = copySourceVersionIdHeaderValue
        } else {
            self.copySourceVersionId = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSEncryptionContextHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-context") {
            self.sSEKMSEncryptionContext = sSEKMSEncryptionContextHeaderValue
        } else {
            self.sSEKMSEncryptionContext = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.CopyObjectResult = try responseDecoder.decode(responseBody: data)
                self.copyObjectResult = output
            } else {
                self.copyObjectResult = nil
            }
        } else {
            self.copyObjectResult = nil
        }
    }
}

public struct CopyObjectOutputResponse: Swift.Equatable {
    /// Indicates whether the copied object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Container for all response elements.
    public var copyObjectResult: S3ClientTypes.CopyObjectResult?
    /// Version of the copied object in the destination bucket.
    public var copySourceVersionId: Swift.String?
    /// If the object expiration is configured, the response includes this header.
    public var expiration: Swift.String?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
    public var sSECustomerAlgorithm: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
    public var sSEKMSEncryptionContext: Swift.String?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// Version ID of the newly created copy.
    public var versionId: Swift.String?

    public init (
        bucketKeyEnabled: Swift.Bool = false,
        copyObjectResult: S3ClientTypes.CopyObjectResult? = nil,
        copySourceVersionId: Swift.String? = nil,
        expiration: Swift.String? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSEncryptionContext: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.copyObjectResult = copyObjectResult
        self.copySourceVersionId = copySourceVersionId
        self.expiration = expiration
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.versionId = versionId
    }
}

struct CopyObjectOutputResponseBody: Swift.Equatable {
    let copyObjectResult: S3ClientTypes.CopyObjectResult?
}

extension CopyObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyObjectResult = "CopyObjectResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyObjectResultDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CopyObjectResult.self, forKey: .copyObjectResult)
        copyObjectResult = copyObjectResultDecoded
    }
}

extension S3ClientTypes.CopyObjectResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: ClientRuntime.Key("ETag"))
        }
        if let lastModified = lastModified {
            try container.encode(ClientRuntime.TimestampWrapper(lastModified, format: .dateTime), forKey: ClientRuntime.Key("LastModified"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        var lastModifiedBuffer:ClientRuntime.Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
    }
}

extension S3ClientTypes.CopyObjectResult: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for all response elements.
    public struct CopyObjectResult: Swift.Equatable {
        /// Returns the ETag of the new object. The ETag reflects only changes to the contents of an object, not its metadata.
        public var eTag: Swift.String?
        /// Creation date of the object.
        public var lastModified: ClientRuntime.Date?

        public init (
            eTag: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.eTag = eTag
            self.lastModified = lastModified
        }
    }

}

extension S3ClientTypes.CopyPartResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: ClientRuntime.Key("ETag"))
        }
        if let lastModified = lastModified {
            try container.encode(ClientRuntime.TimestampWrapper(lastModified, format: .dateTime), forKey: ClientRuntime.Key("LastModified"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        var lastModifiedBuffer:ClientRuntime.Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
    }
}

extension S3ClientTypes.CopyPartResult: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for all response elements.
    public struct CopyPartResult: Swift.Equatable {
        /// Entity tag of the object.
        public var eTag: Swift.String?
        /// Date and time at which the object was uploaded.
        public var lastModified: ClientRuntime.Date?

        public init (
            eTag: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.eTag = eTag
            self.lastModified = lastModified
        }
    }

}

extension S3ClientTypes.CreateBucketConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationConstraint = "LocationConstraint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let locationConstraint = locationConstraint {
            try container.encode(locationConstraint, forKey: ClientRuntime.Key("LocationConstraint"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationConstraintDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketLocationConstraint.self, forKey: .locationConstraint)
        locationConstraint = locationConstraintDecoded
    }
}

extension S3ClientTypes.CreateBucketConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The configuration information for the bucket.
    public struct CreateBucketConfiguration: Swift.Equatable {
        /// Specifies the Region where the bucket will be created. If you don't specify a Region, the bucket is created in the US East (N. Virginia) Region (us-east-1).
        public var locationConstraint: S3ClientTypes.BucketLocationConstraint?

        public init (
            locationConstraint: S3ClientTypes.BucketLocationConstraint? = nil
        )
        {
            self.locationConstraint = locationConstraint
        }
    }

}

public struct CreateBucketInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBucketInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBucketInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateBucketOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let createBucketConfiguration = input.operationInput.createBucketConfiguration {
                let createBucketConfigurationdata = try encoder.encode(createBucketConfiguration)
                let createBucketConfigurationbody = ClientRuntime.HttpBody.data(createBucketConfigurationdata)
                input.builder.withBody(createBucketConfigurationbody)
            } else {
                let createBucketConfigurationdata = try encoder.encode(input.operationInput)
                let createBucketConfigurationbody = ClientRuntime.HttpBody.data(createBucketConfigurationdata)
                input.builder.withBody(createBucketConfigurationbody)
            }
        } catch let err {
            throw SdkError<CreateBucketOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBucketInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateBucketInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateBucketInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createBucketConfiguration = createBucketConfiguration {
            try container.encode(createBucketConfiguration, forKey: ClientRuntime.Key("CreateBucketConfiguration"))
        }
    }
}

extension CreateBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let aCL = aCL {
            items.add(Header(name: "x-amz-acl", value: Swift.String(aCL.rawValue)))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWrite = grantWrite {
            items.add(Header(name: "x-amz-grant-write", value: Swift.String(grantWrite)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if objectLockEnabledForBucket != false {
            items.add(Header(name: "x-amz-bucket-object-lock-enabled", value: Swift.String(objectLockEnabledForBucket)))
        }
        if let objectOwnership = objectOwnership {
            items.add(Header(name: "x-amz-object-ownership", value: Swift.String(objectOwnership.rawValue)))
        }
        return items
    }
}

extension CreateBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct CreateBucketInput: Swift.Equatable {
    /// The canned ACL to apply to the bucket.
    public var aCL: S3ClientTypes.BucketCannedACL?
    /// The name of the bucket to create.
    /// This member is required.
    public var bucket: Swift.String?
    /// The configuration information for the bucket.
    public var createBucketConfiguration: S3ClientTypes.CreateBucketConfiguration?
    /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
    public var grantFullControl: Swift.String?
    /// Allows grantee to list the objects in the bucket.
    public var grantRead: Swift.String?
    /// Allows grantee to read the bucket ACL.
    public var grantReadACP: Swift.String?
    /// Allows grantee to create new objects in the bucket. For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.
    public var grantWrite: Swift.String?
    /// Allows grantee to write the ACL for the applicable bucket.
    public var grantWriteACP: Swift.String?
    /// Specifies whether you want S3 Object Lock to be enabled for the new bucket.
    public var objectLockEnabledForBucket: Swift.Bool
    /// The container element for object ownership for a bucket's ownership controls. BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the bucket-owner-full-control canned ACL. ObjectWriter - The uploading account will own the object if the object is uploaded with the bucket-owner-full-control canned ACL. BucketOwnerEnforced - Access control lists (ACLs) are disabled and no longer affect permissions. The bucket owner automatically owns and has full control over every object in the bucket. The bucket only accepts PUT requests that don't specify an ACL or bucket owner full control ACLs, such as the bucket-owner-full-control canned ACL or an equivalent form of this ACL expressed in the XML format.
    public var objectOwnership: S3ClientTypes.ObjectOwnership?

    public init (
        aCL: S3ClientTypes.BucketCannedACL? = nil,
        bucket: Swift.String? = nil,
        createBucketConfiguration: S3ClientTypes.CreateBucketConfiguration? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWrite: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        objectLockEnabledForBucket: Swift.Bool = false,
        objectOwnership: S3ClientTypes.ObjectOwnership? = nil
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.createBucketConfiguration = createBucketConfiguration
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.objectLockEnabledForBucket = objectLockEnabledForBucket
        self.objectOwnership = objectOwnership
    }
}

struct CreateBucketInputBody: Swift.Equatable {
    let createBucketConfiguration: S3ClientTypes.CreateBucketConfiguration?
}

extension CreateBucketInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createBucketConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CreateBucketConfiguration.self, forKey: .createBucketConfiguration)
        createBucketConfiguration = createBucketConfigurationDecoded
    }
}

extension CreateBucketOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = CreateBucketOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? CreateBucketOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = CreateBucketOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension CreateBucketOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "BucketAlreadyExists" : self = .bucketAlreadyExists(try BucketAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        case "BucketAlreadyOwnedByYou" : self = .bucketAlreadyOwnedByYou(try BucketAlreadyOwnedByYou(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension CreateBucketOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum CreateBucketOutputError: Swift.Error, Swift.Equatable {
    case bucketAlreadyExists(BucketAlreadyExists)
    case bucketAlreadyOwnedByYou(BucketAlreadyOwnedByYou)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBucketOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

public struct CreateBucketOutputResponse: Swift.Equatable {
    /// Specifies the Region where the bucket will be created. If you are creating a bucket on the US East (N. Virginia) Region (us-east-1), you do not need to specify the location.
    public var location: Swift.String?

    public init (
        location: Swift.String? = nil
    )
    {
        self.location = location
    }
}

extension CreateMultipartUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let aCL = aCL {
            items.add(Header(name: "x-amz-acl", value: Swift.String(aCL.rawValue)))
        }
        if bucketKeyEnabled != false {
            items.add(Header(name: "x-amz-server-side-encryption-bucket-key-enabled", value: Swift.String(bucketKeyEnabled)))
        }
        if let cacheControl = cacheControl {
            items.add(Header(name: "Cache-Control", value: Swift.String(cacheControl)))
        }
        if let contentDisposition = contentDisposition {
            items.add(Header(name: "Content-Disposition", value: Swift.String(contentDisposition)))
        }
        if let contentEncoding = contentEncoding {
            items.add(Header(name: "Content-Encoding", value: Swift.String(contentEncoding)))
        }
        if let contentLanguage = contentLanguage {
            items.add(Header(name: "Content-Language", value: Swift.String(contentLanguage)))
        }
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let expires = expires {
            items.add(Header(name: "Expires", value: Swift.String(expires.rfc5322())))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            items.add(Header(name: "x-amz-object-lock-legal-hold", value: Swift.String(objectLockLegalHoldStatus.rawValue)))
        }
        if let objectLockMode = objectLockMode {
            items.add(Header(name: "x-amz-object-lock-mode", value: Swift.String(objectLockMode.rawValue)))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            items.add(Header(name: "x-amz-object-lock-retain-until-date", value: Swift.String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds())))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        if let sSEKMSEncryptionContext = sSEKMSEncryptionContext {
            items.add(Header(name: "x-amz-server-side-encryption-context", value: Swift.String(sSEKMSEncryptionContext)))
        }
        if let sSEKMSKeyId = sSEKMSKeyId {
            items.add(Header(name: "x-amz-server-side-encryption-aws-kms-key-id", value: Swift.String(sSEKMSKeyId)))
        }
        if let serverSideEncryption = serverSideEncryption {
            items.add(Header(name: "x-amz-server-side-encryption", value: Swift.String(serverSideEncryption.rawValue)))
        }
        if let storageClass = storageClass {
            items.add(Header(name: "x-amz-storage-class", value: Swift.String(storageClass.rawValue)))
        }
        if let tagging = tagging {
            items.add(Header(name: "x-amz-tagging", value: Swift.String(tagging)))
        }
        if let websiteRedirectLocation = websiteRedirectLocation {
            items.add(Header(name: "x-amz-website-redirect-location", value: Swift.String(websiteRedirectLocation)))
        }
        if let metadata = metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                items.add(Header(name: "x-amz-meta-\(prefixHeaderMapKey)", value: Swift.String(prefixHeaderMapValue)))
            }
        }
        return items
    }
}

extension CreateMultipartUploadInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "uploads", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "CreateMultipartUpload"))
        return items
    }
}

extension CreateMultipartUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct CreateMultipartUploadInput: Swift.Equatable {
    /// The canned ACL to apply to the object. This action is not supported by Amazon S3 on Outposts.
    public var aCL: S3ClientTypes.ObjectCannedACL?
    /// The name of the bucket to which to initiate the upload When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to true causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. Specifying this header with an object action doesnt affect bucket-level settings for S3 Bucket Key.
    public var bucketKeyEnabled: Swift.Bool
    /// Specifies caching behavior along the request/reply chain.
    public var cacheControl: Swift.String?
    /// Specifies presentational information for the object.
    public var contentDisposition: Swift.String?
    /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
    public var contentEncoding: Swift.String?
    /// The language the content is in.
    public var contentLanguage: Swift.String?
    /// A standard MIME type describing the format of the object data.
    public var contentType: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The date and time at which the object is no longer cacheable.
    public var expires: ClientRuntime.Date?
    /// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object. This action is not supported by Amazon S3 on Outposts.
    public var grantFullControl: Swift.String?
    /// Allows grantee to read the object data and its metadata. This action is not supported by Amazon S3 on Outposts.
    public var grantRead: Swift.String?
    /// Allows grantee to read the object ACL. This action is not supported by Amazon S3 on Outposts.
    public var grantReadACP: Swift.String?
    /// Allows grantee to write the ACL for the applicable object. This action is not supported by Amazon S3 on Outposts.
    public var grantWriteACP: Swift.String?
    /// Object key for which the multipart upload is to be initiated.
    /// This member is required.
    public var key: Swift.String?
    /// A map of metadata to store with the object in S3.
    public var metadata: [Swift.String:Swift.String]?
    /// Specifies whether you want to apply a Legal Hold to the uploaded object.
    public var objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus?
    /// Specifies the Object Lock mode that you want to apply to the uploaded object.
    public var objectLockMode: S3ClientTypes.ObjectLockMode?
    /// Specifies the date and time when you want the Object Lock to expire.
    public var objectLockRetainUntilDate: ClientRuntime.Date?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Specifies the algorithm to use to when encrypting the object (for example, AES256).
    public var sSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
    public var sSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var sSECustomerKeyMD5: Swift.String?
    /// Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
    public var sSEKMSEncryptionContext: Swift.String?
    /// Specifies the ID of the symmetric customer managed key to use for object encryption. All GET and PUT requests for an object protected by Amazon Web Services KMS will fail if not made via SSL or using SigV4. For information about configuring using any of the officially supported Amazon Web Services SDKs and Amazon Web Services CLI, see [Specifying the Signature Version in Request Authentication](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version) in the Amazon S3 User Guide.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The STANDARD storage class provides high durability and high availability. Depending on performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses the OUTPOSTS Storage Class. For more information, see [Storage Classes](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html) in the Amazon S3 User Guide.
    public var storageClass: S3ClientTypes.StorageClass?
    /// The tag-set for the object. The tag-set must be encoded as URL Query parameters.
    public var tagging: Swift.String?
    /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
    public var websiteRedirectLocation: Swift.String?

    public init (
        aCL: S3ClientTypes.ObjectCannedACL? = nil,
        bucket: Swift.String? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        cacheControl: Swift.String? = nil,
        contentDisposition: Swift.String? = nil,
        contentEncoding: Swift.String? = nil,
        contentLanguage: Swift.String? = nil,
        contentType: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        expires: ClientRuntime.Date? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        key: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus? = nil,
        objectLockMode: S3ClientTypes.ObjectLockMode? = nil,
        objectLockRetainUntilDate: ClientRuntime.Date? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSEncryptionContext: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        storageClass: S3ClientTypes.StorageClass? = nil,
        tagging: Swift.String? = nil,
        websiteRedirectLocation: Swift.String? = nil
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentType = contentType
        self.expectedBucketOwner = expectedBucketOwner
        self.expires = expires
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.metadata = metadata
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagging = tagging
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct CreateMultipartUploadInputBody: Swift.Equatable {
}

extension CreateMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = CreateMultipartUploadOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? CreateMultipartUploadOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = CreateMultipartUploadOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension CreateMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension CreateMultipartUploadOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum CreateMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let abortDateHeaderValue = httpResponse.headers.value(for: "x-amz-abort-date") {
            self.abortDate = DateFormatter.rfc5322DateFormatter.date(from: abortDateHeaderValue)
        } else {
            self.abortDate = nil
        }
        if let abortRuleIdHeaderValue = httpResponse.headers.value(for: "x-amz-abort-rule-id") {
            self.abortRuleId = abortRuleIdHeaderValue
        } else {
            self.abortRuleId = nil
        }
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSEncryptionContextHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-context") {
            self.sSEKMSEncryptionContext = sSEKMSEncryptionContextHeaderValue
        } else {
            self.sSEKMSEncryptionContext = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMultipartUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucket = output.bucket
            self.key = output.key
            self.uploadId = output.uploadId
        } else {
            self.bucket = nil
            self.key = nil
            self.uploadId = nil
        }
    }
}

public struct CreateMultipartUploadOutputResponse: Swift.Equatable {
    /// If the bucket has a lifecycle rule configured with an action to abort incomplete multipart uploads and the prefix in the lifecycle rule matches the object name in the request, the response includes this header. The header indicates when the initiated multipart upload becomes eligible for an abort operation. For more information, see [ Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config). The response also includes the x-amz-abort-rule-id header that provides the ID of the lifecycle configuration rule that defines this action.
    public var abortDate: ClientRuntime.Date?
    /// This header is returned along with the x-amz-abort-date header. It identifies the applicable lifecycle configuration rule that defines the action to abort incomplete multipart uploads.
    public var abortRuleId: Swift.String?
    /// The name of the bucket to which the multipart upload was initiated. Does not return the access point ARN or access point alias if used. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    public var bucket: Swift.String?
    /// Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Object key for which the multipart upload was initiated.
    public var key: Swift.String?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
    public var sSECustomerAlgorithm: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
    public var sSEKMSEncryptionContext: Swift.String?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// ID for the initiated multipart upload.
    public var uploadId: Swift.String?

    public init (
        abortDate: ClientRuntime.Date? = nil,
        abortRuleId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        key: Swift.String? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSEncryptionContext: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.abortDate = abortDate
        self.abortRuleId = abortRuleId
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.key = key
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.uploadId = uploadId
    }
}

struct CreateMultipartUploadOutputResponseBody: Swift.Equatable {
    let bucket: Swift.String?
    let key: Swift.String?
    let uploadId: Swift.String?
}

extension CreateMultipartUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
        case uploadId = "UploadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension S3ClientTypes.DefaultRetention: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case days = "Days"
        case mode = "Mode"
        case years = "Years"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if days != 0 {
            try container.encode(days, forKey: ClientRuntime.Key("Days"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: ClientRuntime.Key("Mode"))
        }
        if years != 0 {
            try container.encode(years, forKey: ClientRuntime.Key("Years"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockRetentionMode.self, forKey: .mode)
        mode = modeDecoded
        let daysDecoded = try containerValues.decode(Swift.Int.self, forKey: .days)
        days = daysDecoded
        let yearsDecoded = try containerValues.decode(Swift.Int.self, forKey: .years)
        years = yearsDecoded
    }
}

extension S3ClientTypes.DefaultRetention: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container element for specifying the default Object Lock retention settings for new objects placed in the specified bucket.
    ///
    /// * The DefaultRetention settings require both a mode and a period.
    ///
    /// * The DefaultRetention period can be either Days or Years but you must select one. You cannot specify Days and Years at the same time.
    public struct DefaultRetention: Swift.Equatable {
        /// The number of days that you want to specify for the default retention period. Must be used with Mode.
        public var days: Swift.Int
        /// The default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Must be used with either Days or Years.
        public var mode: S3ClientTypes.ObjectLockRetentionMode?
        /// The number of years that you want to specify for the default retention period. Must be used with Mode.
        public var years: Swift.Int

        public init (
            days: Swift.Int = 0,
            mode: S3ClientTypes.ObjectLockRetentionMode? = nil,
            years: Swift.Int = 0
        )
        {
            self.days = days
            self.mode = mode
            self.years = years
        }
    }

}

extension S3ClientTypes.Delete: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objects = "Object"
        case quiet = "Quiet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let objects = objects {
            if objects.isEmpty {
                var objectsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Object"))
                try objectsContainer.encodeNil()
            } else {
                for objectidentifier0 in objects {
                    var objectsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Object"))
                    try objectsContainer0.encode(objectidentifier0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if quiet != false {
            try container.encode(quiet, forKey: ClientRuntime.Key("Quiet"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.objects) {
            let objectsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .objects)
            if objectsWrappedContainer != nil {
                let objectsContainer = try containerValues.decodeIfPresent([S3ClientTypes.ObjectIdentifier].self, forKey: .objects)
                var objectsBuffer:[S3ClientTypes.ObjectIdentifier]? = nil
                if let objectsContainer = objectsContainer {
                    objectsBuffer = [S3ClientTypes.ObjectIdentifier]()
                    for structureContainer0 in objectsContainer {
                        objectsBuffer?.append(structureContainer0)
                    }
                }
                objects = objectsBuffer
            } else {
                objects = []
            }
        } else {
            objects = nil
        }
        let quietDecoded = try containerValues.decode(Swift.Bool.self, forKey: .quiet)
        quiet = quietDecoded
    }
}

extension S3ClientTypes.Delete: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the objects to delete.
    public struct Delete: Swift.Equatable {
        /// The objects to delete.
        /// This member is required.
        public var objects: [S3ClientTypes.ObjectIdentifier]?
        /// Element to enable quiet mode for the request. When you add this element, you must set its value to true.
        public var quiet: Swift.Bool

        public init (
            objects: [S3ClientTypes.ObjectIdentifier]? = nil,
            quiet: Swift.Bool = false
        )
        {
            self.objects = objects
            self.quiet = quiet
        }
    }

}

extension DeleteBucketAnalyticsConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketAnalyticsConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "analytics", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension DeleteBucketAnalyticsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketAnalyticsConfigurationInput: Swift.Equatable {
    /// The name of the bucket from which an analytics configuration is deleted.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID that identifies the analytics configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct DeleteBucketAnalyticsConfigurationInputBody: Swift.Equatable {
}

extension DeleteBucketAnalyticsConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketAnalyticsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketAnalyticsConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketAnalyticsConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketAnalyticsConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketAnalyticsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketAnalyticsConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketAnalyticsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketAnalyticsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketAnalyticsConfigurationOutputResponse: Swift.Equatable {

}

extension DeleteBucketCorsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketCorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "cors", value: nil))
        return items
    }
}

extension DeleteBucketCorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketCorsInput: Swift.Equatable {
    /// Specifies the bucket whose cors configuration is being deleted.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketCorsInputBody: Swift.Equatable {
}

extension DeleteBucketCorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketCorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketCorsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketCorsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketCorsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketCorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketCorsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketCorsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketCorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketCorsOutputResponse: Swift.Equatable {

}

extension DeleteBucketEncryptionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketEncryptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "encryption", value: nil))
        return items
    }
}

extension DeleteBucketEncryptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketEncryptionInput: Swift.Equatable {
    /// The name of the bucket containing the server-side encryption configuration to delete.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketEncryptionInputBody: Swift.Equatable {
}

extension DeleteBucketEncryptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketEncryptionOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketEncryptionOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketEncryptionOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketEncryptionOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketEncryptionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketEncryptionOutputResponse: Swift.Equatable {

}

extension DeleteBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketInput: Swift.Equatable {
    /// Specifies the bucket being deleted.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketInputBody: Swift.Equatable {
}

extension DeleteBucketInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketIntelligentTieringConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "intelligent-tiering", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension DeleteBucketIntelligentTieringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketIntelligentTieringConfigurationInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The ID used to identify the S3 Intelligent-Tiering configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.id = id
    }
}

struct DeleteBucketIntelligentTieringConfigurationInputBody: Swift.Equatable {
}

extension DeleteBucketIntelligentTieringConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketIntelligentTieringConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketIntelligentTieringConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketIntelligentTieringConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketIntelligentTieringConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketIntelligentTieringConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketIntelligentTieringConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketIntelligentTieringConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketIntelligentTieringConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketIntelligentTieringConfigurationOutputResponse: Swift.Equatable {

}

extension DeleteBucketInventoryConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketInventoryConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "inventory", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension DeleteBucketInventoryConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketInventoryConfigurationInput: Swift.Equatable {
    /// The name of the bucket containing the inventory configuration to delete.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID used to identify the inventory configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct DeleteBucketInventoryConfigurationInputBody: Swift.Equatable {
}

extension DeleteBucketInventoryConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketInventoryConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketInventoryConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketInventoryConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketInventoryConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketInventoryConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketInventoryConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketInventoryConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketInventoryConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketInventoryConfigurationOutputResponse: Swift.Equatable {

}

extension DeleteBucketLifecycleInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketLifecycleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "lifecycle", value: nil))
        return items
    }
}

extension DeleteBucketLifecycleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketLifecycleInput: Swift.Equatable {
    /// The bucket name of the lifecycle to delete.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketLifecycleInputBody: Swift.Equatable {
}

extension DeleteBucketLifecycleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketLifecycleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketLifecycleOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketLifecycleOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketLifecycleOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketLifecycleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketLifecycleOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketLifecycleOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketLifecycleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketLifecycleOutputResponse: Swift.Equatable {

}

extension DeleteBucketMetricsConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketMetricsConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "metrics", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension DeleteBucketMetricsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketMetricsConfigurationInput: Swift.Equatable {
    /// The name of the bucket containing the metrics configuration to delete.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID used to identify the metrics configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct DeleteBucketMetricsConfigurationInputBody: Swift.Equatable {
}

extension DeleteBucketMetricsConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketMetricsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketMetricsConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketMetricsConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketMetricsConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketMetricsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketMetricsConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketMetricsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketMetricsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketMetricsConfigurationOutputResponse: Swift.Equatable {

}

extension DeleteBucketOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketOutputResponse: Swift.Equatable {

}

extension DeleteBucketOwnershipControlsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketOwnershipControlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "ownershipControls", value: nil))
        return items
    }
}

extension DeleteBucketOwnershipControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketOwnershipControlsInput: Swift.Equatable {
    /// The Amazon S3 bucket whose OwnershipControls you want to delete.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketOwnershipControlsInputBody: Swift.Equatable {
}

extension DeleteBucketOwnershipControlsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketOwnershipControlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketOwnershipControlsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketOwnershipControlsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketOwnershipControlsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketOwnershipControlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketOwnershipControlsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketOwnershipControlsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketOwnershipControlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketOwnershipControlsOutputResponse: Swift.Equatable {

}

extension DeleteBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "policy", value: nil))
        return items
    }
}

extension DeleteBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketPolicyInput: Swift.Equatable {
    /// The bucket name.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketPolicyInputBody: Swift.Equatable {
}

extension DeleteBucketPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketPolicyOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketPolicyOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketPolicyOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketPolicyOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketPolicyOutputResponse: Swift.Equatable {

}

extension DeleteBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketReplicationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "replication", value: nil))
        return items
    }
}

extension DeleteBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketReplicationInput: Swift.Equatable {
    /// The bucket name.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketReplicationInputBody: Swift.Equatable {
}

extension DeleteBucketReplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketReplicationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketReplicationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketReplicationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketReplicationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketReplicationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketReplicationOutputResponse: Swift.Equatable {

}

extension DeleteBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketTaggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "tagging", value: nil))
        return items
    }
}

extension DeleteBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketTaggingInput: Swift.Equatable {
    /// The bucket that has the tag set to be removed.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketTaggingInputBody: Swift.Equatable {
}

extension DeleteBucketTaggingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketTaggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketTaggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketTaggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketTaggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketTaggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketTaggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketTaggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketTaggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketTaggingOutputResponse: Swift.Equatable {

}

extension DeleteBucketWebsiteInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteBucketWebsiteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "website", value: nil))
        return items
    }
}

extension DeleteBucketWebsiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketWebsiteInput: Swift.Equatable {
    /// The bucket name for which you want to remove the website configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketWebsiteInputBody: Swift.Equatable {
}

extension DeleteBucketWebsiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketWebsiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteBucketWebsiteOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteBucketWebsiteOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteBucketWebsiteOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteBucketWebsiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteBucketWebsiteOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteBucketWebsiteOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketWebsiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketWebsiteOutputResponse: Swift.Equatable {

}

extension S3ClientTypes.DeleteMarkerEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLatest = "IsLatest"
        case key = "Key"
        case lastModified = "LastModified"
        case owner = "Owner"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isLatest != false {
            try container.encode(isLatest, forKey: ClientRuntime.Key("IsLatest"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let lastModified = lastModified {
            try container.encode(ClientRuntime.TimestampWrapper(lastModified, format: .dateTime), forKey: ClientRuntime.Key("LastModified"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isLatestDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isLatest)
        isLatest = isLatestDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        var lastModifiedBuffer:ClientRuntime.Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
    }
}

extension S3ClientTypes.DeleteMarkerEntry: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Information about the delete marker.
    public struct DeleteMarkerEntry: Swift.Equatable {
        /// Specifies whether the object is (true) or is not (false) the latest version of an object.
        public var isLatest: Swift.Bool
        /// The object key.
        public var key: Swift.String?
        /// Date and time the object was last modified.
        public var lastModified: ClientRuntime.Date?
        /// The account that created the delete marker.>
        public var owner: S3ClientTypes.Owner?
        /// Version ID of an object.
        public var versionId: Swift.String?

        public init (
            isLatest: Swift.Bool = false,
            key: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            owner: S3ClientTypes.Owner? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.isLatest = isLatest
            self.key = key
            self.lastModified = lastModified
            self.owner = owner
            self.versionId = versionId
        }
    }

}

extension S3ClientTypes.DeleteMarkerReplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.DeleteMarkerReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ClientTypes.DeleteMarkerReplication: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies whether Amazon S3 replicates delete markers. If you specify a Filter in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplicationStatus must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config). For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html). If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
    public struct DeleteMarkerReplication: Swift.Equatable {
        /// Indicates whether to replicate delete markers. Indicates whether to replicate delete markers.
        public var status: S3ClientTypes.DeleteMarkerReplicationStatus?

        public init (
            status: S3ClientTypes.DeleteMarkerReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ClientTypes {
    public enum DeleteMarkerReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteMarkerReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeleteMarkerReplicationStatus(rawValue: rawValue) ?? DeleteMarkerReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if bypassGovernanceRetention != false {
            items.add(Header(name: "x-amz-bypass-governance-retention", value: Swift.String(bypassGovernanceRetention)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let mFA = mFA {
            items.add(Header(name: "x-amz-mfa", value: Swift.String(mFA)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension DeleteObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "DeleteObject"))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension DeleteObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct DeleteObjectInput: Swift.Equatable {
    /// The bucket name of the bucket containing the object. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process this operation. To use this header, you must have the s3:PutBucketPublicAccessBlock permission.
    public var bypassGovernanceRetention: Swift.Bool
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Key name of the object to delete.
    /// This member is required.
    public var key: Swift.String?
    /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device. Required to permanently delete a versioned object if versioning is configured with MFA delete enabled.
    public var mFA: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// VersionId used to reference a specific version of the object.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        bypassGovernanceRetention: Swift.Bool = false,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        mFA: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.mFA = mFA
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct DeleteObjectInputBody: Swift.Equatable {
}

extension DeleteObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteObjectOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteObjectOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteObjectOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteObjectOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteObjectOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let deleteMarkerHeaderValue = httpResponse.headers.value(for: "x-amz-delete-marker") {
            self.deleteMarker = Swift.Bool(deleteMarkerHeaderValue) ?? false
        } else {
            self.deleteMarker = false
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct DeleteObjectOutputResponse: Swift.Equatable {
    /// Specifies whether the versioned object that was permanently deleted was (true) or was not (false) a delete marker.
    public var deleteMarker: Swift.Bool
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// Returns the version ID of the delete marker created as a result of the DELETE operation.
    public var versionId: Swift.String?

    public init (
        deleteMarker: Swift.Bool = false,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.deleteMarker = deleteMarker
        self.requestCharged = requestCharged
        self.versionId = versionId
    }
}

extension DeleteObjectTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeleteObjectTaggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "tagging", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension DeleteObjectTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct DeleteObjectTaggingInput: Swift.Equatable {
    /// The bucket name containing the objects from which to remove the tags. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The key that identifies the object in the bucket from which to remove all tags.
    /// This member is required.
    public var key: Swift.String?
    /// The versionId of the object that the tag-set will be removed from.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.versionId = versionId
    }
}

struct DeleteObjectTaggingInputBody: Swift.Equatable {
}

extension DeleteObjectTaggingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteObjectTaggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteObjectTaggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteObjectTaggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteObjectTaggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteObjectTaggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteObjectTaggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteObjectTaggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectTaggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct DeleteObjectTaggingOutputResponse: Swift.Equatable {
    /// The versionId of the object the tag-set was removed from.
    public var versionId: Swift.String?

    public init (
        versionId: Swift.String? = nil
    )
    {
        self.versionId = versionId
    }
}

public struct DeleteObjectsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteObjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteObjectsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<DeleteObjectsOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let delete = input.operationInput.delete {
                let deletedata = try encoder.encode(delete)
                let deletebody = ClientRuntime.HttpBody.data(deletedata)
                input.builder.withBody(deletebody)
            } else {
                let deletedata = try encoder.encode(input.operationInput)
                let deletebody = ClientRuntime.HttpBody.data(deletedata)
                input.builder.withBody(deletebody)
            }
        } catch let err {
            throw SdkError<DeleteObjectsOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteObjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension DeleteObjectsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteObjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delete = "Delete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let delete = delete {
            try container.encode(delete, forKey: ClientRuntime.Key("Delete"))
        }
    }
}

extension DeleteObjectsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if bypassGovernanceRetention != false {
            items.add(Header(name: "x-amz-bypass-governance-retention", value: Swift.String(bypassGovernanceRetention)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let mFA = mFA {
            items.add(Header(name: "x-amz-mfa", value: Swift.String(mFA)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension DeleteObjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "delete", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "DeleteObjects"))
        return items
    }
}

extension DeleteObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteObjectsInput: Swift.Equatable {
    /// The bucket name containing the objects to delete. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Specifies whether you want to delete this object even if it has a Governance-type Object Lock in place. To use this header, you must have the s3:PutBucketPublicAccessBlock permission.
    public var bypassGovernanceRetention: Swift.Bool
    /// Container for the request.
    /// This member is required.
    public var delete: S3ClientTypes.Delete?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device. Required to permanently delete a versioned object if versioning is configured with MFA delete enabled.
    public var mFA: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?

    public init (
        bucket: Swift.String? = nil,
        bypassGovernanceRetention: Swift.Bool = false,
        delete: S3ClientTypes.Delete? = nil,
        expectedBucketOwner: Swift.String? = nil,
        mFA: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil
    )
    {
        self.bucket = bucket
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.delete = delete
        self.expectedBucketOwner = expectedBucketOwner
        self.mFA = mFA
        self.requestPayer = requestPayer
    }
}

struct DeleteObjectsInputBody: Swift.Equatable {
    let delete: S3ClientTypes.Delete?
}

extension DeleteObjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delete = "Delete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Delete.self, forKey: .delete)
        delete = deleteDecoded
    }
}

extension DeleteObjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeleteObjectsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeleteObjectsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeleteObjectsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeleteObjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeleteObjectsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeleteObjectsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteObjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deleted = output.deleted
            self.errors = output.errors
        } else {
            self.deleted = nil
            self.errors = nil
        }
    }
}

public struct DeleteObjectsOutputResponse: Swift.Equatable {
    /// Container element for a successful delete. It identifies the object that was successfully deleted.
    public var deleted: [S3ClientTypes.DeletedObject]?
    /// Container for a failed delete action that describes the object that Amazon S3 attempted to delete and the error it encountered.
    public var errors: [S3ClientTypes.Error]?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        deleted: [S3ClientTypes.DeletedObject]? = nil,
        errors: [S3ClientTypes.Error]? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.deleted = deleted
        self.errors = errors
        self.requestCharged = requestCharged
    }
}

struct DeleteObjectsOutputResponseBody: Swift.Equatable {
    let deleted: [S3ClientTypes.DeletedObject]?
    let errors: [S3ClientTypes.Error]?
}

extension DeleteObjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleted = "Deleted"
        case errors = "Error"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.deleted) {
            let deletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .deleted)
            if deletedWrappedContainer != nil {
                let deletedContainer = try containerValues.decodeIfPresent([S3ClientTypes.DeletedObject].self, forKey: .deleted)
                var deletedBuffer:[S3ClientTypes.DeletedObject]? = nil
                if let deletedContainer = deletedContainer {
                    deletedBuffer = [S3ClientTypes.DeletedObject]()
                    for structureContainer0 in deletedContainer {
                        deletedBuffer?.append(structureContainer0)
                    }
                }
                deleted = deletedBuffer
            } else {
                deleted = []
            }
        } else {
            deleted = nil
        }
        if containerValues.contains(.errors) {
            let errorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .errors)
            if errorsWrappedContainer != nil {
                let errorsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Error].self, forKey: .errors)
                var errorsBuffer:[S3ClientTypes.Error]? = nil
                if let errorsContainer = errorsContainer {
                    errorsBuffer = [S3ClientTypes.Error]()
                    for structureContainer0 in errorsContainer {
                        errorsBuffer?.append(structureContainer0)
                    }
                }
                errors = errorsBuffer
            } else {
                errors = []
            }
        } else {
            errors = nil
        }
    }
}

extension DeletePublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension DeletePublicAccessBlockInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "publicAccessBlock", value: nil))
        return items
    }
}

extension DeletePublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct DeletePublicAccessBlockInput: Swift.Equatable {
    /// The Amazon S3 bucket whose PublicAccessBlock configuration you want to delete.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeletePublicAccessBlockInputBody: Swift.Equatable {
}

extension DeletePublicAccessBlockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicAccessBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = DeletePublicAccessBlockOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? DeletePublicAccessBlockOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = DeletePublicAccessBlockOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension DeletePublicAccessBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension DeletePublicAccessBlockOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum DeletePublicAccessBlockOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublicAccessBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublicAccessBlockOutputResponse: Swift.Equatable {

}

extension S3ClientTypes.DeletedObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteMarker = "DeleteMarker"
        case deleteMarkerVersionId = "DeleteMarkerVersionId"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if deleteMarker != false {
            try container.encode(deleteMarker, forKey: ClientRuntime.Key("DeleteMarker"))
        }
        if let deleteMarkerVersionId = deleteMarkerVersionId {
            try container.encode(deleteMarkerVersionId, forKey: ClientRuntime.Key("DeleteMarkerVersionId"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let deleteMarkerDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteMarker)
        deleteMarker = deleteMarkerDecoded
        let deleteMarkerVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deleteMarkerVersionId)
        deleteMarkerVersionId = deleteMarkerVersionIdDecoded
    }
}

extension S3ClientTypes.DeletedObject: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Information about the deleted object.
    public struct DeletedObject: Swift.Equatable {
        /// Specifies whether the versioned object that was permanently deleted was (true) or was not (false) a delete marker. In a simple DELETE, this header indicates whether (true) or not (false) a delete marker was created.
        public var deleteMarker: Swift.Bool
        /// The version ID of the delete marker created as a result of the DELETE operation. If you delete a specific object version, the value returned by this header is the version ID of the object version deleted.
        public var deleteMarkerVersionId: Swift.String?
        /// The name of the deleted object.
        public var key: Swift.String?
        /// The version ID of the deleted object.
        public var versionId: Swift.String?

        public init (
            deleteMarker: Swift.Bool = false,
            deleteMarkerVersionId: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.deleteMarker = deleteMarker
            self.deleteMarkerVersionId = deleteMarkerVersionId
            self.key = key
            self.versionId = versionId
        }
    }

}

extension S3ClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlTranslation = "AccessControlTranslation"
        case account = "Account"
        case bucket = "Bucket"
        case encryptionConfiguration = "EncryptionConfiguration"
        case metrics = "Metrics"
        case replicationTime = "ReplicationTime"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlTranslation = accessControlTranslation {
            try container.encode(accessControlTranslation, forKey: ClientRuntime.Key("AccessControlTranslation"))
        }
        if let account = account {
            try container.encode(account, forKey: ClientRuntime.Key("Account"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try container.encode(encryptionConfiguration, forKey: ClientRuntime.Key("EncryptionConfiguration"))
        }
        if let metrics = metrics {
            try container.encode(metrics, forKey: ClientRuntime.Key("Metrics"))
        }
        if let replicationTime = replicationTime {
            try container.encode(replicationTime, forKey: ClientRuntime.Key("ReplicationTime"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let accessControlTranslationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AccessControlTranslation.self, forKey: .accessControlTranslation)
        accessControlTranslation = accessControlTranslationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let replicationTimeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationTime.self, forKey: .replicationTime)
        replicationTime = replicationTimeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension S3ClientTypes.Destination: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).
    public struct Destination: Swift.Equatable {
        /// Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the Amazon Web Services account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same Amazon Web Services account that owns the source object.
        public var accessControlTranslation: S3ClientTypes.AccessControlTranslation?
        /// Destination bucket owner account ID. In a cross-account scenario, if you direct Amazon S3 to change replica ownership to the Amazon Web Services account that owns the destination bucket by specifying the AccessControlTranslation property, this is the account ID of the destination bucket owner. For more information, see [Replication Additional Configuration: Changing the Replica Owner](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-change-owner.html) in the Amazon S3 User Guide.
        public var account: Swift.String?
        /// The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to store the results.
        /// This member is required.
        public var bucket: Swift.String?
        /// A container that provides information about encryption. If SourceSelectionCriteria is specified, you must specify this element.
        public var encryptionConfiguration: S3ClientTypes.EncryptionConfiguration?
        /// A container specifying replication metrics-related settings enabling replication metrics and events.
        public var metrics: S3ClientTypes.Metrics?
        /// A container specifying S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block.
        public var replicationTime: S3ClientTypes.ReplicationTime?
        /// The storage class to use when replicating objects, such as S3 Standard or reduced redundancy. By default, Amazon S3 uses the storage class of the source object to create the object replica. For valid values, see the StorageClass element of the [PUT Bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the Amazon S3 API Reference.
        public var storageClass: S3ClientTypes.StorageClass?

        public init (
            accessControlTranslation: S3ClientTypes.AccessControlTranslation? = nil,
            account: Swift.String? = nil,
            bucket: Swift.String? = nil,
            encryptionConfiguration: S3ClientTypes.EncryptionConfiguration? = nil,
            metrics: S3ClientTypes.Metrics? = nil,
            replicationTime: S3ClientTypes.ReplicationTime? = nil,
            storageClass: S3ClientTypes.StorageClass? = nil
        )
        {
            self.accessControlTranslation = accessControlTranslation
            self.account = account
            self.bucket = bucket
            self.encryptionConfiguration = encryptionConfiguration
            self.metrics = metrics
            self.replicationTime = replicationTime
            self.storageClass = storageClass
        }
    }

}

extension S3ClientTypes {
    /// Requests Amazon S3 to encode the object keys in the response and specifies the encoding method to use. An object key may contain any Unicode character; however, XML 1.0 parser cannot parse some characters, such as characters with an ASCII value from 0 to 10. For characters that are not supported in XML 1.0, you can add this parameter to request that Amazon S3 encode the keys in the response.
    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .url: return "url"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.Encryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case kMSContext = "KMSContext"
        case kMSKeyId = "KMSKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let encryptionType = encryptionType {
            try container.encode(encryptionType, forKey: ClientRuntime.Key("EncryptionType"))
        }
        if let kMSContext = kMSContext {
            try container.encode(kMSContext, forKey: ClientRuntime.Key("KMSContext"))
        }
        if let kMSKeyId = kMSKeyId {
            try container.encode(kMSKeyId, forKey: ClientRuntime.Key("KMSKeyId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ServerSideEncryption.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let kMSContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSContext)
        kMSContext = kMSContextDecoded
    }
}

extension S3ClientTypes.Encryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Contains the type of server-side encryption used.
    public struct Encryption: Swift.Equatable {
        /// The server-side encryption algorithm used when storing job results in Amazon S3 (for example, AES256, aws:kms).
        /// This member is required.
        public var encryptionType: S3ClientTypes.ServerSideEncryption?
        /// If the encryption type is aws:kms, this optional value can be used to specify the encryption context for the restore results.
        public var kMSContext: Swift.String?
        /// If the encryption type is aws:kms, this optional value specifies the ID of the symmetric customer managed key to use for encryption of job results. Amazon S3 only supports symmetric keys. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Amazon Web Services Key Management Service Developer Guide.
        public var kMSKeyId: Swift.String?

        public init (
            encryptionType: S3ClientTypes.ServerSideEncryption? = nil,
            kMSContext: Swift.String? = nil,
            kMSKeyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kMSContext = kMSContext
            self.kMSKeyId = kMSKeyId
        }
    }

}

extension S3ClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaKmsKeyID = "ReplicaKmsKeyID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let replicaKmsKeyID = replicaKmsKeyID {
            try container.encode(replicaKmsKeyID, forKey: ClientRuntime.Key("ReplicaKmsKeyID"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicaKmsKeyIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicaKmsKeyID)
        replicaKmsKeyID = replicaKmsKeyIDDecoded
    }
}

extension S3ClientTypes.EncryptionConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// Specifies the ID (Key ARN or Alias ARN) of the customer managed Amazon Web Services KMS key stored in Amazon Web Services Key Management Service (KMS) for the destination bucket. Amazon S3 uses this key to encrypt replica objects. Amazon S3 only supports symmetric, customer managed KMS keys. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Amazon Web Services Key Management Service Developer Guide.
        public var replicaKmsKeyID: Swift.String?

        public init (
            replicaKmsKeyID: Swift.String? = nil
        )
        {
            self.replicaKmsKeyID = replicaKmsKeyID
        }
    }

}

extension S3ClientTypes.EndEvent: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension S3ClientTypes {
    /// A message that indicates the request is complete and no more messages will be sent. You should not assume that the request is complete until the client receives an EndEvent.
    public struct EndEvent: Swift.Equatable {

    }

}

extension S3ClientTypes.Error: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case key = "Key"
        case message = "Message"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ClientTypes.Error: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for all error elements.
    public struct Error: Swift.Equatable {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type. Amazon S3 error codes
        ///
        ///
        /// * Code: AccessDenied
        ///
        /// * Description: Access Denied
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: AccountProblem
        ///
        /// * Description: There is a problem with your Amazon Web Services account that prevents the action from completing successfully. Contact Amazon Web Services Support for further assistance.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: AllAccessDisabled
        ///
        /// * Description: All access to this Amazon S3 resource has been disabled. Contact Amazon Web Services Support for further assistance.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: AmbiguousGrantByEmailAddress
        ///
        /// * Description: The email address you provided is associated with more than one account.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: AuthorizationHeaderMalformed
        ///
        /// * Description: The authorization header you provided is invalid.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * HTTP Status Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: BadDigest
        ///
        /// * Description: The Content-MD5 you specified did not match what we received.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: BucketAlreadyExists
        ///
        /// * Description: The requested bucket name is not available. The bucket namespace is shared by all users of the system. Please select a different name and try again.
        ///
        /// * HTTP Status Code: 409 Conflict
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: BucketAlreadyOwnedByYou
        ///
        /// * Description: The bucket you tried to create already exists, and you own it. Amazon S3 returns this error in all Amazon Web Services Regions except in the North Virginia Region. For legacy compatibility, if you re-create an existing bucket that you already own in the North Virginia Region, Amazon S3 returns 200 OK and resets the bucket access control lists (ACLs).
        ///
        /// * Code: 409 Conflict (in all Regions except the North Virginia Region)
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: BucketNotEmpty
        ///
        /// * Description: The bucket you tried to delete is not empty.
        ///
        /// * HTTP Status Code: 409 Conflict
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: CredentialsNotSupported
        ///
        /// * Description: This request does not support credentials.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: CrossLocationLoggingProhibited
        ///
        /// * Description: Cross-location logging not allowed. Buckets in one geographic location cannot log information to a bucket in another location.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: EntityTooSmall
        ///
        /// * Description: Your proposed upload is smaller than the minimum allowed object size.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: EntityTooLarge
        ///
        /// * Description: Your proposed upload exceeds the maximum allowed object size.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: ExpiredToken
        ///
        /// * Description: The provided token has expired.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: IllegalVersioningConfigurationException
        ///
        /// * Description: Indicates that the versioning configuration specified in the request is invalid.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: IncompleteBody
        ///
        /// * Description: You did not provide the number of bytes specified by the Content-Length HTTP header
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: IncorrectNumberOfFilesInPostRequest
        ///
        /// * Description: POST requires exactly one file upload per request.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InlineDataTooLarge
        ///
        /// * Description: Inline data exceeds the maximum allowed size.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InternalError
        ///
        /// * Description: We encountered an internal error. Please try again.
        ///
        /// * HTTP Status Code: 500 Internal Server Error
        ///
        /// * SOAP Fault Code Prefix: Server
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidAccessKeyId
        ///
        /// * Description: The Amazon Web Services access key ID you provided does not exist in our records.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidAddressingHeader
        ///
        /// * Description: You must specify the Anonymous role.
        ///
        /// * HTTP Status Code: N/A
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidArgument
        ///
        /// * Description: Invalid Argument
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidBucketName
        ///
        /// * Description: The specified bucket is not valid.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidBucketState
        ///
        /// * Description: The request is not valid with the current state of the bucket.
        ///
        /// * HTTP Status Code: 409 Conflict
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidDigest
        ///
        /// * Description: The Content-MD5 you specified is not valid.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidEncryptionAlgorithmError
        ///
        /// * Description: The encryption request you specified is not valid. The valid value is AES256.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidLocationConstraint
        ///
        /// * Description: The specified location constraint is not valid. For more information about Regions, see [How to Select a Region for Your Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro).
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidObjectState
        ///
        /// * Description: The action is not valid for the current state of the object.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidPart
        ///
        /// * Description: One or more of the specified parts could not be found. The part might not have been uploaded, or the specified entity tag might not have matched the part's entity tag.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidPartOrder
        ///
        /// * Description: The list of parts was not in ascending order. Parts list must be specified in order by part number.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidPayer
        ///
        /// * Description: All access to this object has been disabled. Please contact Amazon Web Services Support for further assistance.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidPolicyDocument
        ///
        /// * Description: The content of the form does not meet the conditions specified in the policy document.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRange
        ///
        /// * Description: The requested range cannot be satisfied.
        ///
        /// * HTTP Status Code: 416 Requested Range Not Satisfiable
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Please use AWS4-HMAC-SHA256.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: SOAP requests must be made over an HTTPS connection.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Amazon S3 Transfer Acceleration is not supported for buckets with non-DNS compliant names.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Amazon S3 Transfer Acceleration is not supported for buckets with periods (.) in their names.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Amazon S3 Transfer Accelerate endpoint only supports virtual style requests.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Amazon S3 Transfer Accelerate is not configured on this bucket.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Amazon S3 Transfer Accelerate is disabled on this bucket.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Amazon S3 Transfer Acceleration is not supported on this bucket. Contact Amazon Web Services Support for more information.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidRequest
        ///
        /// * Description: Amazon S3 Transfer Acceleration cannot be enabled on this bucket. Contact Amazon Web Services Support for more information.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * Code: N/A
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidSecurity
        ///
        /// * Description: The provided security credentials are not valid.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidSOAPRequest
        ///
        /// * Description: The SOAP request body is invalid.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidStorageClass
        ///
        /// * Description: The storage class you specified is not valid.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidTargetBucketForLogging
        ///
        /// * Description: The target bucket for logging does not exist, is not owned by you, or does not have the appropriate grants for the log-delivery group.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidToken
        ///
        /// * Description: The provided token is malformed or otherwise invalid.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: InvalidURI
        ///
        /// * Description: Couldn't parse the specified URI.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: KeyTooLongError
        ///
        /// * Description: Your key is too long.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MalformedACLError
        ///
        /// * Description: The XML you provided was not well-formed or did not validate against our published schema.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MalformedPOSTRequest
        ///
        /// * Description: The body of your POST request is not well-formed multipart/form-data.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MalformedXML
        ///
        /// * Description: This happens when the user sends malformed XML (XML that doesn't conform to the published XSD) for the configuration. The error message is, "The XML you provided was not well-formed or did not validate against our published schema."
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MaxMessageLengthExceeded
        ///
        /// * Description: Your request was too big.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MaxPostPreDataLengthExceededError
        ///
        /// * Description: Your POST request fields preceding the upload file were too large.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MetadataTooLarge
        ///
        /// * Description: Your metadata headers exceed the maximum allowed metadata size.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MethodNotAllowed
        ///
        /// * Description: The specified method is not allowed against this resource.
        ///
        /// * HTTP Status Code: 405 Method Not Allowed
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MissingAttachment
        ///
        /// * Description: A SOAP attachment was expected, but none were found.
        ///
        /// * HTTP Status Code: N/A
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MissingContentLength
        ///
        /// * Description: You must provide the Content-Length HTTP header.
        ///
        /// * HTTP Status Code: 411 Length Required
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MissingRequestBodyError
        ///
        /// * Description: This happens when the user sends an empty XML document as a request. The error message is, "Request body is empty."
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MissingSecurityElement
        ///
        /// * Description: The SOAP 1.1 request is missing a security element.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: MissingSecurityHeader
        ///
        /// * Description: Your request is missing a required header.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NoLoggingStatusForKey
        ///
        /// * Description: There is no such thing as a logging status subresource for a key.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NoSuchBucket
        ///
        /// * Description: The specified bucket does not exist.
        ///
        /// * HTTP Status Code: 404 Not Found
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NoSuchBucketPolicy
        ///
        /// * Description: The specified bucket does not have a bucket policy.
        ///
        /// * HTTP Status Code: 404 Not Found
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NoSuchKey
        ///
        /// * Description: The specified key does not exist.
        ///
        /// * HTTP Status Code: 404 Not Found
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NoSuchLifecycleConfiguration
        ///
        /// * Description: The lifecycle configuration does not exist.
        ///
        /// * HTTP Status Code: 404 Not Found
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NoSuchUpload
        ///
        /// * Description: The specified multipart upload does not exist. The upload ID might be invalid, or the multipart upload might have been aborted or completed.
        ///
        /// * HTTP Status Code: 404 Not Found
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NoSuchVersion
        ///
        /// * Description: Indicates that the version ID specified in the request does not match an existing version.
        ///
        /// * HTTP Status Code: 404 Not Found
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: NotImplemented
        ///
        /// * Description: A header you provided implies functionality that is not implemented.
        ///
        /// * HTTP Status Code: 501 Not Implemented
        ///
        /// * SOAP Fault Code Prefix: Server
        ///
        ///
        ///
        ///
        ///
        /// * Code: NotSignedUp
        ///
        /// * Description: Your account is not signed up for the Amazon S3 service. You must sign up before you can use Amazon S3. You can sign up at the following URL: [Amazon S3](http://aws.amazon.com/s3)
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: OperationAborted
        ///
        /// * Description: A conflicting conditional action is currently in progress against this resource. Try again.
        ///
        /// * HTTP Status Code: 409 Conflict
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: PermanentRedirect
        ///
        /// * Description: The bucket you are attempting to access must be addressed using the specified endpoint. Send all future requests to this endpoint.
        ///
        /// * HTTP Status Code: 301 Moved Permanently
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: PreconditionFailed
        ///
        /// * Description: At least one of the preconditions you specified did not hold.
        ///
        /// * HTTP Status Code: 412 Precondition Failed
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: Redirect
        ///
        /// * Description: Temporary redirect.
        ///
        /// * HTTP Status Code: 307 Moved Temporarily
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: RestoreAlreadyInProgress
        ///
        /// * Description: Object restore is already in progress.
        ///
        /// * HTTP Status Code: 409 Conflict
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: RequestIsNotMultiPartContent
        ///
        /// * Description: Bucket POST must be of the enclosure-type multipart/form-data.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: RequestTimeout
        ///
        /// * Description: Your socket connection to the server was not read from or written to within the timeout period.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: RequestTimeTooSkewed
        ///
        /// * Description: The difference between the request time and the server's time is too large.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: RequestTorrentOfBucketError
        ///
        /// * Description: Requesting the torrent file of a bucket is not permitted.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: SignatureDoesNotMatch
        ///
        /// * Description: The request signature we calculated does not match the signature you provided. Check your Amazon Web Services secret access key and signing method. For more information, see [REST Authentication](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html) and [SOAP Authentication](https://docs.aws.amazon.com/AmazonS3/latest/dev/SOAPAuthentication.html) for details.
        ///
        /// * HTTP Status Code: 403 Forbidden
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: ServiceUnavailable
        ///
        /// * Description: Reduce your request rate.
        ///
        /// * HTTP Status Code: 503 Service Unavailable
        ///
        /// * SOAP Fault Code Prefix: Server
        ///
        ///
        ///
        ///
        ///
        /// * Code: SlowDown
        ///
        /// * Description: Reduce your request rate.
        ///
        /// * HTTP Status Code: 503 Slow Down
        ///
        /// * SOAP Fault Code Prefix: Server
        ///
        ///
        ///
        ///
        ///
        /// * Code: TemporaryRedirect
        ///
        /// * Description: You are being redirected to the bucket while DNS updates.
        ///
        /// * HTTP Status Code: 307 Moved Temporarily
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: TokenRefreshRequired
        ///
        /// * Description: The provided token must be refreshed.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: TooManyBuckets
        ///
        /// * Description: You have attempted to create more buckets than allowed.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: UnexpectedContent
        ///
        /// * Description: This request does not support content.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: UnresolvableGrantByEmailAddress
        ///
        /// * Description: The email address you provided does not match any account on record.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        ///
        ///
        ///
        ///
        ///
        /// * Code: UserKeyMustBeSpecified
        ///
        /// * Description: The bucket POST must contain the specified field name. If it is specified, check the order of the fields.
        ///
        /// * HTTP Status Code: 400 Bad Request
        ///
        /// * SOAP Fault Code Prefix: Client
        public var code: Swift.String?
        /// The error key.
        public var key: Swift.String?
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public var message: Swift.String?
        /// The version ID of the error.
        public var versionId: Swift.String?

        public init (
            code: Swift.String? = nil,
            key: Swift.String? = nil,
            message: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.code = code
            self.key = key
            self.message = message
            self.versionId = versionId
        }
    }

}

extension S3ClientTypes.ErrorDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3ClientTypes.ErrorDocument: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The error information.
    public struct ErrorDocument: Swift.Equatable {
        /// The object key name to use when a 4XX class error occurs. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        /// This member is required.
        public var key: Swift.String?

        public init (
            key: Swift.String? = nil
        )
        {
            self.key = key
        }
    }

}

extension S3ClientTypes {
    /// The bucket event for which to send notifications.
    public enum Event: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3intelligenttiering
        case s3lifecycleexpiration
        case s3lifecycleexpirationdelete
        case s3lifecycleexpirationdeletemarkercreated
        case s3lifecycletransition
        case s3objectaclput
        case s3objectcreated
        case s3objectcreatedcompletemultipartupload
        case s3objectcreatedcopy
        case s3objectcreatedpost
        case s3objectcreatedput
        case s3objectremoved
        case s3objectremoveddelete
        case s3objectremoveddeletemarkercreated
        case s3objectrestore
        case s3objectrestorecompleted
        case s3objectrestoredelete
        case s3objectrestorepost
        case s3objecttagging
        case s3objecttaggingdelete
        case s3objecttaggingput
        case s3reducedredundancylostobject
        case s3replication
        case s3replicationoperationfailedreplication
        case s3replicationoperationmissedthreshold
        case s3replicationoperationnottracked
        case s3replicationoperationreplicatedafterthreshold
        case sdkUnknown(Swift.String)

        public static var allCases: [Event] {
            return [
                .s3intelligenttiering,
                .s3lifecycleexpiration,
                .s3lifecycleexpirationdelete,
                .s3lifecycleexpirationdeletemarkercreated,
                .s3lifecycletransition,
                .s3objectaclput,
                .s3objectcreated,
                .s3objectcreatedcompletemultipartupload,
                .s3objectcreatedcopy,
                .s3objectcreatedpost,
                .s3objectcreatedput,
                .s3objectremoved,
                .s3objectremoveddelete,
                .s3objectremoveddeletemarkercreated,
                .s3objectrestore,
                .s3objectrestorecompleted,
                .s3objectrestoredelete,
                .s3objectrestorepost,
                .s3objecttagging,
                .s3objecttaggingdelete,
                .s3objecttaggingput,
                .s3reducedredundancylostobject,
                .s3replication,
                .s3replicationoperationfailedreplication,
                .s3replicationoperationmissedthreshold,
                .s3replicationoperationnottracked,
                .s3replicationoperationreplicatedafterthreshold,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3intelligenttiering: return "s3:IntelligentTiering"
            case .s3lifecycleexpiration: return "s3:LifecycleExpiration:*"
            case .s3lifecycleexpirationdelete: return "s3:LifecycleExpiration:Delete"
            case .s3lifecycleexpirationdeletemarkercreated: return "s3:LifecycleExpiration:DeleteMarkerCreated"
            case .s3lifecycletransition: return "s3:LifecycleTransition"
            case .s3objectaclput: return "s3:ObjectAcl:Put"
            case .s3objectcreated: return "s3:ObjectCreated:*"
            case .s3objectcreatedcompletemultipartupload: return "s3:ObjectCreated:CompleteMultipartUpload"
            case .s3objectcreatedcopy: return "s3:ObjectCreated:Copy"
            case .s3objectcreatedpost: return "s3:ObjectCreated:Post"
            case .s3objectcreatedput: return "s3:ObjectCreated:Put"
            case .s3objectremoved: return "s3:ObjectRemoved:*"
            case .s3objectremoveddelete: return "s3:ObjectRemoved:Delete"
            case .s3objectremoveddeletemarkercreated: return "s3:ObjectRemoved:DeleteMarkerCreated"
            case .s3objectrestore: return "s3:ObjectRestore:*"
            case .s3objectrestorecompleted: return "s3:ObjectRestore:Completed"
            case .s3objectrestoredelete: return "s3:ObjectRestore:Delete"
            case .s3objectrestorepost: return "s3:ObjectRestore:Post"
            case .s3objecttagging: return "s3:ObjectTagging:*"
            case .s3objecttaggingdelete: return "s3:ObjectTagging:Delete"
            case .s3objecttaggingput: return "s3:ObjectTagging:Put"
            case .s3reducedredundancylostobject: return "s3:ReducedRedundancyLostObject"
            case .s3replication: return "s3:Replication:*"
            case .s3replicationoperationfailedreplication: return "s3:Replication:OperationFailedReplication"
            case .s3replicationoperationmissedthreshold: return "s3:Replication:OperationMissedThreshold"
            case .s3replicationoperationnottracked: return "s3:Replication:OperationNotTracked"
            case .s3replicationoperationreplicatedafterthreshold: return "s3:Replication:OperationReplicatedAfterThreshold"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Event(rawValue: rawValue) ?? Event.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.EventBridgeConfiguration: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension S3ClientTypes {
    /// A container for specifying the configuration for Amazon EventBridge.
    public struct EventBridgeConfiguration: Swift.Equatable {

    }

}

extension S3ClientTypes.ExistingObjectReplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ExistingObjectReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ClientTypes.ExistingObjectReplication: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Optional configuration to replicate existing source bucket objects. For more information, see [Replicating Existing Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-what-is-isnot-replicated.html#existing-object-replication) in the Amazon S3 User Guide.
    public struct ExistingObjectReplication: Swift.Equatable {
        ///
        /// This member is required.
        public var status: S3ClientTypes.ExistingObjectReplicationStatus?

        public init (
            status: S3ClientTypes.ExistingObjectReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ClientTypes {
    public enum ExistingObjectReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingObjectReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingObjectReplicationStatus(rawValue: rawValue) ?? ExistingObjectReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum ExpirationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpirationStatus(rawValue: rawValue) ?? ExpirationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum ExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .sql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum FileHeaderInfo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ignore
        case `none`
        case use
        case sdkUnknown(Swift.String)

        public static var allCases: [FileHeaderInfo] {
            return [
                .ignore,
                .none,
                .use,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ignore: return "IGNORE"
            case .none: return "NONE"
            case .use: return "USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileHeaderInfo(rawValue: rawValue) ?? FileHeaderInfo.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.FilterRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(S3ClientTypes.FilterRuleName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ClientTypes.FilterRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
    public struct FilterRule: Swift.Equatable {
        /// The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
        public var name: S3ClientTypes.FilterRuleName?
        /// The value that the filter searches for in object key names.
        public var value: Swift.String?

        public init (
            name: S3ClientTypes.FilterRuleName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension S3ClientTypes {
    public enum FilterRuleName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `prefix`
        case suffix
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterRuleName] {
            return [
                .prefix,
                .suffix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .prefix: return "prefix"
            case .suffix: return "suffix"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterRuleName(rawValue: rawValue) ?? FilterRuleName.sdkUnknown(rawValue)
        }
    }
}

extension GetBucketAccelerateConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketAccelerateConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "accelerate", value: nil))
        return items
    }
}

extension GetBucketAccelerateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketAccelerateConfigurationInput: Swift.Equatable {
    /// The name of the bucket for which the accelerate configuration is retrieved.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketAccelerateConfigurationInputBody: Swift.Equatable {
}

extension GetBucketAccelerateConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketAccelerateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketAccelerateConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketAccelerateConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketAccelerateConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketAccelerateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketAccelerateConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketAccelerateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketAccelerateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketAccelerateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct GetBucketAccelerateConfigurationOutputResponse: Swift.Equatable {
    /// The accelerate configuration of the bucket.
    public var status: S3ClientTypes.BucketAccelerateStatus?

    public init (
        status: S3ClientTypes.BucketAccelerateStatus? = nil
    )
    {
        self.status = status
    }
}

struct GetBucketAccelerateConfigurationOutputResponseBody: Swift.Equatable {
    let status: S3ClientTypes.BucketAccelerateStatus?
}

extension GetBucketAccelerateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketAccelerateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetBucketAclInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketAclInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "acl", value: nil))
        return items
    }
}

extension GetBucketAclInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketAclInput: Swift.Equatable {
    /// Specifies the S3 bucket whose ACL is being requested.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketAclInputBody: Swift.Equatable {
}

extension GetBucketAclInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketAclOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketAclOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketAclOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketAclOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketAclOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketAclOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketAclOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketAclOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketAclOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.owner = output.owner
        } else {
            self.grants = nil
            self.owner = nil
        }
    }
}

public struct GetBucketAclOutputResponse: Swift.Equatable {
    /// A list of grants.
    public var grants: [S3ClientTypes.Grant]?
    /// Container for the bucket owner's display name and ID.
    public var owner: S3ClientTypes.Owner?

    public init (
        grants: [S3ClientTypes.Grant]? = nil,
        owner: S3ClientTypes.Owner? = nil
    )
    {
        self.grants = grants
        self.owner = owner
    }
}

struct GetBucketAclOutputResponseBody: Swift.Equatable {
    let owner: S3ClientTypes.Owner?
    let grants: [S3ClientTypes.Grant]?
}

extension GetBucketAclOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "AccessControlList"
        case owner = "Owner"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.grants) {
            struct KeyVal0{struct Grant{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([S3ClientTypes.Grant].self, forKey: .member)
                var grantsBuffer:[S3ClientTypes.Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [S3ClientTypes.Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
    }
}

extension GetBucketAnalyticsConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketAnalyticsConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "analytics", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "GetBucketAnalyticsConfiguration"))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension GetBucketAnalyticsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketAnalyticsConfigurationInput: Swift.Equatable {
    /// The name of the bucket from which an analytics configuration is retrieved.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID that identifies the analytics configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct GetBucketAnalyticsConfigurationInputBody: Swift.Equatable {
}

extension GetBucketAnalyticsConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketAnalyticsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketAnalyticsConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketAnalyticsConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketAnalyticsConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketAnalyticsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketAnalyticsConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketAnalyticsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketAnalyticsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.AnalyticsConfiguration = try responseDecoder.decode(responseBody: data)
                self.analyticsConfiguration = output
            } else {
                self.analyticsConfiguration = nil
            }
        } else {
            self.analyticsConfiguration = nil
        }
    }
}

public struct GetBucketAnalyticsConfigurationOutputResponse: Swift.Equatable {
    /// The configuration and any analyses for the analytics filter.
    public var analyticsConfiguration: S3ClientTypes.AnalyticsConfiguration?

    public init (
        analyticsConfiguration: S3ClientTypes.AnalyticsConfiguration? = nil
    )
    {
        self.analyticsConfiguration = analyticsConfiguration
    }
}

struct GetBucketAnalyticsConfigurationOutputResponseBody: Swift.Equatable {
    let analyticsConfiguration: S3ClientTypes.AnalyticsConfiguration?
}

extension GetBucketAnalyticsConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyticsConfiguration = "AnalyticsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyticsConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AnalyticsConfiguration.self, forKey: .analyticsConfiguration)
        analyticsConfiguration = analyticsConfigurationDecoded
    }
}

extension GetBucketCorsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketCorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "cors", value: nil))
        return items
    }
}

extension GetBucketCorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketCorsInput: Swift.Equatable {
    /// The bucket name for which to get the cors configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketCorsInputBody: Swift.Equatable {
}

extension GetBucketCorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketCorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketCorsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketCorsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketCorsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketCorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketCorsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketCorsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketCorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketCorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cORSRules = output.cORSRules
        } else {
            self.cORSRules = nil
        }
    }
}

public struct GetBucketCorsOutputResponse: Swift.Equatable {
    /// A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
    public var cORSRules: [S3ClientTypes.CORSRule]?

    public init (
        cORSRules: [S3ClientTypes.CORSRule]? = nil
    )
    {
        self.cORSRules = cORSRules
    }
}

struct GetBucketCorsOutputResponseBody: Swift.Equatable {
    let cORSRules: [S3ClientTypes.CORSRule]?
}

extension GetBucketCorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cORSRules = "CORSRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.cORSRules) {
            let cORSRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .cORSRules)
            if cORSRulesWrappedContainer != nil {
                let cORSRulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.CORSRule].self, forKey: .cORSRules)
                var cORSRulesBuffer:[S3ClientTypes.CORSRule]? = nil
                if let cORSRulesContainer = cORSRulesContainer {
                    cORSRulesBuffer = [S3ClientTypes.CORSRule]()
                    for structureContainer0 in cORSRulesContainer {
                        cORSRulesBuffer?.append(structureContainer0)
                    }
                }
                cORSRules = cORSRulesBuffer
            } else {
                cORSRules = []
            }
        } else {
            cORSRules = nil
        }
    }
}

extension GetBucketEncryptionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketEncryptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "encryption", value: nil))
        return items
    }
}

extension GetBucketEncryptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketEncryptionInput: Swift.Equatable {
    /// The name of the bucket from which the server-side encryption configuration is retrieved.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketEncryptionInputBody: Swift.Equatable {
}

extension GetBucketEncryptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketEncryptionOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketEncryptionOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketEncryptionOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketEncryptionOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketEncryptionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.ServerSideEncryptionConfiguration = try responseDecoder.decode(responseBody: data)
                self.serverSideEncryptionConfiguration = output
            } else {
                self.serverSideEncryptionConfiguration = nil
            }
        } else {
            self.serverSideEncryptionConfiguration = nil
        }
    }
}

public struct GetBucketEncryptionOutputResponse: Swift.Equatable {
    /// Specifies the default server-side-encryption configuration.
    public var serverSideEncryptionConfiguration: S3ClientTypes.ServerSideEncryptionConfiguration?

    public init (
        serverSideEncryptionConfiguration: S3ClientTypes.ServerSideEncryptionConfiguration? = nil
    )
    {
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct GetBucketEncryptionOutputResponseBody: Swift.Equatable {
    let serverSideEncryptionConfiguration: S3ClientTypes.ServerSideEncryptionConfiguration?
}

extension GetBucketEncryptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension GetBucketIntelligentTieringConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "intelligent-tiering", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "GetBucketIntelligentTieringConfiguration"))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension GetBucketIntelligentTieringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketIntelligentTieringConfigurationInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The ID used to identify the S3 Intelligent-Tiering configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.id = id
    }
}

struct GetBucketIntelligentTieringConfigurationInputBody: Swift.Equatable {
}

extension GetBucketIntelligentTieringConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketIntelligentTieringConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketIntelligentTieringConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketIntelligentTieringConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketIntelligentTieringConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketIntelligentTieringConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketIntelligentTieringConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketIntelligentTieringConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketIntelligentTieringConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.IntelligentTieringConfiguration = try responseDecoder.decode(responseBody: data)
                self.intelligentTieringConfiguration = output
            } else {
                self.intelligentTieringConfiguration = nil
            }
        } else {
            self.intelligentTieringConfiguration = nil
        }
    }
}

public struct GetBucketIntelligentTieringConfigurationOutputResponse: Swift.Equatable {
    /// Container for S3 Intelligent-Tiering configuration.
    public var intelligentTieringConfiguration: S3ClientTypes.IntelligentTieringConfiguration?

    public init (
        intelligentTieringConfiguration: S3ClientTypes.IntelligentTieringConfiguration? = nil
    )
    {
        self.intelligentTieringConfiguration = intelligentTieringConfiguration
    }
}

struct GetBucketIntelligentTieringConfigurationOutputResponseBody: Swift.Equatable {
    let intelligentTieringConfiguration: S3ClientTypes.IntelligentTieringConfiguration?
}

extension GetBucketIntelligentTieringConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intelligentTieringConfiguration = "IntelligentTieringConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intelligentTieringConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IntelligentTieringConfiguration.self, forKey: .intelligentTieringConfiguration)
        intelligentTieringConfiguration = intelligentTieringConfigurationDecoded
    }
}

extension GetBucketInventoryConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketInventoryConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "inventory", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "GetBucketInventoryConfiguration"))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension GetBucketInventoryConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketInventoryConfigurationInput: Swift.Equatable {
    /// The name of the bucket containing the inventory configuration to retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID used to identify the inventory configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct GetBucketInventoryConfigurationInputBody: Swift.Equatable {
}

extension GetBucketInventoryConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketInventoryConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketInventoryConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketInventoryConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketInventoryConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketInventoryConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketInventoryConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketInventoryConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketInventoryConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.InventoryConfiguration = try responseDecoder.decode(responseBody: data)
                self.inventoryConfiguration = output
            } else {
                self.inventoryConfiguration = nil
            }
        } else {
            self.inventoryConfiguration = nil
        }
    }
}

public struct GetBucketInventoryConfigurationOutputResponse: Swift.Equatable {
    /// Specifies the inventory configuration.
    public var inventoryConfiguration: S3ClientTypes.InventoryConfiguration?

    public init (
        inventoryConfiguration: S3ClientTypes.InventoryConfiguration? = nil
    )
    {
        self.inventoryConfiguration = inventoryConfiguration
    }
}

struct GetBucketInventoryConfigurationOutputResponseBody: Swift.Equatable {
    let inventoryConfiguration: S3ClientTypes.InventoryConfiguration?
}

extension GetBucketInventoryConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inventoryConfiguration = "InventoryConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inventoryConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryConfiguration.self, forKey: .inventoryConfiguration)
        inventoryConfiguration = inventoryConfigurationDecoded
    }
}

extension GetBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketLifecycleConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "lifecycle", value: nil))
        return items
    }
}

extension GetBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The name of the bucket for which to get the lifecycle information.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketLifecycleConfigurationInputBody: Swift.Equatable {
}

extension GetBucketLifecycleConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketLifecycleConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketLifecycleConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketLifecycleConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketLifecycleConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketLifecycleConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketLifecycleConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketLifecycleConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketLifecycleConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct GetBucketLifecycleConfigurationOutputResponse: Swift.Equatable {
    /// Container for a lifecycle rule.
    public var rules: [S3ClientTypes.LifecycleRule]?

    public init (
        rules: [S3ClientTypes.LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct GetBucketLifecycleConfigurationOutputResponseBody: Swift.Equatable {
    let rules: [S3ClientTypes.LifecycleRule]?
}

extension GetBucketLifecycleConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.LifecycleRule].self, forKey: .rules)
                var rulesBuffer:[S3ClientTypes.LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ClientTypes.LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension GetBucketLocationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketLocationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "location", value: nil))
        return items
    }
}

extension GetBucketLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketLocationInput: Swift.Equatable {
    /// The name of the bucket for which to get the location.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketLocationInputBody: Swift.Equatable {
}

extension GetBucketLocationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketLocationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketLocationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketLocationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketLocationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locationConstraint = output.locationConstraint
        } else {
            self.locationConstraint = nil
        }
    }
}

public struct GetBucketLocationOutputResponse: Swift.Equatable {
    /// Specifies the Region where the bucket resides. For a list of all the Amazon S3 supported location constraints by Region, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region). Buckets in Region us-east-1 have a LocationConstraint of null.
    public var locationConstraint: S3ClientTypes.BucketLocationConstraint?

    public init (
        locationConstraint: S3ClientTypes.BucketLocationConstraint? = nil
    )
    {
        self.locationConstraint = locationConstraint
    }
}

struct GetBucketLocationOutputResponseBody: Swift.Equatable {
    let locationConstraint: S3ClientTypes.BucketLocationConstraint?
}

extension GetBucketLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationConstraint = "LocationConstraint"
    }

    public init (from decoder: Swift.Decoder) throws {
        var containerValues = try decoder.unkeyedContainer()
        let locationConstraintDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketLocationConstraint.self)
        locationConstraint = locationConstraintDecoded
    }
}

extension GetBucketLoggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketLoggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "logging", value: nil))
        return items
    }
}

extension GetBucketLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketLoggingInput: Swift.Equatable {
    /// The bucket name for which to get the logging information.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketLoggingInputBody: Swift.Equatable {
}

extension GetBucketLoggingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketLoggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketLoggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketLoggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketLoggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketLoggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketLoggingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingEnabled = output.loggingEnabled
        } else {
            self.loggingEnabled = nil
        }
    }
}

public struct GetBucketLoggingOutputResponse: Swift.Equatable {
    /// Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For more information, see [PUT Bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the Amazon S3 API Reference.
    public var loggingEnabled: S3ClientTypes.LoggingEnabled?

    public init (
        loggingEnabled: S3ClientTypes.LoggingEnabled? = nil
    )
    {
        self.loggingEnabled = loggingEnabled
    }
}

struct GetBucketLoggingOutputResponseBody: Swift.Equatable {
    let loggingEnabled: S3ClientTypes.LoggingEnabled?
}

extension GetBucketLoggingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingEnabled = "LoggingEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingEnabledDecoded = try containerValues.decodeIfPresent(S3ClientTypes.LoggingEnabled.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
    }
}

extension GetBucketMetricsConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketMetricsConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "metrics", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "GetBucketMetricsConfiguration"))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension GetBucketMetricsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketMetricsConfigurationInput: Swift.Equatable {
    /// The name of the bucket containing the metrics configuration to retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID used to identify the metrics configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct GetBucketMetricsConfigurationInputBody: Swift.Equatable {
}

extension GetBucketMetricsConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketMetricsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketMetricsConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketMetricsConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketMetricsConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketMetricsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketMetricsConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketMetricsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketMetricsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.MetricsConfiguration = try responseDecoder.decode(responseBody: data)
                self.metricsConfiguration = output
            } else {
                self.metricsConfiguration = nil
            }
        } else {
            self.metricsConfiguration = nil
        }
    }
}

public struct GetBucketMetricsConfigurationOutputResponse: Swift.Equatable {
    /// Specifies the metrics configuration.
    public var metricsConfiguration: S3ClientTypes.MetricsConfiguration?

    public init (
        metricsConfiguration: S3ClientTypes.MetricsConfiguration? = nil
    )
    {
        self.metricsConfiguration = metricsConfiguration
    }
}

struct GetBucketMetricsConfigurationOutputResponseBody: Swift.Equatable {
    let metricsConfiguration: S3ClientTypes.MetricsConfiguration?
}

extension GetBucketMetricsConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricsConfiguration = "MetricsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
    }
}

extension GetBucketNotificationConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketNotificationConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "notification", value: nil))
        return items
    }
}

extension GetBucketNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketNotificationConfigurationInput: Swift.Equatable {
    /// The name of the bucket for which to get the notification configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketNotificationConfigurationInputBody: Swift.Equatable {
}

extension GetBucketNotificationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketNotificationConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketNotificationConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketNotificationConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketNotificationConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketNotificationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventBridgeConfiguration = output.eventBridgeConfiguration
            self.lambdaFunctionConfigurations = output.lambdaFunctionConfigurations
            self.queueConfigurations = output.queueConfigurations
            self.topicConfigurations = output.topicConfigurations
        } else {
            self.eventBridgeConfiguration = nil
            self.lambdaFunctionConfigurations = nil
            self.queueConfigurations = nil
            self.topicConfigurations = nil
        }
    }
}

/// A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket.
public struct GetBucketNotificationConfigurationOutputResponse: Swift.Equatable {
    /// Enables delivery of events to Amazon EventBridge.
    public var eventBridgeConfiguration: S3ClientTypes.EventBridgeConfiguration?
    /// Describes the Lambda functions to invoke and the events for which to invoke them.
    public var lambdaFunctionConfigurations: [S3ClientTypes.LambdaFunctionConfiguration]?
    /// The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
    public var queueConfigurations: [S3ClientTypes.QueueConfiguration]?
    /// The topic to which notifications are sent and the events for which notifications are generated.
    public var topicConfigurations: [S3ClientTypes.TopicConfiguration]?

    public init (
        eventBridgeConfiguration: S3ClientTypes.EventBridgeConfiguration? = nil,
        lambdaFunctionConfigurations: [S3ClientTypes.LambdaFunctionConfiguration]? = nil,
        queueConfigurations: [S3ClientTypes.QueueConfiguration]? = nil,
        topicConfigurations: [S3ClientTypes.TopicConfiguration]? = nil
    )
    {
        self.eventBridgeConfiguration = eventBridgeConfiguration
        self.lambdaFunctionConfigurations = lambdaFunctionConfigurations
        self.queueConfigurations = queueConfigurations
        self.topicConfigurations = topicConfigurations
    }
}

struct GetBucketNotificationConfigurationOutputResponseBody: Swift.Equatable {
    let topicConfigurations: [S3ClientTypes.TopicConfiguration]?
    let queueConfigurations: [S3ClientTypes.QueueConfiguration]?
    let lambdaFunctionConfigurations: [S3ClientTypes.LambdaFunctionConfiguration]?
    let eventBridgeConfiguration: S3ClientTypes.EventBridgeConfiguration?
}

extension GetBucketNotificationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridgeConfiguration = "EventBridgeConfiguration"
        case lambdaFunctionConfigurations = "CloudFunctionConfiguration"
        case queueConfigurations = "QueueConfiguration"
        case topicConfigurations = "TopicConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.topicConfigurations) {
            let topicConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .topicConfigurations)
            if topicConfigurationsWrappedContainer != nil {
                let topicConfigurationsContainer = try containerValues.decodeIfPresent([S3ClientTypes.TopicConfiguration].self, forKey: .topicConfigurations)
                var topicConfigurationsBuffer:[S3ClientTypes.TopicConfiguration]? = nil
                if let topicConfigurationsContainer = topicConfigurationsContainer {
                    topicConfigurationsBuffer = [S3ClientTypes.TopicConfiguration]()
                    for structureContainer0 in topicConfigurationsContainer {
                        topicConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                topicConfigurations = topicConfigurationsBuffer
            } else {
                topicConfigurations = []
            }
        } else {
            topicConfigurations = nil
        }
        if containerValues.contains(.queueConfigurations) {
            let queueConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .queueConfigurations)
            if queueConfigurationsWrappedContainer != nil {
                let queueConfigurationsContainer = try containerValues.decodeIfPresent([S3ClientTypes.QueueConfiguration].self, forKey: .queueConfigurations)
                var queueConfigurationsBuffer:[S3ClientTypes.QueueConfiguration]? = nil
                if let queueConfigurationsContainer = queueConfigurationsContainer {
                    queueConfigurationsBuffer = [S3ClientTypes.QueueConfiguration]()
                    for structureContainer0 in queueConfigurationsContainer {
                        queueConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                queueConfigurations = queueConfigurationsBuffer
            } else {
                queueConfigurations = []
            }
        } else {
            queueConfigurations = nil
        }
        if containerValues.contains(.lambdaFunctionConfigurations) {
            let lambdaFunctionConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .lambdaFunctionConfigurations)
            if lambdaFunctionConfigurationsWrappedContainer != nil {
                let lambdaFunctionConfigurationsContainer = try containerValues.decodeIfPresent([S3ClientTypes.LambdaFunctionConfiguration].self, forKey: .lambdaFunctionConfigurations)
                var lambdaFunctionConfigurationsBuffer:[S3ClientTypes.LambdaFunctionConfiguration]? = nil
                if let lambdaFunctionConfigurationsContainer = lambdaFunctionConfigurationsContainer {
                    lambdaFunctionConfigurationsBuffer = [S3ClientTypes.LambdaFunctionConfiguration]()
                    for structureContainer0 in lambdaFunctionConfigurationsContainer {
                        lambdaFunctionConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                lambdaFunctionConfigurations = lambdaFunctionConfigurationsBuffer
            } else {
                lambdaFunctionConfigurations = []
            }
        } else {
            lambdaFunctionConfigurations = nil
        }
        let eventBridgeConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EventBridgeConfiguration.self, forKey: .eventBridgeConfiguration)
        eventBridgeConfiguration = eventBridgeConfigurationDecoded
    }
}

extension GetBucketOwnershipControlsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketOwnershipControlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "ownershipControls", value: nil))
        return items
    }
}

extension GetBucketOwnershipControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketOwnershipControlsInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose OwnershipControls you want to retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketOwnershipControlsInputBody: Swift.Equatable {
}

extension GetBucketOwnershipControlsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketOwnershipControlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketOwnershipControlsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketOwnershipControlsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketOwnershipControlsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketOwnershipControlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketOwnershipControlsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketOwnershipControlsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketOwnershipControlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.OwnershipControls = try responseDecoder.decode(responseBody: data)
                self.ownershipControls = output
            } else {
                self.ownershipControls = nil
            }
        } else {
            self.ownershipControls = nil
        }
    }
}

public struct GetBucketOwnershipControlsOutputResponse: Swift.Equatable {
    /// The OwnershipControls (BucketOwnerEnforced, BucketOwnerPreferred, or ObjectWriter) currently in effect for this Amazon S3 bucket.
    public var ownershipControls: S3ClientTypes.OwnershipControls?

    public init (
        ownershipControls: S3ClientTypes.OwnershipControls? = nil
    )
    {
        self.ownershipControls = ownershipControls
    }
}

struct GetBucketOwnershipControlsOutputResponseBody: Swift.Equatable {
    let ownershipControls: S3ClientTypes.OwnershipControls?
}

extension GetBucketOwnershipControlsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownershipControls = "OwnershipControls"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownershipControlsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.OwnershipControls.self, forKey: .ownershipControls)
        ownershipControls = ownershipControlsDecoded
    }
}

extension GetBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "policy", value: nil))
        return items
    }
}

extension GetBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketPolicyInput: Swift.Equatable {
    /// The bucket name for which to get the bucket policy.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketPolicyInputBody: Swift.Equatable {
}

extension GetBucketPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketPolicyOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketPolicyOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketPolicyOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketPolicyOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let output = Swift.String(data: data, encoding: .utf8) {
                self.policy = output
            } else {
                self.policy = nil
            }
        } else {
            self.policy = nil
        }
    }
}

public struct GetBucketPolicyOutputResponse: Swift.Equatable {
    /// The bucket policy as a JSON document.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetBucketPolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetBucketPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetBucketPolicyStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketPolicyStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "policyStatus", value: nil))
        return items
    }
}

extension GetBucketPolicyStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketPolicyStatusInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose policy status you want to retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketPolicyStatusInputBody: Swift.Equatable {
}

extension GetBucketPolicyStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketPolicyStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketPolicyStatusOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketPolicyStatusOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketPolicyStatusOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketPolicyStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketPolicyStatusOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketPolicyStatusOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketPolicyStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.PolicyStatus = try responseDecoder.decode(responseBody: data)
                self.policyStatus = output
            } else {
                self.policyStatus = nil
            }
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetBucketPolicyStatusOutputResponse: Swift.Equatable {
    /// The policy status for the specified bucket.
    public var policyStatus: S3ClientTypes.PolicyStatus?

    public init (
        policyStatus: S3ClientTypes.PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetBucketPolicyStatusOutputResponseBody: Swift.Equatable {
    let policyStatus: S3ClientTypes.PolicyStatus?
}

extension GetBucketPolicyStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

extension GetBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketReplicationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "replication", value: nil))
        return items
    }
}

extension GetBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketReplicationInput: Swift.Equatable {
    /// The bucket name for which to get the replication information.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketReplicationInputBody: Swift.Equatable {
}

extension GetBucketReplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketReplicationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketReplicationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketReplicationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketReplicationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketReplicationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.ReplicationConfiguration = try responseDecoder.decode(responseBody: data)
                self.replicationConfiguration = output
            } else {
                self.replicationConfiguration = nil
            }
        } else {
            self.replicationConfiguration = nil
        }
    }
}

public struct GetBucketReplicationOutputResponse: Swift.Equatable {
    /// A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
    public var replicationConfiguration: S3ClientTypes.ReplicationConfiguration?

    public init (
        replicationConfiguration: S3ClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct GetBucketReplicationOutputResponseBody: Swift.Equatable {
    let replicationConfiguration: S3ClientTypes.ReplicationConfiguration?
}

extension GetBucketReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension GetBucketRequestPaymentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketRequestPaymentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "requestPayment", value: nil))
        return items
    }
}

extension GetBucketRequestPaymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketRequestPaymentInput: Swift.Equatable {
    /// The name of the bucket for which to get the payment request configuration
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketRequestPaymentInputBody: Swift.Equatable {
}

extension GetBucketRequestPaymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketRequestPaymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketRequestPaymentOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketRequestPaymentOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketRequestPaymentOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketRequestPaymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketRequestPaymentOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketRequestPaymentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketRequestPaymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketRequestPaymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.payer = output.payer
        } else {
            self.payer = nil
        }
    }
}

public struct GetBucketRequestPaymentOutputResponse: Swift.Equatable {
    /// Specifies who pays for the download and request fees.
    public var payer: S3ClientTypes.Payer?

    public init (
        payer: S3ClientTypes.Payer? = nil
    )
    {
        self.payer = payer
    }
}

struct GetBucketRequestPaymentOutputResponseBody: Swift.Equatable {
    let payer: S3ClientTypes.Payer?
}

extension GetBucketRequestPaymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payer = "Payer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Payer.self, forKey: .payer)
        payer = payerDecoded
    }
}

extension GetBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketTaggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "tagging", value: nil))
        return items
    }
}

extension GetBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketTaggingInput: Swift.Equatable {
    /// The name of the bucket for which to get the tagging information.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketTaggingInputBody: Swift.Equatable {
}

extension GetBucketTaggingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketTaggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketTaggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketTaggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketTaggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketTaggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketTaggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketTaggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketTaggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketTaggingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagSet = output.tagSet
        } else {
            self.tagSet = nil
        }
    }
}

public struct GetBucketTaggingOutputResponse: Swift.Equatable {
    /// Contains the tag set.
    /// This member is required.
    public var tagSet: [S3ClientTypes.Tag]?

    public init (
        tagSet: [S3ClientTypes.Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

struct GetBucketTaggingOutputResponseBody: Swift.Equatable {
    let tagSet: [S3ClientTypes.Tag]?
}

extension GetBucketTaggingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct Tag{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .member)
                var tagSetBuffer:[S3ClientTypes.Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension GetBucketVersioningInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketVersioningInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "versioning", value: nil))
        return items
    }
}

extension GetBucketVersioningInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketVersioningInput: Swift.Equatable {
    /// The name of the bucket for which to get the versioning information.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketVersioningInputBody: Swift.Equatable {
}

extension GetBucketVersioningInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketVersioningOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketVersioningOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketVersioningOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketVersioningOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketVersioningOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketVersioningOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketVersioningOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketVersioningOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketVersioningOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mFADelete = output.mFADelete
            self.status = output.status
        } else {
            self.mFADelete = nil
            self.status = nil
        }
    }
}

public struct GetBucketVersioningOutputResponse: Swift.Equatable {
    /// Specifies whether MFA delete is enabled in the bucket versioning configuration. This element is only returned if the bucket has been configured with MFA delete. If the bucket has never been so configured, this element is not returned.
    public var mFADelete: S3ClientTypes.MFADeleteStatus?
    /// The versioning state of the bucket.
    public var status: S3ClientTypes.BucketVersioningStatus?

    public init (
        mFADelete: S3ClientTypes.MFADeleteStatus? = nil,
        status: S3ClientTypes.BucketVersioningStatus? = nil
    )
    {
        self.mFADelete = mFADelete
        self.status = status
    }
}

struct GetBucketVersioningOutputResponseBody: Swift.Equatable {
    let status: S3ClientTypes.BucketVersioningStatus?
    let mFADelete: S3ClientTypes.MFADeleteStatus?
}

extension GetBucketVersioningOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mFADelete = "MfaDelete"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
        let mFADeleteDecoded = try containerValues.decodeIfPresent(S3ClientTypes.MFADeleteStatus.self, forKey: .mFADelete)
        mFADelete = mFADeleteDecoded
    }
}

extension GetBucketWebsiteInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetBucketWebsiteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "website", value: nil))
        return items
    }
}

extension GetBucketWebsiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketWebsiteInput: Swift.Equatable {
    /// The bucket name for which to get the website configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketWebsiteInputBody: Swift.Equatable {
}

extension GetBucketWebsiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketWebsiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetBucketWebsiteOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetBucketWebsiteOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetBucketWebsiteOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetBucketWebsiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetBucketWebsiteOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetBucketWebsiteOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketWebsiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBucketWebsiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorDocument = output.errorDocument
            self.indexDocument = output.indexDocument
            self.redirectAllRequestsTo = output.redirectAllRequestsTo
            self.routingRules = output.routingRules
        } else {
            self.errorDocument = nil
            self.indexDocument = nil
            self.redirectAllRequestsTo = nil
            self.routingRules = nil
        }
    }
}

public struct GetBucketWebsiteOutputResponse: Swift.Equatable {
    /// The object key name of the website error document to use for 4XX class errors.
    public var errorDocument: S3ClientTypes.ErrorDocument?
    /// The name of the index document for the website (for example index.html).
    public var indexDocument: S3ClientTypes.IndexDocument?
    /// Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
    public var redirectAllRequestsTo: S3ClientTypes.RedirectAllRequestsTo?
    /// Rules that define when a redirect is applied and the redirect behavior.
    public var routingRules: [S3ClientTypes.RoutingRule]?

    public init (
        errorDocument: S3ClientTypes.ErrorDocument? = nil,
        indexDocument: S3ClientTypes.IndexDocument? = nil,
        redirectAllRequestsTo: S3ClientTypes.RedirectAllRequestsTo? = nil,
        routingRules: [S3ClientTypes.RoutingRule]? = nil
    )
    {
        self.errorDocument = errorDocument
        self.indexDocument = indexDocument
        self.redirectAllRequestsTo = redirectAllRequestsTo
        self.routingRules = routingRules
    }
}

struct GetBucketWebsiteOutputResponseBody: Swift.Equatable {
    let redirectAllRequestsTo: S3ClientTypes.RedirectAllRequestsTo?
    let indexDocument: S3ClientTypes.IndexDocument?
    let errorDocument: S3ClientTypes.ErrorDocument?
    let routingRules: [S3ClientTypes.RoutingRule]?
}

extension GetBucketWebsiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDocument = "ErrorDocument"
        case indexDocument = "IndexDocument"
        case redirectAllRequestsTo = "RedirectAllRequestsTo"
        case routingRules = "RoutingRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redirectAllRequestsToDecoded = try containerValues.decodeIfPresent(S3ClientTypes.RedirectAllRequestsTo.self, forKey: .redirectAllRequestsTo)
        redirectAllRequestsTo = redirectAllRequestsToDecoded
        let indexDocumentDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IndexDocument.self, forKey: .indexDocument)
        indexDocument = indexDocumentDecoded
        let errorDocumentDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ErrorDocument.self, forKey: .errorDocument)
        errorDocument = errorDocumentDecoded
        if containerValues.contains(.routingRules) {
            struct KeyVal0{struct RoutingRule{}}
            let routingRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RoutingRule>.CodingKeys.self, forKey: .routingRules)
            if let routingRulesWrappedContainer = routingRulesWrappedContainer {
                let routingRulesContainer = try routingRulesWrappedContainer.decodeIfPresent([S3ClientTypes.RoutingRule].self, forKey: .member)
                var routingRulesBuffer:[S3ClientTypes.RoutingRule]? = nil
                if let routingRulesContainer = routingRulesContainer {
                    routingRulesBuffer = [S3ClientTypes.RoutingRule]()
                    for structureContainer0 in routingRulesContainer {
                        routingRulesBuffer?.append(structureContainer0)
                    }
                }
                routingRules = routingRulesBuffer
            } else {
                routingRules = []
            }
        } else {
            routingRules = nil
        }
    }
}

extension GetObjectAclInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension GetObjectAclInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "acl", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension GetObjectAclInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct GetObjectAclInput: Swift.Equatable {
    /// The bucket name that contains the object for which to get the ACL information. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The key of the object for which to get the ACL information.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// VersionId used to reference a specific version of the object.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectAclInputBody: Swift.Equatable {
}

extension GetObjectAclInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectAclOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetObjectAclOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetObjectAclOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetObjectAclOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetObjectAclOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchKey" : self = .noSuchKey(try NoSuchKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetObjectAclOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetObjectAclOutputError: Swift.Error, Swift.Equatable {
    case noSuchKey(NoSuchKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectAclOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetObjectAclOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.owner = output.owner
        } else {
            self.grants = nil
            self.owner = nil
        }
    }
}

public struct GetObjectAclOutputResponse: Swift.Equatable {
    /// A list of grants.
    public var grants: [S3ClientTypes.Grant]?
    /// Container for the bucket owner's display name and ID.
    public var owner: S3ClientTypes.Owner?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        grants: [S3ClientTypes.Grant]? = nil,
        owner: S3ClientTypes.Owner? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.grants = grants
        self.owner = owner
        self.requestCharged = requestCharged
    }
}

struct GetObjectAclOutputResponseBody: Swift.Equatable {
    let owner: S3ClientTypes.Owner?
    let grants: [S3ClientTypes.Grant]?
}

extension GetObjectAclOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "AccessControlList"
        case owner = "Owner"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.grants) {
            struct KeyVal0{struct Grant{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([S3ClientTypes.Grant].self, forKey: .member)
                var grantsBuffer:[S3ClientTypes.Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [S3ClientTypes.Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
    }
}

extension GetObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let ifModifiedSince = ifModifiedSince {
            items.add(Header(name: "If-Modified-Since", value: Swift.String(ifModifiedSince.rfc5322())))
        }
        if let ifNoneMatch = ifNoneMatch {
            items.add(Header(name: "If-None-Match", value: Swift.String(ifNoneMatch)))
        }
        if let ifUnmodifiedSince = ifUnmodifiedSince {
            items.add(Header(name: "If-Unmodified-Since", value: Swift.String(ifUnmodifiedSince.rfc5322())))
        }
        if let range = range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        return items
    }
}

extension GetObjectInput {
    public func presignURL(config: AWSClientRuntime.AWSClientConfiguration, expiration: Swift.Int64) async throws -> ClientRuntime.URL? {
        let serviceName = "S3"
        let input = self
        let encoder = ClientRuntime.XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        let decoder = ClientRuntime.XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.trimValueWhitespaces = false
        decoder.removeWhitespaceElements = true
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getObject")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "s3")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetObjectInput, GetObjectOutputResponse, GetObjectOutputError>(id: "getObject")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<GetObjectInput, GetObjectOutputResponse, GetObjectOutputError>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<GetObjectInput, GetObjectOutputResponse>())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware<GetObjectOutputResponse, GetObjectOutputError>(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.serializeStep.intercept(position: .after, middleware: GetObjectInputGETQueryItemMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware<GetObjectOutputResponse, GetObjectOutputError>(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(signatureType: .requestQueryParams, expiration: expiration, unsignedBody: true)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<GetObjectOutputResponse, GetObjectOutputError>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware<GetObjectOutputResponse, GetObjectOutputError>(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<GetObjectOutputResponse, GetObjectOutputError>())
        let presignedRequestBuilder = try await operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build(), let presignedURL = builtRequest.endpoint.url else {
            return nil
        }
        return presignedURL
    }
}

extension GetObjectInput {
    public func presign(config: AWSClientRuntime.AWSClientConfiguration, expiration: Swift.Int64) async throws -> ClientRuntime.SdkHttpRequest? {
        let serviceName = "S3"
        let input = self
        let encoder = ClientRuntime.XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        let decoder = ClientRuntime.XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.trimValueWhitespaces = false
        decoder.removeWhitespaceElements = true
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getObject")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "s3")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetObjectInput, GetObjectOutputResponse, GetObjectOutputError>(id: "getObject")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<GetObjectInput, GetObjectOutputResponse, GetObjectOutputError>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<GetObjectInput, GetObjectOutputResponse>())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware<GetObjectOutputResponse, GetObjectOutputError>(endpointResolver: config.endpointResolver, serviceId: serviceName))
        let apiMetadata = AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0")
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: apiMetadata, frameworkMetadata: config.frameworkMetadata)))
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.HeaderMiddleware<GetObjectInput, GetObjectOutputResponse>())
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<GetObjectInput, GetObjectOutputResponse>())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware<GetObjectOutputResponse, GetObjectOutputError>(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(expiration: expiration, unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<GetObjectOutputResponse, GetObjectOutputError>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware<GetObjectOutputResponse, GetObjectOutputError>(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<GetObjectOutputResponse, GetObjectOutputError>())
        let presignedRequestBuilder = try await operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build() else {
            return nil
        }
        return builtRequest
    }
}

public struct GetObjectInputGETQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectInputGETQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetObjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<GetObjectOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let bucket = input.operationInput.bucket {
            let queryItem = ClientRuntime.URLQueryItem(name: "Bucket".urlPercentEncoding(), value: Swift.String(bucket).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let ifMatch = input.operationInput.ifMatch {
            let queryItem = ClientRuntime.URLQueryItem(name: "IfMatch".urlPercentEncoding(), value: Swift.String(ifMatch).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let ifNoneMatch = input.operationInput.ifNoneMatch {
            let queryItem = ClientRuntime.URLQueryItem(name: "IfNoneMatch".urlPercentEncoding(), value: Swift.String(ifNoneMatch).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let key = input.operationInput.key {
            let queryItem = ClientRuntime.URLQueryItem(name: "Key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let range = input.operationInput.range {
            let queryItem = ClientRuntime.URLQueryItem(name: "Range".urlPercentEncoding(), value: Swift.String(range).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let responseCacheControl = input.operationInput.responseCacheControl {
            let queryItem = ClientRuntime.URLQueryItem(name: "ResponseCacheControl".urlPercentEncoding(), value: Swift.String(responseCacheControl).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let responseContentDisposition = input.operationInput.responseContentDisposition {
            let queryItem = ClientRuntime.URLQueryItem(name: "ResponseContentDisposition".urlPercentEncoding(), value: Swift.String(responseContentDisposition).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let responseContentEncoding = input.operationInput.responseContentEncoding {
            let queryItem = ClientRuntime.URLQueryItem(name: "ResponseContentEncoding".urlPercentEncoding(), value: Swift.String(responseContentEncoding).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let responseContentLanguage = input.operationInput.responseContentLanguage {
            let queryItem = ClientRuntime.URLQueryItem(name: "ResponseContentLanguage".urlPercentEncoding(), value: Swift.String(responseContentLanguage).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let responseContentType = input.operationInput.responseContentType {
            let queryItem = ClientRuntime.URLQueryItem(name: "ResponseContentType".urlPercentEncoding(), value: Swift.String(responseContentType).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let versionId = input.operationInput.versionId {
            let queryItem = ClientRuntime.URLQueryItem(name: "VersionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            let queryItem = ClientRuntime.URLQueryItem(name: "SSECustomerAlgorithm".urlPercentEncoding(), value: Swift.String(sSECustomerAlgorithm).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            let queryItem = ClientRuntime.URLQueryItem(name: "SSECustomerKey".urlPercentEncoding(), value: Swift.String(sSECustomerKey).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            let queryItem = ClientRuntime.URLQueryItem(name: "SSECustomerKeyMD5".urlPercentEncoding(), value: Swift.String(sSECustomerKeyMD5).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let requestPayer = input.operationInput.requestPayer {
            let queryItem = ClientRuntime.URLQueryItem(name: "RequestPayer".urlPercentEncoding(), value: Swift.String(requestPayer.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            let queryItem = ClientRuntime.URLQueryItem(name: "ExpectedBucketOwner".urlPercentEncoding(), value: Swift.String(expectedBucketOwner).urlPercentEncoding())
            input.builder.withQueryItem(queryItem)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension GetObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "GetObject"))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        if let responseContentDisposition = responseContentDisposition {
            let responseContentDispositionQueryItem = ClientRuntime.URLQueryItem(name: "response-content-disposition".urlPercentEncoding(), value: Swift.String(responseContentDisposition).urlPercentEncoding())
            items.append(responseContentDispositionQueryItem)
        }
        if partNumber != 0 {
            let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
            items.append(partNumberQueryItem)
        }
        if let responseContentType = responseContentType {
            let responseContentTypeQueryItem = ClientRuntime.URLQueryItem(name: "response-content-type".urlPercentEncoding(), value: Swift.String(responseContentType).urlPercentEncoding())
            items.append(responseContentTypeQueryItem)
        }
        if let responseExpires = responseExpires {
            let responseExpiresQueryItem = ClientRuntime.URLQueryItem(name: "response-expires".urlPercentEncoding(), value: Swift.String(responseExpires.rfc5322()).urlPercentEncoding())
            items.append(responseExpiresQueryItem)
        }
        if let responseContentEncoding = responseContentEncoding {
            let responseContentEncodingQueryItem = ClientRuntime.URLQueryItem(name: "response-content-encoding".urlPercentEncoding(), value: Swift.String(responseContentEncoding).urlPercentEncoding())
            items.append(responseContentEncodingQueryItem)
        }
        if let responseCacheControl = responseCacheControl {
            let responseCacheControlQueryItem = ClientRuntime.URLQueryItem(name: "response-cache-control".urlPercentEncoding(), value: Swift.String(responseCacheControl).urlPercentEncoding())
            items.append(responseCacheControlQueryItem)
        }
        if let responseContentLanguage = responseContentLanguage {
            let responseContentLanguageQueryItem = ClientRuntime.URLQueryItem(name: "response-content-language".urlPercentEncoding(), value: Swift.String(responseContentLanguage).urlPercentEncoding())
            items.append(responseContentLanguageQueryItem)
        }
        return items
    }
}

extension GetObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct GetObjectInput: Swift.Equatable {
    /// The bucket name containing the object. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using an Object Lambda access point the hostname takes the form AccessPointName-AccountId.s3-object-lambda.Region.amazonaws.com. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Return the object only if its entity tag (ETag) is the same as the one specified, otherwise return a 412 (precondition failed).
    public var ifMatch: Swift.String?
    /// Return the object only if it has been modified since the specified time, otherwise return a 304 (not modified).
    public var ifModifiedSince: ClientRuntime.Date?
    /// Return the object only if its entity tag (ETag) is different from the one specified, otherwise return a 304 (not modified).
    public var ifNoneMatch: Swift.String?
    /// Return the object only if it has not been modified since the specified time, otherwise return a 412 (precondition failed).
    public var ifUnmodifiedSince: ClientRuntime.Date?
    /// Key of the object to get.
    /// This member is required.
    public var key: Swift.String?
    /// Part number of the object being read. This is a positive integer between 1 and 10,000. Effectively performs a 'ranged' GET request for the part specified. Useful for downloading just a part of an object.
    public var partNumber: Swift.Int
    /// Downloads the specified range bytes of an object. For more information about the HTTP Range header, see [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35). Amazon S3 doesn't support retrieving multiple ranges of data per GET request.
    public var range: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Sets the Cache-Control header of the response.
    public var responseCacheControl: Swift.String?
    /// Sets the Content-Disposition header of the response
    public var responseContentDisposition: Swift.String?
    /// Sets the Content-Encoding header of the response.
    public var responseContentEncoding: Swift.String?
    /// Sets the Content-Language header of the response.
    public var responseContentLanguage: Swift.String?
    /// Sets the Content-Type header of the response.
    public var responseContentType: Swift.String?
    /// Sets the Expires header of the response.
    public var responseExpires: ClientRuntime.Date?
    /// Specifies the algorithm to use to when decrypting the object (for example, AES256).
    public var sSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 used to encrypt the data. This value is used to decrypt the object when recovering it and must match the one used when storing the data. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
    public var sSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var sSECustomerKeyMD5: Swift.String?
    /// VersionId used to reference a specific version of the object.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        ifModifiedSince: ClientRuntime.Date? = nil,
        ifNoneMatch: Swift.String? = nil,
        ifUnmodifiedSince: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        partNumber: Swift.Int = 0,
        range: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        responseCacheControl: Swift.String? = nil,
        responseContentDisposition: Swift.String? = nil,
        responseContentEncoding: Swift.String? = nil,
        responseContentLanguage: Swift.String? = nil,
        responseContentType: Swift.String? = nil,
        responseExpires: ClientRuntime.Date? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.ifMatch = ifMatch
        self.ifModifiedSince = ifModifiedSince
        self.ifNoneMatch = ifNoneMatch
        self.ifUnmodifiedSince = ifUnmodifiedSince
        self.key = key
        self.partNumber = partNumber
        self.range = range
        self.requestPayer = requestPayer
        self.responseCacheControl = responseCacheControl
        self.responseContentDisposition = responseContentDisposition
        self.responseContentEncoding = responseContentEncoding
        self.responseContentLanguage = responseContentLanguage
        self.responseContentType = responseContentType
        self.responseExpires = responseExpires
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.versionId = versionId
    }
}

struct GetObjectInputBody: Swift.Equatable {
}

extension GetObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectLegalHoldInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension GetObjectLegalHoldInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "legal-hold", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension GetObjectLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct GetObjectLegalHoldInput: Swift.Equatable {
    /// The bucket name containing the object whose Legal Hold status you want to retrieve. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The key name for the object whose Legal Hold status you want to retrieve.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// The version ID of the object whose Legal Hold status you want to retrieve.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectLegalHoldInputBody: Swift.Equatable {
}

extension GetObjectLegalHoldInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectLegalHoldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetObjectLegalHoldOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetObjectLegalHoldOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetObjectLegalHoldOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetObjectLegalHoldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetObjectLegalHoldOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetObjectLegalHoldOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectLegalHoldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.ObjectLockLegalHold = try responseDecoder.decode(responseBody: data)
                self.legalHold = output
            } else {
                self.legalHold = nil
            }
        } else {
            self.legalHold = nil
        }
    }
}

public struct GetObjectLegalHoldOutputResponse: Swift.Equatable {
    /// The current Legal Hold status for the specified object.
    public var legalHold: S3ClientTypes.ObjectLockLegalHold?

    public init (
        legalHold: S3ClientTypes.ObjectLockLegalHold? = nil
    )
    {
        self.legalHold = legalHold
    }
}

struct GetObjectLegalHoldOutputResponseBody: Swift.Equatable {
    let legalHold: S3ClientTypes.ObjectLockLegalHold?
}

extension GetObjectLegalHoldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legalHold = "LegalHold"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legalHoldDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockLegalHold.self, forKey: .legalHold)
        legalHold = legalHoldDecoded
    }
}

extension GetObjectLockConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetObjectLockConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "object-lock", value: nil))
        return items
    }
}

extension GetObjectLockConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetObjectLockConfigurationInput: Swift.Equatable {
    /// The bucket whose Object Lock configuration you want to retrieve. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetObjectLockConfigurationInputBody: Swift.Equatable {
}

extension GetObjectLockConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectLockConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetObjectLockConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetObjectLockConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetObjectLockConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetObjectLockConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetObjectLockConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetObjectLockConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectLockConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.ObjectLockConfiguration = try responseDecoder.decode(responseBody: data)
                self.objectLockConfiguration = output
            } else {
                self.objectLockConfiguration = nil
            }
        } else {
            self.objectLockConfiguration = nil
        }
    }
}

public struct GetObjectLockConfigurationOutputResponse: Swift.Equatable {
    /// The specified bucket's Object Lock configuration.
    public var objectLockConfiguration: S3ClientTypes.ObjectLockConfiguration?

    public init (
        objectLockConfiguration: S3ClientTypes.ObjectLockConfiguration? = nil
    )
    {
        self.objectLockConfiguration = objectLockConfiguration
    }
}

struct GetObjectLockConfigurationOutputResponseBody: Swift.Equatable {
    let objectLockConfiguration: S3ClientTypes.ObjectLockConfiguration?
}

extension GetObjectLockConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectLockConfiguration = "ObjectLockConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLockConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockConfiguration.self, forKey: .objectLockConfiguration)
        objectLockConfiguration = objectLockConfigurationDecoded
    }
}

extension GetObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetObjectOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetObjectOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetObjectOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidObjectState" : self = .invalidObjectState(try InvalidObjectState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        case "NoSuchKey" : self = .noSuchKey(try NoSuchKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetObjectOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetObjectOutputError: Swift.Error, Swift.Equatable {
    case invalidObjectState(InvalidObjectState)
    case noSuchKey(NoSuchKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "accept-ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentLanguageHeaderValue = httpResponse.headers.value(for: "Content-Language") {
            self.contentLanguage = contentLanguageHeaderValue
        } else {
            self.contentLanguage = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Swift.Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = 0
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let deleteMarkerHeaderValue = httpResponse.headers.value(for: "x-amz-delete-marker") {
            self.deleteMarker = Swift.Bool(deleteMarkerHeaderValue) ?? false
        } else {
            self.deleteMarker = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let expiresHeaderValue = httpResponse.headers.value(for: "Expires") {
            self.expires = DateFormatter.rfc5322DateFormatter.date(from: expiresHeaderValue)
        } else {
            self.expires = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = DateFormatter.rfc5322DateFormatter.date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        if let missingMetaHeaderValue = httpResponse.headers.value(for: "x-amz-missing-meta") {
            self.missingMeta = Swift.Int(missingMetaHeaderValue) ?? 0
        } else {
            self.missingMeta = 0
        }
        if let objectLockLegalHoldStatusHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-legal-hold") {
            self.objectLockLegalHoldStatus = S3ClientTypes.ObjectLockLegalHoldStatus(rawValue: objectLockLegalHoldStatusHeaderValue)
        } else {
            self.objectLockLegalHoldStatus = nil
        }
        if let objectLockModeHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-mode") {
            self.objectLockMode = S3ClientTypes.ObjectLockMode(rawValue: objectLockModeHeaderValue)
        } else {
            self.objectLockMode = nil
        }
        if let objectLockRetainUntilDateHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-retain-until-date") {
            self.objectLockRetainUntilDate = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds.date(from: objectLockRetainUntilDateHeaderValue)
        } else {
            self.objectLockRetainUntilDate = nil
        }
        if let partsCountHeaderValue = httpResponse.headers.value(for: "x-amz-mp-parts-count") {
            self.partsCount = Swift.Int(partsCountHeaderValue) ?? 0
        } else {
            self.partsCount = 0
        }
        if let replicationStatusHeaderValue = httpResponse.headers.value(for: "x-amz-replication-status") {
            self.replicationStatus = S3ClientTypes.ReplicationStatus(rawValue: replicationStatusHeaderValue)
        } else {
            self.replicationStatus = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let restoreHeaderValue = httpResponse.headers.value(for: "x-amz-restore") {
            self.restore = restoreHeaderValue
        } else {
            self.restore = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let storageClassHeaderValue = httpResponse.headers.value(for: "x-amz-storage-class") {
            self.storageClass = S3ClientTypes.StorageClass(rawValue: storageClassHeaderValue)
        } else {
            self.storageClass = nil
        }
        if let tagCountHeaderValue = httpResponse.headers.value(for: "x-amz-tagging-count") {
            self.tagCount = Swift.Int(tagCountHeaderValue) ?? 0
        } else {
            self.tagCount = 0
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if let websiteRedirectLocationHeaderValue = httpResponse.headers.value(for: "x-amz-website-redirect-location") {
            self.websiteRedirectLocation = websiteRedirectLocationHeaderValue
        } else {
            self.websiteRedirectLocation = nil
        }
        let keysForMetadata = httpResponse.headers.dictionary.keys.filter({ $0.starts(with: "x-amz-meta-") })
        if (!keysForMetadata.isEmpty) {
            var mapMember = [Swift.String: String]()
            for headerKey in keysForMetadata {
                let mapMemberValue = httpResponse.headers.dictionary[headerKey]?[0]
                let mapMemberKey = headerKey.removePrefix("x-amz-meta-")
                mapMember[mapMemberKey] = mapMemberValue
            }
            self.metadata = mapMember
        } else {
            self.metadata = [:]
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.body = data
        } else {
            self.body = nil
        }
    }
}

public struct GetObjectOutputResponse: Swift.Equatable {
    /// Indicates that a range of bytes was specified.
    public var acceptRanges: Swift.String?
    /// Object data.
    public var body: ClientRuntime.ByteStream?
    /// Indicates whether the object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Specifies caching behavior along the request/reply chain.
    public var cacheControl: Swift.String?
    /// Specifies presentational information for the object.
    public var contentDisposition: Swift.String?
    /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
    public var contentEncoding: Swift.String?
    /// The language the content is in.
    public var contentLanguage: Swift.String?
    /// Size of the body in bytes.
    public var contentLength: Swift.Int
    /// The portion of the object returned in the response.
    public var contentRange: Swift.String?
    /// A standard MIME type describing the format of the object data.
    public var contentType: Swift.String?
    /// Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.
    public var deleteMarker: Swift.Bool
    /// An ETag is an opaque identifier assigned by a web server to a specific version of a resource found at a URL.
    public var eTag: Swift.String?
    /// If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded.
    public var expiration: Swift.String?
    /// The date and time at which the object is no longer cacheable.
    public var expires: ClientRuntime.Date?
    /// Creation date of the object.
    public var lastModified: ClientRuntime.Date?
    /// A map of metadata to store with the object in S3.
    public var metadata: [Swift.String:Swift.String]?
    /// This is set to the number of metadata entries not returned in x-amz-meta headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.
    public var missingMeta: Swift.Int
    /// Indicates whether this object has an active legal hold. This field is only returned if you have permission to view an object's legal hold status.
    public var objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus?
    /// The Object Lock mode currently in place for this object.
    public var objectLockMode: S3ClientTypes.ObjectLockMode?
    /// The date and time when this object's Object Lock will expire.
    public var objectLockRetainUntilDate: ClientRuntime.Date?
    /// The count of parts this object has.
    public var partsCount: Swift.Int
    /// Amazon S3 can return this if your request involves a bucket that is either a source or destination in a replication rule.
    public var replicationStatus: S3ClientTypes.ReplicationStatus?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// Provides information about object restoration action and expiration time of the restored object copy.
    public var restore: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
    public var sSECustomerAlgorithm: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// Provides storage class information of the object. Amazon S3 returns this header for all objects except for S3 Standard storage class objects.
    public var storageClass: S3ClientTypes.StorageClass?
    /// The number of tags, if any, on the object.
    public var tagCount: Swift.Int
    /// Version of the object.
    public var versionId: Swift.String?
    /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
    public var websiteRedirectLocation: Swift.String?

    public init (
        acceptRanges: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        cacheControl: Swift.String? = nil,
        contentDisposition: Swift.String? = nil,
        contentEncoding: Swift.String? = nil,
        contentLanguage: Swift.String? = nil,
        contentLength: Swift.Int = 0,
        contentRange: Swift.String? = nil,
        contentType: Swift.String? = nil,
        deleteMarker: Swift.Bool = false,
        eTag: Swift.String? = nil,
        expiration: Swift.String? = nil,
        expires: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        missingMeta: Swift.Int = 0,
        objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus? = nil,
        objectLockMode: S3ClientTypes.ObjectLockMode? = nil,
        objectLockRetainUntilDate: ClientRuntime.Date? = nil,
        partsCount: Swift.Int = 0,
        replicationStatus: S3ClientTypes.ReplicationStatus? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        restore: Swift.String? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        storageClass: S3ClientTypes.StorageClass? = nil,
        tagCount: Swift.Int = 0,
        versionId: Swift.String? = nil,
        websiteRedirectLocation: Swift.String? = nil
    )
    {
        self.acceptRanges = acceptRanges
        self.body = body
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentRange = contentRange
        self.contentType = contentType
        self.deleteMarker = deleteMarker
        self.eTag = eTag
        self.expiration = expiration
        self.expires = expires
        self.lastModified = lastModified
        self.metadata = metadata
        self.missingMeta = missingMeta
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.partsCount = partsCount
        self.replicationStatus = replicationStatus
        self.requestCharged = requestCharged
        self.restore = restore
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagCount = tagCount
        self.versionId = versionId
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct GetObjectOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension GetObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = ClientRuntime.ByteStream.from(data: "".data(using: .utf8)!)
            }
        } else {
            body = nil
        }
    }
}

extension GetObjectRetentionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension GetObjectRetentionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "retention", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension GetObjectRetentionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct GetObjectRetentionInput: Swift.Equatable {
    /// The bucket name containing the object whose retention settings you want to retrieve. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The key name for the object whose retention settings you want to retrieve.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// The version ID for the object whose retention settings you want to retrieve.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectRetentionInputBody: Swift.Equatable {
}

extension GetObjectRetentionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectRetentionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetObjectRetentionOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetObjectRetentionOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetObjectRetentionOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetObjectRetentionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetObjectRetentionOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetObjectRetentionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectRetentionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.ObjectLockRetention = try responseDecoder.decode(responseBody: data)
                self.retention = output
            } else {
                self.retention = nil
            }
        } else {
            self.retention = nil
        }
    }
}

public struct GetObjectRetentionOutputResponse: Swift.Equatable {
    /// The container element for an object's retention settings.
    public var retention: S3ClientTypes.ObjectLockRetention?

    public init (
        retention: S3ClientTypes.ObjectLockRetention? = nil
    )
    {
        self.retention = retention
    }
}

struct GetObjectRetentionOutputResponseBody: Swift.Equatable {
    let retention: S3ClientTypes.ObjectLockRetention?
}

extension GetObjectRetentionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retention = "Retention"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockRetention.self, forKey: .retention)
        retention = retentionDecoded
    }
}

extension GetObjectTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension GetObjectTaggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "tagging", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension GetObjectTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct GetObjectTaggingInput: Swift.Equatable {
    /// The bucket name containing the object for which to get the tagging information. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Object key for which to get the tagging information.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// The versionId of the object for which to get the tagging information.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectTaggingInputBody: Swift.Equatable {
}

extension GetObjectTaggingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectTaggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetObjectTaggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetObjectTaggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetObjectTaggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetObjectTaggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetObjectTaggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetObjectTaggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectTaggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetObjectTaggingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagSet = output.tagSet
        } else {
            self.tagSet = nil
        }
    }
}

public struct GetObjectTaggingOutputResponse: Swift.Equatable {
    /// Contains the tag set.
    /// This member is required.
    public var tagSet: [S3ClientTypes.Tag]?
    /// The versionId of the object for which you got the tagging information.
    public var versionId: Swift.String?

    public init (
        tagSet: [S3ClientTypes.Tag]? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.tagSet = tagSet
        self.versionId = versionId
    }
}

struct GetObjectTaggingOutputResponseBody: Swift.Equatable {
    let tagSet: [S3ClientTypes.Tag]?
}

extension GetObjectTaggingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct Tag{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .member)
                var tagSetBuffer:[S3ClientTypes.Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension GetObjectTorrentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension GetObjectTorrentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "torrent", value: nil))
        return items
    }
}

extension GetObjectTorrentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct GetObjectTorrentInput: Swift.Equatable {
    /// The name of the bucket containing the object for which to get the torrent files.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The object key for which to get the information.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
    }
}

struct GetObjectTorrentInputBody: Swift.Equatable {
}

extension GetObjectTorrentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectTorrentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetObjectTorrentOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetObjectTorrentOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetObjectTorrentOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetObjectTorrentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetObjectTorrentOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetObjectTorrentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectTorrentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.body = data
        } else {
            self.body = nil
        }
    }
}

public struct GetObjectTorrentOutputResponse: Swift.Equatable {
    /// A Bencoded dictionary as defined by the BitTorrent specification
    public var body: ClientRuntime.ByteStream?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        body: ClientRuntime.ByteStream? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.body = body
        self.requestCharged = requestCharged
    }
}

struct GetObjectTorrentOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension GetObjectTorrentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = ClientRuntime.ByteStream.from(data: "".data(using: .utf8)!)
            }
        } else {
            body = nil
        }
    }
}

extension GetPublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension GetPublicAccessBlockInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "publicAccessBlock", value: nil))
        return items
    }
}

extension GetPublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct GetPublicAccessBlockInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose PublicAccessBlock configuration you want to retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetPublicAccessBlockInputBody: Swift.Equatable {
}

extension GetPublicAccessBlockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicAccessBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = GetPublicAccessBlockOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? GetPublicAccessBlockOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = GetPublicAccessBlockOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension GetPublicAccessBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension GetPublicAccessBlockOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum GetPublicAccessBlockOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicAccessBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.PublicAccessBlockConfiguration = try responseDecoder.decode(responseBody: data)
                self.publicAccessBlockConfiguration = output
            } else {
                self.publicAccessBlockConfiguration = nil
            }
        } else {
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetPublicAccessBlockOutputResponse: Swift.Equatable {
    /// The PublicAccessBlock configuration currently in effect for this Amazon S3 bucket.
    public var publicAccessBlockConfiguration: S3ClientTypes.PublicAccessBlockConfiguration?

    public init (
        publicAccessBlockConfiguration: S3ClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetPublicAccessBlockOutputResponseBody: Swift.Equatable {
    let publicAccessBlockConfiguration: S3ClientTypes.PublicAccessBlockConfiguration?
}

extension GetPublicAccessBlockOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension S3ClientTypes.GlacierJobParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tier = tier {
            try container.encode(tier, forKey: ClientRuntime.Key("Tier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tierDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension S3ClientTypes.GlacierJobParameters: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for S3 Glacier job parameters.
    public struct GlacierJobParameters: Swift.Equatable {
        /// Retrieval tier at which the restore will be processed.
        /// This member is required.
        public var tier: S3ClientTypes.Tier?

        public init (
            tier: S3ClientTypes.Tier? = nil
        )
        {
            self.tier = tier
        }
    }

}

extension S3ClientTypes.Grant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let grantee = grantee {
            var granteeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Grantee"))
            try granteeContainer.encode(grantee, forKey: ClientRuntime.Key(""))
            try granteeContainer.encode("http://www.w3.org/2001/XMLSchema-instance", forKey: ClientRuntime.Key("xmlns:xsi"))
        }
        if let permission = permission {
            try container.encode(permission, forKey: ClientRuntime.Key("Permission"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension S3ClientTypes.Grant: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns",
            "xmlns:xsi"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for grant information.
    public struct Grant: Swift.Equatable {
        /// The person being granted permissions.
        public var grantee: S3ClientTypes.Grantee?
        /// Specifies the permission given to the grantee.
        public var permission: S3ClientTypes.Permission?

        public init (
            grantee: S3ClientTypes.Grantee? = nil,
            permission: S3ClientTypes.Permission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension S3ClientTypes.Grantee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case emailAddress = "EmailAddress"
        case iD = "ID"
        case type = "xsi:type"
        case uRI = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: ClientRuntime.Key("DisplayName"))
        }
        if let emailAddress = emailAddress {
            try container.encode(emailAddress, forKey: ClientRuntime.Key("EmailAddress"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: ClientRuntime.Key("ID"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("xsi:type"))
        }
        if let uRI = uRI {
            try container.encode(uRI, forKey: ClientRuntime.Key("URI"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uRI)
        uRI = uRIDecoded
        let typeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension S3ClientTypes.Grantee: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        let codingKeys = [
            "xsi:type"
        ]
        if let key = key as? ClientRuntime.Key {
            if codingKeys.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the person being granted permissions.
    public struct Grantee: Swift.Equatable {
        /// Screen name of the grantee.
        public var displayName: Swift.String?
        /// Email address of the grantee. Using email addresses to specify a grantee is only supported in the following Amazon Web Services Regions:
        ///
        /// * US East (N. Virginia)
        ///
        /// * US West (N. California)
        ///
        /// * US West (Oregon)
        ///
        /// * Asia Pacific (Singapore)
        ///
        /// * Asia Pacific (Sydney)
        ///
        /// * Asia Pacific (Tokyo)
        ///
        /// * Europe (Ireland)
        ///
        /// * South America (So Paulo)
        ///
        ///
        /// For a list of all the Amazon S3 supported Regions and endpoints, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) in the Amazon Web Services General Reference.
        public var emailAddress: Swift.String?
        /// The canonical user ID of the grantee.
        public var iD: Swift.String?
        /// Type of grantee
        /// This member is required.
        public var type: S3ClientTypes.ModelType?
        /// URI of the grantee group.
        public var uRI: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            iD: Swift.String? = nil,
            type: S3ClientTypes.ModelType? = nil,
            uRI: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.iD = iD
            self.type = type
            self.uRI = uRI
        }
    }

}

extension HeadBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension HeadBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct HeadBucketInput: Swift.Equatable {
    /// The bucket name. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct HeadBucketInputBody: Swift.Equatable {
}

extension HeadBucketInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension HeadBucketOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = HeadBucketOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? HeadBucketOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = HeadBucketOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension HeadBucketOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "NotFound" : self = .notFound(try NotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension HeadBucketOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum HeadBucketOutputError: Swift.Error, Swift.Equatable {
    case notFound(NotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension HeadBucketOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct HeadBucketOutputResponse: Swift.Equatable {

}

extension HeadObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let ifModifiedSince = ifModifiedSince {
            items.add(Header(name: "If-Modified-Since", value: Swift.String(ifModifiedSince.rfc5322())))
        }
        if let ifNoneMatch = ifNoneMatch {
            items.add(Header(name: "If-None-Match", value: Swift.String(ifNoneMatch)))
        }
        if let ifUnmodifiedSince = ifUnmodifiedSince {
            items.add(Header(name: "If-Unmodified-Since", value: Swift.String(ifUnmodifiedSince.rfc5322())))
        }
        if let range = range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        return items
    }
}

extension HeadObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        if partNumber != 0 {
            let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
            items.append(partNumberQueryItem)
        }
        return items
    }
}

extension HeadObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct HeadObjectInput: Swift.Equatable {
    /// The name of the bucket containing the object. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Return the object only if its entity tag (ETag) is the same as the one specified, otherwise return a 412 (precondition failed).
    public var ifMatch: Swift.String?
    /// Return the object only if it has been modified since the specified time, otherwise return a 304 (not modified).
    public var ifModifiedSince: ClientRuntime.Date?
    /// Return the object only if its entity tag (ETag) is different from the one specified, otherwise return a 304 (not modified).
    public var ifNoneMatch: Swift.String?
    /// Return the object only if it has not been modified since the specified time, otherwise return a 412 (precondition failed).
    public var ifUnmodifiedSince: ClientRuntime.Date?
    /// The object key.
    /// This member is required.
    public var key: Swift.String?
    /// Part number of the object being read. This is a positive integer between 1 and 10,000. Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about the size of the part and the number of parts in this object.
    public var partNumber: Swift.Int
    /// Downloads the specified range bytes of an object. For more information about the HTTP Range header, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35). Amazon S3 doesn't support retrieving multiple ranges of data per GET request.
    public var range: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Specifies the algorithm to use to when encrypting the object (for example, AES256).
    public var sSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
    public var sSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var sSECustomerKeyMD5: Swift.String?
    /// VersionId used to reference a specific version of the object.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        ifModifiedSince: ClientRuntime.Date? = nil,
        ifNoneMatch: Swift.String? = nil,
        ifUnmodifiedSince: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        partNumber: Swift.Int = 0,
        range: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.ifMatch = ifMatch
        self.ifModifiedSince = ifModifiedSince
        self.ifNoneMatch = ifNoneMatch
        self.ifUnmodifiedSince = ifUnmodifiedSince
        self.key = key
        self.partNumber = partNumber
        self.range = range
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.versionId = versionId
    }
}

struct HeadObjectInputBody: Swift.Equatable {
}

extension HeadObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension HeadObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = HeadObjectOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? HeadObjectOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = HeadObjectOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension HeadObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "NotFound" : self = .notFound(try NotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension HeadObjectOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum HeadObjectOutputError: Swift.Error, Swift.Equatable {
    case notFound(NotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension HeadObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "accept-ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let archiveStatusHeaderValue = httpResponse.headers.value(for: "x-amz-archive-status") {
            self.archiveStatus = S3ClientTypes.ArchiveStatus(rawValue: archiveStatusHeaderValue)
        } else {
            self.archiveStatus = nil
        }
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentLanguageHeaderValue = httpResponse.headers.value(for: "Content-Language") {
            self.contentLanguage = contentLanguageHeaderValue
        } else {
            self.contentLanguage = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Swift.Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = 0
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let deleteMarkerHeaderValue = httpResponse.headers.value(for: "x-amz-delete-marker") {
            self.deleteMarker = Swift.Bool(deleteMarkerHeaderValue) ?? false
        } else {
            self.deleteMarker = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let expiresHeaderValue = httpResponse.headers.value(for: "Expires") {
            self.expires = DateFormatter.rfc5322DateFormatter.date(from: expiresHeaderValue)
        } else {
            self.expires = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = DateFormatter.rfc5322DateFormatter.date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        if let missingMetaHeaderValue = httpResponse.headers.value(for: "x-amz-missing-meta") {
            self.missingMeta = Swift.Int(missingMetaHeaderValue) ?? 0
        } else {
            self.missingMeta = 0
        }
        if let objectLockLegalHoldStatusHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-legal-hold") {
            self.objectLockLegalHoldStatus = S3ClientTypes.ObjectLockLegalHoldStatus(rawValue: objectLockLegalHoldStatusHeaderValue)
        } else {
            self.objectLockLegalHoldStatus = nil
        }
        if let objectLockModeHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-mode") {
            self.objectLockMode = S3ClientTypes.ObjectLockMode(rawValue: objectLockModeHeaderValue)
        } else {
            self.objectLockMode = nil
        }
        if let objectLockRetainUntilDateHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-retain-until-date") {
            self.objectLockRetainUntilDate = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds.date(from: objectLockRetainUntilDateHeaderValue)
        } else {
            self.objectLockRetainUntilDate = nil
        }
        if let partsCountHeaderValue = httpResponse.headers.value(for: "x-amz-mp-parts-count") {
            self.partsCount = Swift.Int(partsCountHeaderValue) ?? 0
        } else {
            self.partsCount = 0
        }
        if let replicationStatusHeaderValue = httpResponse.headers.value(for: "x-amz-replication-status") {
            self.replicationStatus = S3ClientTypes.ReplicationStatus(rawValue: replicationStatusHeaderValue)
        } else {
            self.replicationStatus = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let restoreHeaderValue = httpResponse.headers.value(for: "x-amz-restore") {
            self.restore = restoreHeaderValue
        } else {
            self.restore = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let storageClassHeaderValue = httpResponse.headers.value(for: "x-amz-storage-class") {
            self.storageClass = S3ClientTypes.StorageClass(rawValue: storageClassHeaderValue)
        } else {
            self.storageClass = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if let websiteRedirectLocationHeaderValue = httpResponse.headers.value(for: "x-amz-website-redirect-location") {
            self.websiteRedirectLocation = websiteRedirectLocationHeaderValue
        } else {
            self.websiteRedirectLocation = nil
        }
        let keysForMetadata = httpResponse.headers.dictionary.keys.filter({ $0.starts(with: "x-amz-meta-") })
        if (!keysForMetadata.isEmpty) {
            var mapMember = [Swift.String: String]()
            for headerKey in keysForMetadata {
                let mapMemberValue = httpResponse.headers.dictionary[headerKey]?[0]
                let mapMemberKey = headerKey.removePrefix("x-amz-meta-")
                mapMember[mapMemberKey] = mapMemberValue
            }
            self.metadata = mapMember
        } else {
            self.metadata = [:]
        }
    }
}

public struct HeadObjectOutputResponse: Swift.Equatable {
    /// Indicates that a range of bytes was specified.
    public var acceptRanges: Swift.String?
    /// The archive state of the head object.
    public var archiveStatus: S3ClientTypes.ArchiveStatus?
    /// Indicates whether the object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Specifies caching behavior along the request/reply chain.
    public var cacheControl: Swift.String?
    /// Specifies presentational information for the object.
    public var contentDisposition: Swift.String?
    /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
    public var contentEncoding: Swift.String?
    /// The language the content is in.
    public var contentLanguage: Swift.String?
    /// Size of the body in bytes.
    public var contentLength: Swift.Int
    /// A standard MIME type describing the format of the object data.
    public var contentType: Swift.String?
    /// Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.
    public var deleteMarker: Swift.Bool
    /// An ETag is an opaque identifier assigned by a web server to a specific version of a resource found at a URL.
    public var eTag: Swift.String?
    /// If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded.
    public var expiration: Swift.String?
    /// The date and time at which the object is no longer cacheable.
    public var expires: ClientRuntime.Date?
    /// Creation date of the object.
    public var lastModified: ClientRuntime.Date?
    /// A map of metadata to store with the object in S3.
    public var metadata: [Swift.String:Swift.String]?
    /// This is set to the number of metadata entries not returned in x-amz-meta headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.
    public var missingMeta: Swift.Int
    /// Specifies whether a legal hold is in effect for this object. This header is only returned if the requester has the s3:GetObjectLegalHold permission. This header is not returned if the specified version of this object has never had a legal hold applied. For more information about S3 Object Lock, see [Object Lock](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html).
    public var objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus?
    /// The Object Lock mode, if any, that's in effect for this object. This header is only returned if the requester has the s3:GetObjectRetention permission. For more information about S3 Object Lock, see [Object Lock](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html).
    public var objectLockMode: S3ClientTypes.ObjectLockMode?
    /// The date and time when the Object Lock retention period expires. This header is only returned if the requester has the s3:GetObjectRetention permission.
    public var objectLockRetainUntilDate: ClientRuntime.Date?
    /// The count of parts this object has.
    public var partsCount: Swift.Int
    /// Amazon S3 can return this header if your request involves a bucket that is either a source or a destination in a replication rule. In replication, you have a source bucket on which you configure replication and destination bucket or buckets where Amazon S3 stores object replicas. When you request an object (GetObject) or object metadata (HeadObject) from these buckets, Amazon S3 will return the x-amz-replication-status header in the response as follows:
    ///
    /// * If requesting an object from the source bucket  Amazon S3 will return the x-amz-replication-status header if the object in your request is eligible for replication. For example, suppose that in your replication configuration, you specify object prefix TaxDocs requesting Amazon S3 to replicate objects with key prefix TaxDocs. Any objects you upload with this key name prefix, for example TaxDocs/document1.pdf, are eligible for replication. For any object request with this key name prefix, Amazon S3 will return the x-amz-replication-status header with value PENDING, COMPLETED or FAILED indicating object replication status.
    ///
    /// * If requesting an object from a destination bucket  Amazon S3 will return the x-amz-replication-status header with value REPLICA if the object in your request is a replica that Amazon S3 created and there is no replica modification replication in progress.
    ///
    /// * When replicating objects to multiple destination buckets the x-amz-replication-status header acts differently. The header of the source object will only return a value of COMPLETED when replication is successful to all destinations. The header will remain at value PENDING until replication has completed for all destinations. If one or more destinations fails replication the header will return FAILED.
    ///
    ///
    /// For more information, see [Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html).
    public var replicationStatus: S3ClientTypes.ReplicationStatus?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// If the object is an archived object (an object whose storage class is GLACIER), the response includes this header if either the archive restoration is in progress (see [RestoreObject](https://docs.aws.amazon.com/AmazonS3/latest/API/API_RestoreObject.html) or an archive copy is already restored. If an archive copy is already restored, the header value indicates when Amazon S3 is scheduled to delete the object copy. For example: x-amz-restore: ongoing-request="false", expiry-date="Fri, 21 Dec 2012 00:00:00 GMT" If the object restoration is in progress, the header returns the value ongoing-request="true". For more information about archiving objects, see [Transitioning Objects: General Considerations](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html#lifecycle-transition-general-considerations).
    public var restore: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
    public var sSECustomerAlgorithm: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// If the object is stored using server-side encryption either with an Amazon Web Services KMS key or an Amazon S3-managed encryption key, the response includes this header with the value of the server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// Provides storage class information of the object. Amazon S3 returns this header for all objects except for S3 Standard storage class objects. For more information, see [Storage Classes](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html).
    public var storageClass: S3ClientTypes.StorageClass?
    /// Version of the object.
    public var versionId: Swift.String?
    /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
    public var websiteRedirectLocation: Swift.String?

    public init (
        acceptRanges: Swift.String? = nil,
        archiveStatus: S3ClientTypes.ArchiveStatus? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        cacheControl: Swift.String? = nil,
        contentDisposition: Swift.String? = nil,
        contentEncoding: Swift.String? = nil,
        contentLanguage: Swift.String? = nil,
        contentLength: Swift.Int = 0,
        contentType: Swift.String? = nil,
        deleteMarker: Swift.Bool = false,
        eTag: Swift.String? = nil,
        expiration: Swift.String? = nil,
        expires: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        missingMeta: Swift.Int = 0,
        objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus? = nil,
        objectLockMode: S3ClientTypes.ObjectLockMode? = nil,
        objectLockRetainUntilDate: ClientRuntime.Date? = nil,
        partsCount: Swift.Int = 0,
        replicationStatus: S3ClientTypes.ReplicationStatus? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        restore: Swift.String? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        storageClass: S3ClientTypes.StorageClass? = nil,
        versionId: Swift.String? = nil,
        websiteRedirectLocation: Swift.String? = nil
    )
    {
        self.acceptRanges = acceptRanges
        self.archiveStatus = archiveStatus
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentType = contentType
        self.deleteMarker = deleteMarker
        self.eTag = eTag
        self.expiration = expiration
        self.expires = expires
        self.lastModified = lastModified
        self.metadata = metadata
        self.missingMeta = missingMeta
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.partsCount = partsCount
        self.replicationStatus = replicationStatus
        self.requestCharged = requestCharged
        self.restore = restore
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.versionId = versionId
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

extension S3ClientTypes.IndexDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suffix = "Suffix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let suffix = suffix {
            try container.encode(suffix, forKey: ClientRuntime.Key("Suffix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suffix)
        suffix = suffixDecoded
    }
}

extension S3ClientTypes.IndexDocument: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the Suffix element.
    public struct IndexDocument: Swift.Equatable {
        /// A suffix that is appended to a request that is for a directory on the website endpoint (for example,if the suffix is index.html and you make a request to samplebucket/images/ the data that is returned will be for the object with the key name images/index.html) The suffix must not be empty and must not include a slash character. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        /// This member is required.
        public var suffix: Swift.String?

        public init (
            suffix: Swift.String? = nil
        )
        {
            self.suffix = suffix
        }
    }

}

extension S3ClientTypes.Initiator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case iD = "ID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: ClientRuntime.Key("DisplayName"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: ClientRuntime.Key("ID"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension S3ClientTypes.Initiator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container element that identifies who initiated the multipart upload.
    public struct Initiator: Swift.Equatable {
        /// Name of the Principal.
        public var displayName: Swift.String?
        /// If the principal is an Amazon Web Services account, it provides the Canonical User ID. If the principal is an IAM User, it provides a user ARN value.
        public var iD: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            iD: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.iD = iD
        }
    }

}

extension S3ClientTypes.InputSerialization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cSV = "CSV"
        case compressionType = "CompressionType"
        case jSON = "JSON"
        case parquet = "Parquet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cSV = cSV {
            try container.encode(cSV, forKey: ClientRuntime.Key("CSV"))
        }
        if let compressionType = compressionType {
            try container.encode(compressionType, forKey: ClientRuntime.Key("CompressionType"))
        }
        if let jSON = jSON {
            try container.encode(jSON, forKey: ClientRuntime.Key("JSON"))
        }
        if let parquet = parquet {
            try container.encode(parquet, forKey: ClientRuntime.Key("Parquet"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cSVDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CSVInput.self, forKey: .cSV)
        cSV = cSVDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CompressionType.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let jSONDecoded = try containerValues.decodeIfPresent(S3ClientTypes.JSONInput.self, forKey: .jSON)
        jSON = jSONDecoded
        let parquetDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ParquetInput.self, forKey: .parquet)
        parquet = parquetDecoded
    }
}

extension S3ClientTypes.InputSerialization: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes the serialization format of the object.
    public struct InputSerialization: Swift.Equatable {
        /// Describes the serialization of a CSV-encoded object.
        public var cSV: S3ClientTypes.CSVInput?
        /// Specifies object's compression format. Valid values: NONE, GZIP, BZIP2. Default Value: NONE.
        public var compressionType: S3ClientTypes.CompressionType?
        /// Specifies JSON as object's input serialization format.
        public var jSON: S3ClientTypes.JSONInput?
        /// Specifies Parquet as object's input serialization format.
        public var parquet: S3ClientTypes.ParquetInput?

        public init (
            cSV: S3ClientTypes.CSVInput? = nil,
            compressionType: S3ClientTypes.CompressionType? = nil,
            jSON: S3ClientTypes.JSONInput? = nil,
            parquet: S3ClientTypes.ParquetInput? = nil
        )
        {
            self.cSV = cSV
            self.compressionType = compressionType
            self.jSON = jSON
            self.parquet = parquet
        }
    }

}

extension S3ClientTypes {
    public enum IntelligentTieringAccessTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archiveAccess
        case deepArchiveAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [IntelligentTieringAccessTier] {
            return [
                .archiveAccess,
                .deepArchiveAccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archiveAccess: return "ARCHIVE_ACCESS"
            case .deepArchiveAccess: return "DEEP_ARCHIVE_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntelligentTieringAccessTier(rawValue: rawValue) ?? IntelligentTieringAccessTier.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.IntelligentTieringAndOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .tags)
                var tagsBuffer:[S3ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension S3ClientTypes.IntelligentTieringAndOperator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for specifying S3 Intelligent-Tiering filters. The filters determine the subset of objects to which the rule applies.
    public struct IntelligentTieringAndOperator: Swift.Equatable {
        /// An object key name prefix that identifies the subset of objects to which the configuration applies.
        public var `prefix`: Swift.String?
        /// All of these tags must exist in the object's tag set in order for the configuration to apply.
        public var tags: [S3ClientTypes.Tag]?

        public init (
            `prefix`: Swift.String? = nil,
            tags: [S3ClientTypes.Tag]? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ClientTypes.IntelligentTieringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case id = "Id"
        case status = "Status"
        case tierings = "Tiering"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let tierings = tierings {
            if tierings.isEmpty {
                var tieringsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Tiering"))
                try tieringsContainer.encodeNil()
            } else {
                for tiering0 in tierings {
                    var tieringsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tiering"))
                    try tieringsContainer0.encode(tiering0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IntelligentTieringFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IntelligentTieringStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.tierings) {
            let tieringsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tierings)
            if tieringsWrappedContainer != nil {
                let tieringsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Tiering].self, forKey: .tierings)
                var tieringsBuffer:[S3ClientTypes.Tiering]? = nil
                if let tieringsContainer = tieringsContainer {
                    tieringsBuffer = [S3ClientTypes.Tiering]()
                    for structureContainer0 in tieringsContainer {
                        tieringsBuffer?.append(structureContainer0)
                    }
                }
                tierings = tieringsBuffer
            } else {
                tierings = []
            }
        } else {
            tierings = nil
        }
    }
}

extension S3ClientTypes.IntelligentTieringConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the S3 Intelligent-Tiering configuration for an Amazon S3 bucket. For information about the S3 Intelligent-Tiering storage class, see [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access).
    public struct IntelligentTieringConfiguration: Swift.Equatable {
        /// Specifies a bucket filter. The configuration only includes objects that meet the filter's criteria.
        public var filter: S3ClientTypes.IntelligentTieringFilter?
        /// The ID used to identify the S3 Intelligent-Tiering configuration.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies the status of the configuration.
        /// This member is required.
        public var status: S3ClientTypes.IntelligentTieringStatus?
        /// Specifies the S3 Intelligent-Tiering storage class tier of the configuration.
        /// This member is required.
        public var tierings: [S3ClientTypes.Tiering]?

        public init (
            filter: S3ClientTypes.IntelligentTieringFilter? = nil,
            id: Swift.String? = nil,
            status: S3ClientTypes.IntelligentTieringStatus? = nil,
            tierings: [S3ClientTypes.Tiering]? = nil
        )
        {
            self.filter = filter
            self.id = id
            self.status = status
            self.tierings = tierings
        }
    }

}

extension S3ClientTypes.IntelligentTieringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case `prefix` = "Prefix"
        case tag = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let and = and {
            try container.encode(and, forKey: ClientRuntime.Key("And"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tag = tag {
            try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Tag.self, forKey: .tag)
        tag = tagDecoded
        let andDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IntelligentTieringAndOperator.self, forKey: .and)
        and = andDecoded
    }
}

extension S3ClientTypes.IntelligentTieringFilter: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The Filter is used to identify objects that the S3 Intelligent-Tiering configuration applies to.
    public struct IntelligentTieringFilter: Swift.Equatable {
        /// A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates, and an object must match all of the predicates in order for the filter to apply.
        public var and: S3ClientTypes.IntelligentTieringAndOperator?
        /// An object key name prefix that identifies the subset of objects to which the rule applies. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        public var `prefix`: Swift.String?
        /// A container of a key value name pair.
        public var tag: S3ClientTypes.Tag?

        public init (
            and: S3ClientTypes.IntelligentTieringAndOperator? = nil,
            `prefix`: Swift.String? = nil,
            tag: S3ClientTypes.Tag? = nil
        )
        {
            self.and = and
            self.`prefix` = `prefix`
            self.tag = tag
        }
    }

}

extension S3ClientTypes {
    public enum IntelligentTieringStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [IntelligentTieringStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntelligentTieringStatus(rawValue: rawValue) ?? IntelligentTieringStatus.sdkUnknown(rawValue)
        }
    }
}

extension InvalidObjectState {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidObjectStateBody = try responseDecoder.decode(responseBody: data)
            self.accessTier = output.accessTier
            self.storageClass = output.storageClass
        } else {
            self.accessTier = nil
            self.storageClass = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// Object is archived and inaccessible until restored.
public struct InvalidObjectState: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?
    public var accessTier: S3ClientTypes.IntelligentTieringAccessTier?
    public var storageClass: S3ClientTypes.StorageClass?

    public init (
        accessTier: S3ClientTypes.IntelligentTieringAccessTier? = nil,
        storageClass: S3ClientTypes.StorageClass? = nil
    )
    {
        self.accessTier = accessTier
        self.storageClass = storageClass
    }
}

struct InvalidObjectStateBody: Swift.Equatable {
    let storageClass: S3ClientTypes.StorageClass?
    let accessTier: S3ClientTypes.IntelligentTieringAccessTier?
}

extension InvalidObjectStateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTier = "AccessTier"
        case storageClass = "StorageClass"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let accessTierDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IntelligentTieringAccessTier.self, forKey: .accessTier)
        accessTier = accessTierDecoded
    }
}

extension S3ClientTypes.InventoryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case filter = "Filter"
        case id = "Id"
        case includedObjectVersions = "IncludedObjectVersions"
        case isEnabled = "IsEnabled"
        case optionalFields = "OptionalFields"
        case schedule = "Schedule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: ClientRuntime.Key("Destination"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let includedObjectVersions = includedObjectVersions {
            try container.encode(includedObjectVersions, forKey: ClientRuntime.Key("IncludedObjectVersions"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
        if let optionalFields = optionalFields {
            var optionalFieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionalFields"))
            for inventoryoptionalfield0 in optionalFields {
                try optionalFieldsContainer.encode(inventoryoptionalfield0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: ClientRuntime.Key("Schedule"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryDestination.self, forKey: .destination)
        destination = destinationDecoded
        let isEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isEnabled)
        isEnabled = isEnabledDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryFilter.self, forKey: .filter)
        filter = filterDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let includedObjectVersionsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryIncludedObjectVersions.self, forKey: .includedObjectVersions)
        includedObjectVersions = includedObjectVersionsDecoded
        if containerValues.contains(.optionalFields) {
            struct KeyVal0{struct Field{}}
            let optionalFieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .optionalFields)
            if let optionalFieldsWrappedContainer = optionalFieldsWrappedContainer {
                let optionalFieldsContainer = try optionalFieldsWrappedContainer.decodeIfPresent([S3ClientTypes.InventoryOptionalField].self, forKey: .member)
                var optionalFieldsBuffer:[S3ClientTypes.InventoryOptionalField]? = nil
                if let optionalFieldsContainer = optionalFieldsContainer {
                    optionalFieldsBuffer = [S3ClientTypes.InventoryOptionalField]()
                    for stringContainer0 in optionalFieldsContainer {
                        optionalFieldsBuffer?.append(stringContainer0)
                    }
                }
                optionalFields = optionalFieldsBuffer
            } else {
                optionalFields = []
            }
        } else {
            optionalFields = nil
        }
        let scheduleDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventorySchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

extension S3ClientTypes.InventoryConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the inventory configuration for an Amazon S3 bucket. For more information, see [GET Bucket inventory](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html) in the Amazon S3 API Reference.
    public struct InventoryConfiguration: Swift.Equatable {
        /// Contains information about where to publish the inventory results.
        /// This member is required.
        public var destination: S3ClientTypes.InventoryDestination?
        /// Specifies an inventory filter. The inventory only includes objects that meet the filter's criteria.
        public var filter: S3ClientTypes.InventoryFilter?
        /// The ID used to identify the inventory configuration.
        /// This member is required.
        public var id: Swift.String?
        /// Object versions to include in the inventory list. If set to All, the list includes all the object versions, which adds the version-related fields VersionId, IsLatest, and DeleteMarker to the list. If set to Current, the list does not contain these version-related fields.
        /// This member is required.
        public var includedObjectVersions: S3ClientTypes.InventoryIncludedObjectVersions?
        /// Specifies whether the inventory is enabled or disabled. If set to True, an inventory list is generated. If set to False, no inventory list is generated.
        /// This member is required.
        public var isEnabled: Swift.Bool
        /// Contains the optional fields that are included in the inventory results.
        public var optionalFields: [S3ClientTypes.InventoryOptionalField]?
        /// Specifies the schedule for generating inventory results.
        /// This member is required.
        public var schedule: S3ClientTypes.InventorySchedule?

        public init (
            destination: S3ClientTypes.InventoryDestination? = nil,
            filter: S3ClientTypes.InventoryFilter? = nil,
            id: Swift.String? = nil,
            includedObjectVersions: S3ClientTypes.InventoryIncludedObjectVersions? = nil,
            isEnabled: Swift.Bool = false,
            optionalFields: [S3ClientTypes.InventoryOptionalField]? = nil,
            schedule: S3ClientTypes.InventorySchedule? = nil
        )
        {
            self.destination = destination
            self.filter = filter
            self.id = id
            self.includedObjectVersions = includedObjectVersions
            self.isEnabled = isEnabled
            self.optionalFields = optionalFields
            self.schedule = schedule
        }
    }

}

extension S3ClientTypes.InventoryDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketDestination = "S3BucketDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let s3BucketDestination = s3BucketDestination {
            try container.encode(s3BucketDestination, forKey: ClientRuntime.Key("S3BucketDestination"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDestinationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryS3BucketDestination.self, forKey: .s3BucketDestination)
        s3BucketDestination = s3BucketDestinationDecoded
    }
}

extension S3ClientTypes.InventoryDestination: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the inventory configuration for an Amazon S3 bucket.
    public struct InventoryDestination: Swift.Equatable {
        /// Contains the bucket name, file format, bucket owner (optional), and prefix (optional) where inventory results are published.
        /// This member is required.
        public var s3BucketDestination: S3ClientTypes.InventoryS3BucketDestination?

        public init (
            s3BucketDestination: S3ClientTypes.InventoryS3BucketDestination? = nil
        )
        {
            self.s3BucketDestination = s3BucketDestination
        }
    }

}

extension S3ClientTypes.InventoryEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sSEKMS = "SSE-KMS"
        case sSES3 = "SSE-S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let sSEKMS = sSEKMS {
            try container.encode(sSEKMS, forKey: ClientRuntime.Key("SSE-KMS"))
        }
        if let sSES3 = sSES3 {
            try container.encode(sSES3, forKey: ClientRuntime.Key("SSE-S3"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sSES3Decoded = try containerValues.decodeIfPresent(S3ClientTypes.SSES3.self, forKey: .sSES3)
        sSES3 = sSES3Decoded
        let sSEKMSDecoded = try containerValues.decodeIfPresent(S3ClientTypes.SSEKMS.self, forKey: .sSEKMS)
        sSEKMS = sSEKMSDecoded
    }
}

extension S3ClientTypes.InventoryEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Contains the type of server-side encryption used to encrypt the inventory results.
    public struct InventoryEncryption: Swift.Equatable {
        /// Specifies the use of SSE-KMS to encrypt delivered inventory reports.
        public var sSEKMS: S3ClientTypes.SSEKMS?
        /// Specifies the use of SSE-S3 to encrypt delivered inventory reports.
        public var sSES3: S3ClientTypes.SSES3?

        public init (
            sSEKMS: S3ClientTypes.SSEKMS? = nil,
            sSES3: S3ClientTypes.SSES3? = nil
        )
        {
            self.sSEKMS = sSEKMS
            self.sSES3 = sSES3
        }
    }

}

extension S3ClientTypes.InventoryFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension S3ClientTypes.InventoryFilter: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies an inventory filter. The inventory only includes objects that meet the filter's criteria.
    public struct InventoryFilter: Swift.Equatable {
        /// The prefix that an object must have to be included in the inventory results.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init (
            `prefix`: Swift.String? = nil
        )
        {
            self.`prefix` = `prefix`
        }
    }

}

extension S3ClientTypes {
    public enum InventoryFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case orc
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryFormat] {
            return [
                .csv,
                .orc,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .orc: return "ORC"
            case .parquet: return "Parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryFormat(rawValue: rawValue) ?? InventoryFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum InventoryFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryFrequency] {
            return [
                .daily,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "Daily"
            case .weekly: return "Weekly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryFrequency(rawValue: rawValue) ?? InventoryFrequency.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum InventoryIncludedObjectVersions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case current
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryIncludedObjectVersions] {
            return [
                .all,
                .current,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .current: return "Current"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryIncludedObjectVersions(rawValue: rawValue) ?? InventoryIncludedObjectVersions.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum InventoryOptionalField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketkeystatus
        case etag
        case encryptionstatus
        case intelligenttieringaccesstier
        case ismultipartuploaded
        case lastmodifieddate
        case objectlocklegalholdstatus
        case objectlockmode
        case objectlockretainuntildate
        case replicationstatus
        case size
        case storageclass
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryOptionalField] {
            return [
                .bucketkeystatus,
                .etag,
                .encryptionstatus,
                .intelligenttieringaccesstier,
                .ismultipartuploaded,
                .lastmodifieddate,
                .objectlocklegalholdstatus,
                .objectlockmode,
                .objectlockretainuntildate,
                .replicationstatus,
                .size,
                .storageclass,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketkeystatus: return "BucketKeyStatus"
            case .etag: return "ETag"
            case .encryptionstatus: return "EncryptionStatus"
            case .intelligenttieringaccesstier: return "IntelligentTieringAccessTier"
            case .ismultipartuploaded: return "IsMultipartUploaded"
            case .lastmodifieddate: return "LastModifiedDate"
            case .objectlocklegalholdstatus: return "ObjectLockLegalHoldStatus"
            case .objectlockmode: return "ObjectLockMode"
            case .objectlockretainuntildate: return "ObjectLockRetainUntilDate"
            case .replicationstatus: return "ReplicationStatus"
            case .size: return "Size"
            case .storageclass: return "StorageClass"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryOptionalField(rawValue: rawValue) ?? InventoryOptionalField.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.InventoryS3BucketDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case bucket = "Bucket"
        case encryption = "Encryption"
        case format = "Format"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let encryption = encryption {
            try container.encode(encryption, forKey: ClientRuntime.Key("Encryption"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let formatDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryFormat.self, forKey: .format)
        format = formatDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension S3ClientTypes.InventoryS3BucketDestination: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Contains the bucket name, file format, bucket owner (optional), and prefix (optional) where inventory results are published.
    public struct InventoryS3BucketDestination: Swift.Equatable {
        /// The account ID that owns the destination S3 bucket. If no account ID is provided, the owner is not validated before exporting data. Although this value is optional, we strongly recommend that you set it to help prevent problems if the destination bucket ownership changes.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the bucket where inventory results will be published.
        /// This member is required.
        public var bucket: Swift.String?
        /// Contains the type of server-side encryption used to encrypt the inventory results.
        public var encryption: S3ClientTypes.InventoryEncryption?
        /// Specifies the output format of the inventory results.
        /// This member is required.
        public var format: S3ClientTypes.InventoryFormat?
        /// The prefix that is prepended to all inventory results.
        public var `prefix`: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            bucket: Swift.String? = nil,
            encryption: S3ClientTypes.InventoryEncryption? = nil,
            format: S3ClientTypes.InventoryFormat? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.bucket = bucket
            self.encryption = encryption
            self.format = format
            self.`prefix` = `prefix`
        }
    }

}

extension S3ClientTypes.InventorySchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frequency = "Frequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let frequency = frequency {
            try container.encode(frequency, forKey: ClientRuntime.Key("Frequency"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension S3ClientTypes.InventorySchedule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the schedule for generating inventory results.
    public struct InventorySchedule: Swift.Equatable {
        /// Specifies how frequently inventory results are produced.
        /// This member is required.
        public var frequency: S3ClientTypes.InventoryFrequency?

        public init (
            frequency: S3ClientTypes.InventoryFrequency? = nil
        )
        {
            self.frequency = frequency
        }
    }

}

extension S3ClientTypes.JSONInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.JSONType.self, forKey: .type)
        type = typeDecoded
    }
}

extension S3ClientTypes.JSONInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies JSON as object's input serialization format.
    public struct JSONInput: Swift.Equatable {
        /// The type of JSON. Valid values: Document, Lines.
        public var type: S3ClientTypes.JSONType?

        public init (
            type: S3ClientTypes.JSONType? = nil
        )
        {
            self.type = type
        }
    }

}

extension S3ClientTypes.JSONOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let recordDelimiter = recordDelimiter {
            try container.encode(recordDelimiter, forKey: ClientRuntime.Key("RecordDelimiter"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
    }
}

extension S3ClientTypes.JSONOutput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies JSON as request's output serialization format.
    public struct JSONOutput: Swift.Equatable {
        /// The value used to separate individual records in the output. If no value is specified, Amazon S3 uses a newline character ('\n').
        public var recordDelimiter: Swift.String?

        public init (
            recordDelimiter: Swift.String? = nil
        )
        {
            self.recordDelimiter = recordDelimiter
        }
    }

}

extension S3ClientTypes {
    public enum JSONType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case document
        case lines
        case sdkUnknown(Swift.String)

        public static var allCases: [JSONType] {
            return [
                .document,
                .lines,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .document: return "DOCUMENT"
            case .lines: return "LINES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JSONType(rawValue: rawValue) ?? JSONType.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.LambdaFunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Event"
        case filter = "Filter"
        case id = "Id"
        case lambdaFunctionArn = "CloudFunction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let events = events {
            if events.isEmpty {
                var eventsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Event"))
                try eventsContainer.encodeNil()
            } else {
                for event0 in events {
                    var eventsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Event"))
                    try eventsContainer0.encode(event0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lambdaFunctionArn = lambdaFunctionArn {
            try container.encode(lambdaFunctionArn, forKey: ClientRuntime.Key("CloudFunction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
        if containerValues.contains(.events) {
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .events)
            if eventsWrappedContainer != nil {
                let eventsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Event].self, forKey: .events)
                var eventsBuffer:[S3ClientTypes.Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [S3ClientTypes.Event]()
                    for stringContainer0 in eventsContainer {
                        eventsBuffer?.append(stringContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.NotificationConfigurationFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension S3ClientTypes.LambdaFunctionConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for specifying the configuration for Lambda notifications.
    public struct LambdaFunctionConfiguration: Swift.Equatable {
        /// The Amazon S3 bucket event for which to invoke the Lambda function. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var events: [S3ClientTypes.Event]?
        /// Specifies object key name filtering rules. For information about key name filtering, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
        public var filter: S3ClientTypes.NotificationConfigurationFilter?
        /// An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the Lambda function that Amazon S3 invokes when the specified event type occurs.
        /// This member is required.
        public var lambdaFunctionArn: Swift.String?

        public init (
            events: [S3ClientTypes.Event]? = nil,
            filter: S3ClientTypes.NotificationConfigurationFilter? = nil,
            id: Swift.String? = nil,
            lambdaFunctionArn: Swift.String? = nil
        )
        {
            self.events = events
            self.filter = filter
            self.id = id
            self.lambdaFunctionArn = lambdaFunctionArn
        }
    }

}

extension S3ClientTypes.LifecycleExpiration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case days = "Days"
        case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let date = date {
            try container.encode(ClientRuntime.TimestampWrapper(date, format: .dateTime), forKey: ClientRuntime.Key("Date"))
        }
        if days != 0 {
            try container.encode(days, forKey: ClientRuntime.Key("Days"))
        }
        if expiredObjectDeleteMarker != false {
            try container.encode(expiredObjectDeleteMarker, forKey: ClientRuntime.Key("ExpiredObjectDeleteMarker"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        var dateBuffer:ClientRuntime.Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let daysDecoded = try containerValues.decode(Swift.Int.self, forKey: .days)
        days = daysDecoded
        let expiredObjectDeleteMarkerDecoded = try containerValues.decode(Swift.Bool.self, forKey: .expiredObjectDeleteMarker)
        expiredObjectDeleteMarker = expiredObjectDeleteMarkerDecoded
    }
}

extension S3ClientTypes.LifecycleExpiration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the expiration for the lifecycle of the object.
    public struct LifecycleExpiration: Swift.Equatable {
        /// Indicates at what date the object is to be moved or deleted. Should be in GMT ISO 8601 Format.
        public var date: ClientRuntime.Date?
        /// Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        public var days: Swift.Int
        /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no action. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        public var expiredObjectDeleteMarker: Swift.Bool

        public init (
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            expiredObjectDeleteMarker: Swift.Bool = false
        )
        {
            self.date = date
            self.days = days
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
        }
    }

}

extension S3ClientTypes.LifecycleRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
        case expiration = "Expiration"
        case filter = "Filter"
        case iD = "ID"
        case noncurrentVersionExpiration = "NoncurrentVersionExpiration"
        case noncurrentVersionTransitions = "NoncurrentVersionTransition"
        case `prefix` = "Prefix"
        case status = "Status"
        case transitions = "Transition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let abortIncompleteMultipartUpload = abortIncompleteMultipartUpload {
            try container.encode(abortIncompleteMultipartUpload, forKey: ClientRuntime.Key("AbortIncompleteMultipartUpload"))
        }
        if let expiration = expiration {
            try container.encode(expiration, forKey: ClientRuntime.Key("Expiration"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: ClientRuntime.Key("ID"))
        }
        if let noncurrentVersionExpiration = noncurrentVersionExpiration {
            try container.encode(noncurrentVersionExpiration, forKey: ClientRuntime.Key("NoncurrentVersionExpiration"))
        }
        if let noncurrentVersionTransitions = noncurrentVersionTransitions {
            if noncurrentVersionTransitions.isEmpty {
                var noncurrentVersionTransitionsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("NoncurrentVersionTransition"))
                try noncurrentVersionTransitionsContainer.encodeNil()
            } else {
                for noncurrentversiontransition0 in noncurrentVersionTransitions {
                    var noncurrentVersionTransitionsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NoncurrentVersionTransition"))
                    try noncurrentVersionTransitionsContainer0.encode(noncurrentversiontransition0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let transitions = transitions {
            if transitions.isEmpty {
                var transitionsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Transition"))
                try transitionsContainer.encodeNil()
            } else {
                for transition0 in transitions {
                    var transitionsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Transition"))
                    try transitionsContainer0.encode(transition0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.LifecycleExpiration.self, forKey: .expiration)
        expiration = expirationDecoded
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.LifecycleRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ExpirationStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.transitions) {
            let transitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .transitions)
            if transitionsWrappedContainer != nil {
                let transitionsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Transition].self, forKey: .transitions)
                var transitionsBuffer:[S3ClientTypes.Transition]? = nil
                if let transitionsContainer = transitionsContainer {
                    transitionsBuffer = [S3ClientTypes.Transition]()
                    for structureContainer0 in transitionsContainer {
                        transitionsBuffer?.append(structureContainer0)
                    }
                }
                transitions = transitionsBuffer
            } else {
                transitions = []
            }
        } else {
            transitions = nil
        }
        if containerValues.contains(.noncurrentVersionTransitions) {
            let noncurrentVersionTransitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .noncurrentVersionTransitions)
            if noncurrentVersionTransitionsWrappedContainer != nil {
                let noncurrentVersionTransitionsContainer = try containerValues.decodeIfPresent([S3ClientTypes.NoncurrentVersionTransition].self, forKey: .noncurrentVersionTransitions)
                var noncurrentVersionTransitionsBuffer:[S3ClientTypes.NoncurrentVersionTransition]? = nil
                if let noncurrentVersionTransitionsContainer = noncurrentVersionTransitionsContainer {
                    noncurrentVersionTransitionsBuffer = [S3ClientTypes.NoncurrentVersionTransition]()
                    for structureContainer0 in noncurrentVersionTransitionsContainer {
                        noncurrentVersionTransitionsBuffer?.append(structureContainer0)
                    }
                }
                noncurrentVersionTransitions = noncurrentVersionTransitionsBuffer
            } else {
                noncurrentVersionTransitions = []
            }
        } else {
            noncurrentVersionTransitions = nil
        }
        let noncurrentVersionExpirationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.NoncurrentVersionExpiration.self, forKey: .noncurrentVersionExpiration)
        noncurrentVersionExpiration = noncurrentVersionExpirationDecoded
        let abortIncompleteMultipartUploadDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AbortIncompleteMultipartUpload.self, forKey: .abortIncompleteMultipartUpload)
        abortIncompleteMultipartUpload = abortIncompleteMultipartUploadDecoded
    }
}

extension S3ClientTypes.LifecycleRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A lifecycle rule for individual objects in an Amazon S3 bucket.
    public struct LifecycleRule: Swift.Equatable {
        /// Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see [ Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide.
        public var abortIncompleteMultipartUpload: S3ClientTypes.AbortIncompleteMultipartUpload?
        /// Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker.
        public var expiration: S3ClientTypes.LifecycleExpiration?
        /// The Filter is used to identify objects that a Lifecycle Rule applies to. A Filter must have exactly one of Prefix, Tag, or And specified. Filter is required if the LifecycleRule does not containt a Prefix element.
        public var filter: S3ClientTypes.LifecycleRuleFilter?
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        public var iD: Swift.String?
        /// Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.
        public var noncurrentVersionExpiration: S3ClientTypes.NoncurrentVersionExpiration?
        /// Specifies the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to a specific storage class at a set period in the object's lifetime.
        public var noncurrentVersionTransitions: [S3ClientTypes.NoncurrentVersionTransition]?
        /// Prefix identifying one or more objects to which the rule applies. This is no longer used; use Filter instead. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        @available(*, deprecated)
        public var `prefix`: Swift.String?
        /// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
        /// This member is required.
        public var status: S3ClientTypes.ExpirationStatus?
        /// Specifies when an Amazon S3 object transitions to a specified storage class.
        public var transitions: [S3ClientTypes.Transition]?

        public init (
            abortIncompleteMultipartUpload: S3ClientTypes.AbortIncompleteMultipartUpload? = nil,
            expiration: S3ClientTypes.LifecycleExpiration? = nil,
            filter: S3ClientTypes.LifecycleRuleFilter? = nil,
            iD: Swift.String? = nil,
            noncurrentVersionExpiration: S3ClientTypes.NoncurrentVersionExpiration? = nil,
            noncurrentVersionTransitions: [S3ClientTypes.NoncurrentVersionTransition]? = nil,
            `prefix`: Swift.String? = nil,
            status: S3ClientTypes.ExpirationStatus? = nil,
            transitions: [S3ClientTypes.Transition]? = nil
        )
        {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expiration = expiration
            self.filter = filter
            self.iD = iD
            self.noncurrentVersionExpiration = noncurrentVersionExpiration
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.`prefix` = `prefix`
            self.status = status
            self.transitions = transitions
        }
    }

}

extension S3ClientTypes.LifecycleRuleAndOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectSizeGreaterThan = "ObjectSizeGreaterThan"
        case objectSizeLessThan = "ObjectSizeLessThan"
        case `prefix` = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if objectSizeGreaterThan != 0 {
            try container.encode(objectSizeGreaterThan, forKey: ClientRuntime.Key("ObjectSizeGreaterThan"))
        }
        if objectSizeLessThan != 0 {
            try container.encode(objectSizeLessThan, forKey: ClientRuntime.Key("ObjectSizeLessThan"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .tags)
                var tagsBuffer:[S3ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let objectSizeGreaterThanDecoded = try containerValues.decode(Swift.Int.self, forKey: .objectSizeGreaterThan)
        objectSizeGreaterThan = objectSizeGreaterThanDecoded
        let objectSizeLessThanDecoded = try containerValues.decode(Swift.Int.self, forKey: .objectSizeLessThan)
        objectSizeLessThan = objectSizeLessThanDecoded
    }
}

extension S3ClientTypes.LifecycleRuleAndOperator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// This is used in a Lifecycle Rule Filter to apply a logical AND to two or more predicates. The Lifecycle Rule will apply to any object matching all of the predicates configured inside the And operator.
    public struct LifecycleRuleAndOperator: Swift.Equatable {
        /// Minimum object size to which the rule applies.
        public var objectSizeGreaterThan: Swift.Int
        /// Maximum object size to which the rule applies.
        public var objectSizeLessThan: Swift.Int
        /// Prefix identifying one or more objects to which the rule applies.
        public var `prefix`: Swift.String?
        /// All of these tags must exist in the object's tag set in order for the rule to apply.
        public var tags: [S3ClientTypes.Tag]?

        public init (
            objectSizeGreaterThan: Swift.Int = 0,
            objectSizeLessThan: Swift.Int = 0,
            `prefix`: Swift.String? = nil,
            tags: [S3ClientTypes.Tag]? = nil
        )
        {
            self.objectSizeGreaterThan = objectSizeGreaterThan
            self.objectSizeLessThan = objectSizeLessThan
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ClientTypes.LifecycleRuleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case objectsizegreaterthan = "ObjectSizeGreaterThan"
        case objectsizelessthan = "ObjectSizeLessThan"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        switch self {
            case let .and(and):
                try container.encode(and, forKey: ClientRuntime.Key("And"))
            case let .objectsizegreaterthan(objectsizegreaterthan):
                try container.encode(objectsizegreaterthan, forKey: ClientRuntime.Key("ObjectSizeGreaterThan"))
            case let .objectsizelessthan(objectsizelessthan):
                try container.encode(objectsizelessthan, forKey: ClientRuntime.Key("ObjectSizeLessThan"))
            case let .prefix(prefix):
                try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
            case let .tag(tag):
                try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: ClientRuntime.Key("sdkUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .prefix:
                let prefixDecoded = try containerValues.decode(Swift.String.self, forKey: .prefix)
                self = .prefix(prefixDecoded)
            case .tag:
                let tagDecoded = try containerValues.decode(S3ClientTypes.Tag.self, forKey: .tag)
                self = .tag(tagDecoded)
            case .objectsizegreaterthan:
                let objectsizegreaterthanDecoded = try containerValues.decode(Swift.Int.self, forKey: .objectsizegreaterthan)
                self = .objectsizegreaterthan(objectsizegreaterthanDecoded)
            case .objectsizelessthan:
                let objectsizelessthanDecoded = try containerValues.decode(Swift.Int.self, forKey: .objectsizelessthan)
                self = .objectsizelessthan(objectsizelessthanDecoded)
            case .and:
                let andDecoded = try containerValues.decode(S3ClientTypes.LifecycleRuleAndOperator.self, forKey: .and)
                self = .and(andDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ClientTypes {
    /// The Filter is used to identify objects that a Lifecycle Rule applies to. A Filter must have exactly one of Prefix, Tag, or And specified.
    public enum LifecycleRuleFilter: Swift.Equatable {
        /// Prefix identifying one or more objects to which the rule applies. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        case prefix(Swift.String)
        /// This tag must exist in the object's tag set in order for the rule to apply.
        case tag(S3ClientTypes.Tag)
        /// Minimum object size to which the rule applies.
        case objectsizegreaterthan(Swift.Int)
        /// Maximum object size to which the rule applies.
        case objectsizelessthan(Swift.Int)
        /// This is used in a Lifecycle Rule Filter to apply a logical AND to two or more predicates. The Lifecycle Rule will apply to any object matching all of the predicates configured inside the And operator.
        case and(S3ClientTypes.LifecycleRuleAndOperator)
        case sdkUnknown(Swift.String)
    }

}

extension ListBucketAnalyticsConfigurationsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension ListBucketAnalyticsConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "analytics", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "ListBucketAnalyticsConfigurations"))
        if let continuationToken = continuationToken {
            let continuationTokenQueryItem = ClientRuntime.URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListBucketAnalyticsConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListBucketAnalyticsConfigurationsInput: Swift.Equatable {
    /// The name of the bucket from which analytics configurations are retrieved.
    /// This member is required.
    public var bucket: Swift.String?
    /// The ContinuationToken that represents a placeholder from where this request should begin.
    public var continuationToken: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        continuationToken: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct ListBucketAnalyticsConfigurationsInputBody: Swift.Equatable {
}

extension ListBucketAnalyticsConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBucketAnalyticsConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListBucketAnalyticsConfigurationsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListBucketAnalyticsConfigurationsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListBucketAnalyticsConfigurationsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListBucketAnalyticsConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListBucketAnalyticsConfigurationsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListBucketAnalyticsConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketAnalyticsConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBucketAnalyticsConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyticsConfigurationList = output.analyticsConfigurationList
            self.continuationToken = output.continuationToken
            self.isTruncated = output.isTruncated
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.analyticsConfigurationList = nil
            self.continuationToken = nil
            self.isTruncated = false
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketAnalyticsConfigurationsOutputResponse: Swift.Equatable {
    /// The list of analytics configurations for a bucket.
    public var analyticsConfigurationList: [S3ClientTypes.AnalyticsConfiguration]?
    /// The marker that is used as a starting point for this analytics configuration list response. This value is present if it was sent in the request.
    public var continuationToken: Swift.String?
    /// Indicates whether the returned list of analytics configurations is complete. A value of true indicates that the list is not complete and the NextContinuationToken will be provided for a subsequent request.
    public var isTruncated: Swift.Bool
    /// NextContinuationToken is sent when isTruncated is true, which indicates that there are more analytics configurations to list. The next request must include this NextContinuationToken. The token is obfuscated and is not a usable value.
    public var nextContinuationToken: Swift.String?

    public init (
        analyticsConfigurationList: [S3ClientTypes.AnalyticsConfiguration]? = nil,
        continuationToken: Swift.String? = nil,
        isTruncated: Swift.Bool = false,
        nextContinuationToken: Swift.String? = nil
    )
    {
        self.analyticsConfigurationList = analyticsConfigurationList
        self.continuationToken = continuationToken
        self.isTruncated = isTruncated
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketAnalyticsConfigurationsOutputResponseBody: Swift.Equatable {
    let isTruncated: Swift.Bool
    let continuationToken: Swift.String?
    let nextContinuationToken: Swift.String?
    let analyticsConfigurationList: [S3ClientTypes.AnalyticsConfiguration]?
}

extension ListBucketAnalyticsConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyticsConfigurationList = "AnalyticsConfiguration"
        case continuationToken = "ContinuationToken"
        case isTruncated = "IsTruncated"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        if containerValues.contains(.analyticsConfigurationList) {
            let analyticsConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .analyticsConfigurationList)
            if analyticsConfigurationListWrappedContainer != nil {
                let analyticsConfigurationListContainer = try containerValues.decodeIfPresent([S3ClientTypes.AnalyticsConfiguration].self, forKey: .analyticsConfigurationList)
                var analyticsConfigurationListBuffer:[S3ClientTypes.AnalyticsConfiguration]? = nil
                if let analyticsConfigurationListContainer = analyticsConfigurationListContainer {
                    analyticsConfigurationListBuffer = [S3ClientTypes.AnalyticsConfiguration]()
                    for structureContainer0 in analyticsConfigurationListContainer {
                        analyticsConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                analyticsConfigurationList = analyticsConfigurationListBuffer
            } else {
                analyticsConfigurationList = []
            }
        } else {
            analyticsConfigurationList = nil
        }
    }
}

extension ListBucketIntelligentTieringConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "intelligent-tiering", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "ListBucketIntelligentTieringConfigurations"))
        if let continuationToken = continuationToken {
            let continuationTokenQueryItem = ClientRuntime.URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListBucketIntelligentTieringConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListBucketIntelligentTieringConfigurationsInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The ContinuationToken that represents a placeholder from where this request should begin.
    public var continuationToken: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        continuationToken: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
    }
}

struct ListBucketIntelligentTieringConfigurationsInputBody: Swift.Equatable {
}

extension ListBucketIntelligentTieringConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBucketIntelligentTieringConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListBucketIntelligentTieringConfigurationsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListBucketIntelligentTieringConfigurationsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListBucketIntelligentTieringConfigurationsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListBucketIntelligentTieringConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListBucketIntelligentTieringConfigurationsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListBucketIntelligentTieringConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketIntelligentTieringConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBucketIntelligentTieringConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.continuationToken = output.continuationToken
            self.intelligentTieringConfigurationList = output.intelligentTieringConfigurationList
            self.isTruncated = output.isTruncated
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.continuationToken = nil
            self.intelligentTieringConfigurationList = nil
            self.isTruncated = false
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketIntelligentTieringConfigurationsOutputResponse: Swift.Equatable {
    /// The ContinuationToken that represents a placeholder from where this request should begin.
    public var continuationToken: Swift.String?
    /// The list of S3 Intelligent-Tiering configurations for a bucket.
    public var intelligentTieringConfigurationList: [S3ClientTypes.IntelligentTieringConfiguration]?
    /// Indicates whether the returned list of analytics configurations is complete. A value of true indicates that the list is not complete and the NextContinuationToken will be provided for a subsequent request.
    public var isTruncated: Swift.Bool
    /// The marker used to continue this inventory configuration listing. Use the NextContinuationToken from this response to continue the listing in a subsequent request. The continuation token is an opaque value that Amazon S3 understands.
    public var nextContinuationToken: Swift.String?

    public init (
        continuationToken: Swift.String? = nil,
        intelligentTieringConfigurationList: [S3ClientTypes.IntelligentTieringConfiguration]? = nil,
        isTruncated: Swift.Bool = false,
        nextContinuationToken: Swift.String? = nil
    )
    {
        self.continuationToken = continuationToken
        self.intelligentTieringConfigurationList = intelligentTieringConfigurationList
        self.isTruncated = isTruncated
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketIntelligentTieringConfigurationsOutputResponseBody: Swift.Equatable {
    let isTruncated: Swift.Bool
    let continuationToken: Swift.String?
    let nextContinuationToken: Swift.String?
    let intelligentTieringConfigurationList: [S3ClientTypes.IntelligentTieringConfiguration]?
}

extension ListBucketIntelligentTieringConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuationToken = "ContinuationToken"
        case intelligentTieringConfigurationList = "IntelligentTieringConfiguration"
        case isTruncated = "IsTruncated"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        if containerValues.contains(.intelligentTieringConfigurationList) {
            let intelligentTieringConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .intelligentTieringConfigurationList)
            if intelligentTieringConfigurationListWrappedContainer != nil {
                let intelligentTieringConfigurationListContainer = try containerValues.decodeIfPresent([S3ClientTypes.IntelligentTieringConfiguration].self, forKey: .intelligentTieringConfigurationList)
                var intelligentTieringConfigurationListBuffer:[S3ClientTypes.IntelligentTieringConfiguration]? = nil
                if let intelligentTieringConfigurationListContainer = intelligentTieringConfigurationListContainer {
                    intelligentTieringConfigurationListBuffer = [S3ClientTypes.IntelligentTieringConfiguration]()
                    for structureContainer0 in intelligentTieringConfigurationListContainer {
                        intelligentTieringConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                intelligentTieringConfigurationList = intelligentTieringConfigurationListBuffer
            } else {
                intelligentTieringConfigurationList = []
            }
        } else {
            intelligentTieringConfigurationList = nil
        }
    }
}

extension ListBucketInventoryConfigurationsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension ListBucketInventoryConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "inventory", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "ListBucketInventoryConfigurations"))
        if let continuationToken = continuationToken {
            let continuationTokenQueryItem = ClientRuntime.URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListBucketInventoryConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListBucketInventoryConfigurationsInput: Swift.Equatable {
    /// The name of the bucket containing the inventory configurations to retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The marker used to continue an inventory configuration listing that has been truncated. Use the NextContinuationToken from a previously truncated list response to continue the listing. The continuation token is an opaque value that Amazon S3 understands.
    public var continuationToken: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        continuationToken: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct ListBucketInventoryConfigurationsInputBody: Swift.Equatable {
}

extension ListBucketInventoryConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBucketInventoryConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListBucketInventoryConfigurationsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListBucketInventoryConfigurationsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListBucketInventoryConfigurationsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListBucketInventoryConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListBucketInventoryConfigurationsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListBucketInventoryConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketInventoryConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBucketInventoryConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.continuationToken = output.continuationToken
            self.inventoryConfigurationList = output.inventoryConfigurationList
            self.isTruncated = output.isTruncated
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.continuationToken = nil
            self.inventoryConfigurationList = nil
            self.isTruncated = false
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketInventoryConfigurationsOutputResponse: Swift.Equatable {
    /// If sent in the request, the marker that is used as a starting point for this inventory configuration list response.
    public var continuationToken: Swift.String?
    /// The list of inventory configurations for a bucket.
    public var inventoryConfigurationList: [S3ClientTypes.InventoryConfiguration]?
    /// Tells whether the returned list of inventory configurations is complete. A value of true indicates that the list is not complete and the NextContinuationToken is provided for a subsequent request.
    public var isTruncated: Swift.Bool
    /// The marker used to continue this inventory configuration listing. Use the NextContinuationToken from this response to continue the listing in a subsequent request. The continuation token is an opaque value that Amazon S3 understands.
    public var nextContinuationToken: Swift.String?

    public init (
        continuationToken: Swift.String? = nil,
        inventoryConfigurationList: [S3ClientTypes.InventoryConfiguration]? = nil,
        isTruncated: Swift.Bool = false,
        nextContinuationToken: Swift.String? = nil
    )
    {
        self.continuationToken = continuationToken
        self.inventoryConfigurationList = inventoryConfigurationList
        self.isTruncated = isTruncated
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketInventoryConfigurationsOutputResponseBody: Swift.Equatable {
    let continuationToken: Swift.String?
    let inventoryConfigurationList: [S3ClientTypes.InventoryConfiguration]?
    let isTruncated: Swift.Bool
    let nextContinuationToken: Swift.String?
}

extension ListBucketInventoryConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuationToken = "ContinuationToken"
        case inventoryConfigurationList = "InventoryConfiguration"
        case isTruncated = "IsTruncated"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        if containerValues.contains(.inventoryConfigurationList) {
            let inventoryConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .inventoryConfigurationList)
            if inventoryConfigurationListWrappedContainer != nil {
                let inventoryConfigurationListContainer = try containerValues.decodeIfPresent([S3ClientTypes.InventoryConfiguration].self, forKey: .inventoryConfigurationList)
                var inventoryConfigurationListBuffer:[S3ClientTypes.InventoryConfiguration]? = nil
                if let inventoryConfigurationListContainer = inventoryConfigurationListContainer {
                    inventoryConfigurationListBuffer = [S3ClientTypes.InventoryConfiguration]()
                    for structureContainer0 in inventoryConfigurationListContainer {
                        inventoryConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                inventoryConfigurationList = inventoryConfigurationListBuffer
            } else {
                inventoryConfigurationList = []
            }
        } else {
            inventoryConfigurationList = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
    }
}

extension ListBucketMetricsConfigurationsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension ListBucketMetricsConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "metrics", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "ListBucketMetricsConfigurations"))
        if let continuationToken = continuationToken {
            let continuationTokenQueryItem = ClientRuntime.URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListBucketMetricsConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListBucketMetricsConfigurationsInput: Swift.Equatable {
    /// The name of the bucket containing the metrics configurations to retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The marker that is used to continue a metrics configuration listing that has been truncated. Use the NextContinuationToken from a previously truncated list response to continue the listing. The continuation token is an opaque value that Amazon S3 understands.
    public var continuationToken: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        continuationToken: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct ListBucketMetricsConfigurationsInputBody: Swift.Equatable {
}

extension ListBucketMetricsConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBucketMetricsConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListBucketMetricsConfigurationsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListBucketMetricsConfigurationsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListBucketMetricsConfigurationsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListBucketMetricsConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListBucketMetricsConfigurationsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListBucketMetricsConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketMetricsConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBucketMetricsConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.continuationToken = output.continuationToken
            self.isTruncated = output.isTruncated
            self.metricsConfigurationList = output.metricsConfigurationList
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.continuationToken = nil
            self.isTruncated = false
            self.metricsConfigurationList = nil
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketMetricsConfigurationsOutputResponse: Swift.Equatable {
    /// The marker that is used as a starting point for this metrics configuration list response. This value is present if it was sent in the request.
    public var continuationToken: Swift.String?
    /// Indicates whether the returned list of metrics configurations is complete. A value of true indicates that the list is not complete and the NextContinuationToken will be provided for a subsequent request.
    public var isTruncated: Swift.Bool
    /// The list of metrics configurations for a bucket.
    public var metricsConfigurationList: [S3ClientTypes.MetricsConfiguration]?
    /// The marker used to continue a metrics configuration listing that has been truncated. Use the NextContinuationToken from a previously truncated list response to continue the listing. The continuation token is an opaque value that Amazon S3 understands.
    public var nextContinuationToken: Swift.String?

    public init (
        continuationToken: Swift.String? = nil,
        isTruncated: Swift.Bool = false,
        metricsConfigurationList: [S3ClientTypes.MetricsConfiguration]? = nil,
        nextContinuationToken: Swift.String? = nil
    )
    {
        self.continuationToken = continuationToken
        self.isTruncated = isTruncated
        self.metricsConfigurationList = metricsConfigurationList
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketMetricsConfigurationsOutputResponseBody: Swift.Equatable {
    let isTruncated: Swift.Bool
    let continuationToken: Swift.String?
    let nextContinuationToken: Swift.String?
    let metricsConfigurationList: [S3ClientTypes.MetricsConfiguration]?
}

extension ListBucketMetricsConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuationToken = "ContinuationToken"
        case isTruncated = "IsTruncated"
        case metricsConfigurationList = "MetricsConfiguration"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        if containerValues.contains(.metricsConfigurationList) {
            let metricsConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .metricsConfigurationList)
            if metricsConfigurationListWrappedContainer != nil {
                let metricsConfigurationListContainer = try containerValues.decodeIfPresent([S3ClientTypes.MetricsConfiguration].self, forKey: .metricsConfigurationList)
                var metricsConfigurationListBuffer:[S3ClientTypes.MetricsConfiguration]? = nil
                if let metricsConfigurationListContainer = metricsConfigurationListContainer {
                    metricsConfigurationListBuffer = [S3ClientTypes.MetricsConfiguration]()
                    for structureContainer0 in metricsConfigurationListContainer {
                        metricsConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                metricsConfigurationList = metricsConfigurationListBuffer
            } else {
                metricsConfigurationList = []
            }
        } else {
            metricsConfigurationList = nil
        }
    }
}

extension ListBucketsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBucketsInput: Swift.Equatable {

}

struct ListBucketsInputBody: Swift.Equatable {
}

extension ListBucketsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBucketsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListBucketsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListBucketsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListBucketsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListBucketsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListBucketsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListBucketsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBucketsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buckets = output.buckets
            self.owner = output.owner
        } else {
            self.buckets = nil
            self.owner = nil
        }
    }
}

public struct ListBucketsOutputResponse: Swift.Equatable {
    /// The list of buckets owned by the requestor.
    public var buckets: [S3ClientTypes.Bucket]?
    /// The owner of the buckets listed.
    public var owner: S3ClientTypes.Owner?

    public init (
        buckets: [S3ClientTypes.Bucket]? = nil,
        owner: S3ClientTypes.Owner? = nil
    )
    {
        self.buckets = buckets
        self.owner = owner
    }
}

struct ListBucketsOutputResponseBody: Swift.Equatable {
    let buckets: [S3ClientTypes.Bucket]?
    let owner: S3ClientTypes.Owner?
}

extension ListBucketsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "Buckets"
        case owner = "Owner"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Bucket{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Bucket>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([S3ClientTypes.Bucket].self, forKey: .member)
                var bucketsBuffer:[S3ClientTypes.Bucket]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [S3ClientTypes.Bucket]()
                    for structureContainer0 in bucketsContainer {
                        bucketsBuffer?.append(structureContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension ListMultipartUploadsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension ListMultipartUploadsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "uploads", value: nil))
        if let uploadIdMarker = uploadIdMarker {
            let uploadIdMarkerQueryItem = ClientRuntime.URLQueryItem(name: "upload-id-marker".urlPercentEncoding(), value: Swift.String(uploadIdMarker).urlPercentEncoding())
            items.append(uploadIdMarkerQueryItem)
        }
        if let delimiter = delimiter {
            let delimiterQueryItem = ClientRuntime.URLQueryItem(name: "delimiter".urlPercentEncoding(), value: Swift.String(delimiter).urlPercentEncoding())
            items.append(delimiterQueryItem)
        }
        if maxUploads != 0 {
            let maxUploadsQueryItem = ClientRuntime.URLQueryItem(name: "max-uploads".urlPercentEncoding(), value: Swift.String(maxUploads).urlPercentEncoding())
            items.append(maxUploadsQueryItem)
        }
        if let encodingType = encodingType {
            let encodingTypeQueryItem = ClientRuntime.URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: Swift.String(encodingType.rawValue).urlPercentEncoding())
            items.append(encodingTypeQueryItem)
        }
        if let `prefix` = `prefix` {
            let prefixQueryItem = ClientRuntime.URLQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let keyMarker = keyMarker {
            let keyMarkerQueryItem = ClientRuntime.URLQueryItem(name: "key-marker".urlPercentEncoding(), value: Swift.String(keyMarker).urlPercentEncoding())
            items.append(keyMarkerQueryItem)
        }
        return items
    }
}

extension ListMultipartUploadsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListMultipartUploadsInput: Swift.Equatable {
    /// The name of the bucket to which the multipart upload was initiated. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Character you use to group keys. All keys that contain the same string between the prefix, if specified, and the first occurrence of the delimiter after the prefix are grouped under a single result element, CommonPrefixes. If you don't specify the prefix parameter, then the substring starts at the beginning of the key. The keys that are grouped under CommonPrefixes result element are not returned elsewhere in the response.
    public var delimiter: Swift.String?
    /// Requests Amazon S3 to encode the object keys in the response and specifies the encoding method to use. An object key may contain any Unicode character; however, XML 1.0 parser cannot parse some characters, such as characters with an ASCII value from 0 to 10. For characters that are not supported in XML 1.0, you can add this parameter to request that Amazon S3 encode the keys in the response.
    public var encodingType: S3ClientTypes.EncodingType?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Together with upload-id-marker, this parameter specifies the multipart upload after which listing should begin. If upload-id-marker is not specified, only the keys lexicographically greater than the specified key-marker will be included in the list. If upload-id-marker is specified, any multipart uploads for a key equal to the key-marker might also be included, provided those multipart uploads have upload IDs lexicographically greater than the specified upload-id-marker.
    public var keyMarker: Swift.String?
    /// Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response body. 1,000 is the maximum number of uploads that can be returned in a response.
    public var maxUploads: Swift.Int
    /// Lists in-progress uploads only for those keys that begin with the specified prefix. You can use prefixes to separate a bucket into different grouping of keys. (You can think of using prefix to make groups in the same way you'd use a folder in a file system.)
    public var `prefix`: Swift.String?
    /// Together with key-marker, specifies the multipart upload after which listing should begin. If key-marker is not specified, the upload-id-marker parameter is ignored. Otherwise, any multipart uploads for a key equal to the key-marker might be included in the list only if they have an upload ID lexicographically greater than the specified upload-id-marker.
    public var uploadIdMarker: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        expectedBucketOwner: Swift.String? = nil,
        keyMarker: Swift.String? = nil,
        maxUploads: Swift.Int = 0,
        `prefix`: Swift.String? = nil,
        uploadIdMarker: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.keyMarker = keyMarker
        self.maxUploads = maxUploads
        self.`prefix` = `prefix`
        self.uploadIdMarker = uploadIdMarker
    }
}

struct ListMultipartUploadsInputBody: Swift.Equatable {
}

extension ListMultipartUploadsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMultipartUploadsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListMultipartUploadsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListMultipartUploadsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListMultipartUploadsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListMultipartUploadsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListMultipartUploadsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListMultipartUploadsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMultipartUploadsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMultipartUploadsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`prefix` = output.`prefix`
            self.bucket = output.bucket
            self.commonPrefixes = output.commonPrefixes
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.keyMarker = output.keyMarker
            self.maxUploads = output.maxUploads
            self.nextKeyMarker = output.nextKeyMarker
            self.nextUploadIdMarker = output.nextUploadIdMarker
            self.uploadIdMarker = output.uploadIdMarker
            self.uploads = output.uploads
        } else {
            self.bucket = nil
            self.commonPrefixes = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.keyMarker = nil
            self.maxUploads = 0
            self.nextKeyMarker = nil
            self.nextUploadIdMarker = nil
            self.`prefix` = nil
            self.uploadIdMarker = nil
            self.uploads = nil
        }
    }
}

public struct ListMultipartUploadsOutputResponse: Swift.Equatable {
    /// The name of the bucket to which the multipart upload was initiated. Does not return the access point ARN or access point alias if used.
    public var bucket: Swift.String?
    /// If you specify a delimiter in the request, then the result returns each distinct key prefix containing the delimiter in a CommonPrefixes element. The distinct key prefixes are returned in the Prefix child element.
    public var commonPrefixes: [S3ClientTypes.CommonPrefix]?
    /// Contains the delimiter you specified in the request. If you don't specify a delimiter in your request, this element is absent from the response.
    public var delimiter: Swift.String?
    /// Encoding type used by Amazon S3 to encode object keys in the response. If you specify encoding-type request parameter, Amazon S3 includes this element in the response, and returns encoded key name values in the following response elements: Delimiter, KeyMarker, Prefix, NextKeyMarker, Key.
    public var encodingType: S3ClientTypes.EncodingType?
    /// Indicates whether the returned list of multipart uploads is truncated. A value of true indicates that the list was truncated. The list can be truncated if the number of multipart uploads exceeds the limit allowed or specified by max uploads.
    public var isTruncated: Swift.Bool
    /// The key at or after which the listing began.
    public var keyMarker: Swift.String?
    /// Maximum number of multipart uploads that could have been included in the response.
    public var maxUploads: Swift.Int
    /// When a list is truncated, this element specifies the value that should be used for the key-marker request parameter in a subsequent request.
    public var nextKeyMarker: Swift.String?
    /// When a list is truncated, this element specifies the value that should be used for the upload-id-marker request parameter in a subsequent request.
    public var nextUploadIdMarker: Swift.String?
    /// When a prefix is provided in the request, this field contains the specified prefix. The result contains only keys starting with the specified prefix.
    public var `prefix`: Swift.String?
    /// Upload ID after which listing began.
    public var uploadIdMarker: Swift.String?
    /// Container for elements related to a particular multipart upload. A response can contain zero or more Upload elements.
    public var uploads: [S3ClientTypes.MultipartUpload]?

    public init (
        bucket: Swift.String? = nil,
        commonPrefixes: [S3ClientTypes.CommonPrefix]? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        isTruncated: Swift.Bool = false,
        keyMarker: Swift.String? = nil,
        maxUploads: Swift.Int = 0,
        nextKeyMarker: Swift.String? = nil,
        nextUploadIdMarker: Swift.String? = nil,
        `prefix`: Swift.String? = nil,
        uploadIdMarker: Swift.String? = nil,
        uploads: [S3ClientTypes.MultipartUpload]? = nil
    )
    {
        self.bucket = bucket
        self.commonPrefixes = commonPrefixes
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.keyMarker = keyMarker
        self.maxUploads = maxUploads
        self.nextKeyMarker = nextKeyMarker
        self.nextUploadIdMarker = nextUploadIdMarker
        self.`prefix` = `prefix`
        self.uploadIdMarker = uploadIdMarker
        self.uploads = uploads
    }
}

struct ListMultipartUploadsOutputResponseBody: Swift.Equatable {
    let bucket: Swift.String?
    let keyMarker: Swift.String?
    let uploadIdMarker: Swift.String?
    let nextKeyMarker: Swift.String?
    let `prefix`: Swift.String?
    let delimiter: Swift.String?
    let nextUploadIdMarker: Swift.String?
    let maxUploads: Swift.Int
    let isTruncated: Swift.Bool
    let uploads: [S3ClientTypes.MultipartUpload]?
    let commonPrefixes: [S3ClientTypes.CommonPrefix]?
    let encodingType: S3ClientTypes.EncodingType?
}

extension ListMultipartUploadsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case commonPrefixes = "CommonPrefixes"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyMarker = "KeyMarker"
        case maxUploads = "MaxUploads"
        case nextKeyMarker = "NextKeyMarker"
        case nextUploadIdMarker = "NextUploadIdMarker"
        case `prefix` = "Prefix"
        case uploadIdMarker = "UploadIdMarker"
        case uploads = "Upload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyMarker)
        keyMarker = keyMarkerDecoded
        let uploadIdMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadIdMarker)
        uploadIdMarker = uploadIdMarkerDecoded
        let nextKeyMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextKeyMarker)
        nextKeyMarker = nextKeyMarkerDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let nextUploadIdMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextUploadIdMarker)
        nextUploadIdMarker = nextUploadIdMarkerDecoded
        let maxUploadsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxUploads)
        maxUploads = maxUploadsDecoded
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.uploads) {
            let uploadsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .uploads)
            if uploadsWrappedContainer != nil {
                let uploadsContainer = try containerValues.decodeIfPresent([S3ClientTypes.MultipartUpload].self, forKey: .uploads)
                var uploadsBuffer:[S3ClientTypes.MultipartUpload]? = nil
                if let uploadsContainer = uploadsContainer {
                    uploadsBuffer = [S3ClientTypes.MultipartUpload]()
                    for structureContainer0 in uploadsContainer {
                        uploadsBuffer?.append(structureContainer0)
                    }
                }
                uploads = uploadsBuffer
            } else {
                uploads = []
            }
        } else {
            uploads = nil
        }
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([S3ClientTypes.CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[S3ClientTypes.CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [S3ClientTypes.CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}

extension ListObjectVersionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension ListObjectVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "versions", value: nil))
        if let versionIdMarker = versionIdMarker {
            let versionIdMarkerQueryItem = ClientRuntime.URLQueryItem(name: "version-id-marker".urlPercentEncoding(), value: Swift.String(versionIdMarker).urlPercentEncoding())
            items.append(versionIdMarkerQueryItem)
        }
        if let delimiter = delimiter {
            let delimiterQueryItem = ClientRuntime.URLQueryItem(name: "delimiter".urlPercentEncoding(), value: Swift.String(delimiter).urlPercentEncoding())
            items.append(delimiterQueryItem)
        }
        if let encodingType = encodingType {
            let encodingTypeQueryItem = ClientRuntime.URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: Swift.String(encodingType.rawValue).urlPercentEncoding())
            items.append(encodingTypeQueryItem)
        }
        if let `prefix` = `prefix` {
            let prefixQueryItem = ClientRuntime.URLQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if maxKeys != 0 {
            let maxKeysQueryItem = ClientRuntime.URLQueryItem(name: "max-keys".urlPercentEncoding(), value: Swift.String(maxKeys).urlPercentEncoding())
            items.append(maxKeysQueryItem)
        }
        if let keyMarker = keyMarker {
            let keyMarkerQueryItem = ClientRuntime.URLQueryItem(name: "key-marker".urlPercentEncoding(), value: Swift.String(keyMarker).urlPercentEncoding())
            items.append(keyMarkerQueryItem)
        }
        return items
    }
}

extension ListObjectVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListObjectVersionsInput: Swift.Equatable {
    /// The bucket name that contains the objects.
    /// This member is required.
    public var bucket: Swift.String?
    /// A delimiter is a character that you specify to group keys. All keys that contain the same string between the prefix and the first occurrence of the delimiter are grouped under a single result element in CommonPrefixes. These groups are counted as one result against the max-keys limitation. These keys are not returned elsewhere in the response.
    public var delimiter: Swift.String?
    /// Requests Amazon S3 to encode the object keys in the response and specifies the encoding method to use. An object key may contain any Unicode character; however, XML 1.0 parser cannot parse some characters, such as characters with an ASCII value from 0 to 10. For characters that are not supported in XML 1.0, you can add this parameter to request that Amazon S3 encode the keys in the response.
    public var encodingType: S3ClientTypes.EncodingType?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Specifies the key to start with when listing objects in a bucket.
    public var keyMarker: Swift.String?
    /// Sets the maximum number of keys returned in the response. By default the action returns up to 1,000 key names. The response might contain fewer keys but will never contain more. If additional keys satisfy the search criteria, but were not returned because max-keys was exceeded, the response contains true. To return the additional keys, see key-marker and version-id-marker.
    public var maxKeys: Swift.Int
    /// Use this parameter to select only those keys that begin with the specified prefix. You can use prefixes to separate a bucket into different groupings of keys. (You can think of using prefix to make groups in the same way you'd use a folder in a file system.) You can use prefix with delimiter to roll up numerous objects into a single result under CommonPrefixes.
    public var `prefix`: Swift.String?
    /// Specifies the object version you want to start listing from.
    public var versionIdMarker: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        expectedBucketOwner: Swift.String? = nil,
        keyMarker: Swift.String? = nil,
        maxKeys: Swift.Int = 0,
        `prefix`: Swift.String? = nil,
        versionIdMarker: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.keyMarker = keyMarker
        self.maxKeys = maxKeys
        self.`prefix` = `prefix`
        self.versionIdMarker = versionIdMarker
    }
}

struct ListObjectVersionsInputBody: Swift.Equatable {
}

extension ListObjectVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListObjectVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListObjectVersionsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListObjectVersionsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListObjectVersionsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListObjectVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListObjectVersionsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListObjectVersionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`prefix` = output.`prefix`
            self.commonPrefixes = output.commonPrefixes
            self.deleteMarkers = output.deleteMarkers
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.keyMarker = output.keyMarker
            self.maxKeys = output.maxKeys
            self.name = output.name
            self.nextKeyMarker = output.nextKeyMarker
            self.nextVersionIdMarker = output.nextVersionIdMarker
            self.versionIdMarker = output.versionIdMarker
            self.versions = output.versions
        } else {
            self.commonPrefixes = nil
            self.deleteMarkers = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.keyMarker = nil
            self.maxKeys = 0
            self.name = nil
            self.nextKeyMarker = nil
            self.nextVersionIdMarker = nil
            self.`prefix` = nil
            self.versionIdMarker = nil
            self.versions = nil
        }
    }
}

public struct ListObjectVersionsOutputResponse: Swift.Equatable {
    /// All of the keys rolled up into a common prefix count as a single return when calculating the number of returns.
    public var commonPrefixes: [S3ClientTypes.CommonPrefix]?
    /// Container for an object that is a delete marker.
    public var deleteMarkers: [S3ClientTypes.DeleteMarkerEntry]?
    /// The delimiter grouping the included keys. A delimiter is a character that you specify to group keys. All keys that contain the same string between the prefix and the first occurrence of the delimiter are grouped under a single result element in CommonPrefixes. These groups are counted as one result against the max-keys limitation. These keys are not returned elsewhere in the response.
    public var delimiter: Swift.String?
    /// Encoding type used by Amazon S3 to encode object key names in the XML response. If you specify encoding-type request parameter, Amazon S3 includes this element in the response, and returns encoded key name values in the following response elements: KeyMarker, NextKeyMarker, Prefix, Key, and Delimiter.
    public var encodingType: S3ClientTypes.EncodingType?
    /// A flag that indicates whether Amazon S3 returned all of the results that satisfied the search criteria. If your results were truncated, you can make a follow-up paginated request using the NextKeyMarker and NextVersionIdMarker response parameters as a starting place in another request to return the rest of the results.
    public var isTruncated: Swift.Bool
    /// Marks the last key returned in a truncated response.
    public var keyMarker: Swift.String?
    /// Specifies the maximum number of objects to return.
    public var maxKeys: Swift.Int
    /// The bucket name.
    public var name: Swift.String?
    /// When the number of responses exceeds the value of MaxKeys, NextKeyMarker specifies the first key not returned that satisfies the search criteria. Use this value for the key-marker request parameter in a subsequent request.
    public var nextKeyMarker: Swift.String?
    /// When the number of responses exceeds the value of MaxKeys, NextVersionIdMarker specifies the first object version not returned that satisfies the search criteria. Use this value for the version-id-marker request parameter in a subsequent request.
    public var nextVersionIdMarker: Swift.String?
    /// Selects objects that start with the value supplied by this parameter.
    public var `prefix`: Swift.String?
    /// Marks the last version of the key returned in a truncated response.
    public var versionIdMarker: Swift.String?
    /// Container for version information.
    public var versions: [S3ClientTypes.ObjectVersion]?

    public init (
        commonPrefixes: [S3ClientTypes.CommonPrefix]? = nil,
        deleteMarkers: [S3ClientTypes.DeleteMarkerEntry]? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        isTruncated: Swift.Bool = false,
        keyMarker: Swift.String? = nil,
        maxKeys: Swift.Int = 0,
        name: Swift.String? = nil,
        nextKeyMarker: Swift.String? = nil,
        nextVersionIdMarker: Swift.String? = nil,
        `prefix`: Swift.String? = nil,
        versionIdMarker: Swift.String? = nil,
        versions: [S3ClientTypes.ObjectVersion]? = nil
    )
    {
        self.commonPrefixes = commonPrefixes
        self.deleteMarkers = deleteMarkers
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.keyMarker = keyMarker
        self.maxKeys = maxKeys
        self.name = name
        self.nextKeyMarker = nextKeyMarker
        self.nextVersionIdMarker = nextVersionIdMarker
        self.`prefix` = `prefix`
        self.versionIdMarker = versionIdMarker
        self.versions = versions
    }
}

struct ListObjectVersionsOutputResponseBody: Swift.Equatable {
    let isTruncated: Swift.Bool
    let keyMarker: Swift.String?
    let versionIdMarker: Swift.String?
    let nextKeyMarker: Swift.String?
    let nextVersionIdMarker: Swift.String?
    let versions: [S3ClientTypes.ObjectVersion]?
    let deleteMarkers: [S3ClientTypes.DeleteMarkerEntry]?
    let name: Swift.String?
    let `prefix`: Swift.String?
    let delimiter: Swift.String?
    let maxKeys: Swift.Int
    let commonPrefixes: [S3ClientTypes.CommonPrefix]?
    let encodingType: S3ClientTypes.EncodingType?
}

extension ListObjectVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case deleteMarkers = "DeleteMarker"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyMarker = "KeyMarker"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextKeyMarker = "NextKeyMarker"
        case nextVersionIdMarker = "NextVersionIdMarker"
        case `prefix` = "Prefix"
        case versionIdMarker = "VersionIdMarker"
        case versions = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let keyMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyMarker)
        keyMarker = keyMarkerDecoded
        let versionIdMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionIdMarker)
        versionIdMarker = versionIdMarkerDecoded
        let nextKeyMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextKeyMarker)
        nextKeyMarker = nextKeyMarkerDecoded
        let nextVersionIdMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextVersionIdMarker)
        nextVersionIdMarker = nextVersionIdMarkerDecoded
        if containerValues.contains(.versions) {
            let versionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .versions)
            if versionsWrappedContainer != nil {
                let versionsContainer = try containerValues.decodeIfPresent([S3ClientTypes.ObjectVersion].self, forKey: .versions)
                var versionsBuffer:[S3ClientTypes.ObjectVersion]? = nil
                if let versionsContainer = versionsContainer {
                    versionsBuffer = [S3ClientTypes.ObjectVersion]()
                    for structureContainer0 in versionsContainer {
                        versionsBuffer?.append(structureContainer0)
                    }
                }
                versions = versionsBuffer
            } else {
                versions = []
            }
        } else {
            versions = nil
        }
        if containerValues.contains(.deleteMarkers) {
            let deleteMarkersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .deleteMarkers)
            if deleteMarkersWrappedContainer != nil {
                let deleteMarkersContainer = try containerValues.decodeIfPresent([S3ClientTypes.DeleteMarkerEntry].self, forKey: .deleteMarkers)
                var deleteMarkersBuffer:[S3ClientTypes.DeleteMarkerEntry]? = nil
                if let deleteMarkersContainer = deleteMarkersContainer {
                    deleteMarkersBuffer = [S3ClientTypes.DeleteMarkerEntry]()
                    for structureContainer0 in deleteMarkersContainer {
                        deleteMarkersBuffer?.append(structureContainer0)
                    }
                }
                deleteMarkers = deleteMarkersBuffer
            } else {
                deleteMarkers = []
            }
        } else {
            deleteMarkers = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([S3ClientTypes.CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[S3ClientTypes.CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [S3ClientTypes.CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}

extension ListObjectsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension ListObjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let delimiter = delimiter {
            let delimiterQueryItem = ClientRuntime.URLQueryItem(name: "delimiter".urlPercentEncoding(), value: Swift.String(delimiter).urlPercentEncoding())
            items.append(delimiterQueryItem)
        }
        if let encodingType = encodingType {
            let encodingTypeQueryItem = ClientRuntime.URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: Swift.String(encodingType.rawValue).urlPercentEncoding())
            items.append(encodingTypeQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let `prefix` = `prefix` {
            let prefixQueryItem = ClientRuntime.URLQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if maxKeys != 0 {
            let maxKeysQueryItem = ClientRuntime.URLQueryItem(name: "max-keys".urlPercentEncoding(), value: Swift.String(maxKeys).urlPercentEncoding())
            items.append(maxKeysQueryItem)
        }
        return items
    }
}

extension ListObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListObjectsInput: Swift.Equatable {
    /// The name of the bucket containing the objects. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// A delimiter is a character you use to group keys.
    public var delimiter: Swift.String?
    /// Requests Amazon S3 to encode the object keys in the response and specifies the encoding method to use. An object key may contain any Unicode character; however, XML 1.0 parser cannot parse some characters, such as characters with an ASCII value from 0 to 10. For characters that are not supported in XML 1.0, you can add this parameter to request that Amazon S3 encode the keys in the response.
    public var encodingType: S3ClientTypes.EncodingType?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Marker is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this specified key. Marker can be any key in the bucket.
    public var marker: Swift.String?
    /// Sets the maximum number of keys returned in the response. By default the action returns up to 1,000 key names. The response might contain fewer keys but will never contain more.
    public var maxKeys: Swift.Int
    /// Limits the response to keys that begin with the specified prefix.
    public var `prefix`: Swift.String?
    /// Confirms that the requester knows that she or he will be charged for the list objects request. Bucket owners need not specify this parameter in their requests.
    public var requestPayer: S3ClientTypes.RequestPayer?

    public init (
        bucket: Swift.String? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        expectedBucketOwner: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxKeys: Swift.Int = 0,
        `prefix`: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil
    )
    {
        self.bucket = bucket
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.marker = marker
        self.maxKeys = maxKeys
        self.`prefix` = `prefix`
        self.requestPayer = requestPayer
    }
}

struct ListObjectsInputBody: Swift.Equatable {
}

extension ListObjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListObjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListObjectsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListObjectsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListObjectsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListObjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchBucket" : self = .noSuchBucket(try NoSuchBucket(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListObjectsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListObjectsOutputError: Swift.Error, Swift.Equatable {
    case noSuchBucket(NoSuchBucket)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`prefix` = output.`prefix`
            self.commonPrefixes = output.commonPrefixes
            self.contents = output.contents
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.maxKeys = output.maxKeys
            self.name = output.name
            self.nextMarker = output.nextMarker
        } else {
            self.commonPrefixes = nil
            self.contents = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.marker = nil
            self.maxKeys = 0
            self.name = nil
            self.nextMarker = nil
            self.`prefix` = nil
        }
    }
}

public struct ListObjectsOutputResponse: Swift.Equatable {
    /// All of the keys (up to 1,000) rolled up in a common prefix count as a single return when calculating the number of returns. A response can contain CommonPrefixes only if you specify a delimiter. CommonPrefixes contains all (if there are any) keys between Prefix and the next occurrence of the string specified by the delimiter. CommonPrefixes lists keys that act like subdirectories in the directory specified by Prefix. For example, if the prefix is notes/ and the delimiter is a slash (/) as in notes/summer/july, the common prefix is notes/summer/. All of the keys that roll up into a common prefix count as a single return when calculating the number of returns.
    public var commonPrefixes: [S3ClientTypes.CommonPrefix]?
    /// Metadata about each object returned.
    public var contents: [S3ClientTypes.Object]?
    /// Causes keys that contain the same string between the prefix and the first occurrence of the delimiter to be rolled up into a single result element in the CommonPrefixes collection. These rolled-up keys are not returned elsewhere in the response. Each rolled-up result counts as only one return against the MaxKeys value.
    public var delimiter: Swift.String?
    /// Encoding type used by Amazon S3 to encode object keys in the response.
    public var encodingType: S3ClientTypes.EncodingType?
    /// A flag that indicates whether Amazon S3 returned all of the results that satisfied the search criteria.
    public var isTruncated: Swift.Bool
    /// Indicates where in the bucket listing begins. Marker is included in the response if it was sent with the request.
    public var marker: Swift.String?
    /// The maximum number of keys returned in the response body.
    public var maxKeys: Swift.Int
    /// The bucket name.
    public var name: Swift.String?
    /// When response is truncated (the IsTruncated element value in the response is true), you can use the key name in this field as marker in the subsequent request to get next set of objects. Amazon S3 lists objects in alphabetical order Note: This element is returned only if you have delimiter request parameter specified. If response does not include the NextMarker and it is truncated, you can use the value of the last Key in the response as the marker in the subsequent request to get the next set of object keys.
    public var nextMarker: Swift.String?
    /// Keys that begin with the indicated prefix.
    public var `prefix`: Swift.String?

    public init (
        commonPrefixes: [S3ClientTypes.CommonPrefix]? = nil,
        contents: [S3ClientTypes.Object]? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxKeys: Swift.Int = 0,
        name: Swift.String? = nil,
        nextMarker: Swift.String? = nil,
        `prefix`: Swift.String? = nil
    )
    {
        self.commonPrefixes = commonPrefixes
        self.contents = contents
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.marker = marker
        self.maxKeys = maxKeys
        self.name = name
        self.nextMarker = nextMarker
        self.`prefix` = `prefix`
    }
}

struct ListObjectsOutputResponseBody: Swift.Equatable {
    let isTruncated: Swift.Bool
    let marker: Swift.String?
    let nextMarker: Swift.String?
    let contents: [S3ClientTypes.Object]?
    let name: Swift.String?
    let `prefix`: Swift.String?
    let delimiter: Swift.String?
    let maxKeys: Swift.Int
    let commonPrefixes: [S3ClientTypes.CommonPrefix]?
    let encodingType: S3ClientTypes.EncodingType?
}

extension ListObjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case contents = "Contents"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextMarker = "NextMarker"
        case `prefix` = "Prefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        if containerValues.contains(.contents) {
            let contentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .contents)
            if contentsWrappedContainer != nil {
                let contentsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Object].self, forKey: .contents)
                var contentsBuffer:[S3ClientTypes.Object]? = nil
                if let contentsContainer = contentsContainer {
                    contentsBuffer = [S3ClientTypes.Object]()
                    for structureContainer0 in contentsContainer {
                        contentsBuffer?.append(structureContainer0)
                    }
                }
                contents = contentsBuffer
            } else {
                contents = []
            }
        } else {
            contents = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([S3ClientTypes.CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[S3ClientTypes.CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [S3ClientTypes.CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}

extension ListObjectsV2Input: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension ListObjectsV2Input: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "list-type", value: "2"))
        if let continuationToken = continuationToken {
            let continuationTokenQueryItem = ClientRuntime.URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        if let delimiter = delimiter {
            let delimiterQueryItem = ClientRuntime.URLQueryItem(name: "delimiter".urlPercentEncoding(), value: Swift.String(delimiter).urlPercentEncoding())
            items.append(delimiterQueryItem)
        }
        if fetchOwner != false {
            let fetchOwnerQueryItem = ClientRuntime.URLQueryItem(name: "fetch-owner".urlPercentEncoding(), value: Swift.String(fetchOwner).urlPercentEncoding())
            items.append(fetchOwnerQueryItem)
        }
        if let encodingType = encodingType {
            let encodingTypeQueryItem = ClientRuntime.URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: Swift.String(encodingType.rawValue).urlPercentEncoding())
            items.append(encodingTypeQueryItem)
        }
        if let startAfter = startAfter {
            let startAfterQueryItem = ClientRuntime.URLQueryItem(name: "start-after".urlPercentEncoding(), value: Swift.String(startAfter).urlPercentEncoding())
            items.append(startAfterQueryItem)
        }
        if let `prefix` = `prefix` {
            let prefixQueryItem = ClientRuntime.URLQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if maxKeys != 0 {
            let maxKeysQueryItem = ClientRuntime.URLQueryItem(name: "max-keys".urlPercentEncoding(), value: Swift.String(maxKeys).urlPercentEncoding())
            items.append(maxKeysQueryItem)
        }
        return items
    }
}

extension ListObjectsV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct ListObjectsV2Input: Swift.Equatable {
    /// Bucket name to list. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key.
    public var continuationToken: Swift.String?
    /// A delimiter is a character you use to group keys.
    public var delimiter: Swift.String?
    /// Encoding type used by Amazon S3 to encode object keys in the response.
    public var encodingType: S3ClientTypes.EncodingType?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The owner field is not present in listV2 by default, if you want to return owner field with each key in the result then set the fetch owner field to true.
    public var fetchOwner: Swift.Bool
    /// Sets the maximum number of keys returned in the response. By default the action returns up to 1,000 key names. The response might contain fewer keys but will never contain more.
    public var maxKeys: Swift.Int
    /// Limits the response to keys that begin with the specified prefix.
    public var `prefix`: Swift.String?
    /// Confirms that the requester knows that she or he will be charged for the list objects request in V2 style. Bucket owners need not specify this parameter in their requests.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this specified key. StartAfter can be any key in the bucket.
    public var startAfter: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        continuationToken: Swift.String? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        expectedBucketOwner: Swift.String? = nil,
        fetchOwner: Swift.Bool = false,
        maxKeys: Swift.Int = 0,
        `prefix`: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        startAfter: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.fetchOwner = fetchOwner
        self.maxKeys = maxKeys
        self.`prefix` = `prefix`
        self.requestPayer = requestPayer
        self.startAfter = startAfter
    }
}

struct ListObjectsV2InputBody: Swift.Equatable {
}

extension ListObjectsV2InputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListObjectsV2OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListObjectsV2OutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListObjectsV2OutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListObjectsV2OutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListObjectsV2OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchBucket" : self = .noSuchBucket(try NoSuchBucket(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListObjectsV2OutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListObjectsV2OutputError: Swift.Error, Swift.Equatable {
    case noSuchBucket(NoSuchBucket)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectsV2OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectsV2OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`prefix` = output.`prefix`
            self.commonPrefixes = output.commonPrefixes
            self.contents = output.contents
            self.continuationToken = output.continuationToken
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.keyCount = output.keyCount
            self.maxKeys = output.maxKeys
            self.name = output.name
            self.nextContinuationToken = output.nextContinuationToken
            self.startAfter = output.startAfter
        } else {
            self.commonPrefixes = nil
            self.contents = nil
            self.continuationToken = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.keyCount = 0
            self.maxKeys = 0
            self.name = nil
            self.nextContinuationToken = nil
            self.`prefix` = nil
            self.startAfter = nil
        }
    }
}

public struct ListObjectsV2OutputResponse: Swift.Equatable {
    /// All of the keys (up to 1,000) rolled up into a common prefix count as a single return when calculating the number of returns. A response can contain CommonPrefixes only if you specify a delimiter. CommonPrefixes contains all (if there are any) keys between Prefix and the next occurrence of the string specified by a delimiter. CommonPrefixes lists keys that act like subdirectories in the directory specified by Prefix. For example, if the prefix is notes/ and the delimiter is a slash (/) as in notes/summer/july, the common prefix is notes/summer/. All of the keys that roll up into a common prefix count as a single return when calculating the number of returns.
    public var commonPrefixes: [S3ClientTypes.CommonPrefix]?
    /// Metadata about each object returned.
    public var contents: [S3ClientTypes.Object]?
    /// If ContinuationToken was sent with the request, it is included in the response.
    public var continuationToken: Swift.String?
    /// Causes keys that contain the same string between the prefix and the first occurrence of the delimiter to be rolled up into a single result element in the CommonPrefixes collection. These rolled-up keys are not returned elsewhere in the response. Each rolled-up result counts as only one return against the MaxKeys value.
    public var delimiter: Swift.String?
    /// Encoding type used by Amazon S3 to encode object key names in the XML response. If you specify the encoding-type request parameter, Amazon S3 includes this element in the response, and returns encoded key name values in the following response elements: Delimiter, Prefix, Key, and StartAfter.
    public var encodingType: S3ClientTypes.EncodingType?
    /// Set to false if all of the results were returned. Set to true if more keys are available to return. If the number of results exceeds that specified by MaxKeys, all of the results might not be returned.
    public var isTruncated: Swift.Bool
    /// KeyCount is the number of keys returned with this request. KeyCount will always be less than or equals to MaxKeys field. Say you ask for 50 keys, your result will include less than equals 50 keys
    public var keyCount: Swift.Int
    /// Sets the maximum number of keys returned in the response. By default the action returns up to 1,000 key names. The response might contain fewer keys but will never contain more.
    public var maxKeys: Swift.Int
    /// The bucket name. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    public var name: Swift.String?
    /// NextContinuationToken is sent when isTruncated is true, which means there are more keys in the bucket that can be listed. The next list requests to Amazon S3 can be continued with this NextContinuationToken. NextContinuationToken is obfuscated and is not a real key
    public var nextContinuationToken: Swift.String?
    /// Keys that begin with the indicated prefix.
    public var `prefix`: Swift.String?
    /// If StartAfter was sent with the request, it is included in the response.
    public var startAfter: Swift.String?

    public init (
        commonPrefixes: [S3ClientTypes.CommonPrefix]? = nil,
        contents: [S3ClientTypes.Object]? = nil,
        continuationToken: Swift.String? = nil,
        delimiter: Swift.String? = nil,
        encodingType: S3ClientTypes.EncodingType? = nil,
        isTruncated: Swift.Bool = false,
        keyCount: Swift.Int = 0,
        maxKeys: Swift.Int = 0,
        name: Swift.String? = nil,
        nextContinuationToken: Swift.String? = nil,
        `prefix`: Swift.String? = nil,
        startAfter: Swift.String? = nil
    )
    {
        self.commonPrefixes = commonPrefixes
        self.contents = contents
        self.continuationToken = continuationToken
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.keyCount = keyCount
        self.maxKeys = maxKeys
        self.name = name
        self.nextContinuationToken = nextContinuationToken
        self.`prefix` = `prefix`
        self.startAfter = startAfter
    }
}

struct ListObjectsV2OutputResponseBody: Swift.Equatable {
    let isTruncated: Swift.Bool
    let contents: [S3ClientTypes.Object]?
    let name: Swift.String?
    let `prefix`: Swift.String?
    let delimiter: Swift.String?
    let maxKeys: Swift.Int
    let commonPrefixes: [S3ClientTypes.CommonPrefix]?
    let encodingType: S3ClientTypes.EncodingType?
    let keyCount: Swift.Int
    let continuationToken: Swift.String?
    let nextContinuationToken: Swift.String?
    let startAfter: Swift.String?
}

extension ListObjectsV2OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case contents = "Contents"
        case continuationToken = "ContinuationToken"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyCount = "KeyCount"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextContinuationToken = "NextContinuationToken"
        case `prefix` = "Prefix"
        case startAfter = "StartAfter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.contents) {
            let contentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .contents)
            if contentsWrappedContainer != nil {
                let contentsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Object].self, forKey: .contents)
                var contentsBuffer:[S3ClientTypes.Object]? = nil
                if let contentsContainer = contentsContainer {
                    contentsBuffer = [S3ClientTypes.Object]()
                    for structureContainer0 in contentsContainer {
                        contentsBuffer?.append(structureContainer0)
                    }
                }
                contents = contentsBuffer
            } else {
                contents = []
            }
        } else {
            contents = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([S3ClientTypes.CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[S3ClientTypes.CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [S3ClientTypes.CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let keyCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .keyCount)
        keyCount = keyCountDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        let startAfterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startAfter)
        startAfter = startAfterDecoded
    }
}

extension ListPartsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension ListPartsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "ListParts"))
        if let partNumberMarker = partNumberMarker {
            let partNumberMarkerQueryItem = ClientRuntime.URLQueryItem(name: "part-number-marker".urlPercentEncoding(), value: Swift.String(partNumberMarker).urlPercentEncoding())
            items.append(partNumberMarkerQueryItem)
        }
        if maxParts != 0 {
            let maxPartsQueryItem = ClientRuntime.URLQueryItem(name: "max-parts".urlPercentEncoding(), value: Swift.String(maxParts).urlPercentEncoding())
            items.append(maxPartsQueryItem)
        }
        if let uploadId = uploadId {
            let uploadIdQueryItem = ClientRuntime.URLQueryItem(name: "uploadId".urlPercentEncoding(), value: Swift.String(uploadId).urlPercentEncoding())
            items.append(uploadIdQueryItem)
        }
        return items
    }
}

extension ListPartsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct ListPartsInput: Swift.Equatable {
    /// The name of the bucket to which the parts are being uploaded. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Object key for which the multipart upload was initiated.
    /// This member is required.
    public var key: Swift.String?
    /// Sets the maximum number of parts to return.
    public var maxParts: Swift.Int
    /// Specifies the part after which listing should begin. Only parts with higher part numbers will be listed.
    public var partNumberMarker: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Upload ID identifying the multipart upload whose parts are being listed.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        maxParts: Swift.Int = 0,
        partNumberMarker: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.maxParts = maxParts
        self.partNumberMarker = partNumberMarker
        self.requestPayer = requestPayer
        self.uploadId = uploadId
    }
}

struct ListPartsInputBody: Swift.Equatable {
}

extension ListPartsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPartsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = ListPartsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? ListPartsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = ListPartsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension ListPartsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension ListPartsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum ListPartsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let abortDateHeaderValue = httpResponse.headers.value(for: "x-amz-abort-date") {
            self.abortDate = DateFormatter.rfc5322DateFormatter.date(from: abortDateHeaderValue)
        } else {
            self.abortDate = nil
        }
        if let abortRuleIdHeaderValue = httpResponse.headers.value(for: "x-amz-abort-rule-id") {
            self.abortRuleId = abortRuleIdHeaderValue
        } else {
            self.abortRuleId = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPartsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucket = output.bucket
            self.initiator = output.initiator
            self.isTruncated = output.isTruncated
            self.key = output.key
            self.maxParts = output.maxParts
            self.nextPartNumberMarker = output.nextPartNumberMarker
            self.owner = output.owner
            self.partNumberMarker = output.partNumberMarker
            self.parts = output.parts
            self.storageClass = output.storageClass
            self.uploadId = output.uploadId
        } else {
            self.bucket = nil
            self.initiator = nil
            self.isTruncated = false
            self.key = nil
            self.maxParts = 0
            self.nextPartNumberMarker = nil
            self.owner = nil
            self.partNumberMarker = nil
            self.parts = nil
            self.storageClass = nil
            self.uploadId = nil
        }
    }
}

public struct ListPartsOutputResponse: Swift.Equatable {
    /// If the bucket has a lifecycle rule configured with an action to abort incomplete multipart uploads and the prefix in the lifecycle rule matches the object name in the request, then the response includes this header indicating when the initiated multipart upload will become eligible for abort operation. For more information, see [Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config). The response will also include the x-amz-abort-rule-id header that will provide the ID of the lifecycle configuration rule that defines this action.
    public var abortDate: ClientRuntime.Date?
    /// This header is returned along with the x-amz-abort-date header. It identifies applicable lifecycle configuration rule that defines the action to abort incomplete multipart uploads.
    public var abortRuleId: Swift.String?
    /// The name of the bucket to which the multipart upload was initiated. Does not return the access point ARN or access point alias if used.
    public var bucket: Swift.String?
    /// Container element that identifies who initiated the multipart upload. If the initiator is an Amazon Web Services account, this element provides the same information as the Owner element. If the initiator is an IAM User, this element provides the user ARN and display name.
    public var initiator: S3ClientTypes.Initiator?
    /// Indicates whether the returned list of parts is truncated. A true value indicates that the list was truncated. A list can be truncated if the number of parts exceeds the limit returned in the MaxParts element.
    public var isTruncated: Swift.Bool
    /// Object key for which the multipart upload was initiated.
    public var key: Swift.String?
    /// Maximum number of parts that were allowed in the response.
    public var maxParts: Swift.Int
    /// When a list is truncated, this element specifies the last part in the list, as well as the value to use for the part-number-marker request parameter in a subsequent request.
    public var nextPartNumberMarker: Swift.String?
    /// Container element that identifies the object owner, after the object is created. If multipart upload is initiated by an IAM user, this element provides the parent account ID and display name.
    public var owner: S3ClientTypes.Owner?
    /// When a list is truncated, this element specifies the last part in the list, as well as the value to use for the part-number-marker request parameter in a subsequent request.
    public var partNumberMarker: Swift.String?
    /// Container for elements related to a particular part. A response can contain zero or more Part elements.
    public var parts: [S3ClientTypes.Part]?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// Class of storage (STANDARD or REDUCED_REDUNDANCY) used to store the uploaded object.
    public var storageClass: S3ClientTypes.StorageClass?
    /// Upload ID identifying the multipart upload whose parts are being listed.
    public var uploadId: Swift.String?

    public init (
        abortDate: ClientRuntime.Date? = nil,
        abortRuleId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        initiator: S3ClientTypes.Initiator? = nil,
        isTruncated: Swift.Bool = false,
        key: Swift.String? = nil,
        maxParts: Swift.Int = 0,
        nextPartNumberMarker: Swift.String? = nil,
        owner: S3ClientTypes.Owner? = nil,
        partNumberMarker: Swift.String? = nil,
        parts: [S3ClientTypes.Part]? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        storageClass: S3ClientTypes.StorageClass? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.abortDate = abortDate
        self.abortRuleId = abortRuleId
        self.bucket = bucket
        self.initiator = initiator
        self.isTruncated = isTruncated
        self.key = key
        self.maxParts = maxParts
        self.nextPartNumberMarker = nextPartNumberMarker
        self.owner = owner
        self.partNumberMarker = partNumberMarker
        self.parts = parts
        self.requestCharged = requestCharged
        self.storageClass = storageClass
        self.uploadId = uploadId
    }
}

struct ListPartsOutputResponseBody: Swift.Equatable {
    let bucket: Swift.String?
    let key: Swift.String?
    let uploadId: Swift.String?
    let partNumberMarker: Swift.String?
    let nextPartNumberMarker: Swift.String?
    let maxParts: Swift.Int
    let isTruncated: Swift.Bool
    let parts: [S3ClientTypes.Part]?
    let initiator: S3ClientTypes.Initiator?
    let owner: S3ClientTypes.Owner?
    let storageClass: S3ClientTypes.StorageClass?
}

extension ListPartsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case initiator = "Initiator"
        case isTruncated = "IsTruncated"
        case key = "Key"
        case maxParts = "MaxParts"
        case nextPartNumberMarker = "NextPartNumberMarker"
        case owner = "Owner"
        case partNumberMarker = "PartNumberMarker"
        case parts = "Part"
        case storageClass = "StorageClass"
        case uploadId = "UploadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partNumberMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partNumberMarker)
        partNumberMarker = partNumberMarkerDecoded
        let nextPartNumberMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPartNumberMarker)
        nextPartNumberMarker = nextPartNumberMarkerDecoded
        let maxPartsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxParts)
        maxParts = maxPartsDecoded
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.parts) {
            let partsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .parts)
            if partsWrappedContainer != nil {
                let partsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Part].self, forKey: .parts)
                var partsBuffer:[S3ClientTypes.Part]? = nil
                if let partsContainer = partsContainer {
                    partsBuffer = [S3ClientTypes.Part]()
                    for structureContainer0 in partsContainer {
                        partsBuffer?.append(structureContainer0)
                    }
                }
                parts = partsBuffer
            } else {
                parts = []
            }
        } else {
            parts = nil
        }
        let initiatorDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Initiator.self, forKey: .initiator)
        initiator = initiatorDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ClientTypes.LoggingEnabled: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetBucket = "TargetBucket"
        case targetGrants = "TargetGrants"
        case targetPrefix = "TargetPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let targetBucket = targetBucket {
            try container.encode(targetBucket, forKey: ClientRuntime.Key("TargetBucket"))
        }
        if let targetGrants = targetGrants {
            var targetGrantsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TargetGrants"))
            for targetgrant0 in targetGrants {
                try targetGrantsContainer.encode(targetgrant0, forKey: ClientRuntime.Key("Grant"))
            }
        }
        if let targetPrefix = targetPrefix {
            try container.encode(targetPrefix, forKey: ClientRuntime.Key("TargetPrefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBucket)
        targetBucket = targetBucketDecoded
        if containerValues.contains(.targetGrants) {
            struct KeyVal0{struct Grant{}}
            let targetGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .targetGrants)
            if let targetGrantsWrappedContainer = targetGrantsWrappedContainer {
                let targetGrantsContainer = try targetGrantsWrappedContainer.decodeIfPresent([S3ClientTypes.TargetGrant].self, forKey: .member)
                var targetGrantsBuffer:[S3ClientTypes.TargetGrant]? = nil
                if let targetGrantsContainer = targetGrantsContainer {
                    targetGrantsBuffer = [S3ClientTypes.TargetGrant]()
                    for structureContainer0 in targetGrantsContainer {
                        targetGrantsBuffer?.append(structureContainer0)
                    }
                }
                targetGrants = targetGrantsBuffer
            } else {
                targetGrants = []
            }
        } else {
            targetGrants = nil
        }
        let targetPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetPrefix)
        targetPrefix = targetPrefixDecoded
    }
}

extension S3ClientTypes.LoggingEnabled: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For more information, see [PUT Bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the Amazon S3 API Reference.
    public struct LoggingEnabled: Swift.Equatable {
        /// Specifies the bucket where you want Amazon S3 to store server access logs. You can have your logs delivered to any bucket that you own, including the same bucket that is being logged. You can also configure multiple buckets to deliver their logs to the same target bucket. In this case, you should choose a different TargetPrefix for each source bucket so that the delivered log files can be distinguished by key.
        /// This member is required.
        public var targetBucket: Swift.String?
        /// Container for granting information. Buckets that use the bucket owner enforced setting for Object Ownership don't support target grants. For more information, see [Permissions for server access log delivery](https://docs.aws.amazon.com/AmazonS3/latest/userguide/enable-server-access-logging.html#grant-log-delivery-permissions-general) in the Amazon S3 User Guide.
        public var targetGrants: [S3ClientTypes.TargetGrant]?
        /// A prefix for all log object keys. If you store log files from multiple Amazon S3 buckets in a single bucket, you can use a prefix to distinguish which log files came from which bucket.
        /// This member is required.
        public var targetPrefix: Swift.String?

        public init (
            targetBucket: Swift.String? = nil,
            targetGrants: [S3ClientTypes.TargetGrant]? = nil,
            targetPrefix: Swift.String? = nil
        )
        {
            self.targetBucket = targetBucket
            self.targetGrants = targetGrants
            self.targetPrefix = targetPrefix
        }
    }

}

extension S3ClientTypes {
    public enum MFADelete: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADelete] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADelete(rawValue: rawValue) ?? MFADelete.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum MFADeleteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADeleteStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADeleteStatus(rawValue: rawValue) ?? MFADeleteStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum MetadataDirective: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataDirective] {
            return [
                .copy,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetadataDirective(rawValue: rawValue) ?? MetadataDirective.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.MetadataEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ClientTypes.MetadataEntry: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A metadata key-value pair to store with an object.
    public struct MetadataEntry: Swift.Equatable {
        /// Name of the Object.
        public var name: Swift.String?
        /// Value of the Object.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension S3ClientTypes.Metrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventThreshold = "EventThreshold"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventThreshold = eventThreshold {
            try container.encode(eventThreshold, forKey: ClientRuntime.Key("EventThreshold"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.MetricsStatus.self, forKey: .status)
        status = statusDecoded
        let eventThresholdDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationTimeValue.self, forKey: .eventThreshold)
        eventThreshold = eventThresholdDecoded
    }
}

extension S3ClientTypes.Metrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container specifying replication metrics-related settings enabling replication metrics and events.
    public struct Metrics: Swift.Equatable {
        /// A container specifying the time threshold for emitting the s3:Replication:OperationMissedThreshold event.
        public var eventThreshold: S3ClientTypes.ReplicationTimeValue?
        /// Specifies whether the replication metrics are enabled.
        /// This member is required.
        public var status: S3ClientTypes.MetricsStatus?

        public init (
            eventThreshold: S3ClientTypes.ReplicationTimeValue? = nil,
            status: S3ClientTypes.MetricsStatus? = nil
        )
        {
            self.eventThreshold = eventThreshold
            self.status = status
        }
    }

}

extension S3ClientTypes.MetricsAndOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case `prefix` = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessPointArn = accessPointArn {
            try container.encode(accessPointArn, forKey: ClientRuntime.Key("AccessPointArn"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .tags)
                var tagsBuffer:[S3ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
    }
}

extension S3ClientTypes.MetricsAndOperator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates, and an object must match all of the predicates in order for the filter to apply.
    public struct MetricsAndOperator: Swift.Equatable {
        /// The access point ARN used when evaluating an AND predicate.
        public var accessPointArn: Swift.String?
        /// The prefix used when evaluating an AND predicate.
        public var `prefix`: Swift.String?
        /// The list of tags used when evaluating an AND predicate.
        public var tags: [S3ClientTypes.Tag]?

        public init (
            accessPointArn: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            tags: [S3ClientTypes.Tag]? = nil
        )
        {
            self.accessPointArn = accessPointArn
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ClientTypes.MetricsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.MetricsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension S3ClientTypes.MetricsConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket. If you're updating an existing metrics configuration, note that this is a full replacement of the existing metrics configuration. If you don't include the elements you want to keep, they are erased. For more information, see [PutBucketMetricsConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html).
    public struct MetricsConfiguration: Swift.Equatable {
        /// Specifies a metrics configuration filter. The metrics configuration will only include objects that meet the filter's criteria. A filter must be a prefix, an object tag, an access point ARN, or a conjunction (MetricsAndOperator).
        public var filter: S3ClientTypes.MetricsFilter?
        /// The ID used to identify the metrics configuration.
        /// This member is required.
        public var id: Swift.String?

        public init (
            filter: S3ClientTypes.MetricsFilter? = nil,
            id: Swift.String? = nil
        )
        {
            self.filter = filter
            self.id = id
        }
    }

}

extension S3ClientTypes.MetricsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accesspointarn = "AccessPointArn"
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        switch self {
            case let .accesspointarn(accesspointarn):
                try container.encode(accesspointarn, forKey: ClientRuntime.Key("AccessPointArn"))
            case let .and(and):
                try container.encode(and, forKey: ClientRuntime.Key("And"))
            case let .prefix(prefix):
                try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
            case let .tag(tag):
                try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: ClientRuntime.Key("sdkUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .prefix:
                let prefixDecoded = try containerValues.decode(Swift.String.self, forKey: .prefix)
                self = .prefix(prefixDecoded)
            case .tag:
                let tagDecoded = try containerValues.decode(S3ClientTypes.Tag.self, forKey: .tag)
                self = .tag(tagDecoded)
            case .accesspointarn:
                let accesspointarnDecoded = try containerValues.decode(Swift.String.self, forKey: .accesspointarn)
                self = .accesspointarn(accesspointarnDecoded)
            case .and:
                let andDecoded = try containerValues.decode(S3ClientTypes.MetricsAndOperator.self, forKey: .and)
                self = .and(andDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ClientTypes {
    /// Specifies a metrics configuration filter. The metrics configuration only includes objects that meet the filter's criteria. A filter must be a prefix, an object tag, an access point ARN, or a conjunction (MetricsAndOperator). For more information, see [PutBucketMetricsConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketMetricsConfiguration.html).
    public enum MetricsFilter: Swift.Equatable {
        /// The prefix used when evaluating a metrics filter.
        case prefix(Swift.String)
        /// The tag used when evaluating a metrics filter.
        case tag(S3ClientTypes.Tag)
        /// The access point ARN used when evaluating a metrics filter.
        case accesspointarn(Swift.String)
        /// A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates, and an object must match all of the predicates in order for the filter to apply.
        case and(S3ClientTypes.MetricsAndOperator)
        case sdkUnknown(Swift.String)
    }

}

extension S3ClientTypes {
    public enum MetricsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricsStatus(rawValue: rawValue) ?? MetricsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.MultipartUpload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiated = "Initiated"
        case initiator = "Initiator"
        case key = "Key"
        case owner = "Owner"
        case storageClass = "StorageClass"
        case uploadId = "UploadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let initiated = initiated {
            try container.encode(ClientRuntime.TimestampWrapper(initiated, format: .dateTime), forKey: ClientRuntime.Key("Initiated"))
        }
        if let initiator = initiator {
            try container.encode(initiator, forKey: ClientRuntime.Key("Initiator"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
        if let uploadId = uploadId {
            try container.encode(uploadId, forKey: ClientRuntime.Key("UploadId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let initiatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiated)
        var initiatedBuffer:ClientRuntime.Date? = nil
        if let initiatedDecoded = initiatedDecoded {
            initiatedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(initiatedDecoded, format: .dateTime)
        }
        initiated = initiatedBuffer
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Initiator.self, forKey: .initiator)
        initiator = initiatorDecoded
    }
}

extension S3ClientTypes.MultipartUpload: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the MultipartUpload for the Amazon S3 object.
    public struct MultipartUpload: Swift.Equatable {
        /// Date and time at which the multipart upload was initiated.
        public var initiated: ClientRuntime.Date?
        /// Identifies who initiated the multipart upload.
        public var initiator: S3ClientTypes.Initiator?
        /// Key of the object for which the multipart upload was initiated.
        public var key: Swift.String?
        /// Specifies the owner of the object that is part of the multipart upload.
        public var owner: S3ClientTypes.Owner?
        /// The class of storage used to store the object.
        public var storageClass: S3ClientTypes.StorageClass?
        /// Upload ID that identifies the multipart upload.
        public var uploadId: Swift.String?

        public init (
            initiated: ClientRuntime.Date? = nil,
            initiator: S3ClientTypes.Initiator? = nil,
            key: Swift.String? = nil,
            owner: S3ClientTypes.Owner? = nil,
            storageClass: S3ClientTypes.StorageClass? = nil,
            uploadId: Swift.String? = nil
        )
        {
            self.initiated = initiated
            self.initiator = initiator
            self.key = key
            self.owner = owner
            self.storageClass = storageClass
            self.uploadId = uploadId
        }
    }

}

extension NoSuchBucket {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// The specified bucket does not exist.
public struct NoSuchBucket: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension NoSuchKey {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// The specified key does not exist.
public struct NoSuchKey: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension NoSuchUpload {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// The specified multipart upload does not exist.
public struct NoSuchUpload: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension S3ClientTypes.NoncurrentVersionExpiration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newerNoncurrentVersions = "NewerNoncurrentVersions"
        case noncurrentDays = "NoncurrentDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if newerNoncurrentVersions != 0 {
            try container.encode(newerNoncurrentVersions, forKey: ClientRuntime.Key("NewerNoncurrentVersions"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: ClientRuntime.Key("NoncurrentDays"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .noncurrentDays)
        noncurrentDays = noncurrentDaysDecoded
        let newerNoncurrentVersionsDecoded = try containerValues.decode(Swift.Int.self, forKey: .newerNoncurrentVersions)
        newerNoncurrentVersions = newerNoncurrentVersionsDecoded
    }
}

extension S3ClientTypes.NoncurrentVersionExpiration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.
    public struct NoncurrentVersionExpiration: Swift.Equatable {
        /// Specifies how many noncurrent versions Amazon S3 will retain. If there are this many more recent noncurrent versions, Amazon S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the Amazon S3 User Guide.
        public var newerNoncurrentVersions: Swift.Int
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int

        public init (
            newerNoncurrentVersions: Swift.Int = 0,
            noncurrentDays: Swift.Int = 0
        )
        {
            self.newerNoncurrentVersions = newerNoncurrentVersions
            self.noncurrentDays = noncurrentDays
        }
    }

}

extension S3ClientTypes.NoncurrentVersionTransition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newerNoncurrentVersions = "NewerNoncurrentVersions"
        case noncurrentDays = "NoncurrentDays"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if newerNoncurrentVersions != 0 {
            try container.encode(newerNoncurrentVersions, forKey: ClientRuntime.Key("NewerNoncurrentVersions"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: ClientRuntime.Key("NoncurrentDays"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .noncurrentDays)
        noncurrentDays = noncurrentDaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let newerNoncurrentVersionsDecoded = try containerValues.decode(Swift.Int.self, forKey: .newerNoncurrentVersions)
        newerNoncurrentVersions = newerNoncurrentVersionsDecoded
    }
}

extension S3ClientTypes.NoncurrentVersionTransition: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the transition rule that describes when noncurrent objects transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's lifetime.
    public struct NoncurrentVersionTransition: Swift.Equatable {
        /// Specifies how many noncurrent versions Amazon S3 will retain. If there are this many more recent noncurrent versions, Amazon S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the Amazon S3 User Guide.
        public var newerNoncurrentVersions: Swift.Int
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates How Long an Object Has Been Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int
        /// The class of storage used to store the object.
        public var storageClass: S3ClientTypes.TransitionStorageClass?

        public init (
            newerNoncurrentVersions: Swift.Int = 0,
            noncurrentDays: Swift.Int = 0,
            storageClass: S3ClientTypes.TransitionStorageClass? = nil
        )
        {
            self.newerNoncurrentVersions = newerNoncurrentVersions
            self.noncurrentDays = noncurrentDays
            self.storageClass = storageClass
        }
    }

}

extension NotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// The specified content does not exist.
public struct NotFound: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension S3ClientTypes.NotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridgeConfiguration = "EventBridgeConfiguration"
        case lambdaFunctionConfigurations = "CloudFunctionConfiguration"
        case queueConfigurations = "QueueConfiguration"
        case topicConfigurations = "TopicConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventBridgeConfiguration = eventBridgeConfiguration {
            try container.encode(eventBridgeConfiguration, forKey: ClientRuntime.Key("EventBridgeConfiguration"))
        }
        if let lambdaFunctionConfigurations = lambdaFunctionConfigurations {
            if lambdaFunctionConfigurations.isEmpty {
                var lambdaFunctionConfigurationsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("CloudFunctionConfiguration"))
                try lambdaFunctionConfigurationsContainer.encodeNil()
            } else {
                for lambdafunctionconfiguration0 in lambdaFunctionConfigurations {
                    var lambdaFunctionConfigurationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CloudFunctionConfiguration"))
                    try lambdaFunctionConfigurationsContainer0.encode(lambdafunctionconfiguration0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let queueConfigurations = queueConfigurations {
            if queueConfigurations.isEmpty {
                var queueConfigurationsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("QueueConfiguration"))
                try queueConfigurationsContainer.encodeNil()
            } else {
                for queueconfiguration0 in queueConfigurations {
                    var queueConfigurationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("QueueConfiguration"))
                    try queueConfigurationsContainer0.encode(queueconfiguration0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let topicConfigurations = topicConfigurations {
            if topicConfigurations.isEmpty {
                var topicConfigurationsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("TopicConfiguration"))
                try topicConfigurationsContainer.encodeNil()
            } else {
                for topicconfiguration0 in topicConfigurations {
                    var topicConfigurationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TopicConfiguration"))
                    try topicConfigurationsContainer0.encode(topicconfiguration0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.topicConfigurations) {
            let topicConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .topicConfigurations)
            if topicConfigurationsWrappedContainer != nil {
                let topicConfigurationsContainer = try containerValues.decodeIfPresent([S3ClientTypes.TopicConfiguration].self, forKey: .topicConfigurations)
                var topicConfigurationsBuffer:[S3ClientTypes.TopicConfiguration]? = nil
                if let topicConfigurationsContainer = topicConfigurationsContainer {
                    topicConfigurationsBuffer = [S3ClientTypes.TopicConfiguration]()
                    for structureContainer0 in topicConfigurationsContainer {
                        topicConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                topicConfigurations = topicConfigurationsBuffer
            } else {
                topicConfigurations = []
            }
        } else {
            topicConfigurations = nil
        }
        if containerValues.contains(.queueConfigurations) {
            let queueConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .queueConfigurations)
            if queueConfigurationsWrappedContainer != nil {
                let queueConfigurationsContainer = try containerValues.decodeIfPresent([S3ClientTypes.QueueConfiguration].self, forKey: .queueConfigurations)
                var queueConfigurationsBuffer:[S3ClientTypes.QueueConfiguration]? = nil
                if let queueConfigurationsContainer = queueConfigurationsContainer {
                    queueConfigurationsBuffer = [S3ClientTypes.QueueConfiguration]()
                    for structureContainer0 in queueConfigurationsContainer {
                        queueConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                queueConfigurations = queueConfigurationsBuffer
            } else {
                queueConfigurations = []
            }
        } else {
            queueConfigurations = nil
        }
        if containerValues.contains(.lambdaFunctionConfigurations) {
            let lambdaFunctionConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .lambdaFunctionConfigurations)
            if lambdaFunctionConfigurationsWrappedContainer != nil {
                let lambdaFunctionConfigurationsContainer = try containerValues.decodeIfPresent([S3ClientTypes.LambdaFunctionConfiguration].self, forKey: .lambdaFunctionConfigurations)
                var lambdaFunctionConfigurationsBuffer:[S3ClientTypes.LambdaFunctionConfiguration]? = nil
                if let lambdaFunctionConfigurationsContainer = lambdaFunctionConfigurationsContainer {
                    lambdaFunctionConfigurationsBuffer = [S3ClientTypes.LambdaFunctionConfiguration]()
                    for structureContainer0 in lambdaFunctionConfigurationsContainer {
                        lambdaFunctionConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                lambdaFunctionConfigurations = lambdaFunctionConfigurationsBuffer
            } else {
                lambdaFunctionConfigurations = []
            }
        } else {
            lambdaFunctionConfigurations = nil
        }
        let eventBridgeConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EventBridgeConfiguration.self, forKey: .eventBridgeConfiguration)
        eventBridgeConfiguration = eventBridgeConfigurationDecoded
    }
}

extension S3ClientTypes.NotificationConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket.
    public struct NotificationConfiguration: Swift.Equatable {
        /// Enables delivery of events to Amazon EventBridge.
        public var eventBridgeConfiguration: S3ClientTypes.EventBridgeConfiguration?
        /// Describes the Lambda functions to invoke and the events for which to invoke them.
        public var lambdaFunctionConfigurations: [S3ClientTypes.LambdaFunctionConfiguration]?
        /// The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
        public var queueConfigurations: [S3ClientTypes.QueueConfiguration]?
        /// The topic to which notifications are sent and the events for which notifications are generated.
        public var topicConfigurations: [S3ClientTypes.TopicConfiguration]?

        public init (
            eventBridgeConfiguration: S3ClientTypes.EventBridgeConfiguration? = nil,
            lambdaFunctionConfigurations: [S3ClientTypes.LambdaFunctionConfiguration]? = nil,
            queueConfigurations: [S3ClientTypes.QueueConfiguration]? = nil,
            topicConfigurations: [S3ClientTypes.TopicConfiguration]? = nil
        )
        {
            self.eventBridgeConfiguration = eventBridgeConfiguration
            self.lambdaFunctionConfigurations = lambdaFunctionConfigurations
            self.queueConfigurations = queueConfigurations
            self.topicConfigurations = topicConfigurations
        }
    }

}

extension S3ClientTypes.NotificationConfigurationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("S3Key"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(S3ClientTypes.S3KeyFilter.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3ClientTypes.NotificationConfigurationFilter: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies object key name filtering rules. For information about key name filtering, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
    public struct NotificationConfigurationFilter: Swift.Equatable {
        /// A container for object key name prefix and suffix filtering rules.
        public var key: S3ClientTypes.S3KeyFilter?

        public init (
            key: S3ClientTypes.S3KeyFilter? = nil
        )
        {
            self.key = key
        }
    }

}

extension S3ClientTypes.Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case key = "Key"
        case lastModified = "LastModified"
        case owner = "Owner"
        case size = "Size"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: ClientRuntime.Key("ETag"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let lastModified = lastModified {
            try container.encode(ClientRuntime.TimestampWrapper(lastModified, format: .dateTime), forKey: ClientRuntime.Key("LastModified"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if size != 0 {
            try container.encode(size, forKey: ClientRuntime.Key("Size"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        var lastModifiedBuffer:ClientRuntime.Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension S3ClientTypes.Object: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// An object consists of data and its descriptive metadata.
    public struct Object: Swift.Equatable {
        /// The entity tag is a hash of the object. The ETag reflects changes only to the contents of an object, not its metadata. The ETag may or may not be an MD5 digest of the object data. Whether or not it is depends on how the object was created and how it is encrypted as described below:
        ///
        /// * Objects created by the PUT Object, POST Object, or Copy operation, or through the Amazon Web Services Management Console, and are encrypted by SSE-S3 or plaintext, have ETags that are an MD5 digest of their object data.
        ///
        /// * Objects created by the PUT Object, POST Object, or Copy operation, or through the Amazon Web Services Management Console, and are encrypted by SSE-C or SSE-KMS, have ETags that are not an MD5 digest of their object data.
        ///
        /// * If an object is created by either the Multipart Upload or Part Copy operation, the ETag is not an MD5 digest, regardless of the method of encryption.
        public var eTag: Swift.String?
        /// The name that you assign to an object. You use the object key to retrieve the object.
        public var key: Swift.String?
        /// Creation date of the object.
        public var lastModified: ClientRuntime.Date?
        /// The owner of the object
        public var owner: S3ClientTypes.Owner?
        /// Size in bytes of the object
        public var size: Swift.Int
        /// The class of storage used to store the object.
        public var storageClass: S3ClientTypes.ObjectStorageClass?

        public init (
            eTag: Swift.String? = nil,
            key: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            owner: S3ClientTypes.Owner? = nil,
            size: Swift.Int = 0,
            storageClass: S3ClientTypes.ObjectStorageClass? = nil
        )
        {
            self.eTag = eTag
            self.key = key
            self.lastModified = lastModified
            self.owner = owner
            self.size = size
            self.storageClass = storageClass
        }
    }

}

extension ObjectAlreadyInActiveTierError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// This action is not allowed against this storage tier.
public struct ObjectAlreadyInActiveTierError: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension S3ClientTypes {
    public enum ObjectCannedACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectCannedACL] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectCannedACL(rawValue: rawValue) ?? ObjectCannedACL.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ObjectIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension S3ClientTypes.ObjectIdentifier: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Object Identifier is unique value to identify objects.
    public struct ObjectIdentifier: Swift.Equatable {
        /// Key name of the object. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        /// This member is required.
        public var key: Swift.String?
        /// VersionId for the specific version of the object to delete.
        public var versionId: Swift.String?

        public init (
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.key = key
            self.versionId = versionId
        }
    }

}

extension S3ClientTypes.ObjectLockConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectLockEnabled = "ObjectLockEnabled"
        case rule = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let objectLockEnabled = objectLockEnabled {
            try container.encode(objectLockEnabled, forKey: ClientRuntime.Key("ObjectLockEnabled"))
        }
        if let rule = rule {
            try container.encode(rule, forKey: ClientRuntime.Key("Rule"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLockEnabledDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockEnabled.self, forKey: .objectLockEnabled)
        objectLockEnabled = objectLockEnabledDecoded
        let ruleDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockRule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

extension S3ClientTypes.ObjectLockConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container element for Object Lock configuration parameters.
    public struct ObjectLockConfiguration: Swift.Equatable {
        /// Indicates whether this bucket has an Object Lock configuration enabled. Enable ObjectLockEnabled when you apply ObjectLockConfiguration to a bucket.
        public var objectLockEnabled: S3ClientTypes.ObjectLockEnabled?
        /// Specifies the Object Lock rule for the specified object. Enable the this rule when you apply ObjectLockConfiguration to a bucket. Bucket settings require both a mode and a period. The period can be either Days or Years but you must select one. You cannot specify Days and Years at the same time.
        public var rule: S3ClientTypes.ObjectLockRule?

        public init (
            objectLockEnabled: S3ClientTypes.ObjectLockEnabled? = nil,
            rule: S3ClientTypes.ObjectLockRule? = nil
        )
        {
            self.objectLockEnabled = objectLockEnabled
            self.rule = rule
        }
    }

}

extension S3ClientTypes {
    public enum ObjectLockEnabled: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLockEnabled] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLockEnabled(rawValue: rawValue) ?? ObjectLockEnabled.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ObjectLockLegalHold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockLegalHoldStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ClientTypes.ObjectLockLegalHold: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A Legal Hold configuration for an object.
    public struct ObjectLockLegalHold: Swift.Equatable {
        /// Indicates whether the specified object has a Legal Hold in place.
        public var status: S3ClientTypes.ObjectLockLegalHoldStatus?

        public init (
            status: S3ClientTypes.ObjectLockLegalHoldStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ClientTypes {
    public enum ObjectLockLegalHoldStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLockLegalHoldStatus] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLockLegalHoldStatus(rawValue: rawValue) ?? ObjectLockLegalHoldStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum ObjectLockMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLockMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLockMode(rawValue: rawValue) ?? ObjectLockMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ObjectLockRetention: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
        case retainUntilDate = "RetainUntilDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: ClientRuntime.Key("Mode"))
        }
        if let retainUntilDate = retainUntilDate {
            try container.encode(ClientRuntime.TimestampWrapper(retainUntilDate, format: .dateTime), forKey: ClientRuntime.Key("RetainUntilDate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockRetentionMode.self, forKey: .mode)
        mode = modeDecoded
        let retainUntilDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retainUntilDate)
        var retainUntilDateBuffer:ClientRuntime.Date? = nil
        if let retainUntilDateDecoded = retainUntilDateDecoded {
            retainUntilDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(retainUntilDateDecoded, format: .dateTime)
        }
        retainUntilDate = retainUntilDateBuffer
    }
}

extension S3ClientTypes.ObjectLockRetention: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A Retention configuration for an object.
    public struct ObjectLockRetention: Swift.Equatable {
        /// Indicates the Retention mode for the specified object.
        public var mode: S3ClientTypes.ObjectLockRetentionMode?
        /// The date on which this Object Lock Retention will expire.
        public var retainUntilDate: ClientRuntime.Date?

        public init (
            mode: S3ClientTypes.ObjectLockRetentionMode? = nil,
            retainUntilDate: ClientRuntime.Date? = nil
        )
        {
            self.mode = mode
            self.retainUntilDate = retainUntilDate
        }
    }

}

extension S3ClientTypes {
    public enum ObjectLockRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLockRetentionMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLockRetentionMode(rawValue: rawValue) ?? ObjectLockRetentionMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ObjectLockRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultRetention = "DefaultRetention"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let defaultRetention = defaultRetention {
            try container.encode(defaultRetention, forKey: ClientRuntime.Key("DefaultRetention"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultRetentionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.DefaultRetention.self, forKey: .defaultRetention)
        defaultRetention = defaultRetentionDecoded
    }
}

extension S3ClientTypes.ObjectLockRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container element for an Object Lock rule.
    public struct ObjectLockRule: Swift.Equatable {
        /// The default Object Lock retention mode and period that you want to apply to new objects placed in the specified bucket. Bucket settings require both a mode and a period. The period can be either Days or Years but you must select one. You cannot specify Days and Years at the same time.
        public var defaultRetention: S3ClientTypes.DefaultRetention?

        public init (
            defaultRetention: S3ClientTypes.DefaultRetention? = nil
        )
        {
            self.defaultRetention = defaultRetention
        }
    }

}

extension ObjectNotInActiveTierError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
        self._requestID2 = requestID2
    }
}

/// The source object of the COPY action is not in the active tier and is only stored in Amazon S3 Glacier.
public struct ObjectNotInActiveTierError: AWSClientRuntime.S3HttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var _requestID2: Swift.String?

}

extension S3ClientTypes {
    /// The container element for object ownership for a bucket's ownership controls. BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the bucket-owner-full-control canned ACL. ObjectWriter - The uploading account will own the object if the object is uploaded with the bucket-owner-full-control canned ACL. BucketOwnerEnforced - Access control lists (ACLs) are disabled and no longer affect permissions. The bucket owner automatically owns and has full control over every object in the bucket. The bucket only accepts PUT requests that don't specify an ACL or bucket owner full control ACLs, such as the bucket-owner-full-control canned ACL or an equivalent form of this ACL expressed in the XML format.
    public enum ObjectOwnership: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketownerenforced
        case bucketownerpreferred
        case objectwriter
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectOwnership] {
            return [
                .bucketownerenforced,
                .bucketownerpreferred,
                .objectwriter,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketownerenforced: return "BucketOwnerEnforced"
            case .bucketownerpreferred: return "BucketOwnerPreferred"
            case .objectwriter: return "ObjectWriter"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectOwnership(rawValue: rawValue) ?? ObjectOwnership.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum ObjectStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case outposts
        case reducedRedundancy
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .outposts,
                .reducedRedundancy,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .outposts: return "OUTPOSTS"
            case .reducedRedundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectStorageClass(rawValue: rawValue) ?? ObjectStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ObjectVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case isLatest = "IsLatest"
        case key = "Key"
        case lastModified = "LastModified"
        case owner = "Owner"
        case size = "Size"
        case storageClass = "StorageClass"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: ClientRuntime.Key("ETag"))
        }
        if isLatest != false {
            try container.encode(isLatest, forKey: ClientRuntime.Key("IsLatest"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let lastModified = lastModified {
            try container.encode(ClientRuntime.TimestampWrapper(lastModified, format: .dateTime), forKey: ClientRuntime.Key("LastModified"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if size != 0 {
            try container.encode(size, forKey: ClientRuntime.Key("Size"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectVersionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isLatestDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isLatest)
        isLatest = isLatestDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        var lastModifiedBuffer:ClientRuntime.Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
        let ownerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension S3ClientTypes.ObjectVersion: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The version of an object.
    public struct ObjectVersion: Swift.Equatable {
        /// The entity tag is an MD5 hash of that version of the object.
        public var eTag: Swift.String?
        /// Specifies whether the object is (true) or is not (false) the latest version of an object.
        public var isLatest: Swift.Bool
        /// The object key.
        public var key: Swift.String?
        /// Date and time the object was last modified.
        public var lastModified: ClientRuntime.Date?
        /// Specifies the owner of the object.
        public var owner: S3ClientTypes.Owner?
        /// Size in bytes of the object.
        public var size: Swift.Int
        /// The class of storage used to store the object.
        public var storageClass: S3ClientTypes.ObjectVersionStorageClass?
        /// Version ID of an object.
        public var versionId: Swift.String?

        public init (
            eTag: Swift.String? = nil,
            isLatest: Swift.Bool = false,
            key: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            owner: S3ClientTypes.Owner? = nil,
            size: Swift.Int = 0,
            storageClass: S3ClientTypes.ObjectVersionStorageClass? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.isLatest = isLatest
            self.key = key
            self.lastModified = lastModified
            self.owner = owner
            self.size = size
            self.storageClass = storageClass
            self.versionId = versionId
        }
    }

}

extension S3ClientTypes {
    public enum ObjectVersionStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectVersionStorageClass] {
            return [
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectVersionStorageClass(rawValue: rawValue) ?? ObjectVersionStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.OutputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3 = "S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let s3 = s3 {
            try container.encode(s3, forKey: ClientRuntime.Key("S3"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3ClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension S3ClientTypes.OutputLocation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes the location where the restore job's output is stored.
    public struct OutputLocation: Swift.Equatable {
        /// Describes an S3 location that will receive the results of the restore request.
        public var s3: S3ClientTypes.S3Location?

        public init (
            s3: S3ClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension S3ClientTypes.OutputSerialization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cSV = "CSV"
        case jSON = "JSON"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cSV = cSV {
            try container.encode(cSV, forKey: ClientRuntime.Key("CSV"))
        }
        if let jSON = jSON {
            try container.encode(jSON, forKey: ClientRuntime.Key("JSON"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cSVDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CSVOutput.self, forKey: .cSV)
        cSV = cSVDecoded
        let jSONDecoded = try containerValues.decodeIfPresent(S3ClientTypes.JSONOutput.self, forKey: .jSON)
        jSON = jSONDecoded
    }
}

extension S3ClientTypes.OutputSerialization: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes how results of the Select job are serialized.
    public struct OutputSerialization: Swift.Equatable {
        /// Describes the serialization of CSV-encoded Select results.
        public var cSV: S3ClientTypes.CSVOutput?
        /// Specifies JSON as request's output serialization format.
        public var jSON: S3ClientTypes.JSONOutput?

        public init (
            cSV: S3ClientTypes.CSVOutput? = nil,
            jSON: S3ClientTypes.JSONOutput? = nil
        )
        {
            self.cSV = cSV
            self.jSON = jSON
        }
    }

}

extension S3ClientTypes.Owner: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case iD = "ID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: ClientRuntime.Key("DisplayName"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: ClientRuntime.Key("ID"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
    }
}

extension S3ClientTypes.Owner: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the owner's display name and ID.
    public struct Owner: Swift.Equatable {
        /// Container for the display name of the owner.
        public var displayName: Swift.String?
        /// Container for the ID of the owner.
        public var iD: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            iD: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.iD = iD
        }
    }

}

extension S3ClientTypes {
    public enum OwnerOverride: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case destination
        case sdkUnknown(Swift.String)

        public static var allCases: [OwnerOverride] {
            return [
                .destination,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .destination: return "Destination"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OwnerOverride(rawValue: rawValue) ?? OwnerOverride.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.OwnershipControls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for ownershipcontrolsrule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Rule"))
                    try rulesContainer0.encode(ownershipcontrolsrule0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.OwnershipControlsRule].self, forKey: .rules)
                var rulesBuffer:[S3ClientTypes.OwnershipControlsRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ClientTypes.OwnershipControlsRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ClientTypes.OwnershipControls: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container element for a bucket's ownership controls.
    public struct OwnershipControls: Swift.Equatable {
        /// The container element for an ownership control rule.
        /// This member is required.
        public var rules: [S3ClientTypes.OwnershipControlsRule]?

        public init (
            rules: [S3ClientTypes.OwnershipControlsRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension S3ClientTypes.OwnershipControlsRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectOwnership = "ObjectOwnership"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let objectOwnership = objectOwnership {
            try container.encode(objectOwnership, forKey: ClientRuntime.Key("ObjectOwnership"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectOwnershipDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectOwnership.self, forKey: .objectOwnership)
        objectOwnership = objectOwnershipDecoded
    }
}

extension S3ClientTypes.OwnershipControlsRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container element for an ownership control rule.
    public struct OwnershipControlsRule: Swift.Equatable {
        /// The container element for object ownership for a bucket's ownership controls. BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the bucket-owner-full-control canned ACL. ObjectWriter - The uploading account will own the object if the object is uploaded with the bucket-owner-full-control canned ACL. BucketOwnerEnforced - Access control lists (ACLs) are disabled and no longer affect permissions. The bucket owner automatically owns and has full control over every object in the bucket. The bucket only accepts PUT requests that don't specify an ACL or bucket owner full control ACLs, such as the bucket-owner-full-control canned ACL or an equivalent form of this ACL expressed in the XML format.
        /// This member is required.
        public var objectOwnership: S3ClientTypes.ObjectOwnership?

        public init (
            objectOwnership: S3ClientTypes.ObjectOwnership? = nil
        )
        {
            self.objectOwnership = objectOwnership
        }
    }

}

extension S3ClientTypes.ParquetInput: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension S3ClientTypes {
    /// Container for Parquet.
    public struct ParquetInput: Swift.Equatable {

    }

}

extension S3ClientTypes.Part: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case lastModified = "LastModified"
        case partNumber = "PartNumber"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: ClientRuntime.Key("ETag"))
        }
        if let lastModified = lastModified {
            try container.encode(ClientRuntime.TimestampWrapper(lastModified, format: .dateTime), forKey: ClientRuntime.Key("LastModified"))
        }
        if partNumber != 0 {
            try container.encode(partNumber, forKey: ClientRuntime.Key("PartNumber"))
        }
        if size != 0 {
            try container.encode(size, forKey: ClientRuntime.Key("Size"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .partNumber)
        partNumber = partNumberDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        var lastModifiedBuffer:ClientRuntime.Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension S3ClientTypes.Part: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for elements related to a part.
    public struct Part: Swift.Equatable {
        /// Entity tag returned when the part was uploaded.
        public var eTag: Swift.String?
        /// Date and time at which the part was uploaded.
        public var lastModified: ClientRuntime.Date?
        /// Part number identifying the part. This is a positive integer between 1 and 10,000.
        public var partNumber: Swift.Int
        /// Size in bytes of the uploaded part data.
        public var size: Swift.Int

        public init (
            eTag: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            partNumber: Swift.Int = 0,
            size: Swift.Int = 0
        )
        {
            self.eTag = eTag
            self.lastModified = lastModified
            self.partNumber = partNumber
            self.size = size
        }
    }

}

extension S3ClientTypes {
    public enum Payer: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketowner
        case requester
        case sdkUnknown(Swift.String)

        public static var allCases: [Payer] {
            return [
                .bucketowner,
                .requester,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketowner: return "BucketOwner"
            case .requester: return "Requester"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Payer(rawValue: rawValue) ?? Payer.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.PolicyStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPublic = "IsPublic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isPublic != false {
            try container.encode(isPublic, forKey: ClientRuntime.Key("IsPublic"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isPublicDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
    }
}

extension S3ClientTypes.PolicyStatus: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container element for a bucket's policy status.
    public struct PolicyStatus: Swift.Equatable {
        /// The policy status for this bucket. TRUE indicates that this bucket is public. FALSE indicates that the bucket is not public.
        public var isPublic: Swift.Bool

        public init (
            isPublic: Swift.Bool = false
        )
        {
            self.isPublic = isPublic
        }
    }

}

extension S3ClientTypes.Progress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesProcessed = "BytesProcessed"
        case bytesReturned = "BytesReturned"
        case bytesScanned = "BytesScanned"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if bytesProcessed != 0 {
            try container.encode(bytesProcessed, forKey: ClientRuntime.Key("BytesProcessed"))
        }
        if bytesReturned != 0 {
            try container.encode(bytesReturned, forKey: ClientRuntime.Key("BytesReturned"))
        }
        if bytesScanned != 0 {
            try container.encode(bytesScanned, forKey: ClientRuntime.Key("BytesScanned"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesScannedDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
        let bytesProcessedDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesReturnedDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytesReturned)
        bytesReturned = bytesReturnedDecoded
    }
}

extension S3ClientTypes.Progress: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// This data type contains information about progress of an operation.
    public struct Progress: Swift.Equatable {
        /// The current number of uncompressed object bytes processed.
        public var bytesProcessed: Swift.Int
        /// The current number of bytes of records payload data returned.
        public var bytesReturned: Swift.Int
        /// The current number of object bytes scanned.
        public var bytesScanned: Swift.Int

        public init (
            bytesProcessed: Swift.Int = 0,
            bytesReturned: Swift.Int = 0,
            bytesScanned: Swift.Int = 0
        )
        {
            self.bytesProcessed = bytesProcessed
            self.bytesReturned = bytesReturned
            self.bytesScanned = bytesScanned
        }
    }

}

extension S3ClientTypes.ProgressEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let details = details {
            try container.encode(details, forKey: ClientRuntime.Key("Details"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Progress.self, forKey: .details)
        details = detailsDecoded
    }
}

extension S3ClientTypes.ProgressEvent: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// This data type contains information about the progress event of an operation.
    public struct ProgressEvent: Swift.Equatable {
        /// The Progress event details.
        public var details: S3ClientTypes.Progress?

        public init (
            details: S3ClientTypes.Progress? = nil
        )
        {
            self.details = details
        }
    }

}

extension S3ClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "http"
            case .https: return "https"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.PublicAccessBlockConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "BlockPublicAcls"
        case blockPublicPolicy = "BlockPublicPolicy"
        case ignorePublicAcls = "IgnorePublicAcls"
        case restrictPublicBuckets = "RestrictPublicBuckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if blockPublicAcls != false {
            try container.encode(blockPublicAcls, forKey: ClientRuntime.Key("BlockPublicAcls"))
        }
        if blockPublicPolicy != false {
            try container.encode(blockPublicPolicy, forKey: ClientRuntime.Key("BlockPublicPolicy"))
        }
        if ignorePublicAcls != false {
            try container.encode(ignorePublicAcls, forKey: ClientRuntime.Key("IgnorePublicAcls"))
        }
        if restrictPublicBuckets != false {
            try container.encode(restrictPublicBuckets, forKey: ClientRuntime.Key("RestrictPublicBuckets"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let ignorePublicAclsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
        let restrictPublicBucketsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension S3ClientTypes.PublicAccessBlockConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public struct PublicAccessBlockConfiguration: Swift.Equatable {
        /// Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to TRUE causes the following behavior:
        ///
        /// * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
        ///
        /// * PUT Object calls fail if the request includes a public ACL.
        ///
        /// * PUT Bucket calls fail if the request includes a public ACL.
        ///
        ///
        /// Enabling this setting doesn't affect existing policies or ACLs.
        public var blockPublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
        public var blockPublicPolicy: Swift.Bool
        /// Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        public var ignorePublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only Amazon Web Service principals and authorized users within this account if the bucket has a public policy. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        public var restrictPublicBuckets: Swift.Bool

        public init (
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

public struct PutBucketAccelerateConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketAccelerateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketAccelerateConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketAccelerateConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let accelerateConfiguration = input.operationInput.accelerateConfiguration {
                let accelerateConfigurationdata = try encoder.encode(accelerateConfiguration)
                let accelerateConfigurationbody = ClientRuntime.HttpBody.data(accelerateConfigurationdata)
                input.builder.withBody(accelerateConfigurationbody)
            } else {
                let accelerateConfigurationdata = try encoder.encode(input.operationInput)
                let accelerateConfigurationbody = ClientRuntime.HttpBody.data(accelerateConfigurationdata)
                input.builder.withBody(accelerateConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketAccelerateConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketAccelerateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketAccelerateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketAccelerateConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketAccelerateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerateConfiguration = "AccelerateConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accelerateConfiguration = accelerateConfiguration {
            try container.encode(accelerateConfiguration, forKey: ClientRuntime.Key("AccelerateConfiguration"))
        }
    }
}

extension PutBucketAccelerateConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketAccelerateConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "accelerate", value: nil))
        return items
    }
}

extension PutBucketAccelerateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketAccelerateConfigurationInput: Swift.Equatable {
    /// Container for setting the transfer acceleration state.
    /// This member is required.
    public var accelerateConfiguration: S3ClientTypes.AccelerateConfiguration?
    /// The name of the bucket for which the accelerate configuration is set.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        accelerateConfiguration: S3ClientTypes.AccelerateConfiguration? = nil,
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.accelerateConfiguration = accelerateConfiguration
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct PutBucketAccelerateConfigurationInputBody: Swift.Equatable {
    let accelerateConfiguration: S3ClientTypes.AccelerateConfiguration?
}

extension PutBucketAccelerateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerateConfiguration = "AccelerateConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accelerateConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AccelerateConfiguration.self, forKey: .accelerateConfiguration)
        accelerateConfiguration = accelerateConfigurationDecoded
    }
}

extension PutBucketAccelerateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketAccelerateConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketAccelerateConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketAccelerateConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketAccelerateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketAccelerateConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketAccelerateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketAccelerateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketAccelerateConfigurationOutputResponse: Swift.Equatable {

}

public struct PutBucketAclInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketAclInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketAclInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketAclOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let accessControlPolicy = input.operationInput.accessControlPolicy {
                let accessControlPolicydata = try encoder.encode(accessControlPolicy)
                let accessControlPolicybody = ClientRuntime.HttpBody.data(accessControlPolicydata)
                input.builder.withBody(accessControlPolicybody)
            } else {
                let accessControlPolicydata = try encoder.encode(input.operationInput)
                let accessControlPolicybody = ClientRuntime.HttpBody.data(accessControlPolicydata)
                input.builder.withBody(accessControlPolicybody)
            }
        } catch let err {
            throw SdkError<PutBucketAclOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketAclInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketAclInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketAclInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlPolicy = accessControlPolicy {
            try container.encode(accessControlPolicy, forKey: ClientRuntime.Key("AccessControlPolicy"))
        }
    }
}

extension PutBucketAclInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let aCL = aCL {
            items.add(Header(name: "x-amz-acl", value: Swift.String(aCL.rawValue)))
        }
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWrite = grantWrite {
            items.add(Header(name: "x-amz-grant-write", value: Swift.String(grantWrite)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        return items
    }
}

extension PutBucketAclInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "acl", value: nil))
        return items
    }
}

extension PutBucketAclInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketAclInput: Swift.Equatable {
    /// The canned ACL to apply to the bucket.
    public var aCL: S3ClientTypes.BucketCannedACL?
    /// Contains the elements that set the ACL permissions for an object per grantee.
    public var accessControlPolicy: S3ClientTypes.AccessControlPolicy?
    /// The bucket to which to apply the ACL.
    /// This member is required.
    public var bucket: Swift.String?
    /// The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message integrity check to verify that the request body was not corrupted in transit. For more information, go to [RFC 1864.](http://www.ietf.org/rfc/rfc1864.txt) For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
    public var grantFullControl: Swift.String?
    /// Allows grantee to list the objects in the bucket.
    public var grantRead: Swift.String?
    /// Allows grantee to read the bucket ACL.
    public var grantReadACP: Swift.String?
    /// Allows grantee to create new objects in the bucket. For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.
    public var grantWrite: Swift.String?
    /// Allows grantee to write the ACL for the applicable bucket.
    public var grantWriteACP: Swift.String?

    public init (
        aCL: S3ClientTypes.BucketCannedACL? = nil,
        accessControlPolicy: S3ClientTypes.AccessControlPolicy? = nil,
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWrite: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil
    )
    {
        self.aCL = aCL
        self.accessControlPolicy = accessControlPolicy
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
    }
}

struct PutBucketAclInputBody: Swift.Equatable {
    let accessControlPolicy: S3ClientTypes.AccessControlPolicy?
}

extension PutBucketAclInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlPolicyDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AccessControlPolicy.self, forKey: .accessControlPolicy)
        accessControlPolicy = accessControlPolicyDecoded
    }
}

extension PutBucketAclOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketAclOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketAclOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketAclOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketAclOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketAclOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketAclOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketAclOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketAclOutputResponse: Swift.Equatable {

}

public struct PutBucketAnalyticsConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketAnalyticsConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketAnalyticsConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let analyticsConfiguration = input.operationInput.analyticsConfiguration {
                let analyticsConfigurationdata = try encoder.encode(analyticsConfiguration)
                let analyticsConfigurationbody = ClientRuntime.HttpBody.data(analyticsConfigurationdata)
                input.builder.withBody(analyticsConfigurationbody)
            } else {
                let analyticsConfigurationdata = try encoder.encode(input.operationInput)
                let analyticsConfigurationbody = ClientRuntime.HttpBody.data(analyticsConfigurationdata)
                input.builder.withBody(analyticsConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketAnalyticsConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketAnalyticsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketAnalyticsConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketAnalyticsConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyticsConfiguration = "AnalyticsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let analyticsConfiguration = analyticsConfiguration {
            try container.encode(analyticsConfiguration, forKey: ClientRuntime.Key("AnalyticsConfiguration"))
        }
    }
}

extension PutBucketAnalyticsConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketAnalyticsConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "analytics", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension PutBucketAnalyticsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketAnalyticsConfigurationInput: Swift.Equatable {
    /// The configuration and any analyses for the analytics filter.
    /// This member is required.
    public var analyticsConfiguration: S3ClientTypes.AnalyticsConfiguration?
    /// The name of the bucket to which an analytics configuration is stored.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID that identifies the analytics configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        analyticsConfiguration: S3ClientTypes.AnalyticsConfiguration? = nil,
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.analyticsConfiguration = analyticsConfiguration
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct PutBucketAnalyticsConfigurationInputBody: Swift.Equatable {
    let analyticsConfiguration: S3ClientTypes.AnalyticsConfiguration?
}

extension PutBucketAnalyticsConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyticsConfiguration = "AnalyticsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyticsConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AnalyticsConfiguration.self, forKey: .analyticsConfiguration)
        analyticsConfiguration = analyticsConfigurationDecoded
    }
}

extension PutBucketAnalyticsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketAnalyticsConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketAnalyticsConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketAnalyticsConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketAnalyticsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketAnalyticsConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketAnalyticsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketAnalyticsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketAnalyticsConfigurationOutputResponse: Swift.Equatable {

}

public struct PutBucketCorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketCorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketCorsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketCorsOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cORSConfiguration = input.operationInput.cORSConfiguration {
                let cORSConfigurationdata = try encoder.encode(cORSConfiguration)
                let cORSConfigurationbody = ClientRuntime.HttpBody.data(cORSConfigurationdata)
                input.builder.withBody(cORSConfigurationbody)
            } else {
                let cORSConfigurationdata = try encoder.encode(input.operationInput)
                let cORSConfigurationbody = ClientRuntime.HttpBody.data(cORSConfigurationdata)
                input.builder.withBody(cORSConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketCorsOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketCorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketCorsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketCorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cORSConfiguration = "CORSConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cORSConfiguration = cORSConfiguration {
            try container.encode(cORSConfiguration, forKey: ClientRuntime.Key("CORSConfiguration"))
        }
    }
}

extension PutBucketCorsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketCorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "cors", value: nil))
        return items
    }
}

extension PutBucketCorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketCorsInput: Swift.Equatable {
    /// Specifies the bucket impacted by the corsconfiguration.
    /// This member is required.
    public var bucket: Swift.String?
    /// Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var cORSConfiguration: S3ClientTypes.CORSConfiguration?
    /// The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message integrity check to verify that the request body was not corrupted in transit. For more information, go to [RFC 1864.](http://www.ietf.org/rfc/rfc1864.txt) For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        cORSConfiguration: S3ClientTypes.CORSConfiguration? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.cORSConfiguration = cORSConfiguration
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct PutBucketCorsInputBody: Swift.Equatable {
    let cORSConfiguration: S3ClientTypes.CORSConfiguration?
}

extension PutBucketCorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cORSConfiguration = "CORSConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cORSConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CORSConfiguration.self, forKey: .cORSConfiguration)
        cORSConfiguration = cORSConfigurationDecoded
    }
}

extension PutBucketCorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketCorsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketCorsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketCorsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketCorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketCorsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketCorsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketCorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketCorsOutputResponse: Swift.Equatable {

}

public struct PutBucketEncryptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketEncryptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketEncryptionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketEncryptionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let serverSideEncryptionConfiguration = input.operationInput.serverSideEncryptionConfiguration {
                let serverSideEncryptionConfigurationdata = try encoder.encode(serverSideEncryptionConfiguration)
                let serverSideEncryptionConfigurationbody = ClientRuntime.HttpBody.data(serverSideEncryptionConfigurationdata)
                input.builder.withBody(serverSideEncryptionConfigurationbody)
            } else {
                let serverSideEncryptionConfigurationdata = try encoder.encode(input.operationInput)
                let serverSideEncryptionConfigurationbody = ClientRuntime.HttpBody.data(serverSideEncryptionConfigurationdata)
                input.builder.withBody(serverSideEncryptionConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketEncryptionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketEncryptionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketEncryptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try container.encode(serverSideEncryptionConfiguration, forKey: ClientRuntime.Key("ServerSideEncryptionConfiguration"))
        }
    }
}

extension PutBucketEncryptionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketEncryptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "encryption", value: nil))
        return items
    }
}

extension PutBucketEncryptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketEncryptionInput: Swift.Equatable {
    /// Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3) or customer managed keys (SSE-KMS). For information about the Amazon S3 default encryption feature, see [Amazon S3 Default Bucket Encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The base64-encoded 128-bit MD5 digest of the server-side encryption configuration. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Specifies the default server-side-encryption configuration.
    /// This member is required.
    public var serverSideEncryptionConfiguration: S3ClientTypes.ServerSideEncryptionConfiguration?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        serverSideEncryptionConfiguration: S3ClientTypes.ServerSideEncryptionConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct PutBucketEncryptionInputBody: Swift.Equatable {
    let serverSideEncryptionConfiguration: S3ClientTypes.ServerSideEncryptionConfiguration?
}

extension PutBucketEncryptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension PutBucketEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketEncryptionOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketEncryptionOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketEncryptionOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketEncryptionOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketEncryptionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketEncryptionOutputResponse: Swift.Equatable {

}

public struct PutBucketIntelligentTieringConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketIntelligentTieringConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let intelligentTieringConfiguration = input.operationInput.intelligentTieringConfiguration {
                let intelligentTieringConfigurationdata = try encoder.encode(intelligentTieringConfiguration)
                let intelligentTieringConfigurationbody = ClientRuntime.HttpBody.data(intelligentTieringConfigurationdata)
                input.builder.withBody(intelligentTieringConfigurationbody)
            } else {
                let intelligentTieringConfigurationdata = try encoder.encode(input.operationInput)
                let intelligentTieringConfigurationbody = ClientRuntime.HttpBody.data(intelligentTieringConfigurationdata)
                input.builder.withBody(intelligentTieringConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketIntelligentTieringConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketIntelligentTieringConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketIntelligentTieringConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intelligentTieringConfiguration = "IntelligentTieringConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let intelligentTieringConfiguration = intelligentTieringConfiguration {
            try container.encode(intelligentTieringConfiguration, forKey: ClientRuntime.Key("IntelligentTieringConfiguration"))
        }
    }
}

extension PutBucketIntelligentTieringConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "intelligent-tiering", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension PutBucketIntelligentTieringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketIntelligentTieringConfigurationInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.
    /// This member is required.
    public var bucket: Swift.String?
    /// The ID used to identify the S3 Intelligent-Tiering configuration.
    /// This member is required.
    public var id: Swift.String?
    /// Container for S3 Intelligent-Tiering configuration.
    /// This member is required.
    public var intelligentTieringConfiguration: S3ClientTypes.IntelligentTieringConfiguration?

    public init (
        bucket: Swift.String? = nil,
        id: Swift.String? = nil,
        intelligentTieringConfiguration: S3ClientTypes.IntelligentTieringConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.id = id
        self.intelligentTieringConfiguration = intelligentTieringConfiguration
    }
}

struct PutBucketIntelligentTieringConfigurationInputBody: Swift.Equatable {
    let intelligentTieringConfiguration: S3ClientTypes.IntelligentTieringConfiguration?
}

extension PutBucketIntelligentTieringConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intelligentTieringConfiguration = "IntelligentTieringConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intelligentTieringConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IntelligentTieringConfiguration.self, forKey: .intelligentTieringConfiguration)
        intelligentTieringConfiguration = intelligentTieringConfigurationDecoded
    }
}

extension PutBucketIntelligentTieringConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketIntelligentTieringConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketIntelligentTieringConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketIntelligentTieringConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketIntelligentTieringConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketIntelligentTieringConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketIntelligentTieringConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketIntelligentTieringConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketIntelligentTieringConfigurationOutputResponse: Swift.Equatable {

}

public struct PutBucketInventoryConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketInventoryConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketInventoryConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketInventoryConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let inventoryConfiguration = input.operationInput.inventoryConfiguration {
                let inventoryConfigurationdata = try encoder.encode(inventoryConfiguration)
                let inventoryConfigurationbody = ClientRuntime.HttpBody.data(inventoryConfigurationdata)
                input.builder.withBody(inventoryConfigurationbody)
            } else {
                let inventoryConfigurationdata = try encoder.encode(input.operationInput)
                let inventoryConfigurationbody = ClientRuntime.HttpBody.data(inventoryConfigurationdata)
                input.builder.withBody(inventoryConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketInventoryConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketInventoryConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketInventoryConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketInventoryConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inventoryConfiguration = "InventoryConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let inventoryConfiguration = inventoryConfiguration {
            try container.encode(inventoryConfiguration, forKey: ClientRuntime.Key("InventoryConfiguration"))
        }
    }
}

extension PutBucketInventoryConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketInventoryConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "inventory", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension PutBucketInventoryConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketInventoryConfigurationInput: Swift.Equatable {
    /// The name of the bucket where the inventory configuration will be stored.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID used to identify the inventory configuration.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the inventory configuration.
    /// This member is required.
    public var inventoryConfiguration: S3ClientTypes.InventoryConfiguration?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil,
        inventoryConfiguration: S3ClientTypes.InventoryConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
        self.inventoryConfiguration = inventoryConfiguration
    }
}

struct PutBucketInventoryConfigurationInputBody: Swift.Equatable {
    let inventoryConfiguration: S3ClientTypes.InventoryConfiguration?
}

extension PutBucketInventoryConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inventoryConfiguration = "InventoryConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inventoryConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InventoryConfiguration.self, forKey: .inventoryConfiguration)
        inventoryConfiguration = inventoryConfigurationDecoded
    }
}

extension PutBucketInventoryConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketInventoryConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketInventoryConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketInventoryConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketInventoryConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketInventoryConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketInventoryConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketInventoryConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketInventoryConfigurationOutputResponse: Swift.Equatable {

}

public struct PutBucketLifecycleConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketLifecycleConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let lifecycleConfiguration = input.operationInput.lifecycleConfiguration {
                let lifecycleConfigurationdata = try encoder.encode(lifecycleConfiguration)
                let lifecycleConfigurationbody = ClientRuntime.HttpBody.data(lifecycleConfigurationdata)
                input.builder.withBody(lifecycleConfigurationbody)
            } else {
                let lifecycleConfigurationdata = try encoder.encode(input.operationInput)
                let lifecycleConfigurationbody = ClientRuntime.HttpBody.data(lifecycleConfigurationdata)
                input.builder.withBody(lifecycleConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketLifecycleConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketLifecycleConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let lifecycleConfiguration = lifecycleConfiguration {
            try container.encode(lifecycleConfiguration, forKey: ClientRuntime.Key("LifecycleConfiguration"))
        }
    }
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "lifecycle", value: nil))
        return items
    }
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The name of the bucket for which to set the configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Container for lifecycle rules. You can add as many as 1,000 rules.
    public var lifecycleConfiguration: S3ClientTypes.BucketLifecycleConfiguration?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        lifecycleConfiguration: S3ClientTypes.BucketLifecycleConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.lifecycleConfiguration = lifecycleConfiguration
    }
}

struct PutBucketLifecycleConfigurationInputBody: Swift.Equatable {
    let lifecycleConfiguration: S3ClientTypes.BucketLifecycleConfiguration?
}

extension PutBucketLifecycleConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketLifecycleConfiguration.self, forKey: .lifecycleConfiguration)
        lifecycleConfiguration = lifecycleConfigurationDecoded
    }
}

extension PutBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketLifecycleConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketLifecycleConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketLifecycleConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketLifecycleConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketLifecycleConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketLifecycleConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketLifecycleConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketLifecycleConfigurationOutputResponse: Swift.Equatable {

}

public struct PutBucketLoggingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketLoggingInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketLoggingOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let bucketLoggingStatus = input.operationInput.bucketLoggingStatus {
                let bucketLoggingStatusdata = try encoder.encode(bucketLoggingStatus)
                let bucketLoggingStatusbody = ClientRuntime.HttpBody.data(bucketLoggingStatusdata)
                input.builder.withBody(bucketLoggingStatusbody)
            } else {
                let bucketLoggingStatusdata = try encoder.encode(input.operationInput)
                let bucketLoggingStatusbody = ClientRuntime.HttpBody.data(bucketLoggingStatusdata)
                input.builder.withBody(bucketLoggingStatusbody)
            }
        } catch let err {
            throw SdkError<PutBucketLoggingOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketLoggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketLoggingInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketLoggingStatus = "BucketLoggingStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucketLoggingStatus = bucketLoggingStatus {
            try container.encode(bucketLoggingStatus, forKey: ClientRuntime.Key("BucketLoggingStatus"))
        }
    }
}

extension PutBucketLoggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketLoggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "logging", value: nil))
        return items
    }
}

extension PutBucketLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketLoggingInput: Swift.Equatable {
    /// The name of the bucket for which to set the logging parameters.
    /// This member is required.
    public var bucket: Swift.String?
    /// Container for logging status information.
    /// This member is required.
    public var bucketLoggingStatus: S3ClientTypes.BucketLoggingStatus?
    /// The MD5 hash of the PutBucketLogging request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        bucketLoggingStatus: S3ClientTypes.BucketLoggingStatus? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.bucketLoggingStatus = bucketLoggingStatus
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct PutBucketLoggingInputBody: Swift.Equatable {
    let bucketLoggingStatus: S3ClientTypes.BucketLoggingStatus?
}

extension PutBucketLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketLoggingStatus = "BucketLoggingStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketLoggingStatusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketLoggingStatus.self, forKey: .bucketLoggingStatus)
        bucketLoggingStatus = bucketLoggingStatusDecoded
    }
}

extension PutBucketLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketLoggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketLoggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketLoggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketLoggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketLoggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketLoggingOutputResponse: Swift.Equatable {

}

public struct PutBucketMetricsConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketMetricsConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketMetricsConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketMetricsConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let metricsConfiguration = input.operationInput.metricsConfiguration {
                let metricsConfigurationdata = try encoder.encode(metricsConfiguration)
                let metricsConfigurationbody = ClientRuntime.HttpBody.data(metricsConfigurationdata)
                input.builder.withBody(metricsConfigurationbody)
            } else {
                let metricsConfigurationdata = try encoder.encode(input.operationInput)
                let metricsConfigurationbody = ClientRuntime.HttpBody.data(metricsConfigurationdata)
                input.builder.withBody(metricsConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketMetricsConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketMetricsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketMetricsConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketMetricsConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricsConfiguration = "MetricsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let metricsConfiguration = metricsConfiguration {
            try container.encode(metricsConfiguration, forKey: ClientRuntime.Key("MetricsConfiguration"))
        }
    }
}

extension PutBucketMetricsConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketMetricsConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "metrics", value: nil))
        if let id = id {
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
        }
        return items
    }
}

extension PutBucketMetricsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketMetricsConfigurationInput: Swift.Equatable {
    /// The name of the bucket for which the metrics configuration is set.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The ID used to identify the metrics configuration.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the metrics configuration.
    /// This member is required.
    public var metricsConfiguration: S3ClientTypes.MetricsConfiguration?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        id: Swift.String? = nil,
        metricsConfiguration: S3ClientTypes.MetricsConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
        self.metricsConfiguration = metricsConfiguration
    }
}

struct PutBucketMetricsConfigurationInputBody: Swift.Equatable {
    let metricsConfiguration: S3ClientTypes.MetricsConfiguration?
}

extension PutBucketMetricsConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricsConfiguration = "MetricsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
    }
}

extension PutBucketMetricsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketMetricsConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketMetricsConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketMetricsConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketMetricsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketMetricsConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketMetricsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketMetricsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketMetricsConfigurationOutputResponse: Swift.Equatable {

}

public struct PutBucketNotificationConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketNotificationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketNotificationConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketNotificationConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let notificationConfiguration = input.operationInput.notificationConfiguration {
                let notificationConfigurationdata = try encoder.encode(notificationConfiguration)
                let notificationConfigurationbody = ClientRuntime.HttpBody.data(notificationConfigurationdata)
                input.builder.withBody(notificationConfigurationbody)
            } else {
                let notificationConfigurationdata = try encoder.encode(input.operationInput)
                let notificationConfigurationbody = ClientRuntime.HttpBody.data(notificationConfigurationdata)
                input.builder.withBody(notificationConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketNotificationConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketNotificationConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketNotificationConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketNotificationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let notificationConfiguration = notificationConfiguration {
            try container.encode(notificationConfiguration, forKey: ClientRuntime.Key("NotificationConfiguration"))
        }
    }
}

extension PutBucketNotificationConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if skipDestinationValidation != false {
            items.add(Header(name: "x-amz-skip-destination-validation", value: Swift.String(skipDestinationValidation)))
        }
        return items
    }
}

extension PutBucketNotificationConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "notification", value: nil))
        return items
    }
}

extension PutBucketNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketNotificationConfigurationInput: Swift.Equatable {
    /// The name of the bucket.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket.
    /// This member is required.
    public var notificationConfiguration: S3ClientTypes.NotificationConfiguration?
    /// Skips validation of Amazon SQS, Amazon SNS, and Lambda destinations. True or false value.
    public var skipDestinationValidation: Swift.Bool

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        notificationConfiguration: S3ClientTypes.NotificationConfiguration? = nil,
        skipDestinationValidation: Swift.Bool = false
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.notificationConfiguration = notificationConfiguration
        self.skipDestinationValidation = skipDestinationValidation
    }
}

struct PutBucketNotificationConfigurationInputBody: Swift.Equatable {
    let notificationConfiguration: S3ClientTypes.NotificationConfiguration?
}

extension PutBucketNotificationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension PutBucketNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketNotificationConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketNotificationConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketNotificationConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketNotificationConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketNotificationConfigurationOutputResponse: Swift.Equatable {

}

public struct PutBucketOwnershipControlsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketOwnershipControlsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketOwnershipControlsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketOwnershipControlsOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let ownershipControls = input.operationInput.ownershipControls {
                let ownershipControlsdata = try encoder.encode(ownershipControls)
                let ownershipControlsbody = ClientRuntime.HttpBody.data(ownershipControlsdata)
                input.builder.withBody(ownershipControlsbody)
            } else {
                let ownershipControlsdata = try encoder.encode(input.operationInput)
                let ownershipControlsbody = ClientRuntime.HttpBody.data(ownershipControlsdata)
                input.builder.withBody(ownershipControlsbody)
            }
        } catch let err {
            throw SdkError<PutBucketOwnershipControlsOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketOwnershipControlsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketOwnershipControlsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketOwnershipControlsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownershipControls = "OwnershipControls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let ownershipControls = ownershipControls {
            try container.encode(ownershipControls, forKey: ClientRuntime.Key("OwnershipControls"))
        }
    }
}

extension PutBucketOwnershipControlsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketOwnershipControlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "ownershipControls", value: nil))
        return items
    }
}

extension PutBucketOwnershipControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketOwnershipControlsInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose OwnershipControls you want to set.
    /// This member is required.
    public var bucket: Swift.String?
    /// The MD5 hash of the OwnershipControls request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The OwnershipControls (BucketOwnerEnforced, BucketOwnerPreferred, or ObjectWriter) that you want to apply to this Amazon S3 bucket.
    /// This member is required.
    public var ownershipControls: S3ClientTypes.OwnershipControls?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        ownershipControls: S3ClientTypes.OwnershipControls? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.ownershipControls = ownershipControls
    }
}

struct PutBucketOwnershipControlsInputBody: Swift.Equatable {
    let ownershipControls: S3ClientTypes.OwnershipControls?
}

extension PutBucketOwnershipControlsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownershipControls = "OwnershipControls"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownershipControlsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.OwnershipControls.self, forKey: .ownershipControls)
        ownershipControls = ownershipControlsDecoded
    }
}

extension PutBucketOwnershipControlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketOwnershipControlsOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketOwnershipControlsOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketOwnershipControlsOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketOwnershipControlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketOwnershipControlsOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketOwnershipControlsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketOwnershipControlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketOwnershipControlsOutputResponse: Swift.Equatable {

}

public struct PutBucketPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketPolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let policy = input.operationInput.policy {
            let policydata = policy.data(using: .utf8)
            let policybody = ClientRuntime.HttpBody.data(policydata)
            input.builder.withBody(policybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
    }
}

extension PutBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if confirmRemoveSelfBucketAccess != false {
            items.add(Header(name: "x-amz-confirm-remove-self-bucket-access", value: Swift.String(confirmRemoveSelfBucketAccess)))
        }
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "policy", value: nil))
        return items
    }
}

extension PutBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketPolicyInput: Swift.Equatable {
    /// The name of the bucket.
    /// This member is required.
    public var bucket: Swift.String?
    /// Set this parameter to true to confirm that you want to remove your permissions to change this bucket policy in the future.
    public var confirmRemoveSelfBucketAccess: Swift.Bool
    /// The MD5 hash of the request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The bucket policy as a JSON document.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        confirmRemoveSelfBucketAccess: Swift.Bool = false,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.policy = policy
    }
}

struct PutBucketPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutBucketPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBucketPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketPolicyOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketPolicyOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketPolicyOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketPolicyOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketPolicyOutputResponse: Swift.Equatable {

}

public struct PutBucketReplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketReplicationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketReplicationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let replicationConfiguration = input.operationInput.replicationConfiguration {
                let replicationConfigurationdata = try encoder.encode(replicationConfiguration)
                let replicationConfigurationbody = ClientRuntime.HttpBody.data(replicationConfigurationdata)
                input.builder.withBody(replicationConfigurationbody)
            } else {
                let replicationConfigurationdata = try encoder.encode(input.operationInput)
                let replicationConfigurationbody = ClientRuntime.HttpBody.data(replicationConfigurationdata)
                input.builder.withBody(replicationConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketReplicationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketReplicationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let replicationConfiguration = replicationConfiguration {
            try container.encode(replicationConfiguration, forKey: ClientRuntime.Key("ReplicationConfiguration"))
        }
    }
}

extension PutBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let token = token {
            items.add(Header(name: "x-amz-bucket-object-lock-token", value: Swift.String(token)))
        }
        return items
    }
}

extension PutBucketReplicationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "replication", value: nil))
        return items
    }
}

extension PutBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketReplicationInput: Swift.Equatable {
    /// The name of the bucket
    /// This member is required.
    public var bucket: Swift.String?
    /// The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message integrity check to verify that the request body was not corrupted in transit. For more information, see [RFC 1864](http://www.ietf.org/rfc/rfc1864.txt). For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
    /// This member is required.
    public var replicationConfiguration: S3ClientTypes.ReplicationConfiguration?
    /// A token to allow Object Lock to be enabled for an existing bucket.
    public var token: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        replicationConfiguration: S3ClientTypes.ReplicationConfiguration? = nil,
        token: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.replicationConfiguration = replicationConfiguration
        self.token = token
    }
}

struct PutBucketReplicationInputBody: Swift.Equatable {
    let replicationConfiguration: S3ClientTypes.ReplicationConfiguration?
}

extension PutBucketReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension PutBucketReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketReplicationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketReplicationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketReplicationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketReplicationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketReplicationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketReplicationOutputResponse: Swift.Equatable {

}

public struct PutBucketRequestPaymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketRequestPaymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketRequestPaymentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketRequestPaymentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let requestPaymentConfiguration = input.operationInput.requestPaymentConfiguration {
                let requestPaymentConfigurationdata = try encoder.encode(requestPaymentConfiguration)
                let requestPaymentConfigurationbody = ClientRuntime.HttpBody.data(requestPaymentConfigurationdata)
                input.builder.withBody(requestPaymentConfigurationbody)
            } else {
                let requestPaymentConfigurationdata = try encoder.encode(input.operationInput)
                let requestPaymentConfigurationbody = ClientRuntime.HttpBody.data(requestPaymentConfigurationdata)
                input.builder.withBody(requestPaymentConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketRequestPaymentOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketRequestPaymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketRequestPaymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketRequestPaymentInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketRequestPaymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestPaymentConfiguration = "RequestPaymentConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let requestPaymentConfiguration = requestPaymentConfiguration {
            try container.encode(requestPaymentConfiguration, forKey: ClientRuntime.Key("RequestPaymentConfiguration"))
        }
    }
}

extension PutBucketRequestPaymentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketRequestPaymentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "requestPayment", value: nil))
        return items
    }
}

extension PutBucketRequestPaymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketRequestPaymentInput: Swift.Equatable {
    /// The bucket name.
    /// This member is required.
    public var bucket: Swift.String?
    /// The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message integrity check to verify that the request body was not corrupted in transit. For more information, see [RFC 1864](http://www.ietf.org/rfc/rfc1864.txt). For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Container for Payer.
    /// This member is required.
    public var requestPaymentConfiguration: S3ClientTypes.RequestPaymentConfiguration?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        requestPaymentConfiguration: S3ClientTypes.RequestPaymentConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.requestPaymentConfiguration = requestPaymentConfiguration
    }
}

struct PutBucketRequestPaymentInputBody: Swift.Equatable {
    let requestPaymentConfiguration: S3ClientTypes.RequestPaymentConfiguration?
}

extension PutBucketRequestPaymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestPaymentConfiguration = "RequestPaymentConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestPaymentConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.RequestPaymentConfiguration.self, forKey: .requestPaymentConfiguration)
        requestPaymentConfiguration = requestPaymentConfigurationDecoded
    }
}

extension PutBucketRequestPaymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketRequestPaymentOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketRequestPaymentOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketRequestPaymentOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketRequestPaymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketRequestPaymentOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketRequestPaymentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketRequestPaymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketRequestPaymentOutputResponse: Swift.Equatable {

}

public struct PutBucketTaggingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketTaggingInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketTaggingOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let tagging = input.operationInput.tagging {
                let taggingdata = try encoder.encode(tagging)
                let taggingbody = ClientRuntime.HttpBody.data(taggingdata)
                input.builder.withBody(taggingbody)
            } else {
                let taggingdata = try encoder.encode(input.operationInput)
                let taggingbody = ClientRuntime.HttpBody.data(taggingdata)
                input.builder.withBody(taggingbody)
            }
        } catch let err {
            throw SdkError<PutBucketTaggingOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketTaggingInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketTaggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: ClientRuntime.Key("Tagging"))
        }
    }
}

extension PutBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketTaggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "tagging", value: nil))
        return items
    }
}

extension PutBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketTaggingInput: Swift.Equatable {
    /// The bucket name.
    /// This member is required.
    public var bucket: Swift.String?
    /// The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message integrity check to verify that the request body was not corrupted in transit. For more information, see [RFC 1864](http://www.ietf.org/rfc/rfc1864.txt). For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Container for the TagSet and Tag elements.
    /// This member is required.
    public var tagging: S3ClientTypes.Tagging?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        tagging: S3ClientTypes.Tagging? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.tagging = tagging
    }
}

struct PutBucketTaggingInputBody: Swift.Equatable {
    let tagging: S3ClientTypes.Tagging?
}

extension PutBucketTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taggingDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
    }
}

extension PutBucketTaggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketTaggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketTaggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketTaggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketTaggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketTaggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketTaggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketTaggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketTaggingOutputResponse: Swift.Equatable {

}

public struct PutBucketVersioningInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketVersioningInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketVersioningInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketVersioningOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let versioningConfiguration = input.operationInput.versioningConfiguration {
                let versioningConfigurationdata = try encoder.encode(versioningConfiguration)
                let versioningConfigurationbody = ClientRuntime.HttpBody.data(versioningConfigurationdata)
                input.builder.withBody(versioningConfigurationbody)
            } else {
                let versioningConfigurationdata = try encoder.encode(input.operationInput)
                let versioningConfigurationbody = ClientRuntime.HttpBody.data(versioningConfigurationdata)
                input.builder.withBody(versioningConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketVersioningOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketVersioningInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketVersioningOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketVersioningInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketVersioningInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let versioningConfiguration = versioningConfiguration {
            try container.encode(versioningConfiguration, forKey: ClientRuntime.Key("VersioningConfiguration"))
        }
    }
}

extension PutBucketVersioningInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let mFA = mFA {
            items.add(Header(name: "x-amz-mfa", value: Swift.String(mFA)))
        }
        return items
    }
}

extension PutBucketVersioningInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "versioning", value: nil))
        return items
    }
}

extension PutBucketVersioningInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketVersioningInput: Swift.Equatable {
    /// The bucket name.
    /// This member is required.
    public var bucket: Swift.String?
    /// >The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message integrity check to verify that the request body was not corrupted in transit. For more information, see [RFC 1864](http://www.ietf.org/rfc/rfc1864.txt). For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
    public var mFA: Swift.String?
    /// Container for setting the versioning state.
    /// This member is required.
    public var versioningConfiguration: S3ClientTypes.VersioningConfiguration?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        mFA: Swift.String? = nil,
        versioningConfiguration: S3ClientTypes.VersioningConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.mFA = mFA
        self.versioningConfiguration = versioningConfiguration
    }
}

struct PutBucketVersioningInputBody: Swift.Equatable {
    let versioningConfiguration: S3ClientTypes.VersioningConfiguration?
}

extension PutBucketVersioningInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
    }
}

extension PutBucketVersioningOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketVersioningOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketVersioningOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketVersioningOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketVersioningOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketVersioningOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketVersioningOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketVersioningOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketVersioningOutputResponse: Swift.Equatable {

}

public struct PutBucketWebsiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketWebsiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketWebsiteInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketWebsiteOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let websiteConfiguration = input.operationInput.websiteConfiguration {
                let websiteConfigurationdata = try encoder.encode(websiteConfiguration)
                let websiteConfigurationbody = ClientRuntime.HttpBody.data(websiteConfigurationdata)
                input.builder.withBody(websiteConfigurationbody)
            } else {
                let websiteConfigurationdata = try encoder.encode(input.operationInput)
                let websiteConfigurationbody = ClientRuntime.HttpBody.data(websiteConfigurationdata)
                input.builder.withBody(websiteConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutBucketWebsiteOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketWebsiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketWebsiteInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketWebsiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case websiteConfiguration = "WebsiteConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let websiteConfiguration = websiteConfiguration {
            try container.encode(websiteConfiguration, forKey: ClientRuntime.Key("WebsiteConfiguration"))
        }
    }
}

extension PutBucketWebsiteInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutBucketWebsiteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "website", value: nil))
        return items
    }
}

extension PutBucketWebsiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutBucketWebsiteInput: Swift.Equatable {
    /// The bucket name.
    /// This member is required.
    public var bucket: Swift.String?
    /// The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message integrity check to verify that the request body was not corrupted in transit. For more information, see [RFC 1864](http://www.ietf.org/rfc/rfc1864.txt). For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Container for the request.
    /// This member is required.
    public var websiteConfiguration: S3ClientTypes.WebsiteConfiguration?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        websiteConfiguration: S3ClientTypes.WebsiteConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.websiteConfiguration = websiteConfiguration
    }
}

struct PutBucketWebsiteInputBody: Swift.Equatable {
    let websiteConfiguration: S3ClientTypes.WebsiteConfiguration?
}

extension PutBucketWebsiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case websiteConfiguration = "WebsiteConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.WebsiteConfiguration.self, forKey: .websiteConfiguration)
        websiteConfiguration = websiteConfigurationDecoded
    }
}

extension PutBucketWebsiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutBucketWebsiteOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutBucketWebsiteOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutBucketWebsiteOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutBucketWebsiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutBucketWebsiteOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutBucketWebsiteOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketWebsiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketWebsiteOutputResponse: Swift.Equatable {

}

public struct PutObjectAclInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectAclInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectAclInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectAclOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let accessControlPolicy = input.operationInput.accessControlPolicy {
                let accessControlPolicydata = try encoder.encode(accessControlPolicy)
                let accessControlPolicybody = ClientRuntime.HttpBody.data(accessControlPolicydata)
                input.builder.withBody(accessControlPolicybody)
            } else {
                let accessControlPolicydata = try encoder.encode(input.operationInput)
                let accessControlPolicybody = ClientRuntime.HttpBody.data(accessControlPolicydata)
                input.builder.withBody(accessControlPolicybody)
            }
        } catch let err {
            throw SdkError<PutObjectAclOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectAclInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectAclInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectAclInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlPolicy = accessControlPolicy {
            try container.encode(accessControlPolicy, forKey: ClientRuntime.Key("AccessControlPolicy"))
        }
    }
}

extension PutObjectAclInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let aCL = aCL {
            items.add(Header(name: "x-amz-acl", value: Swift.String(aCL.rawValue)))
        }
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWrite = grantWrite {
            items.add(Header(name: "x-amz-grant-write", value: Swift.String(grantWrite)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension PutObjectAclInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "acl", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension PutObjectAclInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct PutObjectAclInput: Swift.Equatable {
    /// The canned ACL to apply to the object. For more information, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL).
    public var aCL: S3ClientTypes.ObjectCannedACL?
    /// Contains the elements that set the ACL permissions for an object per grantee.
    public var accessControlPolicy: S3ClientTypes.AccessControlPolicy?
    /// The bucket name that contains the object to which you want to attach the ACL. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message integrity check to verify that the request body was not corrupted in transit. For more information, go to [RFC 1864.>](http://www.ietf.org/rfc/rfc1864.txt) For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket. This action is not supported by Amazon S3 on Outposts.
    public var grantFullControl: Swift.String?
    /// Allows grantee to list the objects in the bucket. This action is not supported by Amazon S3 on Outposts.
    public var grantRead: Swift.String?
    /// Allows grantee to read the bucket ACL. This action is not supported by Amazon S3 on Outposts.
    public var grantReadACP: Swift.String?
    /// Allows grantee to create new objects in the bucket. For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.
    public var grantWrite: Swift.String?
    /// Allows grantee to write the ACL for the applicable bucket. This action is not supported by Amazon S3 on Outposts.
    public var grantWriteACP: Swift.String?
    /// Key for which the PUT action was initiated. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// VersionId used to reference a specific version of the object.
    public var versionId: Swift.String?

    public init (
        aCL: S3ClientTypes.ObjectCannedACL? = nil,
        accessControlPolicy: S3ClientTypes.AccessControlPolicy? = nil,
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWrite: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aCL = aCL
        self.accessControlPolicy = accessControlPolicy
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct PutObjectAclInputBody: Swift.Equatable {
    let accessControlPolicy: S3ClientTypes.AccessControlPolicy?
}

extension PutObjectAclInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlPolicyDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AccessControlPolicy.self, forKey: .accessControlPolicy)
        accessControlPolicy = accessControlPolicyDecoded
    }
}

extension PutObjectAclOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutObjectAclOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutObjectAclOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutObjectAclOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutObjectAclOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchKey" : self = .noSuchKey(try NoSuchKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutObjectAclOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutObjectAclOutputError: Swift.Error, Swift.Equatable {
    case noSuchKey(NoSuchKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectAclOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectAclOutputResponse: Swift.Equatable {
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

public struct PutObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let body = body {
            try container.encode(body, forKey: ClientRuntime.Key("Body"))
        }
    }
}

extension PutObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let aCL = aCL {
            items.add(Header(name: "x-amz-acl", value: Swift.String(aCL.rawValue)))
        }
        if bucketKeyEnabled != false {
            items.add(Header(name: "x-amz-server-side-encryption-bucket-key-enabled", value: Swift.String(bucketKeyEnabled)))
        }
        if let cacheControl = cacheControl {
            items.add(Header(name: "Cache-Control", value: Swift.String(cacheControl)))
        }
        if let contentDisposition = contentDisposition {
            items.add(Header(name: "Content-Disposition", value: Swift.String(contentDisposition)))
        }
        if let contentEncoding = contentEncoding {
            items.add(Header(name: "Content-Encoding", value: Swift.String(contentEncoding)))
        }
        if let contentLanguage = contentLanguage {
            items.add(Header(name: "Content-Language", value: Swift.String(contentLanguage)))
        }
        if contentLength != 0 {
            items.add(Header(name: "Content-Length", value: Swift.String(contentLength)))
        }
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let expires = expires {
            items.add(Header(name: "Expires", value: Swift.String(expires.rfc5322())))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            items.add(Header(name: "x-amz-object-lock-legal-hold", value: Swift.String(objectLockLegalHoldStatus.rawValue)))
        }
        if let objectLockMode = objectLockMode {
            items.add(Header(name: "x-amz-object-lock-mode", value: Swift.String(objectLockMode.rawValue)))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            items.add(Header(name: "x-amz-object-lock-retain-until-date", value: Swift.String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds())))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        if let sSEKMSEncryptionContext = sSEKMSEncryptionContext {
            items.add(Header(name: "x-amz-server-side-encryption-context", value: Swift.String(sSEKMSEncryptionContext)))
        }
        if let sSEKMSKeyId = sSEKMSKeyId {
            items.add(Header(name: "x-amz-server-side-encryption-aws-kms-key-id", value: Swift.String(sSEKMSKeyId)))
        }
        if let serverSideEncryption = serverSideEncryption {
            items.add(Header(name: "x-amz-server-side-encryption", value: Swift.String(serverSideEncryption.rawValue)))
        }
        if let storageClass = storageClass {
            items.add(Header(name: "x-amz-storage-class", value: Swift.String(storageClass.rawValue)))
        }
        if let tagging = tagging {
            items.add(Header(name: "x-amz-tagging", value: Swift.String(tagging)))
        }
        if let websiteRedirectLocation = websiteRedirectLocation {
            items.add(Header(name: "x-amz-website-redirect-location", value: Swift.String(websiteRedirectLocation)))
        }
        if let metadata = metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                items.add(Header(name: "x-amz-meta-\(prefixHeaderMapKey)", value: Swift.String(prefixHeaderMapValue)))
            }
        }
        return items
    }
}

extension PutObjectInput {
    public func presignURL(config: AWSClientRuntime.AWSClientConfiguration, expiration: Swift.Int64) async throws -> ClientRuntime.URL? {
        let serviceName = "S3"
        let input = self
        let encoder = ClientRuntime.XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        let decoder = ClientRuntime.XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.trimValueWhitespaces = false
        decoder.removeWhitespaceElements = true
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putObject")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "s3")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<PutObjectInput, PutObjectOutputResponse, PutObjectOutputError>(id: "putObject")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<PutObjectInput, PutObjectOutputResponse, PutObjectOutputError>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<PutObjectInput, PutObjectOutputResponse>())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware<PutObjectOutputResponse, PutObjectOutputError>(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.serializeStep.intercept(position: .after, middleware: PutObjectInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware<PutObjectOutputResponse, PutObjectOutputError>(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(signatureType: .requestQueryParams, expiration: expiration, unsignedBody: true)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<PutObjectOutputResponse, PutObjectOutputError>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware<PutObjectOutputResponse, PutObjectOutputError>(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<PutObjectOutputResponse, PutObjectOutputError>())
        let presignedRequestBuilder = try await operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build(), let presignedURL = builtRequest.endpoint.url else {
            return nil
        }
        return presignedURL
    }
}

extension PutObjectInput {
    public func presign(config: AWSClientRuntime.AWSClientConfiguration, expiration: Swift.Int64) async throws -> ClientRuntime.SdkHttpRequest? {
        let serviceName = "S3"
        let input = self
        let encoder = ClientRuntime.XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        let decoder = ClientRuntime.XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.trimValueWhitespaces = false
        decoder.removeWhitespaceElements = true
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putObject")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "s3")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<PutObjectInput, PutObjectOutputResponse, PutObjectOutputError>(id: "putObject")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<PutObjectInput, PutObjectOutputResponse, PutObjectOutputError>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<PutObjectInput, PutObjectOutputResponse>())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware<PutObjectOutputResponse, PutObjectOutputError>(endpointResolver: config.endpointResolver, serviceId: serviceName))
        let apiMetadata = AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0")
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: apiMetadata, frameworkMetadata: config.frameworkMetadata)))
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.HeaderMiddleware<PutObjectInput, PutObjectOutputResponse>())
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<PutObjectInput, PutObjectOutputResponse>())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PutObjectInput, PutObjectOutputResponse>(contentType: "application/octet-stream"))
        operation.serializeStep.intercept(position: .after, middleware: PutObjectInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware<PutObjectOutputResponse, PutObjectOutputError>(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(expiration: expiration, unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<PutObjectOutputResponse, PutObjectOutputError>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware<PutObjectOutputResponse, PutObjectOutputError>(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<PutObjectOutputResponse, PutObjectOutputError>())
        let presignedRequestBuilder = try await operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build() else {
            return nil
        }
        return builtRequest
    }
}

extension PutObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "PutObject"))
        return items
    }
}

extension PutObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct PutObjectInput: Swift.Equatable {
    /// The canned ACL to apply to the object. For more information, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL). This action is not supported by Amazon S3 on Outposts.
    public var aCL: S3ClientTypes.ObjectCannedACL?
    /// Object data.
    public var body: ClientRuntime.ByteStream?
    /// The bucket name to which the PUT action was initiated. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to true causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. Specifying this header with a PUT action doesnt affect bucket-level settings for S3 Bucket Key.
    public var bucketKeyEnabled: Swift.Bool
    /// Can be used to specify caching behavior along the request/reply chain. For more information, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9).
    public var cacheControl: Swift.String?
    /// Specifies presentational information for the object. For more information, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1](http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1).
    public var contentDisposition: Swift.String?
    /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. For more information, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11).
    public var contentEncoding: Swift.String?
    /// The language the content is in.
    public var contentLanguage: Swift.String?
    /// Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically. For more information, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13).
    public var contentLength: Swift.Int
    /// The base64-encoded 128-bit MD5 digest of the message (without the headers) according to RFC 1864. This header can be used as a message integrity check to verify that the data is the same data that was originally sent. Although it is optional, we recommend using the Content-MD5 mechanism as an end-to-end integrity check. For more information about REST request authentication, see [REST Authentication](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html).
    public var contentMD5: Swift.String?
    /// A standard MIME type describing the format of the contents. For more information, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    public var contentType: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The date and time at which the object is no longer cacheable. For more information, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21).
    public var expires: ClientRuntime.Date?
    /// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object. This action is not supported by Amazon S3 on Outposts.
    public var grantFullControl: Swift.String?
    /// Allows grantee to read the object data and its metadata. This action is not supported by Amazon S3 on Outposts.
    public var grantRead: Swift.String?
    /// Allows grantee to read the object ACL. This action is not supported by Amazon S3 on Outposts.
    public var grantReadACP: Swift.String?
    /// Allows grantee to write the ACL for the applicable object. This action is not supported by Amazon S3 on Outposts.
    public var grantWriteACP: Swift.String?
    /// Object key for which the PUT action was initiated.
    /// This member is required.
    public var key: Swift.String?
    /// A map of metadata to store with the object in S3.
    public var metadata: [Swift.String:Swift.String]?
    /// Specifies whether a legal hold will be applied to this object. For more information about S3 Object Lock, see [Object Lock](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html).
    public var objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus?
    /// The Object Lock mode that you want to apply to this object.
    public var objectLockMode: S3ClientTypes.ObjectLockMode?
    /// The date and time when you want this object's Object Lock to expire. Must be formatted as a timestamp parameter.
    public var objectLockRetainUntilDate: ClientRuntime.Date?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Specifies the algorithm to use to when encrypting the object (for example, AES256).
    public var sSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
    public var sSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var sSECustomerKeyMD5: Swift.String?
    /// Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
    public var sSEKMSEncryptionContext: Swift.String?
    /// If x-amz-server-side-encryption is present and has the value of aws:kms, this header specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetrical customer managed key that was used for the object. If you specify x-amz-server-side-encryption:aws:kms, but do not provide x-amz-server-side-encryption-aws-kms-key-id, Amazon S3 uses the Amazon Web Services managed key to protect the data. If the KMS key does not exist in the same account issuing the command, you must use the full ARN and not just the ID.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The STANDARD storage class provides high durability and high availability. Depending on performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses the OUTPOSTS Storage Class. For more information, see [Storage Classes](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html) in the Amazon S3 User Guide.
    public var storageClass: S3ClientTypes.StorageClass?
    /// The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For example, "Key1=Value1")
    public var tagging: Swift.String?
    /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata. For information about object metadata, see [Object Key and Metadata](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html). In the following example, the request header sets the redirect to an object (anotherPage.html) in the same bucket: x-amz-website-redirect-location: /anotherPage.html In the following example, the request header sets the object redirect to another website: x-amz-website-redirect-location: http://www.example.com/ For more information about website hosting in Amazon S3, see [Hosting Websites on Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) and [How to Configure Website Page Redirects](https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html).
    public var websiteRedirectLocation: Swift.String?

    public init (
        aCL: S3ClientTypes.ObjectCannedACL? = nil,
        body: ClientRuntime.ByteStream? = nil,
        bucket: Swift.String? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        cacheControl: Swift.String? = nil,
        contentDisposition: Swift.String? = nil,
        contentEncoding: Swift.String? = nil,
        contentLanguage: Swift.String? = nil,
        contentLength: Swift.Int = 0,
        contentMD5: Swift.String? = nil,
        contentType: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        expires: ClientRuntime.Date? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        key: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus? = nil,
        objectLockMode: S3ClientTypes.ObjectLockMode? = nil,
        objectLockRetainUntilDate: ClientRuntime.Date? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSEncryptionContext: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        storageClass: S3ClientTypes.StorageClass? = nil,
        tagging: Swift.String? = nil,
        websiteRedirectLocation: Swift.String? = nil
    )
    {
        self.aCL = aCL
        self.body = body
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentMD5 = contentMD5
        self.contentType = contentType
        self.expectedBucketOwner = expectedBucketOwner
        self.expires = expires
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.metadata = metadata
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagging = tagging
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct PutObjectInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension PutObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = ClientRuntime.ByteStream.from(data: "".data(using: .utf8)!)
            }
        } else {
            body = nil
        }
    }
}

public struct PutObjectLegalHoldInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectLegalHoldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectLegalHoldInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectLegalHoldOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let legalHold = input.operationInput.legalHold {
                let legalHolddata = try encoder.encode(legalHold)
                let legalHoldbody = ClientRuntime.HttpBody.data(legalHolddata)
                input.builder.withBody(legalHoldbody)
            } else {
                let legalHolddata = try encoder.encode(input.operationInput)
                let legalHoldbody = ClientRuntime.HttpBody.data(legalHolddata)
                input.builder.withBody(legalHoldbody)
            }
        } catch let err {
            throw SdkError<PutObjectLegalHoldOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectLegalHoldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectLegalHoldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectLegalHoldInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectLegalHoldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legalHold = "LegalHold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let legalHold = legalHold {
            try container.encode(legalHold, forKey: ClientRuntime.Key("LegalHold"))
        }
    }
}

extension PutObjectLegalHoldInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension PutObjectLegalHoldInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "legal-hold", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension PutObjectLegalHoldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct PutObjectLegalHoldInput: Swift.Equatable {
    /// The bucket name containing the object that you want to place a Legal Hold on. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The MD5 hash for the request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The key name for the object that you want to place a Legal Hold on.
    /// This member is required.
    public var key: Swift.String?
    /// Container element for the Legal Hold configuration you want to apply to the specified object.
    public var legalHold: S3ClientTypes.ObjectLockLegalHold?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// The version ID of the object that you want to place a Legal Hold on.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        legalHold: S3ClientTypes.ObjectLockLegalHold? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.legalHold = legalHold
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct PutObjectLegalHoldInputBody: Swift.Equatable {
    let legalHold: S3ClientTypes.ObjectLockLegalHold?
}

extension PutObjectLegalHoldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legalHold = "LegalHold"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legalHoldDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockLegalHold.self, forKey: .legalHold)
        legalHold = legalHoldDecoded
    }
}

extension PutObjectLegalHoldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutObjectLegalHoldOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutObjectLegalHoldOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutObjectLegalHoldOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutObjectLegalHoldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutObjectLegalHoldOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutObjectLegalHoldOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectLegalHoldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectLegalHoldOutputResponse: Swift.Equatable {
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

public struct PutObjectLockConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectLockConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectLockConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectLockConfigurationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let objectLockConfiguration = input.operationInput.objectLockConfiguration {
                let objectLockConfigurationdata = try encoder.encode(objectLockConfiguration)
                let objectLockConfigurationbody = ClientRuntime.HttpBody.data(objectLockConfigurationdata)
                input.builder.withBody(objectLockConfigurationbody)
            } else {
                let objectLockConfigurationdata = try encoder.encode(input.operationInput)
                let objectLockConfigurationbody = ClientRuntime.HttpBody.data(objectLockConfigurationdata)
                input.builder.withBody(objectLockConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutObjectLockConfigurationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectLockConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectLockConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectLockConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectLockConfiguration = "ObjectLockConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let objectLockConfiguration = objectLockConfiguration {
            try container.encode(objectLockConfiguration, forKey: ClientRuntime.Key("ObjectLockConfiguration"))
        }
    }
}

extension PutObjectLockConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let token = token {
            items.add(Header(name: "x-amz-bucket-object-lock-token", value: Swift.String(token)))
        }
        return items
    }
}

extension PutObjectLockConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "object-lock", value: nil))
        return items
    }
}

extension PutObjectLockConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutObjectLockConfigurationInput: Swift.Equatable {
    /// The bucket whose Object Lock configuration you want to create or replace.
    /// This member is required.
    public var bucket: Swift.String?
    /// The MD5 hash for the request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The Object Lock configuration that you want to apply to the specified bucket.
    public var objectLockConfiguration: S3ClientTypes.ObjectLockConfiguration?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// A token to allow Object Lock to be enabled for an existing bucket.
    public var token: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        objectLockConfiguration: S3ClientTypes.ObjectLockConfiguration? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        token: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.objectLockConfiguration = objectLockConfiguration
        self.requestPayer = requestPayer
        self.token = token
    }
}

struct PutObjectLockConfigurationInputBody: Swift.Equatable {
    let objectLockConfiguration: S3ClientTypes.ObjectLockConfiguration?
}

extension PutObjectLockConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectLockConfiguration = "ObjectLockConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLockConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockConfiguration.self, forKey: .objectLockConfiguration)
        objectLockConfiguration = objectLockConfigurationDecoded
    }
}

extension PutObjectLockConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutObjectLockConfigurationOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutObjectLockConfigurationOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutObjectLockConfigurationOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutObjectLockConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutObjectLockConfigurationOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutObjectLockConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectLockConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectLockConfigurationOutputResponse: Swift.Equatable {
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

extension PutObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutObjectOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutObjectOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutObjectOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutObjectOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutObjectOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSEncryptionContextHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-context") {
            self.sSEKMSEncryptionContext = sSEKMSEncryptionContextHeaderValue
        } else {
            self.sSEKMSEncryptionContext = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct PutObjectOutputResponse: Swift.Equatable {
    /// Indicates whether the uploaded object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Entity tag for the uploaded object.
    public var eTag: Swift.String?
    /// If the expiration is configured for the object (see [PutBucketLifecycleConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketLifecycleConfiguration.html)), the response includes this header. It includes the expiry-date and rule-id key-value pairs that provide information about object expiration. The value of the rule-id is URL encoded.
    public var expiration: Swift.String?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
    public var sSECustomerAlgorithm: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
    public var sSEKMSEncryptionContext: Swift.String?
    /// If x-amz-server-side-encryption is present and has the value of aws:kms, this header specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// If you specified server-side encryption either with an Amazon Web Services KMS key or Amazon S3-managed encryption key in your PUT request, the response includes this header. It confirms the encryption algorithm that Amazon S3 used to encrypt the object.
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// Version of the object.
    public var versionId: Swift.String?

    public init (
        bucketKeyEnabled: Swift.Bool = false,
        eTag: Swift.String? = nil,
        expiration: Swift.String? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSEncryptionContext: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.eTag = eTag
        self.expiration = expiration
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.versionId = versionId
    }
}

public struct PutObjectRetentionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectRetentionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectRetentionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectRetentionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let retention = input.operationInput.retention {
                let retentiondata = try encoder.encode(retention)
                let retentionbody = ClientRuntime.HttpBody.data(retentiondata)
                input.builder.withBody(retentionbody)
            } else {
                let retentiondata = try encoder.encode(input.operationInput)
                let retentionbody = ClientRuntime.HttpBody.data(retentiondata)
                input.builder.withBody(retentionbody)
            }
        } catch let err {
            throw SdkError<PutObjectRetentionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectRetentionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectRetentionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectRetentionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retention = "Retention"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let retention = retention {
            try container.encode(retention, forKey: ClientRuntime.Key("Retention"))
        }
    }
}

extension PutObjectRetentionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if bypassGovernanceRetention != false {
            items.add(Header(name: "x-amz-bypass-governance-retention", value: Swift.String(bypassGovernanceRetention)))
        }
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension PutObjectRetentionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "retention", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension PutObjectRetentionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct PutObjectRetentionInput: Swift.Equatable {
    /// The bucket name that contains the object you want to apply this Object Retention configuration to. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Indicates whether this action should bypass Governance-mode restrictions.
    public var bypassGovernanceRetention: Swift.Bool
    /// The MD5 hash for the request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The key name for the object that you want to apply this Object Retention configuration to.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// The container element for the Object Retention configuration.
    public var retention: S3ClientTypes.ObjectLockRetention?
    /// The version ID for the object that you want to apply this Object Retention configuration to.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        bypassGovernanceRetention: Swift.Bool = false,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        retention: S3ClientTypes.ObjectLockRetention? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.retention = retention
        self.versionId = versionId
    }
}

struct PutObjectRetentionInputBody: Swift.Equatable {
    let retention: S3ClientTypes.ObjectLockRetention?
}

extension PutObjectRetentionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retention = "Retention"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectLockRetention.self, forKey: .retention)
        retention = retentionDecoded
    }
}

extension PutObjectRetentionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutObjectRetentionOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutObjectRetentionOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutObjectRetentionOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutObjectRetentionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutObjectRetentionOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutObjectRetentionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectRetentionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectRetentionOutputResponse: Swift.Equatable {
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?

    public init (
        requestCharged: S3ClientTypes.RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

public struct PutObjectTaggingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectTaggingInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectTaggingOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let tagging = input.operationInput.tagging {
                let taggingdata = try encoder.encode(tagging)
                let taggingbody = ClientRuntime.HttpBody.data(taggingdata)
                input.builder.withBody(taggingbody)
            } else {
                let taggingdata = try encoder.encode(input.operationInput)
                let taggingbody = ClientRuntime.HttpBody.data(taggingdata)
                input.builder.withBody(taggingbody)
            }
        } catch let err {
            throw SdkError<PutObjectTaggingOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectTaggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectTaggingInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectTaggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: ClientRuntime.Key("Tagging"))
        }
    }
}

extension PutObjectTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension PutObjectTaggingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "tagging", value: nil))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension PutObjectTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct PutObjectTaggingInput: Swift.Equatable {
    /// The bucket name containing the object. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The MD5 hash for the request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Name of the object key.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Container for the TagSet and Tag elements
    /// This member is required.
    public var tagging: S3ClientTypes.Tagging?
    /// The versionId of the object that the tag-set will be added to.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        tagging: S3ClientTypes.Tagging? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.tagging = tagging
        self.versionId = versionId
    }
}

struct PutObjectTaggingInputBody: Swift.Equatable {
    let tagging: S3ClientTypes.Tagging?
}

extension PutObjectTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taggingDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
    }
}

extension PutObjectTaggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutObjectTaggingOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutObjectTaggingOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutObjectTaggingOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutObjectTaggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutObjectTaggingOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutObjectTaggingOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectTaggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct PutObjectTaggingOutputResponse: Swift.Equatable {
    /// The versionId of the object the tag-set was added to.
    public var versionId: Swift.String?

    public init (
        versionId: Swift.String? = nil
    )
    {
        self.versionId = versionId
    }
}

public struct PutPublicAccessBlockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPublicAccessBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutPublicAccessBlockOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let publicAccessBlockConfiguration = input.operationInput.publicAccessBlockConfiguration {
                let publicAccessBlockConfigurationdata = try encoder.encode(publicAccessBlockConfiguration)
                let publicAccessBlockConfigurationbody = ClientRuntime.HttpBody.data(publicAccessBlockConfigurationdata)
                input.builder.withBody(publicAccessBlockConfigurationbody)
            } else {
                let publicAccessBlockConfigurationdata = try encoder.encode(input.operationInput)
                let publicAccessBlockConfigurationbody = ClientRuntime.HttpBody.data(publicAccessBlockConfigurationdata)
                input.builder.withBody(publicAccessBlockConfigurationbody)
            }
        } catch let err {
            throw SdkError<PutPublicAccessBlockOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutPublicAccessBlockInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutPublicAccessBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicAccessBlockConfiguration = publicAccessBlockConfiguration {
            try container.encode(publicAccessBlockConfiguration, forKey: ClientRuntime.Key("PublicAccessBlockConfiguration"))
        }
    }
}

extension PutPublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        return items
    }
}

extension PutPublicAccessBlockInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "publicAccessBlock", value: nil))
        return items
    }
}

extension PutPublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())"
    }
}

public struct PutPublicAccessBlockInput: Swift.Equatable {
    /// The name of the Amazon S3 bucket whose PublicAccessBlock configuration you want to set.
    /// This member is required.
    public var bucket: Swift.String?
    /// The MD5 hash of the PutPublicAccessBlock request body. For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    /// This member is required.
    public var publicAccessBlockConfiguration: S3ClientTypes.PublicAccessBlockConfiguration?

    public init (
        bucket: Swift.String? = nil,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct PutPublicAccessBlockInputBody: Swift.Equatable {
    let publicAccessBlockConfiguration: S3ClientTypes.PublicAccessBlockConfiguration?
}

extension PutPublicAccessBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension PutPublicAccessBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = PutPublicAccessBlockOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? PutPublicAccessBlockOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = PutPublicAccessBlockOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension PutPublicAccessBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension PutPublicAccessBlockOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum PutPublicAccessBlockOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPublicAccessBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutPublicAccessBlockOutputResponse: Swift.Equatable {

}

extension S3ClientTypes.QueueConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Event"
        case filter = "Filter"
        case id = "Id"
        case queueArn = "Queue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let events = events {
            if events.isEmpty {
                var eventsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Event"))
                try eventsContainer.encodeNil()
            } else {
                for event0 in events {
                    var eventsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Event"))
                    try eventsContainer0.encode(event0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let queueArn = queueArn {
            try container.encode(queueArn, forKey: ClientRuntime.Key("Queue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        if containerValues.contains(.events) {
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .events)
            if eventsWrappedContainer != nil {
                let eventsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Event].self, forKey: .events)
                var eventsBuffer:[S3ClientTypes.Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [S3ClientTypes.Event]()
                    for stringContainer0 in eventsContainer {
                        eventsBuffer?.append(stringContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.NotificationConfigurationFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension S3ClientTypes.QueueConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the configuration for publishing messages to an Amazon Simple Queue Service (Amazon SQS) queue when Amazon S3 detects specified events.
    public struct QueueConfiguration: Swift.Equatable {
        /// A collection of bucket events for which to send notifications
        /// This member is required.
        public var events: [S3ClientTypes.Event]?
        /// Specifies object key name filtering rules. For information about key name filtering, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
        public var filter: S3ClientTypes.NotificationConfigurationFilter?
        /// An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
        /// This member is required.
        public var queueArn: Swift.String?

        public init (
            events: [S3ClientTypes.Event]? = nil,
            filter: S3ClientTypes.NotificationConfigurationFilter? = nil,
            id: Swift.String? = nil,
            queueArn: Swift.String? = nil
        )
        {
            self.events = events
            self.filter = filter
            self.id = id
            self.queueArn = queueArn
        }
    }

}

extension S3ClientTypes {
    public enum QuoteFields: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case asneeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QuoteFields] {
            return [
                .always,
                .asneeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .asneeded: return "ASNEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuoteFields(rawValue: rawValue) ?? QuoteFields.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.RecordsEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let payload = payload {
            try container.encode(payload, forKey: ClientRuntime.Key("Payload"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.payload) {
            do {
                let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
                payload = payloadDecoded
            } catch {
                payload = "".data(using: .utf8)
            }
        } else {
            payload = nil
        }
    }
}

extension S3ClientTypes.RecordsEvent: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The container for the records event.
    public struct RecordsEvent: Swift.Equatable {
        /// The byte array of partial, one or more result records.
        public var payload: ClientRuntime.Data?

        public init (
            payload: ClientRuntime.Data? = nil
        )
        {
            self.payload = payload
        }
    }

}

extension S3ClientTypes.Redirect: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostName = "HostName"
        case httpRedirectCode = "HttpRedirectCode"
        case `protocol` = "Protocol"
        case replaceKeyPrefixWith = "ReplaceKeyPrefixWith"
        case replaceKeyWith = "ReplaceKeyWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let hostName = hostName {
            try container.encode(hostName, forKey: ClientRuntime.Key("HostName"))
        }
        if let httpRedirectCode = httpRedirectCode {
            try container.encode(httpRedirectCode, forKey: ClientRuntime.Key("HttpRedirectCode"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let replaceKeyPrefixWith = replaceKeyPrefixWith {
            try container.encode(replaceKeyPrefixWith, forKey: ClientRuntime.Key("ReplaceKeyPrefixWith"))
        }
        if let replaceKeyWith = replaceKeyWith {
            try container.encode(replaceKeyWith, forKey: ClientRuntime.Key("ReplaceKeyWith"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let httpRedirectCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpRedirectCode)
        httpRedirectCode = httpRedirectCodeDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let replaceKeyPrefixWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceKeyPrefixWith)
        replaceKeyPrefixWith = replaceKeyPrefixWithDecoded
        let replaceKeyWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceKeyWith)
        replaceKeyWith = replaceKeyWithDecoded
    }
}

extension S3ClientTypes.Redirect: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
    public struct Redirect: Swift.Equatable {
        /// The host name to use in the redirect request.
        public var hostName: Swift.String?
        /// The HTTP redirect code to use on the response. Not required if one of the siblings is present.
        public var httpRedirectCode: Swift.String?
        /// Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        public var `protocol`: S3ClientTypes.ModelProtocol?
        /// The object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix docs/ (objects in the docs/ folder) to documents/, you can set a condition block with KeyPrefixEquals set to docs/ and in the Redirect set ReplaceKeyPrefixWith to /documents. Not required if one of the siblings is present. Can be present only if ReplaceKeyWith is not provided. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        public var replaceKeyPrefixWith: Swift.String?
        /// The specific object key to use in the redirect request. For example, redirect request to error.html. Not required if one of the siblings is present. Can be present only if ReplaceKeyPrefixWith is not provided. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        public var replaceKeyWith: Swift.String?

        public init (
            hostName: Swift.String? = nil,
            httpRedirectCode: Swift.String? = nil,
            `protocol`: S3ClientTypes.ModelProtocol? = nil,
            replaceKeyPrefixWith: Swift.String? = nil,
            replaceKeyWith: Swift.String? = nil
        )
        {
            self.hostName = hostName
            self.httpRedirectCode = httpRedirectCode
            self.`protocol` = `protocol`
            self.replaceKeyPrefixWith = replaceKeyPrefixWith
            self.replaceKeyWith = replaceKeyWith
        }
    }

}

extension S3ClientTypes.RedirectAllRequestsTo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostName = "HostName"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let hostName = hostName {
            try container.encode(hostName, forKey: ClientRuntime.Key("HostName"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension S3ClientTypes.RedirectAllRequestsTo: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
    public struct RedirectAllRequestsTo: Swift.Equatable {
        /// Name of the host where requests are redirected.
        /// This member is required.
        public var hostName: Swift.String?
        /// Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        public var `protocol`: S3ClientTypes.ModelProtocol?

        public init (
            hostName: Swift.String? = nil,
            `protocol`: S3ClientTypes.ModelProtocol? = nil
        )
        {
            self.hostName = hostName
            self.`protocol` = `protocol`
        }
    }

}

extension S3ClientTypes.ReplicaModifications: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicaModificationsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ClientTypes.ReplicaModifications: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A filter that you can specify for selection for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when Filter is specified), you can specify this element and set the status to Enabled to replicate modifications on replicas. If you don't specify the Filter element, Amazon S3 assumes that the replication configuration is the earlier version, V1. In the earlier version, this element is not allowed.
    public struct ReplicaModifications: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates modifications on replicas.
        /// This member is required.
        public var status: S3ClientTypes.ReplicaModificationsStatus?

        public init (
            status: S3ClientTypes.ReplicaModificationsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ClientTypes {
    public enum ReplicaModificationsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicaModificationsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicaModificationsStatus(rawValue: rawValue) ?? ReplicaModificationsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ReplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
        case rules = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let role = role {
            try container.encode(role, forKey: ClientRuntime.Key("Role"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for replicationrule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Rule"))
                    try rulesContainer0.encode(replicationrule0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.ReplicationRule].self, forKey: .rules)
                var rulesBuffer:[S3ClientTypes.ReplicationRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ClientTypes.ReplicationRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ClientTypes.ReplicationConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
    public struct ReplicationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects. For more information, see [How to Set Up Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-how-setup.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var role: Swift.String?
        /// A container for one or more replication rules. A replication configuration must have at least one rule and can contain a maximum of 1,000 rules.
        /// This member is required.
        public var rules: [S3ClientTypes.ReplicationRule]?

        public init (
            role: Swift.String? = nil,
            rules: [S3ClientTypes.ReplicationRule]? = nil
        )
        {
            self.role = role
            self.rules = rules
        }
    }

}

extension S3ClientTypes.ReplicationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteMarkerReplication = "DeleteMarkerReplication"
        case destination = "Destination"
        case existingObjectReplication = "ExistingObjectReplication"
        case filter = "Filter"
        case iD = "ID"
        case `prefix` = "Prefix"
        case priority = "Priority"
        case sourceSelectionCriteria = "SourceSelectionCriteria"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let deleteMarkerReplication = deleteMarkerReplication {
            try container.encode(deleteMarkerReplication, forKey: ClientRuntime.Key("DeleteMarkerReplication"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: ClientRuntime.Key("Destination"))
        }
        if let existingObjectReplication = existingObjectReplication {
            try container.encode(existingObjectReplication, forKey: ClientRuntime.Key("ExistingObjectReplication"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: ClientRuntime.Key("ID"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let sourceSelectionCriteria = sourceSelectionCriteria {
            try container.encode(sourceSelectionCriteria, forKey: ClientRuntime.Key("SourceSelectionCriteria"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let sourceSelectionCriteriaDecoded = try containerValues.decodeIfPresent(S3ClientTypes.SourceSelectionCriteria.self, forKey: .sourceSelectionCriteria)
        sourceSelectionCriteria = sourceSelectionCriteriaDecoded
        let existingObjectReplicationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ExistingObjectReplication.self, forKey: .existingObjectReplication)
        existingObjectReplication = existingObjectReplicationDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let deleteMarkerReplicationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.DeleteMarkerReplication.self, forKey: .deleteMarkerReplication)
        deleteMarkerReplication = deleteMarkerReplicationDecoded
    }
}

extension S3ClientTypes.ReplicationRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies which Amazon S3 objects to replicate and where to store the replicas.
    public struct ReplicationRule: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates delete markers. If you specify a Filter in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplicationStatus must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config). For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html). If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
        public var deleteMarkerReplication: S3ClientTypes.DeleteMarkerReplication?
        /// A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC).
        /// This member is required.
        public var destination: S3ClientTypes.Destination?
        ///
        public var existingObjectReplication: S3ClientTypes.ExistingObjectReplication?
        /// A filter that identifies the subset of objects to which the replication rule applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
        public var filter: S3ClientTypes.ReplicationRuleFilter?
        /// A unique identifier for the rule. The maximum value is 255 characters.
        public var iD: Swift.String?
        /// An object key name prefix that identifies the object or objects to which the rule applies. The maximum prefix length is 1,024 characters. To include all objects in a bucket, specify an empty string. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        @available(*, deprecated)
        public var `prefix`: Swift.String?
        /// The priority indicates which rule has precedence whenever two or more replication rules conflict. Amazon S3 will attempt to replicate objects according to all replication rules. However, if there are two or more rules with the same destination bucket, then objects will be replicated according to the rule with the highest priority. The higher the number, the higher the priority. For more information, see [Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html) in the Amazon S3 User Guide.
        public var priority: Swift.Int
        /// A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. Currently, Amazon S3 supports only the filter that you can specify for objects created with server-side encryption using a customer managed key stored in Amazon Web Services Key Management Service (SSE-KMS).
        public var sourceSelectionCriteria: S3ClientTypes.SourceSelectionCriteria?
        /// Specifies whether the rule is enabled.
        /// This member is required.
        public var status: S3ClientTypes.ReplicationRuleStatus?

        public init (
            deleteMarkerReplication: S3ClientTypes.DeleteMarkerReplication? = nil,
            destination: S3ClientTypes.Destination? = nil,
            existingObjectReplication: S3ClientTypes.ExistingObjectReplication? = nil,
            filter: S3ClientTypes.ReplicationRuleFilter? = nil,
            iD: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            priority: Swift.Int = 0,
            sourceSelectionCriteria: S3ClientTypes.SourceSelectionCriteria? = nil,
            status: S3ClientTypes.ReplicationRuleStatus? = nil
        )
        {
            self.deleteMarkerReplication = deleteMarkerReplication
            self.destination = destination
            self.existingObjectReplication = existingObjectReplication
            self.filter = filter
            self.iD = iD
            self.`prefix` = `prefix`
            self.priority = priority
            self.sourceSelectionCriteria = sourceSelectionCriteria
            self.status = status
        }
    }

}

extension S3ClientTypes.ReplicationRuleAndOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .tags)
                var tagsBuffer:[S3ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension S3ClientTypes.ReplicationRuleAndOperator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
    ///
    /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And tag.
    ///
    /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And tag.
    public struct ReplicationRuleAndOperator: Swift.Equatable {
        /// An object key name prefix that identifies the subset of objects to which the rule applies.
        public var `prefix`: Swift.String?
        /// An array of tags containing key and value pairs.
        public var tags: [S3ClientTypes.Tag]?

        public init (
            `prefix`: Swift.String? = nil,
            tags: [S3ClientTypes.Tag]? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ClientTypes.ReplicationRuleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        switch self {
            case let .and(and):
                try container.encode(and, forKey: ClientRuntime.Key("And"))
            case let .prefix(prefix):
                try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
            case let .tag(tag):
                try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: ClientRuntime.Key("sdkUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .prefix:
                let prefixDecoded = try containerValues.decode(Swift.String.self, forKey: .prefix)
                self = .prefix(prefixDecoded)
            case .tag:
                let tagDecoded = try containerValues.decode(S3ClientTypes.Tag.self, forKey: .tag)
                self = .tag(tagDecoded)
            case .and:
                let andDecoded = try containerValues.decode(S3ClientTypes.ReplicationRuleAndOperator.self, forKey: .and)
                self = .and(andDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ClientTypes {
    /// A filter that identifies the subset of objects to which the replication rule applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
    public enum ReplicationRuleFilter: Swift.Equatable {
        /// An object key name prefix that identifies the subset of objects to which the rule applies. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [ XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        case prefix(Swift.String)
        /// A container for specifying a tag key and value. The rule applies only to objects that have the tag in their tag set.
        case tag(S3ClientTypes.Tag)
        /// A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
        ///
        /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And tag.
        ///
        /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And tag.
        case and(S3ClientTypes.ReplicationRuleAndOperator)
        case sdkUnknown(Swift.String)
    }

}

extension S3ClientTypes {
    public enum ReplicationRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRuleStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationRuleStatus(rawValue: rawValue) ?? ReplicationRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum ReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case pending
        case replica
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatus] {
            return [
                .complete,
                .failed,
                .pending,
                .replica,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .replica: return "REPLICA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ReplicationTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let time = time {
            try container.encode(time, forKey: ClientRuntime.Key("Time"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationTimeStatus.self, forKey: .status)
        status = statusDecoded
        let timeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicationTimeValue.self, forKey: .time)
        time = timeDecoded
    }
}

extension S3ClientTypes.ReplicationTime: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block.
    public struct ReplicationTime: Swift.Equatable {
        /// Specifies whether the replication time is enabled.
        /// This member is required.
        public var status: S3ClientTypes.ReplicationTimeStatus?
        /// A container specifying the time by which replication should be complete for all objects and operations on objects.
        /// This member is required.
        public var time: S3ClientTypes.ReplicationTimeValue?

        public init (
            status: S3ClientTypes.ReplicationTimeStatus? = nil,
            time: S3ClientTypes.ReplicationTimeValue? = nil
        )
        {
            self.status = status
            self.time = time
        }
    }

}

extension S3ClientTypes {
    public enum ReplicationTimeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationTimeStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationTimeStatus(rawValue: rawValue) ?? ReplicationTimeStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ReplicationTimeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minutes = "Minutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if minutes != 0 {
            try container.encode(minutes, forKey: ClientRuntime.Key("Minutes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .minutes)
        minutes = minutesDecoded
    }
}

extension S3ClientTypes.ReplicationTimeValue: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics EventThreshold.
    public struct ReplicationTimeValue: Swift.Equatable {
        /// Contains an integer specifying time in minutes. Valid value: 15
        public var minutes: Swift.Int

        public init (
            minutes: Swift.Int = 0
        )
        {
            self.minutes = minutes
        }
    }

}

extension S3ClientTypes {
    /// If present, indicates that the requester was successfully charged for the request.
    public enum RequestCharged: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requester
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestCharged] {
            return [
                .requester,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requester: return "requester"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestCharged(rawValue: rawValue) ?? RequestCharged.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public enum RequestPayer: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requester
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestPayer] {
            return [
                .requester,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requester: return "requester"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestPayer(rawValue: rawValue) ?? RequestPayer.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.RequestPaymentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payer = "Payer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let payer = payer {
            try container.encode(payer, forKey: ClientRuntime.Key("Payer"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payerDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Payer.self, forKey: .payer)
        payer = payerDecoded
    }
}

extension S3ClientTypes.RequestPaymentConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for Payer.
    public struct RequestPaymentConfiguration: Swift.Equatable {
        /// Specifies who pays for the download and request fees.
        /// This member is required.
        public var payer: S3ClientTypes.Payer?

        public init (
            payer: S3ClientTypes.Payer? = nil
        )
        {
            self.payer = payer
        }
    }

}

extension S3ClientTypes.RequestProgress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension S3ClientTypes.RequestProgress: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for specifying if periodic QueryProgress messages should be sent.
    public struct RequestProgress: Swift.Equatable {
        /// Specifies whether periodic QueryProgress frames should be sent. Valid values: TRUE, FALSE. Default value: FALSE.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

public struct RestoreObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreObjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<RestoreObjectOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let restoreRequest = input.operationInput.restoreRequest {
                let restoreRequestdata = try encoder.encode(restoreRequest)
                let restoreRequestbody = ClientRuntime.HttpBody.data(restoreRequestdata)
                input.builder.withBody(restoreRequestbody)
            } else {
                let restoreRequestdata = try encoder.encode(input.operationInput)
                let restoreRequestbody = ClientRuntime.HttpBody.data(restoreRequestdata)
                input.builder.withBody(restoreRequestbody)
            }
        } catch let err {
            throw SdkError<RestoreObjectOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension RestoreObjectInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension RestoreObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoreRequest = "RestoreRequest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let restoreRequest = restoreRequest {
            try container.encode(restoreRequest, forKey: ClientRuntime.Key("RestoreRequest"))
        }
    }
}

extension RestoreObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        return items
    }
}

extension RestoreObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "restore", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "RestoreObject"))
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension RestoreObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct RestoreObjectInput: Swift.Equatable {
    /// The bucket name containing the object to restore. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Object key for which the action was initiated.
    /// This member is required.
    public var key: Swift.String?
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Container for restore job parameters.
    public var restoreRequest: S3ClientTypes.RestoreRequest?
    /// VersionId used to reference a specific version of the object.
    public var versionId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        restoreRequest: S3ClientTypes.RestoreRequest? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.restoreRequest = restoreRequest
        self.versionId = versionId
    }
}

struct RestoreObjectInputBody: Swift.Equatable {
    let restoreRequest: S3ClientTypes.RestoreRequest?
}

extension RestoreObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoreRequest = "RestoreRequest"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreRequestDecoded = try containerValues.decodeIfPresent(S3ClientTypes.RestoreRequest.self, forKey: .restoreRequest)
        restoreRequest = restoreRequestDecoded
    }
}

extension RestoreObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = RestoreObjectOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? RestoreObjectOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = RestoreObjectOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension RestoreObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        case "ObjectAlreadyInActiveTierError" : self = .objectAlreadyInActiveTierError(try ObjectAlreadyInActiveTierError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID, requestID2: requestID2))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension RestoreObjectOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum RestoreObjectOutputError: Swift.Error, Swift.Equatable {
    case objectAlreadyInActiveTierError(ObjectAlreadyInActiveTierError)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let restoreOutputPathHeaderValue = httpResponse.headers.value(for: "x-amz-restore-output-path") {
            self.restoreOutputPath = restoreOutputPathHeaderValue
        } else {
            self.restoreOutputPath = nil
        }
    }
}

public struct RestoreObjectOutputResponse: Swift.Equatable {
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// Indicates the path in the provided S3 output location where Select results will be restored to.
    public var restoreOutputPath: Swift.String?

    public init (
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        restoreOutputPath: Swift.String? = nil
    )
    {
        self.requestCharged = requestCharged
        self.restoreOutputPath = restoreOutputPath
    }
}

extension S3ClientTypes.RestoreRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case days = "Days"
        case description = "Description"
        case glacierJobParameters = "GlacierJobParameters"
        case outputLocation = "OutputLocation"
        case selectParameters = "SelectParameters"
        case tier = "Tier"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if days != 0 {
            try container.encode(days, forKey: ClientRuntime.Key("Days"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let glacierJobParameters = glacierJobParameters {
            try container.encode(glacierJobParameters, forKey: ClientRuntime.Key("GlacierJobParameters"))
        }
        if let outputLocation = outputLocation {
            try container.encode(outputLocation, forKey: ClientRuntime.Key("OutputLocation"))
        }
        if let selectParameters = selectParameters {
            try container.encode(selectParameters, forKey: ClientRuntime.Key("SelectParameters"))
        }
        if let tier = tier {
            try container.encode(tier, forKey: ClientRuntime.Key("Tier"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysDecoded = try containerValues.decode(Swift.Int.self, forKey: .days)
        days = daysDecoded
        let glacierJobParametersDecoded = try containerValues.decodeIfPresent(S3ClientTypes.GlacierJobParameters.self, forKey: .glacierJobParameters)
        glacierJobParameters = glacierJobParametersDecoded
        let typeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.RestoreRequestType.self, forKey: .type)
        type = typeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(S3ClientTypes.SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension S3ClientTypes.RestoreRequest: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for restore job parameters.
    public struct RestoreRequest: Swift.Equatable {
        /// Lifetime of the active copy in days. Do not use with restores that specify OutputLocation. The Days element is required for regular restores, and must not be provided for select requests.
        public var days: Swift.Int
        /// The optional description for the job.
        public var description: Swift.String?
        /// S3 Glacier related parameters pertaining to this job. Do not use with restores that specify OutputLocation.
        public var glacierJobParameters: S3ClientTypes.GlacierJobParameters?
        /// Describes the location where the restore job's output is stored.
        public var outputLocation: S3ClientTypes.OutputLocation?
        /// Describes the parameters for Select job types.
        public var selectParameters: S3ClientTypes.SelectParameters?
        /// Retrieval tier at which the restore will be processed.
        public var tier: S3ClientTypes.Tier?
        /// Type of restore request.
        public var type: S3ClientTypes.RestoreRequestType?

        public init (
            days: Swift.Int = 0,
            description: Swift.String? = nil,
            glacierJobParameters: S3ClientTypes.GlacierJobParameters? = nil,
            outputLocation: S3ClientTypes.OutputLocation? = nil,
            selectParameters: S3ClientTypes.SelectParameters? = nil,
            tier: S3ClientTypes.Tier? = nil,
            type: S3ClientTypes.RestoreRequestType? = nil
        )
        {
            self.days = days
            self.description = description
            self.glacierJobParameters = glacierJobParameters
            self.outputLocation = outputLocation
            self.selectParameters = selectParameters
            self.tier = tier
            self.type = type
        }
    }

}

extension S3ClientTypes {
    public enum RestoreRequestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreRequestType] {
            return [
                .select,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .select: return "SELECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RestoreRequestType(rawValue: rawValue) ?? RestoreRequestType.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.RoutingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case redirect = "Redirect"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let condition = condition {
            try container.encode(condition, forKey: ClientRuntime.Key("Condition"))
        }
        if let redirect = redirect {
            try container.encode(redirect, forKey: ClientRuntime.Key("Redirect"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
        let redirectDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Redirect.self, forKey: .redirect)
        redirect = redirectDecoded
    }
}

extension S3ClientTypes.RoutingRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the redirect behavior and when a redirect is applied. For more information about routing rules, see [Configuring advanced conditional redirects](https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html#advanced-conditional-redirects) in the Amazon S3 User Guide.
    public struct RoutingRule: Swift.Equatable {
        /// A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
        public var condition: S3ClientTypes.Condition?
        /// Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
        /// This member is required.
        public var redirect: S3ClientTypes.Redirect?

        public init (
            condition: S3ClientTypes.Condition? = nil,
            redirect: S3ClientTypes.Redirect? = nil
        )
        {
            self.condition = condition
            self.redirect = redirect
        }
    }

}

extension S3ClientTypes.S3KeyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterRules = "FilterRule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let filterRules = filterRules {
            if filterRules.isEmpty {
                var filterRulesContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("FilterRule"))
                try filterRulesContainer.encodeNil()
            } else {
                for filterrule0 in filterRules {
                    var filterRulesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FilterRule"))
                    try filterRulesContainer0.encode(filterrule0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.filterRules) {
            let filterRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .filterRules)
            if filterRulesWrappedContainer != nil {
                let filterRulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.FilterRule].self, forKey: .filterRules)
                var filterRulesBuffer:[S3ClientTypes.FilterRule]? = nil
                if let filterRulesContainer = filterRulesContainer {
                    filterRulesBuffer = [S3ClientTypes.FilterRule]()
                    for structureContainer0 in filterRulesContainer {
                        filterRulesBuffer?.append(structureContainer0)
                    }
                }
                filterRules = filterRulesBuffer
            } else {
                filterRules = []
            }
        } else {
            filterRules = nil
        }
    }
}

extension S3ClientTypes.S3KeyFilter: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for object key name prefix and suffix filtering rules.
    public struct S3KeyFilter: Swift.Equatable {
        /// A list of containers for the key-value pair that defines the criteria for the filter rule.
        public var filterRules: [S3ClientTypes.FilterRule]?

        public init (
            filterRules: [S3ClientTypes.FilterRule]? = nil
        )
        {
            self.filterRules = filterRules
        }
    }

}

extension S3ClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "AccessControlList"
        case bucketName = "BucketName"
        case cannedACL = "CannedACL"
        case encryption = "Encryption"
        case `prefix` = "Prefix"
        case storageClass = "StorageClass"
        case tagging = "Tagging"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlList = accessControlList {
            var accessControlListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AccessControlList"))
            for grant0 in accessControlList {
                try accessControlListContainer.encode(grant0, forKey: ClientRuntime.Key("Grant"))
            }
        }
        if let bucketName = bucketName {
            try container.encode(bucketName, forKey: ClientRuntime.Key("BucketName"))
        }
        if let cannedACL = cannedACL {
            try container.encode(cannedACL, forKey: ClientRuntime.Key("CannedACL"))
        }
        if let encryption = encryption {
            try container.encode(encryption, forKey: ClientRuntime.Key("Encryption"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: ClientRuntime.Key("Tagging"))
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserMetadata"))
            for metadataentry0 in userMetadata {
                try userMetadataContainer.encode(metadataentry0, forKey: ClientRuntime.Key("MetadataEntry"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let cannedACLDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ObjectCannedACL.self, forKey: .cannedACL)
        cannedACL = cannedACLDecoded
        if containerValues.contains(.accessControlList) {
            struct KeyVal0{struct Grant{}}
            let accessControlListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .accessControlList)
            if let accessControlListWrappedContainer = accessControlListWrappedContainer {
                let accessControlListContainer = try accessControlListWrappedContainer.decodeIfPresent([S3ClientTypes.Grant].self, forKey: .member)
                var accessControlListBuffer:[S3ClientTypes.Grant]? = nil
                if let accessControlListContainer = accessControlListContainer {
                    accessControlListBuffer = [S3ClientTypes.Grant]()
                    for structureContainer0 in accessControlListContainer {
                        accessControlListBuffer?.append(structureContainer0)
                    }
                }
                accessControlList = accessControlListBuffer
            } else {
                accessControlList = []
            }
        } else {
            accessControlList = nil
        }
        let taggingDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
        if containerValues.contains(.userMetadata) {
            struct KeyVal0{struct MetadataEntry{}}
            let userMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.MetadataEntry>.CodingKeys.self, forKey: .userMetadata)
            if let userMetadataWrappedContainer = userMetadataWrappedContainer {
                let userMetadataContainer = try userMetadataWrappedContainer.decodeIfPresent([S3ClientTypes.MetadataEntry].self, forKey: .member)
                var userMetadataBuffer:[S3ClientTypes.MetadataEntry]? = nil
                if let userMetadataContainer = userMetadataContainer {
                    userMetadataBuffer = [S3ClientTypes.MetadataEntry]()
                    for structureContainer0 in userMetadataContainer {
                        userMetadataBuffer?.append(structureContainer0)
                    }
                }
                userMetadata = userMetadataBuffer
            } else {
                userMetadata = []
            }
        } else {
            userMetadata = nil
        }
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ClientTypes.S3Location: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes an Amazon S3 location that will receive the results of the restore request.
    public struct S3Location: Swift.Equatable {
        /// A list of grants that control access to the staged results.
        public var accessControlList: [S3ClientTypes.Grant]?
        /// The name of the bucket where the restore results will be placed.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The canned ACL to apply to the restore results.
        public var cannedACL: S3ClientTypes.ObjectCannedACL?
        /// Contains the type of server-side encryption used.
        public var encryption: S3ClientTypes.Encryption?
        /// The prefix that is prepended to the restore results for this request.
        /// This member is required.
        public var `prefix`: Swift.String?
        /// The class of storage used to store the restore results.
        public var storageClass: S3ClientTypes.StorageClass?
        /// The tag-set that is applied to the restore results.
        public var tagging: S3ClientTypes.Tagging?
        /// A list of metadata to store with the restore results in S3.
        public var userMetadata: [S3ClientTypes.MetadataEntry]?

        public init (
            accessControlList: [S3ClientTypes.Grant]? = nil,
            bucketName: Swift.String? = nil,
            cannedACL: S3ClientTypes.ObjectCannedACL? = nil,
            encryption: S3ClientTypes.Encryption? = nil,
            `prefix`: Swift.String? = nil,
            storageClass: S3ClientTypes.StorageClass? = nil,
            tagging: S3ClientTypes.Tagging? = nil,
            userMetadata: [S3ClientTypes.MetadataEntry]? = nil
        )
        {
            self.accessControlList = accessControlList
            self.bucketName = bucketName
            self.cannedACL = cannedACL
            self.encryption = encryption
            self.`prefix` = `prefix`
            self.storageClass = storageClass
            self.tagging = tagging
            self.userMetadata = userMetadata
        }
    }

}

extension S3ClientTypes.SSEKMS: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyId = keyId {
            try container.encode(keyId, forKey: ClientRuntime.Key("KeyId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension S3ClientTypes.SSEKMS: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the use of SSE-KMS to encrypt delivered inventory reports.
    public struct SSEKMS: Swift.Equatable {
        /// Specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key to use for encrypting inventory reports.
        /// This member is required.
        public var keyId: Swift.String?

        public init (
            keyId: Swift.String? = nil
        )
        {
            self.keyId = keyId
        }
    }

}

extension S3ClientTypes.SSES3: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension S3ClientTypes {
    /// Specifies the use of SSE-S3 to encrypt delivered inventory reports.
    public struct SSES3: Swift.Equatable {

    }

}

extension S3ClientTypes.ScanRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if end != 0 {
            try container.encode(end, forKey: ClientRuntime.Key("End"))
        }
        if start != 0 {
            try container.encode(start, forKey: ClientRuntime.Key("Start"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decode(Swift.Int.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decode(Swift.Int.self, forKey: .end)
        end = endDecoded
    }
}

extension S3ClientTypes.ScanRange: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the byte range of the object to get the records from. A record is processed when its first byte is contained by the range. This parameter is optional, but when specified, it must not be empty. See RFC 2616, Section 14.35.1 about how to specify the start and end of the range.
    public struct ScanRange: Swift.Equatable {
        /// Specifies the end of the byte range. This parameter is optional. Valid values: non-negative integers. The default value is one less than the size of the object being queried. If only the End parameter is supplied, it is interpreted to mean scan the last N bytes of the file. For example, 50 means scan the last 50 bytes.
        public var end: Swift.Int
        /// Specifies the start of the byte range. This parameter is optional. Valid values: non-negative integers. The default value is 0. If only start is supplied, it means scan from that point to the end of the file.For example; 50 means scan from byte 50 until the end of the file.
        public var start: Swift.Int

        public init (
            end: Swift.Int = 0,
            start: Swift.Int = 0
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension S3ClientTypes.SelectObjectContentEventStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cont = "Cont"
        case end = "End"
        case progress = "Progress"
        case records = "Records"
        case stats = "Stats"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        switch self {
            case let .cont(cont):
                try container.encode(cont, forKey: ClientRuntime.Key("Cont"))
            case let .end(end):
                try container.encode(end, forKey: ClientRuntime.Key("End"))
            case let .progress(progress):
                try container.encode(progress, forKey: ClientRuntime.Key("Progress"))
            case let .records(records):
                try container.encode(records, forKey: ClientRuntime.Key("Records"))
            case let .stats(stats):
                try container.encode(stats, forKey: ClientRuntime.Key("Stats"))
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: ClientRuntime.Key("sdkUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .records:
                let recordsDecoded = try containerValues.decode(S3ClientTypes.RecordsEvent.self, forKey: .records)
                self = .records(recordsDecoded)
            case .stats:
                let statsDecoded = try containerValues.decode(S3ClientTypes.StatsEvent.self, forKey: .stats)
                self = .stats(statsDecoded)
            case .progress:
                let progressDecoded = try containerValues.decode(S3ClientTypes.ProgressEvent.self, forKey: .progress)
                self = .progress(progressDecoded)
            case .cont:
                let contDecoded = try containerValues.decode(S3ClientTypes.ContinuationEvent.self, forKey: .cont)
                self = .cont(contDecoded)
            case .end:
                let endDecoded = try containerValues.decode(S3ClientTypes.EndEvent.self, forKey: .end)
                self = .end(endDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ClientTypes {
    /// The container for selecting objects from a content event stream.
    public enum SelectObjectContentEventStream: Swift.Equatable {
        /// The Records Event.
        case records(S3ClientTypes.RecordsEvent)
        /// The Stats Event.
        case stats(S3ClientTypes.StatsEvent)
        /// The Progress Event.
        case progress(S3ClientTypes.ProgressEvent)
        /// The Continuation Event.
        case cont(S3ClientTypes.ContinuationEvent)
        /// The End Event.
        case end(S3ClientTypes.EndEvent)
        case sdkUnknown(Swift.String)
    }

}

extension SelectObjectContentInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension SelectObjectContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
        case requestProgress = "RequestProgress"
        case scanRange = "ScanRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: ClientRuntime.Key("Expression"))
        }
        if let expressionType = expressionType {
            try container.encode(expressionType, forKey: ClientRuntime.Key("ExpressionType"))
        }
        if let inputSerialization = inputSerialization {
            try container.encode(inputSerialization, forKey: ClientRuntime.Key("InputSerialization"))
        }
        if let outputSerialization = outputSerialization {
            try container.encode(outputSerialization, forKey: ClientRuntime.Key("OutputSerialization"))
        }
        if let requestProgress = requestProgress {
            try container.encode(requestProgress, forKey: ClientRuntime.Key("RequestProgress"))
        }
        if let scanRange = scanRange {
            try container.encode(scanRange, forKey: ClientRuntime.Key("ScanRange"))
        }
    }
}

extension SelectObjectContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        return items
    }
}

extension SelectObjectContentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "select", value: nil))
        items.append(ClientRuntime.URLQueryItem(name: "select-type", value: "2"))
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "SelectObjectContent"))
        return items
    }
}

extension SelectObjectContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

/// Request to filter the contents of an Amazon S3 object based on a simple Structured Query Language (SQL) statement. In the request, along with the SQL expression, you must specify a data serialization format (JSON or CSV) of the object. Amazon S3 uses this to parse object data into records. It returns only records that match the specified SQL expression. You must also specify the data serialization format for the response. For more information, see [S3Select API Documentation](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectSELECTContent.html).
public struct SelectObjectContentInput: Swift.Equatable {
    /// The S3 bucket.
    /// This member is required.
    public var bucket: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The expression that is used to query the object.
    /// This member is required.
    public var expression: Swift.String?
    /// The type of the provided expression (for example, SQL).
    /// This member is required.
    public var expressionType: S3ClientTypes.ExpressionType?
    /// Describes the format of the data in the object that is being queried.
    /// This member is required.
    public var inputSerialization: S3ClientTypes.InputSerialization?
    /// The object key.
    /// This member is required.
    public var key: Swift.String?
    /// Describes the format of the data that you want Amazon S3 to return in response.
    /// This member is required.
    public var outputSerialization: S3ClientTypes.OutputSerialization?
    /// Specifies if periodic request progress information should be enabled.
    public var requestProgress: S3ClientTypes.RequestProgress?
    /// The SSE Algorithm used to encrypt the object. For more information, see [Server-Side Encryption (Using Customer-Provided Encryption Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html).
    public var sSECustomerAlgorithm: Swift.String?
    /// The SSE Customer Key. For more information, see [Server-Side Encryption (Using Customer-Provided Encryption Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html).
    public var sSECustomerKey: Swift.String?
    /// The SSE Customer Key MD5. For more information, see [Server-Side Encryption (Using Customer-Provided Encryption Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html).
    public var sSECustomerKeyMD5: Swift.String?
    /// Specifies the byte range of the object to get the records from. A record is processed when its first byte is contained by the range. This parameter is optional, but when specified, it must not be empty. See RFC 2616, Section 14.35.1 about how to specify the start and end of the range. ScanRangemay be used in the following ways:
    ///
    /// * 50100 - process only the records starting between the bytes 50 and 100 (inclusive, counting from zero)
    ///
    /// * 50 - process only the records starting after the byte 50
    ///
    /// * 50 - process only the records within the last 50 bytes of the file.
    public var scanRange: S3ClientTypes.ScanRange?

    public init (
        bucket: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: S3ClientTypes.ExpressionType? = nil,
        inputSerialization: S3ClientTypes.InputSerialization? = nil,
        key: Swift.String? = nil,
        outputSerialization: S3ClientTypes.OutputSerialization? = nil,
        requestProgress: S3ClientTypes.RequestProgress? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        scanRange: S3ClientTypes.ScanRange? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.expression = expression
        self.expressionType = expressionType
        self.inputSerialization = inputSerialization
        self.key = key
        self.outputSerialization = outputSerialization
        self.requestProgress = requestProgress
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.scanRange = scanRange
    }
}

struct SelectObjectContentInputBody: Swift.Equatable {
    let expression: Swift.String?
    let expressionType: S3ClientTypes.ExpressionType?
    let requestProgress: S3ClientTypes.RequestProgress?
    let inputSerialization: S3ClientTypes.InputSerialization?
    let outputSerialization: S3ClientTypes.OutputSerialization?
    let scanRange: S3ClientTypes.ScanRange?
}

extension SelectObjectContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
        case requestProgress = "RequestProgress"
        case scanRange = "ScanRange"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let requestProgressDecoded = try containerValues.decodeIfPresent(S3ClientTypes.RequestProgress.self, forKey: .requestProgress)
        requestProgress = requestProgressDecoded
        let inputSerializationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InputSerialization.self, forKey: .inputSerialization)
        inputSerialization = inputSerializationDecoded
        let outputSerializationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.OutputSerialization.self, forKey: .outputSerialization)
        outputSerialization = outputSerializationDecoded
        let scanRangeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ScanRange.self, forKey: .scanRange)
        scanRange = scanRangeDecoded
    }
}

extension SelectObjectContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = SelectObjectContentOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? SelectObjectContentOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = SelectObjectContentOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension SelectObjectContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension SelectObjectContentOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum SelectObjectContentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SelectObjectContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.SelectObjectContentEventStream = try responseDecoder.decode(responseBody: data)
                self.payload = output
            } else {
                self.payload = nil
            }
        } else {
            self.payload = nil
        }
    }
}

public struct SelectObjectContentOutputResponse: Swift.Equatable {
    /// The array of results.
    public var payload: S3ClientTypes.SelectObjectContentEventStream?

    public init (
        payload: S3ClientTypes.SelectObjectContentEventStream? = nil
    )
    {
        self.payload = payload
    }
}

struct SelectObjectContentOutputResponseBody: Swift.Equatable {
    let payload: S3ClientTypes.SelectObjectContentEventStream?
}

extension SelectObjectContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(S3ClientTypes.SelectObjectContentEventStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension S3ClientTypes.SelectParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: ClientRuntime.Key("Expression"))
        }
        if let expressionType = expressionType {
            try container.encode(expressionType, forKey: ClientRuntime.Key("ExpressionType"))
        }
        if let inputSerialization = inputSerialization {
            try container.encode(inputSerialization, forKey: ClientRuntime.Key("InputSerialization"))
        }
        if let outputSerialization = outputSerialization {
            try container.encode(outputSerialization, forKey: ClientRuntime.Key("OutputSerialization"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSerializationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.InputSerialization.self, forKey: .inputSerialization)
        inputSerialization = inputSerializationDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let outputSerializationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.OutputSerialization.self, forKey: .outputSerialization)
        outputSerialization = outputSerializationDecoded
    }
}

extension S3ClientTypes.SelectParameters: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes the parameters for Select job types.
    public struct SelectParameters: Swift.Equatable {
        /// The expression that is used to query the object.
        /// This member is required.
        public var expression: Swift.String?
        /// The type of the provided expression (for example, SQL).
        /// This member is required.
        public var expressionType: S3ClientTypes.ExpressionType?
        /// Describes the serialization format of the object.
        /// This member is required.
        public var inputSerialization: S3ClientTypes.InputSerialization?
        /// Describes how the results of the Select job are serialized.
        /// This member is required.
        public var outputSerialization: S3ClientTypes.OutputSerialization?

        public init (
            expression: Swift.String? = nil,
            expressionType: S3ClientTypes.ExpressionType? = nil,
            inputSerialization: S3ClientTypes.InputSerialization? = nil,
            outputSerialization: S3ClientTypes.OutputSerialization? = nil
        )
        {
            self.expression = expression
            self.expressionType = expressionType
            self.inputSerialization = inputSerialization
            self.outputSerialization = outputSerialization
        }
    }

}

extension S3ClientTypes {
    public enum ServerSideEncryption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case awsKms
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryption] {
            return [
                .aes256,
                .awsKms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .awsKms: return "aws:kms"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerSideEncryption(rawValue: rawValue) ?? ServerSideEncryption.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.ServerSideEncryptionByDefault: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kMSMasterKeyID = "KMSMasterKeyID"
        case sSEAlgorithm = "SSEAlgorithm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let kMSMasterKeyID = kMSMasterKeyID {
            try container.encode(kMSMasterKeyID, forKey: ClientRuntime.Key("KMSMasterKeyID"))
        }
        if let sSEAlgorithm = sSEAlgorithm {
            try container.encode(sSEAlgorithm, forKey: ClientRuntime.Key("SSEAlgorithm"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sSEAlgorithmDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ServerSideEncryption.self, forKey: .sSEAlgorithm)
        sSEAlgorithm = sSEAlgorithmDecoded
        let kMSMasterKeyIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSMasterKeyID)
        kMSMasterKeyID = kMSMasterKeyIDDecoded
    }
}

extension S3ClientTypes.ServerSideEncryptionByDefault: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. For more information, see [PUT Bucket encryption](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html) in the Amazon S3 API Reference.
    public struct ServerSideEncryptionByDefault: Swift.Equatable {
        /// Amazon Web Services Key Management Service (KMS) customer Amazon Web Services KMS key ID to use for the default encryption. This parameter is allowed if and only if SSEAlgorithm is set to aws:kms. You can specify the key ID or the Amazon Resource Name (ARN) of the KMS key. However, if you are using encryption with cross-account operations, you must use a fully qualified KMS key ARN. For more information, see [Using encryption for cross-account operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html#bucket-encryption-update-bucket-policy). For example:
        ///
        /// * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
        ///
        /// * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
        ///
        ///
        /// Amazon S3 only supports symmetric KMS keys and not asymmetric KMS keys. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Amazon Web Services Key Management Service Developer Guide.
        public var kMSMasterKeyID: Swift.String?
        /// Server-side encryption algorithm to use for the default encryption.
        /// This member is required.
        public var sSEAlgorithm: S3ClientTypes.ServerSideEncryption?

        public init (
            kMSMasterKeyID: Swift.String? = nil,
            sSEAlgorithm: S3ClientTypes.ServerSideEncryption? = nil
        )
        {
            self.kMSMasterKeyID = kMSMasterKeyID
            self.sSEAlgorithm = sSEAlgorithm
        }
    }

}

extension S3ClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for serversideencryptionrule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Rule"))
                    try rulesContainer0.encode(serversideencryptionrule0, forKey: ClientRuntime.Key(""))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([S3ClientTypes.ServerSideEncryptionRule].self, forKey: .rules)
                var rulesBuffer:[S3ClientTypes.ServerSideEncryptionRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ClientTypes.ServerSideEncryptionRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ClientTypes.ServerSideEncryptionConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the default server-side-encryption configuration.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// Container for information about a particular server-side encryption configuration rule.
        /// This member is required.
        public var rules: [S3ClientTypes.ServerSideEncryptionRule]?

        public init (
            rules: [S3ClientTypes.ServerSideEncryptionRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension S3ClientTypes.ServerSideEncryptionRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyServerSideEncryptionByDefault = "ApplyServerSideEncryptionByDefault"
        case bucketKeyEnabled = "BucketKeyEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault {
            try container.encode(applyServerSideEncryptionByDefault, forKey: ClientRuntime.Key("ApplyServerSideEncryptionByDefault"))
        }
        if bucketKeyEnabled != false {
            try container.encode(bucketKeyEnabled, forKey: ClientRuntime.Key("BucketKeyEnabled"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyServerSideEncryptionByDefaultDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ServerSideEncryptionByDefault.self, forKey: .applyServerSideEncryptionByDefault)
        applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefaultDecoded
        let bucketKeyEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .bucketKeyEnabled)
        bucketKeyEnabled = bucketKeyEnabledDecoded
    }
}

extension S3ClientTypes.ServerSideEncryptionRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies the default server-side encryption configuration.
    public struct ServerSideEncryptionRule: Swift.Equatable {
        /// Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
        public var applyServerSideEncryptionByDefault: S3ClientTypes.ServerSideEncryptionByDefault?
        /// Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled. For more information, see [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) in the Amazon S3 User Guide.
        public var bucketKeyEnabled: Swift.Bool

        public init (
            applyServerSideEncryptionByDefault: S3ClientTypes.ServerSideEncryptionByDefault? = nil,
            bucketKeyEnabled: Swift.Bool = false
        )
        {
            self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
            self.bucketKeyEnabled = bucketKeyEnabled
        }
    }

}

extension S3ClientTypes.SourceSelectionCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaModifications = "ReplicaModifications"
        case sseKmsEncryptedObjects = "SseKmsEncryptedObjects"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let replicaModifications = replicaModifications {
            try container.encode(replicaModifications, forKey: ClientRuntime.Key("ReplicaModifications"))
        }
        if let sseKmsEncryptedObjects = sseKmsEncryptedObjects {
            try container.encode(sseKmsEncryptedObjects, forKey: ClientRuntime.Key("SseKmsEncryptedObjects"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsEncryptedObjectsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.SseKmsEncryptedObjects.self, forKey: .sseKmsEncryptedObjects)
        sseKmsEncryptedObjects = sseKmsEncryptedObjectsDecoded
        let replicaModificationsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ReplicaModifications.self, forKey: .replicaModifications)
        replicaModifications = replicaModificationsDecoded
    }
}

extension S3ClientTypes.SourceSelectionCriteria: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. Currently, Amazon S3 supports only the filter that you can specify for objects created with server-side encryption using a customer managed key stored in Amazon Web Services Key Management Service (SSE-KMS).
    public struct SourceSelectionCriteria: Swift.Equatable {
        /// A filter that you can specify for selections for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when Filter is specified), you can specify this element and set the status to Enabled to replicate modifications on replicas. If you don't specify the Filter element, Amazon S3 assumes that the replication configuration is the earlier version, V1. In the earlier version, this element is not allowed
        public var replicaModifications: S3ClientTypes.ReplicaModifications?
        /// A container for filter information for the selection of Amazon S3 objects encrypted with Amazon Web Services KMS. If you include SourceSelectionCriteria in the replication configuration, this element is required.
        public var sseKmsEncryptedObjects: S3ClientTypes.SseKmsEncryptedObjects?

        public init (
            replicaModifications: S3ClientTypes.ReplicaModifications? = nil,
            sseKmsEncryptedObjects: S3ClientTypes.SseKmsEncryptedObjects? = nil
        )
        {
            self.replicaModifications = replicaModifications
            self.sseKmsEncryptedObjects = sseKmsEncryptedObjects
        }
    }

}

extension S3ClientTypes.SseKmsEncryptedObjects: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.SseKmsEncryptedObjectsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ClientTypes.SseKmsEncryptedObjects: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for filter information for the selection of S3 objects encrypted with Amazon Web Services KMS.
    public struct SseKmsEncryptedObjects: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates objects created with server-side encryption using an Amazon Web Services KMS key stored in Amazon Web Services Key Management Service.
        /// This member is required.
        public var status: S3ClientTypes.SseKmsEncryptedObjectsStatus?

        public init (
            status: S3ClientTypes.SseKmsEncryptedObjectsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ClientTypes {
    public enum SseKmsEncryptedObjectsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SseKmsEncryptedObjectsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SseKmsEncryptedObjectsStatus(rawValue: rawValue) ?? SseKmsEncryptedObjectsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.Stats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesProcessed = "BytesProcessed"
        case bytesReturned = "BytesReturned"
        case bytesScanned = "BytesScanned"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if bytesProcessed != 0 {
            try container.encode(bytesProcessed, forKey: ClientRuntime.Key("BytesProcessed"))
        }
        if bytesReturned != 0 {
            try container.encode(bytesReturned, forKey: ClientRuntime.Key("BytesReturned"))
        }
        if bytesScanned != 0 {
            try container.encode(bytesScanned, forKey: ClientRuntime.Key("BytesScanned"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesScannedDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
        let bytesProcessedDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesReturnedDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytesReturned)
        bytesReturned = bytesReturnedDecoded
    }
}

extension S3ClientTypes.Stats: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the stats details.
    public struct Stats: Swift.Equatable {
        /// The total number of uncompressed object bytes processed.
        public var bytesProcessed: Swift.Int
        /// The total number of bytes of records payload data returned.
        public var bytesReturned: Swift.Int
        /// The total number of object bytes scanned.
        public var bytesScanned: Swift.Int

        public init (
            bytesProcessed: Swift.Int = 0,
            bytesReturned: Swift.Int = 0,
            bytesScanned: Swift.Int = 0
        )
        {
            self.bytesProcessed = bytesProcessed
            self.bytesReturned = bytesReturned
            self.bytesScanned = bytesScanned
        }
    }

}

extension S3ClientTypes.StatsEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let details = details {
            try container.encode(details, forKey: ClientRuntime.Key("Details"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Stats.self, forKey: .details)
        details = detailsDecoded
    }
}

extension S3ClientTypes.StatsEvent: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for the Stats Event.
    public struct StatsEvent: Swift.Equatable {
        /// The Stats event details.
        public var details: S3ClientTypes.Stats?

        public init (
            details: S3ClientTypes.Stats? = nil
        )
        {
            self.details = details
        }
    }

}

extension S3ClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case outposts
        case reducedRedundancy
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .outposts,
                .reducedRedundancy,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .outposts: return "OUTPOSTS"
            case .reducedRedundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.StorageClassAnalysis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataExport = "DataExport"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let dataExport = dataExport {
            try container.encode(dataExport, forKey: ClientRuntime.Key("DataExport"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataExportDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClassAnalysisDataExport.self, forKey: .dataExport)
        dataExport = dataExportDecoded
    }
}

extension S3ClientTypes.StorageClassAnalysis: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
    public struct StorageClassAnalysis: Swift.Equatable {
        /// Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
        public var dataExport: S3ClientTypes.StorageClassAnalysisDataExport?

        public init (
            dataExport: S3ClientTypes.StorageClassAnalysisDataExport? = nil
        )
        {
            self.dataExport = dataExport
        }
    }

}

extension S3ClientTypes.StorageClassAnalysisDataExport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case outputSchemaVersion = "OutputSchemaVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: ClientRuntime.Key("Destination"))
        }
        if let outputSchemaVersion = outputSchemaVersion {
            try container.encode(outputSchemaVersion, forKey: ClientRuntime.Key("OutputSchemaVersion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputSchemaVersionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.StorageClassAnalysisSchemaVersion.self, forKey: .outputSchemaVersion)
        outputSchemaVersion = outputSchemaVersionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(S3ClientTypes.AnalyticsExportDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension S3ClientTypes.StorageClassAnalysisDataExport: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for data related to the storage class analysis for an Amazon S3 bucket for export.
    public struct StorageClassAnalysisDataExport: Swift.Equatable {
        /// The place to store the data for an analysis.
        /// This member is required.
        public var destination: S3ClientTypes.AnalyticsExportDestination?
        /// The version of the output schema to use when exporting data. Must be V_1.
        /// This member is required.
        public var outputSchemaVersion: S3ClientTypes.StorageClassAnalysisSchemaVersion?

        public init (
            destination: S3ClientTypes.AnalyticsExportDestination? = nil,
            outputSchemaVersion: S3ClientTypes.StorageClassAnalysisSchemaVersion? = nil
        )
        {
            self.destination = destination
            self.outputSchemaVersion = outputSchemaVersion
        }
    }

}

extension S3ClientTypes {
    public enum StorageClassAnalysisSchemaVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClassAnalysisSchemaVersion] {
            return [
                .v1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClassAnalysisSchemaVersion(rawValue: rawValue) ?? StorageClassAnalysisSchemaVersion.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ClientTypes.Tag: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container of a key value name pair.
    public struct Tag: Swift.Equatable {
        /// Name of the object key.
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension S3ClientTypes.Tagging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagSet = tagSet {
            var tagSetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
            for tag0 in tagSet {
                try tagSetContainer.encode(tag0, forKey: ClientRuntime.Key("Tag"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct Tag{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ClientTypes.Tag].self, forKey: .member)
                var tagSetBuffer:[S3ClientTypes.Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ClientTypes.Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension S3ClientTypes.Tagging: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for TagSet elements.
    public struct Tagging: Swift.Equatable {
        /// A collection for a set of tags
        /// This member is required.
        public var tagSet: [S3ClientTypes.Tag]?

        public init (
            tagSet: [S3ClientTypes.Tag]? = nil
        )
        {
            self.tagSet = tagSet
        }
    }

}

extension S3ClientTypes {
    public enum TaggingDirective: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [TaggingDirective] {
            return [
                .copy,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaggingDirective(rawValue: rawValue) ?? TaggingDirective.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.TargetGrant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let grantee = grantee {
            var granteeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Grantee"))
            try granteeContainer.encode(grantee, forKey: ClientRuntime.Key(""))
            try granteeContainer.encode("http://www.w3.org/2001/XMLSchema-instance", forKey: ClientRuntime.Key("xmlns:xsi"))
        }
        if let permission = permission {
            try container.encode(permission, forKey: ClientRuntime.Key("Permission"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketLogsPermission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension S3ClientTypes.TargetGrant: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns",
            "xmlns:xsi"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Container for granting information. Buckets that use the bucket owner enforced setting for Object Ownership don't support target grants. For more information, see [Permissions server access log delivery](https://docs.aws.amazon.com/AmazonS3/latest/userguide/enable-server-access-logging.html#grant-log-delivery-permissions-general) in the Amazon S3 User Guide.
    public struct TargetGrant: Swift.Equatable {
        /// Container for the person being granted permissions.
        public var grantee: S3ClientTypes.Grantee?
        /// Logging permissions assigned to the grantee for the bucket.
        public var permission: S3ClientTypes.BucketLogsPermission?

        public init (
            grantee: S3ClientTypes.Grantee? = nil,
            permission: S3ClientTypes.BucketLogsPermission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension S3ClientTypes {
    public enum Tier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bulk
        case expedited
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Tier] {
            return [
                .bulk,
                .expedited,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bulk: return "Bulk"
            case .expedited: return "Expedited"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tier(rawValue: rawValue) ?? Tier.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes.Tiering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTier = "AccessTier"
        case days = "Days"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessTier = accessTier {
            try container.encode(accessTier, forKey: ClientRuntime.Key("AccessTier"))
        }
        if days != 0 {
            try container.encode(days, forKey: ClientRuntime.Key("Days"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysDecoded = try containerValues.decode(Swift.Int.self, forKey: .days)
        days = daysDecoded
        let accessTierDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IntelligentTieringAccessTier.self, forKey: .accessTier)
        accessTier = accessTierDecoded
    }
}

extension S3ClientTypes.Tiering: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// The S3 Intelligent-Tiering storage class is designed to optimize storage costs by automatically moving data to the most cost-effective storage access tier, without additional operational overhead.
    public struct Tiering: Swift.Equatable {
        /// S3 Intelligent-Tiering access tier. See [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access) for a list of access tiers in the S3 Intelligent-Tiering storage class.
        /// This member is required.
        public var accessTier: S3ClientTypes.IntelligentTieringAccessTier?
        /// The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
        /// This member is required.
        public var days: Swift.Int

        public init (
            accessTier: S3ClientTypes.IntelligentTieringAccessTier? = nil,
            days: Swift.Int = 0
        )
        {
            self.accessTier = accessTier
            self.days = days
        }
    }

}

extension S3ClientTypes.TopicConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Event"
        case filter = "Filter"
        case id = "Id"
        case topicArn = "Topic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let events = events {
            if events.isEmpty {
                var eventsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("Event"))
                try eventsContainer.encodeNil()
            } else {
                for event0 in events {
                    var eventsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Event"))
                    try eventsContainer0.encode(event0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("Topic"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        if containerValues.contains(.events) {
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .events)
            if eventsWrappedContainer != nil {
                let eventsContainer = try containerValues.decodeIfPresent([S3ClientTypes.Event].self, forKey: .events)
                var eventsBuffer:[S3ClientTypes.Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [S3ClientTypes.Event]()
                    for stringContainer0 in eventsContainer {
                        eventsBuffer?.append(stringContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
        let filterDecoded = try containerValues.decodeIfPresent(S3ClientTypes.NotificationConfigurationFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension S3ClientTypes.TopicConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// A container for specifying the configuration for publication of messages to an Amazon Simple Notification Service (Amazon SNS) topic when Amazon S3 detects specified events.
    public struct TopicConfiguration: Swift.Equatable {
        /// The Amazon S3 bucket event about which to send notifications. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var events: [S3ClientTypes.Event]?
        /// Specifies object key name filtering rules. For information about key name filtering, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
        public var filter: S3ClientTypes.NotificationConfigurationFilter?
        /// An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
        /// This member is required.
        public var topicArn: Swift.String?

        public init (
            events: [S3ClientTypes.Event]? = nil,
            filter: S3ClientTypes.NotificationConfigurationFilter? = nil,
            id: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.events = events
            self.filter = filter
            self.id = id
            self.topicArn = topicArn
        }
    }

}

extension S3ClientTypes.Transition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case days = "Days"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let date = date {
            try container.encode(ClientRuntime.TimestampWrapper(date, format: .dateTime), forKey: ClientRuntime.Key("Date"))
        }
        if days != 0 {
            try container.encode(days, forKey: ClientRuntime.Key("Days"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        var dateBuffer:ClientRuntime.Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let daysDecoded = try containerValues.decode(Swift.Int.self, forKey: .days)
        days = daysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ClientTypes.TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ClientTypes.Transition: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies when an object transitions to a specified storage class. For more information about Amazon S3 lifecycle configuration rules, see [Transitioning Objects Using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the Amazon S3 User Guide.
    public struct Transition: Swift.Equatable {
        /// Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC.
        public var date: ClientRuntime.Date?
        /// Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
        public var days: Swift.Int
        /// The storage class to which you want the object to transition.
        public var storageClass: S3ClientTypes.TransitionStorageClass?

        public init (
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            storageClass: S3ClientTypes.TransitionStorageClass? = nil
        )
        {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension S3ClientTypes {
    public enum TransitionStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitionStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitionStorageClass(rawValue: rawValue) ?? TransitionStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazoncustomerbyemail
        case canonicaluser
        case group
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .amazoncustomerbyemail,
                .canonicaluser,
                .group,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazoncustomerbyemail: return "AmazonCustomerByEmail"
            case .canonicaluser: return "CanonicalUser"
            case .group: return "Group"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UploadPartCopyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let copySource = copySource {
            items.add(Header(name: "x-amz-copy-source", value: Swift.String(copySource)))
        }
        if let copySourceIfMatch = copySourceIfMatch {
            items.add(Header(name: "x-amz-copy-source-if-match", value: Swift.String(copySourceIfMatch)))
        }
        if let copySourceIfModifiedSince = copySourceIfModifiedSince {
            items.add(Header(name: "x-amz-copy-source-if-modified-since", value: Swift.String(copySourceIfModifiedSince.rfc5322())))
        }
        if let copySourceIfNoneMatch = copySourceIfNoneMatch {
            items.add(Header(name: "x-amz-copy-source-if-none-match", value: Swift.String(copySourceIfNoneMatch)))
        }
        if let copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince {
            items.add(Header(name: "x-amz-copy-source-if-unmodified-since", value: Swift.String(copySourceIfUnmodifiedSince.rfc5322())))
        }
        if let copySourceRange = copySourceRange {
            items.add(Header(name: "x-amz-copy-source-range", value: Swift.String(copySourceRange)))
        }
        if let copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm {
            items.add(Header(name: "x-amz-copy-source-server-side-encryption-customer-algorithm", value: Swift.String(copySourceSSECustomerAlgorithm)))
        }
        if let copySourceSSECustomerKey = copySourceSSECustomerKey {
            items.add(Header(name: "x-amz-copy-source-server-side-encryption-customer-key", value: Swift.String(copySourceSSECustomerKey)))
        }
        if let copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-copy-source-server-side-encryption-customer-key-MD5", value: Swift.String(copySourceSSECustomerKeyMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let expectedSourceBucketOwner = expectedSourceBucketOwner {
            items.add(Header(name: "x-amz-source-expected-bucket-owner", value: Swift.String(expectedSourceBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        return items
    }
}

extension UploadPartCopyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "UploadPartCopy"))
        let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
        items.append(partNumberQueryItem)
        if let uploadId = uploadId {
            let uploadIdQueryItem = ClientRuntime.URLQueryItem(name: "uploadId".urlPercentEncoding(), value: Swift.String(uploadId).urlPercentEncoding())
            items.append(uploadIdQueryItem)
        }
        return items
    }
}

extension UploadPartCopyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct UploadPartCopyInput: Swift.Equatable {
    /// The bucket name. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Specifies the source object for the copy operation. You specify the value in one of two formats, depending on whether you want to access the source object through an [access point](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html):
    ///
    /// * For objects not accessed through an access point, specify the name of the source bucket and key of the source object, separated by a slash (/). For example, to copy the object reports/january.pdf from the bucket awsexamplebucket, use awsexamplebucket/reports/january.pdf. The value must be URL encoded.
    ///
    /// * For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format arn:aws:s3:::accesspoint//object/. For example, to copy the object reports/january.pdf through access point my-access-point owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf. The value must be URL encoded. Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same Amazon Web Services Region. Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format arn:aws:s3-outposts:::outpost//object/. For example, to copy the object reports/january.pdf through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf. The value must be URL encoded.
    ///
    ///
    /// To copy a specific version of an object, append ?versionId= to the value (for example, awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893). If you don't specify a version ID, Amazon S3 copies the latest version of the source object.
    /// This member is required.
    public var copySource: Swift.String?
    /// Copies the object if its entity tag (ETag) matches the specified tag.
    public var copySourceIfMatch: Swift.String?
    /// Copies the object if it has been modified since the specified time.
    public var copySourceIfModifiedSince: ClientRuntime.Date?
    /// Copies the object if its entity tag (ETag) is different than the specified ETag.
    public var copySourceIfNoneMatch: Swift.String?
    /// Copies the object if it hasn't been modified since the specified time.
    public var copySourceIfUnmodifiedSince: ClientRuntime.Date?
    /// The range of bytes to copy from the source object. The range value must use the form bytes=first-last, where the first and last are the zero-based byte offsets to copy. For example, bytes=0-9 indicates that you want to copy the first 10 bytes of the source. You can copy a range only if the source object is greater than 5 MB.
    public var copySourceRange: Swift.String?
    /// Specifies the algorithm to use when decrypting the source object (for example, AES256).
    public var copySourceSSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.
    public var copySourceSSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var copySourceSSECustomerKeyMD5: Swift.String?
    /// The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedSourceBucketOwner: Swift.String?
    /// Object key for which the multipart upload was initiated.
    /// This member is required.
    public var key: Swift.String?
    /// Part number of part being copied. This is a positive integer between 1 and 10,000.
    /// This member is required.
    public var partNumber: Swift.Int
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Specifies the algorithm to use to when encrypting the object (for example, AES256).
    public var sSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header. This must be the same encryption key specified in the initiate multipart upload request.
    public var sSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var sSECustomerKeyMD5: Swift.String?
    /// Upload ID identifying the multipart upload whose part is being copied.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        bucket: Swift.String? = nil,
        copySource: Swift.String? = nil,
        copySourceIfMatch: Swift.String? = nil,
        copySourceIfModifiedSince: ClientRuntime.Date? = nil,
        copySourceIfNoneMatch: Swift.String? = nil,
        copySourceIfUnmodifiedSince: ClientRuntime.Date? = nil,
        copySourceRange: Swift.String? = nil,
        copySourceSSECustomerAlgorithm: Swift.String? = nil,
        copySourceSSECustomerKey: Swift.String? = nil,
        copySourceSSECustomerKeyMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        expectedSourceBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        partNumber: Swift.Int = 0,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.bucket = bucket
        self.copySource = copySource
        self.copySourceIfMatch = copySourceIfMatch
        self.copySourceIfModifiedSince = copySourceIfModifiedSince
        self.copySourceIfNoneMatch = copySourceIfNoneMatch
        self.copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince
        self.copySourceRange = copySourceRange
        self.copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm
        self.copySourceSSECustomerKey = copySourceSSECustomerKey
        self.copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.expectedSourceBucketOwner = expectedSourceBucketOwner
        self.key = key
        self.partNumber = partNumber
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.uploadId = uploadId
    }
}

struct UploadPartCopyInputBody: Swift.Equatable {
}

extension UploadPartCopyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UploadPartCopyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = UploadPartCopyOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? UploadPartCopyOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = UploadPartCopyOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension UploadPartCopyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension UploadPartCopyOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum UploadPartCopyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadPartCopyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let copySourceVersionIdHeaderValue = httpResponse.headers.value(for: "x-amz-copy-source-version-id") {
            self.copySourceVersionId = copySourceVersionIdHeaderValue
        } else {
            self.copySourceVersionId = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: S3ClientTypes.CopyPartResult = try responseDecoder.decode(responseBody: data)
                self.copyPartResult = output
            } else {
                self.copyPartResult = nil
            }
        } else {
            self.copyPartResult = nil
        }
    }
}

public struct UploadPartCopyOutputResponse: Swift.Equatable {
    /// Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Container for all response elements.
    public var copyPartResult: S3ClientTypes.CopyPartResult?
    /// The version of the source object that was copied, if you have enabled versioning on the source bucket.
    public var copySourceVersionId: Swift.String?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
    public var sSECustomerAlgorithm: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?

    public init (
        bucketKeyEnabled: Swift.Bool = false,
        copyPartResult: S3ClientTypes.CopyPartResult? = nil,
        copySourceVersionId: Swift.String? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.copyPartResult = copyPartResult
        self.copySourceVersionId = copySourceVersionId
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
    }
}

struct UploadPartCopyOutputResponseBody: Swift.Equatable {
    let copyPartResult: S3ClientTypes.CopyPartResult?
}

extension UploadPartCopyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPartResult = "CopyPartResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyPartResultDecoded = try containerValues.decodeIfPresent(S3ClientTypes.CopyPartResult.self, forKey: .copyPartResult)
        copyPartResult = copyPartResultDecoded
    }
}

public struct UploadPartInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadPartInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UploadPartOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UploadPartInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UploadPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let body = body {
            try container.encode(body, forKey: ClientRuntime.Key("Body"))
        }
    }
}

extension UploadPartInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if contentLength != 0 {
            items.add(Header(name: "Content-Length", value: Swift.String(contentLength)))
        }
        if let contentMD5 = contentMD5 {
            items.add(Header(name: "Content-MD5", value: Swift.String(contentMD5)))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            items.add(Header(name: "x-amz-expected-bucket-owner", value: Swift.String(expectedBucketOwner)))
        }
        if let requestPayer = requestPayer {
            items.add(Header(name: "x-amz-request-payer", value: Swift.String(requestPayer.rawValue)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKey = sSECustomerKey {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key", value: Swift.String(sSECustomerKey)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        return items
    }
}

extension UploadPartInput {
    public func presign(config: AWSClientRuntime.AWSClientConfiguration, expiration: Swift.Int64) async throws -> ClientRuntime.SdkHttpRequest? {
        let serviceName = "S3"
        let input = self
        let encoder = ClientRuntime.XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        let decoder = ClientRuntime.XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.trimValueWhitespaces = false
        decoder.removeWhitespaceElements = true
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "uploadPart")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "s3")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<UploadPartInput, UploadPartOutputResponse, UploadPartOutputError>(id: "uploadPart")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<UploadPartInput, UploadPartOutputResponse, UploadPartOutputError>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<UploadPartInput, UploadPartOutputResponse>())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware<UploadPartOutputResponse, UploadPartOutputError>(endpointResolver: config.endpointResolver, serviceId: serviceName))
        let apiMetadata = AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0")
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: apiMetadata, frameworkMetadata: config.frameworkMetadata)))
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.HeaderMiddleware<UploadPartInput, UploadPartOutputResponse>())
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<UploadPartInput, UploadPartOutputResponse>())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UploadPartInput, UploadPartOutputResponse>(contentType: "application/octet-stream"))
        operation.serializeStep.intercept(position: .after, middleware: UploadPartInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware<UploadPartOutputResponse, UploadPartOutputError>(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(expiration: expiration, unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<UploadPartOutputResponse, UploadPartOutputError>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware<UploadPartOutputResponse, UploadPartOutputError>(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<UploadPartOutputResponse, UploadPartOutputError>())
        let presignedRequestBuilder = try await operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build() else {
            return nil
        }
        return builtRequest
    }
}

extension UploadPartInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "UploadPart"))
        let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
        items.append(partNumberQueryItem)
        if let uploadId = uploadId {
            let uploadIdQueryItem = ClientRuntime.URLQueryItem(name: "uploadId".urlPercentEncoding(), value: Swift.String(uploadId).urlPercentEncoding())
            items.append(uploadIdQueryItem)
        }
        return items
    }
}

extension UploadPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/\(bucket.urlPercentEncoding())/\(key)"
    }
}

public struct UploadPartInput: Swift.Equatable {
    /// Object data.
    public var body: ClientRuntime.ByteStream?
    /// The name of the bucket to which the multipart upload was initiated. When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see [Using access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html) in the Amazon S3 User Guide. When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see [Using S3 on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var bucket: Swift.String?
    /// Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically.
    public var contentLength: Swift.Int
    /// The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated when using the command from the CLI. This parameter is required if object lock parameters are specified.
    public var contentMD5: Swift.String?
    /// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    public var expectedBucketOwner: Swift.String?
    /// Object key for which the multipart upload was initiated.
    /// This member is required.
    public var key: Swift.String?
    /// Part number of part being uploaded. This is a positive integer between 1 and 10,000.
    /// This member is required.
    public var partNumber: Swift.Int
    /// Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see [Downloading Objects in Requestor Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 User Guide.
    public var requestPayer: S3ClientTypes.RequestPayer?
    /// Specifies the algorithm to use to when encrypting the object (for example, AES256).
    public var sSECustomerAlgorithm: Swift.String?
    /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header. This must be the same encryption key specified in the initiate multipart upload request.
    public var sSECustomerKey: Swift.String?
    /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
    public var sSECustomerKeyMD5: Swift.String?
    /// Upload ID identifying the multipart upload whose part is being uploaded.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        body: ClientRuntime.ByteStream? = nil,
        bucket: Swift.String? = nil,
        contentLength: Swift.Int = 0,
        contentMD5: Swift.String? = nil,
        expectedBucketOwner: Swift.String? = nil,
        key: Swift.String? = nil,
        partNumber: Swift.Int = 0,
        requestPayer: S3ClientTypes.RequestPayer? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKey: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.body = body
        self.bucket = bucket
        self.contentLength = contentLength
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.partNumber = partNumber
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.uploadId = uploadId
    }
}

struct UploadPartInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension UploadPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = ClientRuntime.ByteStream.from(data: "".data(using: .utf8)!)
            }
        } else {
            body = nil
        }
    }
}

extension UploadPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = UploadPartOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? UploadPartOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = UploadPartOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension UploadPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension UploadPartOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum UploadPartOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Swift.Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = S3ClientTypes.RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = S3ClientTypes.ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
    }
}

public struct UploadPartOutputResponse: Swift.Equatable {
    /// Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Entity tag for the uploaded object.
    public var eTag: Swift.String?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
    public var sSECustomerAlgorithm: Swift.String?
    /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key was used for the object.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?

    public init (
        bucketKeyEnabled: Swift.Bool = false,
        eTag: Swift.String? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.eTag = eTag
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
    }
}

extension S3ClientTypes.VersioningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mFADelete = "MfaDelete"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let mFADelete = mFADelete {
            try container.encode(mFADelete, forKey: ClientRuntime.Key("MfaDelete"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mFADeleteDecoded = try containerValues.decodeIfPresent(S3ClientTypes.MFADelete.self, forKey: .mFADelete)
        mFADelete = mFADeleteDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ClientTypes.BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ClientTypes.VersioningConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Describes the versioning state of an Amazon S3 bucket. For more information, see [PUT Bucket versioning](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html) in the Amazon S3 API Reference.
    public struct VersioningConfiguration: Swift.Equatable {
        /// Specifies whether MFA delete is enabled in the bucket versioning configuration. This element is only returned if the bucket has been configured with MFA delete. If the bucket has never been so configured, this element is not returned.
        public var mFADelete: S3ClientTypes.MFADelete?
        /// The versioning state of the bucket.
        public var status: S3ClientTypes.BucketVersioningStatus?

        public init (
            mFADelete: S3ClientTypes.MFADelete? = nil,
            status: S3ClientTypes.BucketVersioningStatus? = nil
        )
        {
            self.mFADelete = mFADelete
            self.status = status
        }
    }

}

extension S3ClientTypes.WebsiteConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDocument = "ErrorDocument"
        case indexDocument = "IndexDocument"
        case redirectAllRequestsTo = "RedirectAllRequestsTo"
        case routingRules = "RoutingRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let errorDocument = errorDocument {
            try container.encode(errorDocument, forKey: ClientRuntime.Key("ErrorDocument"))
        }
        if let indexDocument = indexDocument {
            try container.encode(indexDocument, forKey: ClientRuntime.Key("IndexDocument"))
        }
        if let redirectAllRequestsTo = redirectAllRequestsTo {
            try container.encode(redirectAllRequestsTo, forKey: ClientRuntime.Key("RedirectAllRequestsTo"))
        }
        if let routingRules = routingRules {
            var routingRulesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RoutingRules"))
            for routingrule0 in routingRules {
                try routingRulesContainer.encode(routingrule0, forKey: ClientRuntime.Key("RoutingRule"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDocumentDecoded = try containerValues.decodeIfPresent(S3ClientTypes.ErrorDocument.self, forKey: .errorDocument)
        errorDocument = errorDocumentDecoded
        let indexDocumentDecoded = try containerValues.decodeIfPresent(S3ClientTypes.IndexDocument.self, forKey: .indexDocument)
        indexDocument = indexDocumentDecoded
        let redirectAllRequestsToDecoded = try containerValues.decodeIfPresent(S3ClientTypes.RedirectAllRequestsTo.self, forKey: .redirectAllRequestsTo)
        redirectAllRequestsTo = redirectAllRequestsToDecoded
        if containerValues.contains(.routingRules) {
            struct KeyVal0{struct RoutingRule{}}
            let routingRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RoutingRule>.CodingKeys.self, forKey: .routingRules)
            if let routingRulesWrappedContainer = routingRulesWrappedContainer {
                let routingRulesContainer = try routingRulesWrappedContainer.decodeIfPresent([S3ClientTypes.RoutingRule].self, forKey: .member)
                var routingRulesBuffer:[S3ClientTypes.RoutingRule]? = nil
                if let routingRulesContainer = routingRulesContainer {
                    routingRulesBuffer = [S3ClientTypes.RoutingRule]()
                    for structureContainer0 in routingRulesContainer {
                        routingRulesBuffer?.append(structureContainer0)
                    }
                }
                routingRules = routingRulesBuffer
            } else {
                routingRules = []
            }
        } else {
            routingRules = nil
        }
    }
}

extension S3ClientTypes.WebsiteConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ClientTypes {
    /// Specifies website configuration parameters for an Amazon S3 bucket.
    public struct WebsiteConfiguration: Swift.Equatable {
        /// The name of the error document for the website.
        public var errorDocument: S3ClientTypes.ErrorDocument?
        /// The name of the index document for the website.
        public var indexDocument: S3ClientTypes.IndexDocument?
        /// The redirect behavior for every request to this bucket's website endpoint. If you specify this property, you can't specify any other property.
        public var redirectAllRequestsTo: S3ClientTypes.RedirectAllRequestsTo?
        /// Rules that define when a redirect is applied and the redirect behavior.
        public var routingRules: [S3ClientTypes.RoutingRule]?

        public init (
            errorDocument: S3ClientTypes.ErrorDocument? = nil,
            indexDocument: S3ClientTypes.IndexDocument? = nil,
            redirectAllRequestsTo: S3ClientTypes.RedirectAllRequestsTo? = nil,
            routingRules: [S3ClientTypes.RoutingRule]? = nil
        )
        {
            self.errorDocument = errorDocument
            self.indexDocument = indexDocument
            self.redirectAllRequestsTo = redirectAllRequestsTo
            self.routingRules = routingRules
        }
    }

}

public struct WriteGetObjectResponseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "WriteGetObjectResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<WriteGetObjectResponseInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<WriteGetObjectResponseOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<WriteGetObjectResponseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<WriteGetObjectResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension WriteGetObjectResponseInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension WriteGetObjectResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let body = body {
            try container.encode(body, forKey: ClientRuntime.Key("Body"))
        }
    }
}

extension WriteGetObjectResponseInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let acceptRanges = acceptRanges {
            items.add(Header(name: "x-amz-fwd-header-accept-ranges", value: Swift.String(acceptRanges)))
        }
        if bucketKeyEnabled != false {
            items.add(Header(name: "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled", value: Swift.String(bucketKeyEnabled)))
        }
        if let cacheControl = cacheControl {
            items.add(Header(name: "x-amz-fwd-header-Cache-Control", value: Swift.String(cacheControl)))
        }
        if let contentDisposition = contentDisposition {
            items.add(Header(name: "x-amz-fwd-header-Content-Disposition", value: Swift.String(contentDisposition)))
        }
        if let contentEncoding = contentEncoding {
            items.add(Header(name: "x-amz-fwd-header-Content-Encoding", value: Swift.String(contentEncoding)))
        }
        if let contentLanguage = contentLanguage {
            items.add(Header(name: "x-amz-fwd-header-Content-Language", value: Swift.String(contentLanguage)))
        }
        if contentLength != 0 {
            items.add(Header(name: "Content-Length", value: Swift.String(contentLength)))
        }
        if let contentRange = contentRange {
            items.add(Header(name: "x-amz-fwd-header-Content-Range", value: Swift.String(contentRange)))
        }
        if let contentType = contentType {
            items.add(Header(name: "x-amz-fwd-header-Content-Type", value: Swift.String(contentType)))
        }
        if deleteMarker != false {
            items.add(Header(name: "x-amz-fwd-header-x-amz-delete-marker", value: Swift.String(deleteMarker)))
        }
        if let eTag = eTag {
            items.add(Header(name: "x-amz-fwd-header-ETag", value: Swift.String(eTag)))
        }
        if let errorCode = errorCode {
            items.add(Header(name: "x-amz-fwd-error-code", value: Swift.String(errorCode)))
        }
        if let errorMessage = errorMessage {
            items.add(Header(name: "x-amz-fwd-error-message", value: Swift.String(errorMessage)))
        }
        if let expiration = expiration {
            items.add(Header(name: "x-amz-fwd-header-x-amz-expiration", value: Swift.String(expiration)))
        }
        if let expires = expires {
            items.add(Header(name: "x-amz-fwd-header-Expires", value: Swift.String(expires.rfc5322())))
        }
        if let lastModified = lastModified {
            items.add(Header(name: "x-amz-fwd-header-Last-Modified", value: Swift.String(lastModified.rfc5322())))
        }
        if missingMeta != 0 {
            items.add(Header(name: "x-amz-fwd-header-x-amz-missing-meta", value: Swift.String(missingMeta)))
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            items.add(Header(name: "x-amz-fwd-header-x-amz-object-lock-legal-hold", value: Swift.String(objectLockLegalHoldStatus.rawValue)))
        }
        if let objectLockMode = objectLockMode {
            items.add(Header(name: "x-amz-fwd-header-x-amz-object-lock-mode", value: Swift.String(objectLockMode.rawValue)))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            items.add(Header(name: "x-amz-fwd-header-x-amz-object-lock-retain-until-date", value: Swift.String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds())))
        }
        if partsCount != 0 {
            items.add(Header(name: "x-amz-fwd-header-x-amz-mp-parts-count", value: Swift.String(partsCount)))
        }
        if let replicationStatus = replicationStatus {
            items.add(Header(name: "x-amz-fwd-header-x-amz-replication-status", value: Swift.String(replicationStatus.rawValue)))
        }
        if let requestCharged = requestCharged {
            items.add(Header(name: "x-amz-fwd-header-x-amz-request-charged", value: Swift.String(requestCharged.rawValue)))
        }
        if let requestRoute = requestRoute {
            items.add(Header(name: "x-amz-request-route", value: Swift.String(requestRoute)))
        }
        if let requestToken = requestToken {
            items.add(Header(name: "x-amz-request-token", value: Swift.String(requestToken)))
        }
        if let restore = restore {
            items.add(Header(name: "x-amz-fwd-header-x-amz-restore", value: Swift.String(restore)))
        }
        if let sSECustomerAlgorithm = sSECustomerAlgorithm {
            items.add(Header(name: "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm", value: Swift.String(sSECustomerAlgorithm)))
        }
        if let sSECustomerKeyMD5 = sSECustomerKeyMD5 {
            items.add(Header(name: "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5", value: Swift.String(sSECustomerKeyMD5)))
        }
        if let sSEKMSKeyId = sSEKMSKeyId {
            items.add(Header(name: "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id", value: Swift.String(sSEKMSKeyId)))
        }
        if let serverSideEncryption = serverSideEncryption {
            items.add(Header(name: "x-amz-fwd-header-x-amz-server-side-encryption", value: Swift.String(serverSideEncryption.rawValue)))
        }
        if statusCode != 0 {
            items.add(Header(name: "x-amz-fwd-status", value: Swift.String(statusCode)))
        }
        if let storageClass = storageClass {
            items.add(Header(name: "x-amz-fwd-header-x-amz-storage-class", value: Swift.String(storageClass.rawValue)))
        }
        if tagCount != 0 {
            items.add(Header(name: "x-amz-fwd-header-x-amz-tagging-count", value: Swift.String(tagCount)))
        }
        if let versionId = versionId {
            items.add(Header(name: "x-amz-fwd-header-x-amz-version-id", value: Swift.String(versionId)))
        }
        if let metadata = metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                items.add(Header(name: "x-amz-meta-\(prefixHeaderMapKey)", value: Swift.String(prefixHeaderMapValue)))
            }
        }
        return items
    }
}

extension WriteGetObjectResponseInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "x-id", value: "WriteGetObjectResponse"))
        return items
    }
}

extension WriteGetObjectResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/WriteGetObjectResponse"
    }
}

public struct WriteGetObjectResponseInput: Swift.Equatable {
    /// Indicates that a range of bytes was specified.
    public var acceptRanges: Swift.String?
    /// The object data.
    public var body: ClientRuntime.ByteStream?
    /// Indicates whether the object stored in Amazon S3 uses an S3 bucket key for server-side encryption with Amazon Web Services KMS (SSE-KMS).
    public var bucketKeyEnabled: Swift.Bool
    /// Specifies caching behavior along the request/reply chain.
    public var cacheControl: Swift.String?
    /// Specifies presentational information for the object.
    public var contentDisposition: Swift.String?
    /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
    public var contentEncoding: Swift.String?
    /// The language the content is in.
    public var contentLanguage: Swift.String?
    /// The size of the content body in bytes.
    public var contentLength: Swift.Int
    /// The portion of the object returned in the response.
    public var contentRange: Swift.String?
    /// A standard MIME type describing the format of the object data.
    public var contentType: Swift.String?
    /// Specifies whether an object stored in Amazon S3 is (true) or is not (false) a delete marker.
    public var deleteMarker: Swift.Bool
    /// An opaque identifier assigned by a web server to a specific version of a resource found at a URL.
    public var eTag: Swift.String?
    /// A string that uniquely identifies an error condition. Returned in the  tag of the error XML response for a corresponding GetObject call. Cannot be used with a successful StatusCode header or when the transformed object is provided in the body. All error codes from S3 are sentence-cased. Regex value is "^[A-Z][a-zA-Z]+$".
    public var errorCode: Swift.String?
    /// Contains a generic description of the error condition. Returned in the tag of the error XML response for a corresponding GetObject call. Cannot be used with a successful StatusCode header or when the transformed object is provided in body.
    public var errorMessage: Swift.String?
    /// If object stored in Amazon S3 expiration is configured (see PUT Bucket lifecycle) it includes expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded.
    public var expiration: Swift.String?
    /// The date and time at which the object is no longer cacheable.
    public var expires: ClientRuntime.Date?
    /// The date and time that the object was last modified.
    public var lastModified: ClientRuntime.Date?
    /// A map of metadata to store with the object in S3.
    public var metadata: [Swift.String:Swift.String]?
    /// Set to the number of metadata entries not returned in x-amz-meta headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.
    public var missingMeta: Swift.Int
    /// Indicates whether an object stored in Amazon S3 has an active legal hold.
    public var objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus?
    /// Indicates whether an object stored in Amazon S3 has Object Lock enabled. For more information about S3 Object Lock, see [Object Lock](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html).
    public var objectLockMode: S3ClientTypes.ObjectLockMode?
    /// The date and time when Object Lock is configured to expire.
    public var objectLockRetainUntilDate: ClientRuntime.Date?
    /// The count of parts this object has.
    public var partsCount: Swift.Int
    /// Indicates if request involves bucket that is either a source or destination in a Replication rule. For more information about S3 Replication, see [Replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication.html).
    public var replicationStatus: S3ClientTypes.ReplicationStatus?
    /// If present, indicates that the requester was successfully charged for the request.
    public var requestCharged: S3ClientTypes.RequestCharged?
    /// Route prefix to the HTTP URL generated.
    /// This member is required.
    public var requestRoute: Swift.String?
    /// A single use encrypted token that maps WriteGetObjectResponse to the end user GetObject request.
    /// This member is required.
    public var requestToken: Swift.String?
    /// Provides information about object restoration operation and expiration time of the restored object copy.
    public var restore: Swift.String?
    /// Encryption algorithm used if server-side encryption with a customer-provided encryption key was specified for object stored in Amazon S3.
    public var sSECustomerAlgorithm: Swift.String?
    /// 128-bit MD5 digest of customer-provided encryption key used in Amazon S3 to encrypt data stored in S3. For more information, see [Protecting data using server-side encryption with customer-provided encryption keys (SSE-C)](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html).
    public var sSECustomerKeyMD5: Swift.String?
    /// If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for stored in Amazon S3 object.
    public var sSEKMSKeyId: Swift.String?
    /// The server-side encryption algorithm used when storing requested object in Amazon S3 (for example, AES256, aws:kms).
    public var serverSideEncryption: S3ClientTypes.ServerSideEncryption?
    /// The integer status code for an HTTP response of a corresponding GetObject request. Status Codes
    ///
    /// * 200 - OK
    ///
    /// * 206 - Partial Content
    ///
    /// * 304 - Not Modified
    ///
    /// * 400 - Bad Request
    ///
    /// * 401 - Unauthorized
    ///
    /// * 403 - Forbidden
    ///
    /// * 404 - Not Found
    ///
    /// * 405 - Method Not Allowed
    ///
    /// * 409 - Conflict
    ///
    /// * 411 - Length Required
    ///
    /// * 412 - Precondition Failed
    ///
    /// * 416 - Range Not Satisfiable
    ///
    /// * 500 - Internal Server Error
    ///
    /// * 503 - Service Unavailable
    public var statusCode: Swift.Int
    /// The class of storage used to store object in Amazon S3.
    public var storageClass: S3ClientTypes.StorageClass?
    /// The number of tags, if any, on the object.
    public var tagCount: Swift.Int
    /// An ID used to reference a specific version of the object.
    public var versionId: Swift.String?

    public init (
        acceptRanges: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        bucketKeyEnabled: Swift.Bool = false,
        cacheControl: Swift.String? = nil,
        contentDisposition: Swift.String? = nil,
        contentEncoding: Swift.String? = nil,
        contentLanguage: Swift.String? = nil,
        contentLength: Swift.Int = 0,
        contentRange: Swift.String? = nil,
        contentType: Swift.String? = nil,
        deleteMarker: Swift.Bool = false,
        eTag: Swift.String? = nil,
        errorCode: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        expiration: Swift.String? = nil,
        expires: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        missingMeta: Swift.Int = 0,
        objectLockLegalHoldStatus: S3ClientTypes.ObjectLockLegalHoldStatus? = nil,
        objectLockMode: S3ClientTypes.ObjectLockMode? = nil,
        objectLockRetainUntilDate: ClientRuntime.Date? = nil,
        partsCount: Swift.Int = 0,
        replicationStatus: S3ClientTypes.ReplicationStatus? = nil,
        requestCharged: S3ClientTypes.RequestCharged? = nil,
        requestRoute: Swift.String? = nil,
        requestToken: Swift.String? = nil,
        restore: Swift.String? = nil,
        sSECustomerAlgorithm: Swift.String? = nil,
        sSECustomerKeyMD5: Swift.String? = nil,
        sSEKMSKeyId: Swift.String? = nil,
        serverSideEncryption: S3ClientTypes.ServerSideEncryption? = nil,
        statusCode: Swift.Int = 0,
        storageClass: S3ClientTypes.StorageClass? = nil,
        tagCount: Swift.Int = 0,
        versionId: Swift.String? = nil
    )
    {
        self.acceptRanges = acceptRanges
        self.body = body
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentRange = contentRange
        self.contentType = contentType
        self.deleteMarker = deleteMarker
        self.eTag = eTag
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.expiration = expiration
        self.expires = expires
        self.lastModified = lastModified
        self.metadata = metadata
        self.missingMeta = missingMeta
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.partsCount = partsCount
        self.replicationStatus = replicationStatus
        self.requestCharged = requestCharged
        self.requestRoute = requestRoute
        self.requestToken = requestToken
        self.restore = restore
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.statusCode = statusCode
        self.storageClass = storageClass
        self.tagCount = tagCount
        self.versionId = versionId
    }
}

struct WriteGetObjectResponseInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension WriteGetObjectResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = ClientRuntime.ByteStream.from(data: "".data(using: .utf8)!)
            }
        } else {
            body = nil
        }
    }
}

extension WriteGetObjectResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = WriteGetObjectResponseOutputError.isNotFoundAndEmptyBody(httpResponse: httpResponse)
            ? WriteGetObjectResponseOutputError.constructRestXMLError(httpResponse: httpResponse)
            : try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        let requestID2 = WriteGetObjectResponseOutputError.getRequestId2(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId, requestID2: requestID2)
    }
}

extension WriteGetObjectResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil, requestID2: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}
extension WriteGetObjectResponseOutputError {
    static func isNotFoundAndEmptyBody(httpResponse: HttpResponse) -> Bool {
        if case .none = httpResponse.body {
            return httpResponse.statusCode == .notFound
        } else if case .empty = httpResponse.body {
            return httpResponse.statusCode == .notFound
        }
        return false
    }
    static func constructRestXMLError(httpResponse: HttpResponse) -> AWSClientRuntime.RestXMLError {
        return RestXMLError(errorCode: "NotFound", requestId: httpResponse.headers.value(for: "x-amz-request-id"))
    }
    static func getRequestId2(httpResponse: HttpResponse) -> String? {
        return httpResponse.headers.value(for: "x-amz-id-2")
    }
}

public enum WriteGetObjectResponseOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension WriteGetObjectResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct WriteGetObjectResponseOutputResponse: Swift.Equatable {

}
