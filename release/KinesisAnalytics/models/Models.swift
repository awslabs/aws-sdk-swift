// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddApplicationCloudWatchLoggingOptionInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationCloudWatchLoggingOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationCloudWatchLoggingOptionOutputError>
}

extension AddApplicationCloudWatchLoggingOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationCloudWatchLoggingOptionInput(applicationName: \(String(describing: applicationName)), cloudWatchLoggingOption: \(String(describing: cloudWatchLoggingOption)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)))"}
}

extension AddApplicationCloudWatchLoggingOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOption = cloudWatchLoggingOption {
            try encodeContainer.encode(cloudWatchLoggingOption, forKey: .cloudWatchLoggingOption)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

public struct AddApplicationCloudWatchLoggingOptionInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationCloudWatchLoggingOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationCloudWatchLoggingOptionOutputError>
}

public struct AddApplicationCloudWatchLoggingOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationCloudWatchLoggingOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationCloudWatchLoggingOptionOutputError>
}

public struct AddApplicationCloudWatchLoggingOptionInput: Equatable {
    /// <p>The Kinesis Analytics application name.</p>
    public let applicationName: String?
    /// <p>Provides the CloudWatch log stream Amazon Resource Name (ARN) and the IAM role ARN.
    ///             Note: To write application messages to CloudWatch, the IAM role that is used must have
    ///             the <code>PutLogEvents</code> policy action enabled.</p>
    public let cloudWatchLoggingOption: CloudWatchLoggingOption?
    /// <p>The version ID of the Kinesis Analytics application.</p>
    public let currentApplicationVersionId: Int?

    public init (
        applicationName: String? = nil,
        cloudWatchLoggingOption: CloudWatchLoggingOption? = nil,
        currentApplicationVersionId: Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOption = cloudWatchLoggingOption
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct AddApplicationCloudWatchLoggingOptionInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let cloudWatchLoggingOption: CloudWatchLoggingOption?
}

extension AddApplicationCloudWatchLoggingOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionDecoded = try containerValues.decodeIfPresent(CloudWatchLoggingOption.self, forKey: .cloudWatchLoggingOption)
        cloudWatchLoggingOption = cloudWatchLoggingOptionDecoded
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationCloudWatchLoggingOptionOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationCloudWatchLoggingOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationCloudWatchLoggingOptionOutputResponse()"}
}

extension AddApplicationCloudWatchLoggingOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddApplicationCloudWatchLoggingOptionOutputResponse: Equatable {

    public init() {}
}

struct AddApplicationCloudWatchLoggingOptionOutputResponseBody: Equatable {
}

extension AddApplicationCloudWatchLoggingOptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddApplicationInputInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationInputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputInput>
    public typealias MOutput = OperationOutput<AddApplicationInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputOutputError>
}

extension AddApplicationInputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), input: \(String(describing: input)))"}
}

extension AddApplicationInputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
    }
}

public struct AddApplicationInputInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputInput>
    public typealias MOutput = OperationOutput<AddApplicationInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputOutputError>
}

public struct AddApplicationInputInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputInput>
    public typealias MOutput = OperationOutput<AddApplicationInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputOutputError>
}

/// <p></p>
public struct AddApplicationInputInput: Equatable {
    /// <p>Name of your existing Amazon Kinesis Analytics application to which you want to add the streaming source.</p>
    public let applicationName: String?
    /// <p>Current version of your Amazon Kinesis Analytics application. You can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation
    ///             to find the current application version.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_Input.html">Input</a> to add.</p>
    public let input: Input?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        input: Input? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.input = input
    }
}

struct AddApplicationInputInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let input: Input?
}

extension AddApplicationInputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Input.self, forKey: .input)
        input = inputDecoded
    }
}

extension AddApplicationInputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationInputOutputError: Swift.Error, Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputOutputResponse()"}
}

extension AddApplicationInputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct AddApplicationInputOutputResponse: Equatable {

    public init() {}
}

struct AddApplicationInputOutputResponseBody: Equatable {
}

extension AddApplicationInputOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddApplicationInputProcessingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationInputProcessingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputProcessingConfigurationOutputError>
}

extension AddApplicationInputProcessingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputProcessingConfigurationInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), inputId: \(String(describing: inputId)), inputProcessingConfiguration: \(String(describing: inputProcessingConfiguration)))"}
}

extension AddApplicationInputProcessingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputProcessingConfiguration = inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
    }
}

public struct AddApplicationInputProcessingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationInputProcessingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputProcessingConfigurationOutputError>
}

public struct AddApplicationInputProcessingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationInputProcessingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputProcessingConfigurationOutputError>
}

public struct AddApplicationInputProcessingConfigurationInput: Equatable {
    /// <p>Name of the application to which you want to add the input processing configuration.</p>
    public let applicationName: String?
    /// <p>Version of the application to which you want to add the input processing configuration. You can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a>
    ///             operation to get the current application version.  If the version specified is not the current version, the
    ///             <code>ConcurrentModificationException</code> is returned.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the input configuration to add the input processing configuration to. You
    ///             can get a list of the input IDs for an application using the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation.</p>
    public let inputId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html">InputProcessingConfiguration</a> to add to the application.</p>
    public let inputProcessingConfiguration: InputProcessingConfiguration?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        inputId: String? = nil,
        inputProcessingConfiguration: InputProcessingConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
        self.inputProcessingConfiguration = inputProcessingConfiguration
    }
}

struct AddApplicationInputProcessingConfigurationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let inputId: String?
    public let inputProcessingConfiguration: InputProcessingConfiguration?
}

extension AddApplicationInputProcessingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension AddApplicationInputProcessingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputProcessingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationInputProcessingConfigurationOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputProcessingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputProcessingConfigurationOutputResponse()"}
}

extension AddApplicationInputProcessingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddApplicationInputProcessingConfigurationOutputResponse: Equatable {

    public init() {}
}

struct AddApplicationInputProcessingConfigurationOutputResponseBody: Equatable {
}

extension AddApplicationInputProcessingConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddApplicationOutputInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationOutputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationOutputInput>
    public typealias MOutput = OperationOutput<AddApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationOutputOutputError>
}

extension AddApplicationOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationOutputInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), output: \(String(describing: output)))"}
}

extension AddApplicationOutputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
    }
}

public struct AddApplicationOutputInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationOutputInput>
    public typealias MOutput = OperationOutput<AddApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationOutputOutputError>
}

public struct AddApplicationOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationOutputInput>
    public typealias MOutput = OperationOutput<AddApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationOutputOutputError>
}

/// <p></p>
public struct AddApplicationOutputInput: Equatable {
    /// <p>Name of the application to which you want to add the output configuration.</p>
    public let applicationName: String?
    /// <p>Version of the application to which you want to add the output configuration. You
    ///             can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get the current
    ///             application version. If the version specified is not the current version, the
    ///                 <code>ConcurrentModificationException</code> is returned. </p>
    public let currentApplicationVersionId: Int?
    /// <p>An array of objects, each describing one output configuration. In the output
    ///             configuration, you specify the name of an in-application stream, a destination (that is,
    ///             an Amazon Kinesis stream, an Amazon Kinesis Firehose delivery stream, or an AWS Lambda
    ///             function), and record the formation to use when writing to the destination.</p>
    public let output: Output?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        output: Output? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.output = output
    }
}

struct AddApplicationOutputInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let output: Output?
}

extension AddApplicationOutputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Output.self, forKey: .output)
        output = outputDecoded
    }
}

extension AddApplicationOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationOutputOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationOutputOutputResponse()"}
}

extension AddApplicationOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct AddApplicationOutputOutputResponse: Equatable {

    public init() {}
}

struct AddApplicationOutputOutputResponseBody: Equatable {
}

extension AddApplicationOutputOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddApplicationReferenceDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationReferenceDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<AddApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationReferenceDataSourceOutputError>
}

extension AddApplicationReferenceDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationReferenceDataSourceInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), referenceDataSource: \(String(describing: referenceDataSource)))"}
}

extension AddApplicationReferenceDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceDataSource = referenceDataSource {
            try encodeContainer.encode(referenceDataSource, forKey: .referenceDataSource)
        }
    }
}

public struct AddApplicationReferenceDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationReferenceDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<AddApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationReferenceDataSourceOutputError>
}

public struct AddApplicationReferenceDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationReferenceDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<AddApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationReferenceDataSourceOutputError>
}

/// <p></p>
public struct AddApplicationReferenceDataSourceInput: Equatable {
    /// <p>Name of an existing application.</p>
    public let applicationName: String?
    /// <p>Version of the application for which you are adding the reference data source.
    ///             You can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get the current application version.
    ///             If the version specified is not the current version, the
    ///             <code>ConcurrentModificationException</code> is returned.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The reference data source can be an object in your Amazon S3 bucket. Amazon Kinesis Analytics reads the object and copies the data into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting in-application table that is created. You must also provide an IAM role with the necessary permissions that Amazon Kinesis Analytics can assume to read the object from your S3 bucket on your behalf.</p>
    public let referenceDataSource: ReferenceDataSource?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        referenceDataSource: ReferenceDataSource? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceDataSource = referenceDataSource
    }
}

struct AddApplicationReferenceDataSourceInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let referenceDataSource: ReferenceDataSource?
}

extension AddApplicationReferenceDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceDataSourceDecoded = try containerValues.decodeIfPresent(ReferenceDataSource.self, forKey: .referenceDataSource)
        referenceDataSource = referenceDataSourceDecoded
    }
}

extension AddApplicationReferenceDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationReferenceDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationReferenceDataSourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationReferenceDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationReferenceDataSourceOutputResponse()"}
}

extension AddApplicationReferenceDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct AddApplicationReferenceDataSourceOutputResponse: Equatable {

    public init() {}
}

struct AddApplicationReferenceDataSourceOutputResponseBody: Equatable {
}

extension AddApplicationReferenceDataSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ApplicationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationCode = "ApplicationCode"
        case applicationDescription = "ApplicationDescription"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
        case createTimestamp = "CreateTimestamp"
        case inputDescriptions = "InputDescriptions"
        case lastUpdateTimestamp = "LastUpdateTimestamp"
        case outputDescriptions = "OutputDescriptions"
        case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationCode = applicationCode {
            try encodeContainer.encode(applicationCode, forKey: .applicationCode)
        }
        if let applicationDescription = applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions {
            var cloudWatchLoggingOptionDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionDescriptions)
            for cloudwatchloggingoptiondescriptions0 in cloudWatchLoggingOptionDescriptions {
                try cloudWatchLoggingOptionDescriptionsContainer.encode(cloudwatchloggingoptiondescriptions0)
            }
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
        if let inputDescriptions = inputDescriptions {
            var inputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputDescriptions)
            for inputdescriptions0 in inputDescriptions {
                try inputDescriptionsContainer.encode(inputdescriptions0)
            }
        }
        if let lastUpdateTimestamp = lastUpdateTimestamp {
            try encodeContainer.encode(lastUpdateTimestamp.timeIntervalSince1970, forKey: .lastUpdateTimestamp)
        }
        if let outputDescriptions = outputDescriptions {
            var outputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputDescriptions)
            for outputdescriptions0 in outputDescriptions {
                try outputDescriptionsContainer.encode(outputdescriptions0)
            }
        }
        if let referenceDataSourceDescriptions = referenceDataSourceDescriptions {
            var referenceDataSourceDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceDescriptions)
            for referencedatasourcedescriptions0 in referenceDataSourceDescriptions {
                try referenceDataSourceDescriptionsContainer.encode(referencedatasourcedescriptions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let lastUpdateTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTimestamp)
        lastUpdateTimestamp = lastUpdateTimestampDecoded
        let inputDescriptionsContainer = try containerValues.decodeIfPresent([InputDescription?].self, forKey: .inputDescriptions)
        var inputDescriptionsDecoded0:[InputDescription]? = nil
        if let inputDescriptionsContainer = inputDescriptionsContainer {
            inputDescriptionsDecoded0 = [InputDescription]()
            for structure0 in inputDescriptionsContainer {
                if let structure0 = structure0 {
                    inputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        inputDescriptions = inputDescriptionsDecoded0
        let outputDescriptionsContainer = try containerValues.decodeIfPresent([OutputDescription?].self, forKey: .outputDescriptions)
        var outputDescriptionsDecoded0:[OutputDescription]? = nil
        if let outputDescriptionsContainer = outputDescriptionsContainer {
            outputDescriptionsDecoded0 = [OutputDescription]()
            for structure0 in outputDescriptionsContainer {
                if let structure0 = structure0 {
                    outputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        outputDescriptions = outputDescriptionsDecoded0
        let referenceDataSourceDescriptionsContainer = try containerValues.decodeIfPresent([ReferenceDataSourceDescription?].self, forKey: .referenceDataSourceDescriptions)
        var referenceDataSourceDescriptionsDecoded0:[ReferenceDataSourceDescription]? = nil
        if let referenceDataSourceDescriptionsContainer = referenceDataSourceDescriptionsContainer {
            referenceDataSourceDescriptionsDecoded0 = [ReferenceDataSourceDescription]()
            for structure0 in referenceDataSourceDescriptionsContainer {
                if let structure0 = structure0 {
                    referenceDataSourceDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceDescriptions = referenceDataSourceDescriptionsDecoded0
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
        let applicationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationCode)
        applicationCode = applicationCodeDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension ApplicationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationDetail(applicationARN: \(String(describing: applicationARN)), applicationCode: \(String(describing: applicationCode)), applicationDescription: \(String(describing: applicationDescription)), applicationName: \(String(describing: applicationName)), applicationStatus: \(String(describing: applicationStatus)), applicationVersionId: \(String(describing: applicationVersionId)), cloudWatchLoggingOptionDescriptions: \(String(describing: cloudWatchLoggingOptionDescriptions)), createTimestamp: \(String(describing: createTimestamp)), inputDescriptions: \(String(describing: inputDescriptions)), lastUpdateTimestamp: \(String(describing: lastUpdateTimestamp)), outputDescriptions: \(String(describing: outputDescriptions)), referenceDataSourceDescriptions: \(String(describing: referenceDataSourceDescriptions)))"}
}

/// <note>
///             <p>This documentation is for version 1 of the Amazon Kinesis Data Analytics API, which only supports SQL applications. Version 2 of the API supports SQL and Java applications. For more information about version 2, see <a href="/kinesisanalytics/latest/apiv2/Welcome.html">Amazon Kinesis Data Analytics API V2 Documentation</a>.</p>
///          </note>
///         <p>Provides a description of the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configuration.</p>
public struct ApplicationDetail: Equatable {
    /// <p>ARN of the application.</p>
    public let applicationARN: String?
    /// <p>Returns the application code that you provided to perform data analysis on any of the in-application streams in your application.</p>
    public let applicationCode: String?
    /// <p>Description of the application.</p>
    public let applicationDescription: String?
    /// <p>Name of the application.</p>
    public let applicationName: String?
    /// <p>Status of the application.</p>
    public let applicationStatus: ApplicationStatus?
    /// <p>Provides the current application version.</p>
    public let applicationVersionId: Int?
    /// <p>Describes the CloudWatch log streams that are configured to receive application
    ///             messages. For more information about using CloudWatch log streams with Amazon Kinesis
    ///             Analytics applications, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/cloudwatch-logs.html">Working with Amazon
    ///                 CloudWatch Logs</a>. </p>
    public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
    /// <p>Time stamp when the application version was created.</p>
    public let createTimestamp: Date?
    /// <p>Describes the application input configuration.
    ///             For more information,
    ///             see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html">Configuring Application Input</a>.
    ///
    ///         </p>
    public let inputDescriptions: [InputDescription]?
    /// <p>Time stamp when the application was last updated.</p>
    public let lastUpdateTimestamp: Date?
    /// <p>Describes the application output configuration.
    ///             For more information,
    ///             see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html">Configuring Application Output</a>.
    ///
    ///         </p>
    public let outputDescriptions: [OutputDescription]?
    /// <p>Describes reference data sources configured for the application.
    ///
    ///             For more information,
    ///             see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html">Configuring Application Input</a>.
    ///
    ///         </p>
    public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?

    public init (
        applicationARN: String? = nil,
        applicationCode: String? = nil,
        applicationDescription: String? = nil,
        applicationName: String? = nil,
        applicationStatus: ApplicationStatus? = nil,
        applicationVersionId: Int? = nil,
        cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil,
        createTimestamp: Date? = nil,
        inputDescriptions: [InputDescription]? = nil,
        lastUpdateTimestamp: Date? = nil,
        outputDescriptions: [OutputDescription]? = nil,
        referenceDataSourceDescriptions: [ReferenceDataSourceDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationCode = applicationCode
        self.applicationDescription = applicationDescription
        self.applicationName = applicationName
        self.applicationStatus = applicationStatus
        self.applicationVersionId = applicationVersionId
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
        self.createTimestamp = createTimestamp
        self.inputDescriptions = inputDescriptions
        self.lastUpdateTimestamp = lastUpdateTimestamp
        self.outputDescriptions = outputDescriptions
        self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
    }
}

public enum ApplicationStatus {
    case deleting
    case ready
    case running
    case starting
    case stopping
    case updating
    case sdkUnknown(String)
}

extension ApplicationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplicationStatus] {
        return [
            .deleting,
            .ready,
            .running,
            .starting,
            .stopping,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .ready: return "READY"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopping: return "STOPPING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
    }
}

extension ApplicationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
    }
}

extension ApplicationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSummary(applicationARN: \(String(describing: applicationARN)), applicationName: \(String(describing: applicationName)), applicationStatus: \(String(describing: applicationStatus)))"}
}

/// <note>
///             <p>This documentation is for version 1 of the Amazon Kinesis Data Analytics API, which only supports SQL applications. Version 2 of the API supports SQL and Java applications. For more information about version 2, see <a href="/kinesisanalytics/latest/apiv2/Welcome.html">Amazon Kinesis Data Analytics API V2 Documentation</a>.</p>
///          </note>
///         <p>Provides application summary information, including the application Amazon Resource Name (ARN), name, and status.</p>
public struct ApplicationSummary: Equatable {
    /// <p>ARN of the application.</p>
    public let applicationARN: String?
    /// <p>Name of the application.</p>
    public let applicationName: String?
    /// <p>Status of the application.</p>
    public let applicationStatus: ApplicationStatus?

    public init (
        applicationARN: String? = nil,
        applicationName: String? = nil,
        applicationStatus: ApplicationStatus? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationName = applicationName
        self.applicationStatus = applicationStatus
    }
}

extension ApplicationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationCodeUpdate = "ApplicationCodeUpdate"
        case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
        case inputUpdates = "InputUpdates"
        case outputUpdates = "OutputUpdates"
        case referenceDataSourceUpdates = "ReferenceDataSourceUpdates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeUpdate = applicationCodeUpdate {
            try encodeContainer.encode(applicationCodeUpdate, forKey: .applicationCodeUpdate)
        }
        if let cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates {
            var cloudWatchLoggingOptionUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionUpdates)
            for cloudwatchloggingoptionupdates0 in cloudWatchLoggingOptionUpdates {
                try cloudWatchLoggingOptionUpdatesContainer.encode(cloudwatchloggingoptionupdates0)
            }
        }
        if let inputUpdates = inputUpdates {
            var inputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputUpdates)
            for inputupdates0 in inputUpdates {
                try inputUpdatesContainer.encode(inputupdates0)
            }
        }
        if let outputUpdates = outputUpdates {
            var outputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputUpdates)
            for outputupdates0 in outputUpdates {
                try outputUpdatesContainer.encode(outputupdates0)
            }
        }
        if let referenceDataSourceUpdates = referenceDataSourceUpdates {
            var referenceDataSourceUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceUpdates)
            for referencedatasourceupdates0 in referenceDataSourceUpdates {
                try referenceDataSourceUpdatesContainer.encode(referencedatasourceupdates0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputUpdatesContainer = try containerValues.decodeIfPresent([InputUpdate?].self, forKey: .inputUpdates)
        var inputUpdatesDecoded0:[InputUpdate]? = nil
        if let inputUpdatesContainer = inputUpdatesContainer {
            inputUpdatesDecoded0 = [InputUpdate]()
            for structure0 in inputUpdatesContainer {
                if let structure0 = structure0 {
                    inputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        inputUpdates = inputUpdatesDecoded0
        let applicationCodeUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationCodeUpdate)
        applicationCodeUpdate = applicationCodeUpdateDecoded
        let outputUpdatesContainer = try containerValues.decodeIfPresent([OutputUpdate?].self, forKey: .outputUpdates)
        var outputUpdatesDecoded0:[OutputUpdate]? = nil
        if let outputUpdatesContainer = outputUpdatesContainer {
            outputUpdatesDecoded0 = [OutputUpdate]()
            for structure0 in outputUpdatesContainer {
                if let structure0 = structure0 {
                    outputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        outputUpdates = outputUpdatesDecoded0
        let referenceDataSourceUpdatesContainer = try containerValues.decodeIfPresent([ReferenceDataSourceUpdate?].self, forKey: .referenceDataSourceUpdates)
        var referenceDataSourceUpdatesDecoded0:[ReferenceDataSourceUpdate]? = nil
        if let referenceDataSourceUpdatesContainer = referenceDataSourceUpdatesContainer {
            referenceDataSourceUpdatesDecoded0 = [ReferenceDataSourceUpdate]()
            for structure0 in referenceDataSourceUpdatesContainer {
                if let structure0 = structure0 {
                    referenceDataSourceUpdatesDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceUpdates = referenceDataSourceUpdatesDecoded0
        let cloudWatchLoggingOptionUpdatesContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOptionUpdate?].self, forKey: .cloudWatchLoggingOptionUpdates)
        var cloudWatchLoggingOptionUpdatesDecoded0:[CloudWatchLoggingOptionUpdate]? = nil
        if let cloudWatchLoggingOptionUpdatesContainer = cloudWatchLoggingOptionUpdatesContainer {
            cloudWatchLoggingOptionUpdatesDecoded0 = [CloudWatchLoggingOptionUpdate]()
            for structure0 in cloudWatchLoggingOptionUpdatesContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionUpdatesDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdatesDecoded0
    }
}

extension ApplicationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationUpdate(applicationCodeUpdate: \(String(describing: applicationCodeUpdate)), cloudWatchLoggingOptionUpdates: \(String(describing: cloudWatchLoggingOptionUpdates)), inputUpdates: \(String(describing: inputUpdates)), outputUpdates: \(String(describing: outputUpdates)), referenceDataSourceUpdates: \(String(describing: referenceDataSourceUpdates)))"}
}

/// <p>Describes updates to apply to an existing Amazon Kinesis Analytics application.</p>
public struct ApplicationUpdate: Equatable {
    /// <p>Describes application code updates.</p>
    public let applicationCodeUpdate: String?
    /// <p>Describes application CloudWatch logging option updates.</p>
    public let cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]?
    /// <p>Describes application input configuration updates.</p>
    public let inputUpdates: [InputUpdate]?
    /// <p>Describes application output configuration updates.</p>
    public let outputUpdates: [OutputUpdate]?
    /// <p>Describes application reference data source updates.</p>
    public let referenceDataSourceUpdates: [ReferenceDataSourceUpdate]?

    public init (
        applicationCodeUpdate: String? = nil,
        cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]? = nil,
        inputUpdates: [InputUpdate]? = nil,
        outputUpdates: [OutputUpdate]? = nil,
        referenceDataSourceUpdates: [ReferenceDataSourceUpdate]? = nil
    )
    {
        self.applicationCodeUpdate = applicationCodeUpdate
        self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
        self.inputUpdates = inputUpdates
        self.outputUpdates = outputUpdates
        self.referenceDataSourceUpdates = referenceDataSourceUpdates
    }
}

extension CSVMappingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordColumnDelimiter = "RecordColumnDelimiter"
        case recordRowDelimiter = "RecordRowDelimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnDelimiter = recordColumnDelimiter {
            try encodeContainer.encode(recordColumnDelimiter, forKey: .recordColumnDelimiter)
        }
        if let recordRowDelimiter = recordRowDelimiter {
            try encodeContainer.encode(recordRowDelimiter, forKey: .recordRowDelimiter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordRowDelimiter)
        recordRowDelimiter = recordRowDelimiterDecoded
        let recordColumnDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordColumnDelimiter)
        recordColumnDelimiter = recordColumnDelimiterDecoded
    }
}

extension CSVMappingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CSVMappingParameters(recordColumnDelimiter: \(String(describing: recordColumnDelimiter)), recordRowDelimiter: \(String(describing: recordRowDelimiter)))"}
}

/// <p>Provides additional mapping information when the record format
///             uses delimiters, such as CSV. For example, the following sample records
///             use CSV format, where the records use the <i>'\n'</i> as the row delimiter and a comma (",") as the column delimiter:
///         </p>
///
///         <p>
///             <code>"name1", "address1"</code>
///          </p>
///         <p>
///             <code>"name2", "address2"</code>
///          </p>
public struct CSVMappingParameters: Equatable {
    /// <p>Column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.</p>
    public let recordColumnDelimiter: String?
    /// <p>Row delimiter. For example, in a CSV format, <i>'\n'</i> is the typical row delimiter.</p>
    public let recordRowDelimiter: String?

    public init (
        recordColumnDelimiter: String? = nil,
        recordRowDelimiter: String? = nil
    )
    {
        self.recordColumnDelimiter = recordColumnDelimiter
        self.recordRowDelimiter = recordRowDelimiter
    }
}

extension CloudWatchLoggingOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logStreamARN = "LogStreamARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logStreamARN = logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logStreamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension CloudWatchLoggingOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLoggingOption(logStreamARN: \(String(describing: logStreamARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>Provides a description of CloudWatch logging options, including the log stream
///             Amazon Resource Name (ARN) and the role ARN.</p>
public struct CloudWatchLoggingOption: Equatable {
    /// <p>ARN of the CloudWatch log to receive application messages.</p>
    public let logStreamARN: String?
    /// <p>IAM ARN of the role to use to send application messages. Note: To write application
    ///             messages to CloudWatch, the IAM role that is used must have the
    ///             <code>PutLogEvents</code> policy action enabled.</p>
    public let roleARN: String?

    public init (
        logStreamARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.logStreamARN = logStreamARN
        self.roleARN = roleARN
    }
}

extension CloudWatchLoggingOptionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARN = "LogStreamARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARN = logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension CloudWatchLoggingOptionDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLoggingOptionDescription(cloudWatchLoggingOptionId: \(String(describing: cloudWatchLoggingOptionId)), logStreamARN: \(String(describing: logStreamARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>Description of the CloudWatch logging option.</p>
public struct CloudWatchLoggingOptionDescription: Equatable {
    /// <p>ID of the CloudWatch logging option description.</p>
    public let cloudWatchLoggingOptionId: String?
    /// <p>ARN of the CloudWatch log to receive application messages.</p>
    public let logStreamARN: String?
    /// <p>IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role used must have the <code>PutLogEvents</code> policy action enabled.</p>
    public let roleARN: String?

    public init (
        cloudWatchLoggingOptionId: String? = nil,
        logStreamARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.logStreamARN = logStreamARN
        self.roleARN = roleARN
    }
}

extension CloudWatchLoggingOptionUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARNUpdate = "LogStreamARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARNUpdate = logStreamARNUpdate {
            try encodeContainer.encode(logStreamARNUpdate, forKey: .logStreamARNUpdate)
        }
        if let roleARNUpdate = roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamARNUpdate)
        logStreamARNUpdate = logStreamARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension CloudWatchLoggingOptionUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLoggingOptionUpdate(cloudWatchLoggingOptionId: \(String(describing: cloudWatchLoggingOptionId)), logStreamARNUpdate: \(String(describing: logStreamARNUpdate)), roleARNUpdate: \(String(describing: roleARNUpdate)))"}
}

/// <p>Describes CloudWatch logging option updates.</p>
public struct CloudWatchLoggingOptionUpdate: Equatable {
    /// <p>ID of the CloudWatch logging option to update</p>
    public let cloudWatchLoggingOptionId: String?
    /// <p>ARN of the CloudWatch log to receive application messages.</p>
    public let logStreamARNUpdate: String?
    /// <p>IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role used must have the <code>PutLogEvents</code> policy action enabled.</p>
    public let roleARNUpdate: String?

    public init (
        cloudWatchLoggingOptionId: String? = nil,
        logStreamARNUpdate: String? = nil,
        roleARNUpdate: String? = nil
    )
    {
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.logStreamARNUpdate = logStreamARNUpdate
        self.roleARNUpdate = roleARNUpdate
    }
}

extension CodeValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeValidationException(message: \(String(describing: message)))"}
}

extension CodeValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CodeValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User-provided application code (query) is invalid. This can be a simple syntax error.</p>
public struct CodeValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Test</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CodeValidationExceptionBody: Equatable {
    public let message: String?
}

extension CodeValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception thrown as a result of concurrent modification to an application. For example, two individuals attempting to edit the same application at the same time.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(applicationCode: \(String(describing: applicationCode)), applicationDescription: \(String(describing: applicationDescription)), applicationName: \(String(describing: applicationName)), cloudWatchLoggingOptions: \(String(describing: cloudWatchLoggingOptions)), inputs: \(String(describing: inputs)), outputs: \(String(describing: outputs)), tags: \(String(describing: tags)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationCode = "ApplicationCode"
        case applicationDescription = "ApplicationDescription"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case inputs = "Inputs"
        case outputs = "Outputs"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCode = applicationCode {
            try encodeContainer.encode(applicationCode, forKey: .applicationCode)
        }
        if let applicationDescription = applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptions = cloudWatchLoggingOptions {
            var cloudWatchLoggingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptions)
            for cloudwatchloggingoptions0 in cloudWatchLoggingOptions {
                try cloudWatchLoggingOptionsContainer.encode(cloudwatchloggingoptions0)
            }
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for inputs0 in inputs {
                try inputsContainer.encode(inputs0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for outputs0 in outputs {
                try outputsContainer.encode(outputs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

/// <p>TBD</p>
public struct CreateApplicationInput: Equatable {
    /// <p>One or more SQL statements that read input data, transform it, and generate output.
    ///             For example, you can write a SQL statement that reads data from one in-application
    ///             stream, generates a running average of the number of advertisement clicks by vendor, and
    ///             insert resulting rows in another in-application stream using pumps. For more information
    ///             about the typical pattern, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-app-code.html">Application
    ///                 Code</a>. </p>
    ///
    ///         <p>You can provide such series of SQL statements,
    ///             where output of one statement can be
    ///             used as the input for the next statement. You store
    ///             intermediate results by creating in-application streams and pumps.</p>
    ///
    ///         <p>Note that the application code must create the streams with names
    ///             specified in the <code>Outputs</code>. For example,
    ///             if your <code>Outputs</code> defines output streams named
    ///             <code>ExampleOutputStream1</code> and <code>ExampleOutputStream2</code>,
    ///             then your application code must create these streams. </p>
    public let applicationCode: String?
    /// <p>Summary description of the application.</p>
    public let applicationDescription: String?
    /// <p>Name of your Amazon Kinesis Analytics application (for example, <code>sample-app</code>).</p>
    public let applicationName: String?
    /// <p>Use this parameter to configure a CloudWatch log stream to monitor application
    ///             configuration errors. For more information, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/cloudwatch-logs.html">Working with Amazon
    ///                 CloudWatch Logs</a>.</p>
    public let cloudWatchLoggingOptions: [CloudWatchLoggingOption]?
    /// <p>Use this parameter to configure the application input.</p>
    ///         <p>You can configure your application to receive input from a single streaming source. In this configuration, you map this streaming source to an in-application stream that is created. Your application code can then query the in-application stream like a table (you can think of it as a constantly updating table).</p>
    ///         <p>For the streaming source, you provide its Amazon Resource Name (ARN) and format of
    ///             data on the stream (for example, JSON, CSV, etc.). You also must provide an IAM role
    ///             that Amazon Kinesis Analytics can assume to read this stream on your behalf.</p>
    ///         <p>To create the in-application stream, you need to specify a schema to transform your data into a schematized version used in SQL. In the schema, you provide the necessary mapping of the data elements in the streaming source to record columns in the in-app stream.</p>
    public let inputs: [Input]?
    /// <p>You can configure application output to write data from any of the in-application streams to up to three destinations.</p>
    ///         <p>These destinations can be Amazon Kinesis streams, Amazon Kinesis Firehose delivery
    ///             streams, AWS Lambda destinations, or any combination of the three.</p>
    ///         <p>In the configuration, you specify the in-application stream name, the destination stream or Lambda function Amazon Resource Name (ARN), and the format to use when writing data. You must also provide an IAM role that Amazon Kinesis Analytics can assume to write to the
    ///             destination stream or Lambda function on your behalf.</p>
    ///         <p>In the output configuration, you also provide the output stream or Lambda function ARN. For stream destinations, you provide the format
    ///             of data in the stream (for example, JSON, CSV). You also must provide an IAM role that
    ///             Amazon Kinesis Analytics can assume to write to the stream or Lambda function on your behalf.</p>
    public let outputs: [Output]?
    /// <p>A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
    ///         For more information, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-tagging.html">Using Tagging</a>.</p>
    public let tags: [Tag]?

    public init (
        applicationCode: String? = nil,
        applicationDescription: String? = nil,
        applicationName: String? = nil,
        cloudWatchLoggingOptions: [CloudWatchLoggingOption]? = nil,
        inputs: [Input]? = nil,
        outputs: [Output]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.applicationCode = applicationCode
        self.applicationDescription = applicationDescription
        self.applicationName = applicationName
        self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
        self.inputs = inputs
        self.outputs = outputs
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Equatable {
    public let applicationName: String?
    public let applicationDescription: String?
    public let inputs: [Input]?
    public let outputs: [Output]?
    public let cloudWatchLoggingOptions: [CloudWatchLoggingOption]?
    public let applicationCode: String?
    public let tags: [Tag]?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationCode = "ApplicationCode"
        case applicationDescription = "ApplicationDescription"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case inputs = "Inputs"
        case outputs = "Outputs"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let inputsContainer = try containerValues.decodeIfPresent([Input?].self, forKey: .inputs)
        var inputsDecoded0:[Input]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [Input]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let cloudWatchLoggingOptionsContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOption?].self, forKey: .cloudWatchLoggingOptions)
        var cloudWatchLoggingOptionsDecoded0:[CloudWatchLoggingOption]? = nil
        if let cloudWatchLoggingOptionsContainer = cloudWatchLoggingOptionsContainer {
            cloudWatchLoggingOptionsDecoded0 = [CloudWatchLoggingOption]()
            for structure0 in cloudWatchLoggingOptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptions = cloudWatchLoggingOptionsDecoded0
        let applicationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationCode)
        applicationCode = applicationCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(applicationSummary: \(String(describing: applicationSummary)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationSummary = output.applicationSummary
        } else {
            self.applicationSummary = nil
        }
    }
}

/// <p>TBD</p>
public struct CreateApplicationOutputResponse: Equatable {
    /// <p>In response to your <code>CreateApplication</code> request, Amazon Kinesis Analytics returns a
    ///             response with a summary of the application it created, including the application Amazon Resource Name (ARN),
    ///             name, and status.</p>
    public let applicationSummary: ApplicationSummary?

    public init (
        applicationSummary: ApplicationSummary? = nil
    )
    {
        self.applicationSummary = applicationSummary
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let applicationSummary: ApplicationSummary?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSummary = "ApplicationSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummaryDecoded = try containerValues.decodeIfPresent(ApplicationSummary.self, forKey: .applicationSummary)
        applicationSummary = applicationSummaryDecoded
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationCloudWatchLoggingOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationCloudWatchLoggingOptionOutputError>
}

extension DeleteApplicationCloudWatchLoggingOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationCloudWatchLoggingOptionInput(applicationName: \(String(describing: applicationName)), cloudWatchLoggingOptionId: \(String(describing: cloudWatchLoggingOptionId)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)))"}
}

extension DeleteApplicationCloudWatchLoggingOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptionId = cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationCloudWatchLoggingOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationCloudWatchLoggingOptionOutputError>
}

public struct DeleteApplicationCloudWatchLoggingOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationCloudWatchLoggingOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationCloudWatchLoggingOptionOutputError>
}

public struct DeleteApplicationCloudWatchLoggingOptionInput: Equatable {
    /// <p>The Kinesis Analytics application name.</p>
    public let applicationName: String?
    /// <p>The <code>CloudWatchLoggingOptionId</code> of the CloudWatch logging option to
    ///             delete. You can get the <code>CloudWatchLoggingOptionId</code> by using the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation. </p>
    public let cloudWatchLoggingOptionId: String?
    /// <p>The version ID of the Kinesis Analytics application.</p>
    public let currentApplicationVersionId: Int?

    public init (
        applicationName: String? = nil,
        cloudWatchLoggingOptionId: String? = nil,
        currentApplicationVersionId: Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct DeleteApplicationCloudWatchLoggingOptionInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let cloudWatchLoggingOptionId: String?
}

extension DeleteApplicationCloudWatchLoggingOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationCloudWatchLoggingOptionOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationCloudWatchLoggingOptionOutputResponse()"}
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationCloudWatchLoggingOptionOutputResponseBody: Equatable {
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(applicationName: \(String(describing: applicationName)), createTimestamp: \(String(describing: createTimestamp)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

/// <p></p>
public struct DeleteApplicationInput: Equatable {
    /// <p>Name of the Amazon Kinesis Analytics application to delete.</p>
    public let applicationName: String?
    /// <p>
    ///             You can use the <code>DescribeApplication</code> operation to get this value.
    ///         </p>
    public let createTimestamp: Date?

    public init (
        applicationName: String? = nil,
        createTimestamp: Date? = nil
    )
    {
        self.applicationName = applicationName
        self.createTimestamp = createTimestamp
    }
}

struct DeleteApplicationInputBody: Equatable {
    public let applicationName: String?
    public let createTimestamp: Date?
}

extension DeleteApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
    }
}

public struct DeleteApplicationInputProcessingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputProcessingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationInputProcessingConfigurationOutputError>
}

extension DeleteApplicationInputProcessingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInputProcessingConfigurationInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), inputId: \(String(describing: inputId)))"}
}

extension DeleteApplicationInputProcessingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
    }
}

public struct DeleteApplicationInputProcessingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputProcessingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationInputProcessingConfigurationOutputError>
}

public struct DeleteApplicationInputProcessingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputProcessingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationInputProcessingConfigurationOutputError>
}

public struct DeleteApplicationInputProcessingConfigurationInput: Equatable {
    /// <p>The Kinesis Analytics application name.</p>
    public let applicationName: String?
    /// <p>The version ID of the Kinesis Analytics application.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the input configuration from which to delete the input processing
    ///             configuration. You can get a list of the input IDs for an application by using the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation.</p>
    public let inputId: String?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        inputId: String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
    }
}

struct DeleteApplicationInputProcessingConfigurationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let inputId: String?
}

extension DeleteApplicationInputProcessingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationInputProcessingConfigurationOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationInputProcessingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInputProcessingConfigurationOutputResponse()"}
}

extension DeleteApplicationInputProcessingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationInputProcessingConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationInputProcessingConfigurationOutputResponseBody: Equatable {
}

extension DeleteApplicationInputProcessingConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

public struct DeleteApplicationOutputInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationOutputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationOutputInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputOutputError>
}

extension DeleteApplicationOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), outputId: \(String(describing: outputId)))"}
}

extension DeleteApplicationOutputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let outputId = outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }
}

public struct DeleteApplicationOutputInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationOutputInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputOutputError>
}

public struct DeleteApplicationOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationOutputInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputOutputError>
}

/// <p></p>
public struct DeleteApplicationOutputInput: Equatable {
    /// <p>Amazon Kinesis Analytics application name.</p>
    public let applicationName: String?
    /// <p>Amazon Kinesis Analytics application version.
    ///             You can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get the current application version.
    ///             If the version specified is not the current version, the
    ///             <code>ConcurrentModificationException</code> is returned.
    ///         </p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the configuration to delete.
    ///             Each output configuration that is added to the application, either when the application is
    ///             created or later using the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationOutput.html">AddApplicationOutput</a> operation, has a unique ID.
    ///             You need to provide the ID to uniquely identify the output configuration that you want to
    ///             delete from the application configuration.
    ///             You can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get the specific
    ///             <code>OutputId</code>.
    ///         </p>
    public let outputId: String?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        outputId: String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.outputId = outputId
    }
}

struct DeleteApplicationOutputInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let outputId: String?
}

extension DeleteApplicationOutputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputId)
        outputId = outputIdDecoded
    }
}

extension DeleteApplicationOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputOutputResponse()"}
}

extension DeleteApplicationOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct DeleteApplicationOutputOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct DeleteApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteApplicationReferenceDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationReferenceDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationReferenceDataSourceOutputError>
}

extension DeleteApplicationReferenceDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationReferenceDataSourceInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), referenceId: \(String(describing: referenceId)))"}
}

extension DeleteApplicationReferenceDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }
}

public struct DeleteApplicationReferenceDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationReferenceDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationReferenceDataSourceOutputError>
}

public struct DeleteApplicationReferenceDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationReferenceDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationReferenceDataSourceOutputError>
}

public struct DeleteApplicationReferenceDataSourceInput: Equatable {
    /// <p>Name of an existing application.</p>
    public let applicationName: String?
    /// <p>Version of the application.
    ///             You can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get the current application version.
    ///             If the version specified
    ///             is not the current version, the <code>ConcurrentModificationException</code> is returned.</p>
    public let currentApplicationVersionId: Int?
    /// <p>ID of the reference data source. When you add a reference data source to your
    ///             application using the
    ///             <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationReferenceDataSource.html">AddApplicationReferenceDataSource</a>, Amazon Kinesis Analytics assigns an ID.
    ///             You can use the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get the reference ID.
    ///         </p>
    public let referenceId: String?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        referenceId: String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceId = referenceId
    }
}

struct DeleteApplicationReferenceDataSourceInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let referenceId: String?
}

extension DeleteApplicationReferenceDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension DeleteApplicationReferenceDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationReferenceDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationReferenceDataSourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationReferenceDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationReferenceDataSourceOutputResponse()"}
}

extension DeleteApplicationReferenceDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationReferenceDataSourceOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationReferenceDataSourceOutputResponseBody: Equatable {
}

extension DeleteApplicationReferenceDataSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

extension DescribeApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationInput(applicationName: \(String(describing: applicationName)))"}
}

extension DescribeApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
    }
}

public struct DescribeApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

public struct DescribeApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

/// <p></p>
public struct DescribeApplicationInput: Equatable {
    /// <p>Name of the application.</p>
    public let applicationName: String?

    public init (
        applicationName: String? = nil
    )
    {
        self.applicationName = applicationName
    }
}

struct DescribeApplicationInputBody: Equatable {
    public let applicationName: String?
}

extension DescribeApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
    }
}

extension DescribeApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationOutputResponse(applicationDetail: \(String(describing: applicationDetail)))"}
}

extension DescribeApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

/// <p></p>
public struct DescribeApplicationOutputResponse: Equatable {
    /// <p>Provides a description of the application, such as the application Amazon Resource Name (ARN), status, latest version, and input and output configuration details.</p>
    public let applicationDetail: ApplicationDetail?

    public init (
        applicationDetail: ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct DescribeApplicationOutputResponseBody: Equatable {
    public let applicationDetail: ApplicationDetail?
}

extension DescribeApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

extension DestinationSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordFormatType = recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
    }
}

extension DestinationSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationSchema(recordFormatType: \(String(describing: recordFormatType)))"}
}

/// <p>Describes the data format when records are written to the destination.
///             For more information,
///             see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html">Configuring Application Output</a>.
///
///
///         </p>
public struct DestinationSchema: Equatable {
    /// <p>Specifies the format of the records on the output stream.</p>
    public let recordFormatType: RecordFormatType?

    public init (
        recordFormatType: RecordFormatType? = nil
    )
    {
        self.recordFormatType = recordFormatType
    }
}

public struct DiscoverInputSchemaInputBodyMiddleware: Middleware {
    public let id: String = "DiscoverInputSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInputSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInputSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInputSchemaInput>
    public typealias MOutput = OperationOutput<DiscoverInputSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInputSchemaOutputError>
}

extension DiscoverInputSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscoverInputSchemaInput(inputProcessingConfiguration: \(String(describing: inputProcessingConfiguration)), inputStartingPositionConfiguration: \(String(describing: inputStartingPositionConfiguration)), resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)), s3Configuration: \(String(describing: s3Configuration)))"}
}

extension DiscoverInputSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
        case s3Configuration = "S3Configuration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputProcessingConfiguration = inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputStartingPositionConfiguration = inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let s3Configuration = s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }
}

public struct DiscoverInputSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DiscoverInputSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInputSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInputSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInputSchemaInput>
    public typealias MOutput = OperationOutput<DiscoverInputSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInputSchemaOutputError>
}

public struct DiscoverInputSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DiscoverInputSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInputSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInputSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInputSchemaInput>
    public typealias MOutput = OperationOutput<DiscoverInputSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInputSchemaOutputError>
}

public struct DiscoverInputSchemaInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html">InputProcessingConfiguration</a> to use to preprocess the records before discovering the schema of the records.</p>
    public let inputProcessingConfiguration: InputProcessingConfiguration?
    /// <p>Point at which you want Amazon Kinesis Analytics to start reading records from the specified streaming source discovery purposes.</p>
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
    /// <p>Amazon Resource Name (ARN) of the streaming source.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf.</p>
    public let roleARN: String?
    /// <p>Specify this parameter to discover a schema from data in an Amazon S3
    ///             object.</p>
    public let s3Configuration: S3Configuration?

    public init (
        inputProcessingConfiguration: InputProcessingConfiguration? = nil,
        inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil,
        resourceARN: String? = nil,
        roleARN: String? = nil,
        s3Configuration: S3Configuration? = nil
    )
    {
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.resourceARN = resourceARN
        self.roleARN = roleARN
        self.s3Configuration = s3Configuration
    }
}

struct DiscoverInputSchemaInputBody: Equatable {
    public let resourceARN: String?
    public let roleARN: String?
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
    public let s3Configuration: S3Configuration?
    public let inputProcessingConfiguration: InputProcessingConfiguration?
}

extension DiscoverInputSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
        case s3Configuration = "S3Configuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(S3Configuration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension DiscoverInputSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInputSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceProvisionedThroughputExceededException" : self = .resourceProvisionedThroughputExceededException(try ResourceProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnableToDetectSchemaException" : self = .unableToDetectSchemaException(try UnableToDetectSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DiscoverInputSchemaOutputError: Swift.Error, Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceProvisionedThroughputExceededException(ResourceProvisionedThroughputExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unableToDetectSchemaException(UnableToDetectSchemaException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInputSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscoverInputSchemaOutputResponse(inputSchema: \(String(describing: inputSchema)), parsedInputRecords: \(String(describing: parsedInputRecords)), processedInputRecords: \(String(describing: processedInputRecords)), rawInputRecords: \(String(describing: rawInputRecords)))"}
}

extension DiscoverInputSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DiscoverInputSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inputSchema = output.inputSchema
            self.parsedInputRecords = output.parsedInputRecords
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.inputSchema = nil
            self.parsedInputRecords = nil
            self.processedInputRecords = nil
            self.rawInputRecords = nil
        }
    }
}

/// <p></p>
public struct DiscoverInputSchemaOutputResponse: Equatable {
    /// <p>Schema inferred from the streaming source. It identifies the format of the data in the streaming source and how each data element maps to corresponding columns in the in-application stream that you can create.</p>
    public let inputSchema: SourceSchema?
    /// <p>An array of elements, where each element corresponds to a row in a stream record (a stream record can have more than one row).</p>
    public let parsedInputRecords: [[String]]?
    /// <p>Stream data that was modified by the processor specified in the <code>InputProcessingConfiguration</code> parameter.</p>
    public let processedInputRecords: [String]?
    /// <p>Raw stream data that was sampled to infer the schema.</p>
    public let rawInputRecords: [String]?

    public init (
        inputSchema: SourceSchema? = nil,
        parsedInputRecords: [[String]]? = nil,
        processedInputRecords: [String]? = nil,
        rawInputRecords: [String]? = nil
    )
    {
        self.inputSchema = inputSchema
        self.parsedInputRecords = parsedInputRecords
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct DiscoverInputSchemaOutputResponseBody: Equatable {
    public let inputSchema: SourceSchema?
    public let parsedInputRecords: [[String]]?
    public let processedInputRecords: [String]?
    public let rawInputRecords: [String]?
}

extension DiscoverInputSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputSchema = "InputSchema"
        case parsedInputRecords = "ParsedInputRecords"
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let parsedInputRecordsContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .parsedInputRecords)
        var parsedInputRecordsDecoded0:[[String]]? = nil
        if let parsedInputRecordsContainer = parsedInputRecordsContainer {
            parsedInputRecordsDecoded0 = [[String]]()
            for list0 in parsedInputRecordsContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parsedInputRecordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parsedInputRecords = parsedInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
    }
}

extension Input: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputParallelism = "InputParallelism"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputSchema = "InputSchema"
        case kinesisFirehoseInput = "KinesisFirehoseInput"
        case kinesisStreamsInput = "KinesisStreamsInput"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputParallelism = inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfiguration = inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputSchema = inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let kinesisFirehoseInput = kinesisFirehoseInput {
            try encodeContainer.encode(kinesisFirehoseInput, forKey: .kinesisFirehoseInput)
        }
        if let kinesisStreamsInput = kinesisStreamsInput {
            try encodeContainer.encode(kinesisStreamsInput, forKey: .kinesisStreamsInput)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
        let kinesisStreamsInputDecoded = try containerValues.decodeIfPresent(KinesisStreamsInput.self, forKey: .kinesisStreamsInput)
        kinesisStreamsInput = kinesisStreamsInputDecoded
        let kinesisFirehoseInputDecoded = try containerValues.decodeIfPresent(KinesisFirehoseInput.self, forKey: .kinesisFirehoseInput)
        kinesisFirehoseInput = kinesisFirehoseInputDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
    }
}

extension Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Input(inputParallelism: \(String(describing: inputParallelism)), inputProcessingConfiguration: \(String(describing: inputProcessingConfiguration)), inputSchema: \(String(describing: inputSchema)), kinesisFirehoseInput: \(String(describing: kinesisFirehoseInput)), kinesisStreamsInput: \(String(describing: kinesisStreamsInput)), namePrefix: \(String(describing: namePrefix)))"}
}

/// <p>When you configure the application input, you specify the streaming source,  the
///             in-application stream name that is created, and the mapping between the two.
///             For more information,
///             see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html">Configuring Application Input</a>. </p>
public struct Input: Equatable {
    /// <p>Describes the number of in-application streams to create. </p>
    ///          <p>Data from your source is routed to these in-application input streams.</p>
    ///         <p>    (see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html">Configuring Application Input</a>.</p>
    public let inputParallelism: InputParallelism?
    /// <p>The <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html">InputProcessingConfiguration</a> for the input. An input
    ///             processor transforms records as they are received from the stream, before the
    ///             application's SQL code executes. Currently, the only input processing configuration
    ///             available is <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html">InputLambdaProcessor</a>.</p>
    public let inputProcessingConfiguration: InputProcessingConfiguration?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.</p>
    ///         <p>Also used to describe the format of the reference data source.</p>
    public let inputSchema: SourceSchema?
    /// <p>If the streaming source is an Amazon Kinesis Firehose delivery stream, identifies
    ///             the delivery stream's ARN and an IAM role that enables Amazon Kinesis Analytics to
    ///             access the stream on your behalf.</p>
    ///         <p>Note: Either <code>KinesisStreamsInput</code> or <code>KinesisFirehoseInput</code> is required.</p>
    public let kinesisFirehoseInput: KinesisFirehoseInput?
    /// <p>If the streaming source is an Amazon Kinesis stream,
    ///             identifies the stream's Amazon Resource Name (ARN) and an IAM role
    ///             that enables Amazon Kinesis Analytics to access the stream on your behalf.</p>
    ///         <p>Note: Either <code>KinesisStreamsInput</code> or <code>KinesisFirehoseInput</code> is required.</p>
    public let kinesisStreamsInput: KinesisStreamsInput?
    /// <p>Name prefix to use when creating an in-application stream. Suppose that you specify
    ///             a prefix "MyInApplicationStream." Amazon Kinesis Analytics then creates one or more (as
    ///             per the <code>InputParallelism</code> count you specified) in-application streams with
    ///             names "MyInApplicationStream_001," "MyInApplicationStream_002," and so on. </p>
    public let namePrefix: String?

    public init (
        inputParallelism: InputParallelism? = nil,
        inputProcessingConfiguration: InputProcessingConfiguration? = nil,
        inputSchema: SourceSchema? = nil,
        kinesisFirehoseInput: KinesisFirehoseInput? = nil,
        kinesisStreamsInput: KinesisStreamsInput? = nil,
        namePrefix: String? = nil
    )
    {
        self.inputParallelism = inputParallelism
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputSchema = inputSchema
        self.kinesisFirehoseInput = kinesisFirehoseInput
        self.kinesisStreamsInput = kinesisStreamsInput
        self.namePrefix = namePrefix
    }
}

extension InputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputStartingPositionConfiguration = inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension InputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputConfiguration(id: \(String(describing: id)), inputStartingPositionConfiguration: \(String(describing: inputStartingPositionConfiguration)))"}
}

/// <p>When you start your application,
///             you provide this configuration, which identifies the input source and the point
///             in the input source at which you want the application to start processing records.</p>
public struct InputConfiguration: Equatable {
    /// <p>Input source ID. You can get this ID by calling
    ///             the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation.</p>
    public let id: String?
    /// <p>Point at which you want the application to start processing
    ///             records from the streaming source.</p>
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?

    public init (
        id: String? = nil,
        inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil
    )
    {
        self.id = id
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
    }
}

extension InputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inAppStreamNames = "InAppStreamNames"
        case inputId = "InputId"
        case inputParallelism = "InputParallelism"
        case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
        case inputSchema = "InputSchema"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case kinesisFirehoseInputDescription = "KinesisFirehoseInputDescription"
        case kinesisStreamsInputDescription = "KinesisStreamsInputDescription"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inAppStreamNames = inAppStreamNames {
            var inAppStreamNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inAppStreamNames)
            for inappstreamnames0 in inAppStreamNames {
                try inAppStreamNamesContainer.encode(inappstreamnames0)
            }
        }
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelism = inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfigurationDescription = inputProcessingConfigurationDescription {
            try encodeContainer.encode(inputProcessingConfigurationDescription, forKey: .inputProcessingConfigurationDescription)
        }
        if let inputSchema = inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let inputStartingPositionConfiguration = inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let kinesisFirehoseInputDescription = kinesisFirehoseInputDescription {
            try encodeContainer.encode(kinesisFirehoseInputDescription, forKey: .kinesisFirehoseInputDescription)
        }
        if let kinesisStreamsInputDescription = kinesisStreamsInputDescription {
            try encodeContainer.encode(kinesisStreamsInputDescription, forKey: .kinesisStreamsInputDescription)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inAppStreamNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inAppStreamNames)
        var inAppStreamNamesDecoded0:[String]? = nil
        if let inAppStreamNamesContainer = inAppStreamNamesContainer {
            inAppStreamNamesDecoded0 = [String]()
            for string0 in inAppStreamNamesContainer {
                if let string0 = string0 {
                    inAppStreamNamesDecoded0?.append(string0)
                }
            }
        }
        inAppStreamNames = inAppStreamNamesDecoded0
        let inputProcessingConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(InputProcessingConfigurationDescription.self, forKey: .inputProcessingConfigurationDescription)
        inputProcessingConfigurationDescription = inputProcessingConfigurationDescriptionDecoded
        let kinesisStreamsInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisStreamsInputDescription.self, forKey: .kinesisStreamsInputDescription)
        kinesisStreamsInputDescription = kinesisStreamsInputDescriptionDecoded
        let kinesisFirehoseInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisFirehoseInputDescription.self, forKey: .kinesisFirehoseInputDescription)
        kinesisFirehoseInputDescription = kinesisFirehoseInputDescriptionDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension InputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputDescription(inAppStreamNames: \(String(describing: inAppStreamNames)), inputId: \(String(describing: inputId)), inputParallelism: \(String(describing: inputParallelism)), inputProcessingConfigurationDescription: \(String(describing: inputProcessingConfigurationDescription)), inputSchema: \(String(describing: inputSchema)), inputStartingPositionConfiguration: \(String(describing: inputStartingPositionConfiguration)), kinesisFirehoseInputDescription: \(String(describing: kinesisFirehoseInputDescription)), kinesisStreamsInputDescription: \(String(describing: kinesisStreamsInputDescription)), namePrefix: \(String(describing: namePrefix)))"}
}

/// <p>Describes the application input configuration.
///             For more information,
///             see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html">Configuring Application Input</a>.
///         </p>
public struct InputDescription: Equatable {
    /// <p>Returns the in-application stream names that are mapped to the
    ///             stream source.</p>
    public let inAppStreamNames: [String]?
    /// <p>Input ID associated with the application input.
    ///             This is the ID that Amazon Kinesis Analytics assigns to each
    ///             input configuration you add to your application. </p>
    public let inputId: String?
    /// <p>Describes the configured parallelism (number of in-application streams
    ///             mapped to the streaming source).</p>
    public let inputParallelism: InputParallelism?
    /// <p>The description of the preprocessor that executes on records in this input before the application's code is run.</p>
    public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding
    ///             columns in the in-application stream that is being created. </p>
    public let inputSchema: SourceSchema?
    /// <p>Point at which the application is configured to read from the input stream.</p>
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
    /// <p>If an Amazon Kinesis Firehose delivery stream is configured as a streaming source,
    ///             provides the delivery stream's ARN and an IAM role that enables Amazon Kinesis Analytics
    ///             to access the stream on your behalf.</p>
    public let kinesisFirehoseInputDescription: KinesisFirehoseInputDescription?
    /// <p>If an Amazon Kinesis stream is configured as streaming source, provides Amazon
    ///             Kinesis stream's Amazon Resource Name (ARN) and an IAM role that enables Amazon Kinesis
    ///             Analytics to access the stream on your behalf.</p>
    public let kinesisStreamsInputDescription: KinesisStreamsInputDescription?
    /// <p>In-application name prefix.</p>
    public let namePrefix: String?

    public init (
        inAppStreamNames: [String]? = nil,
        inputId: String? = nil,
        inputParallelism: InputParallelism? = nil,
        inputProcessingConfigurationDescription: InputProcessingConfigurationDescription? = nil,
        inputSchema: SourceSchema? = nil,
        inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil,
        kinesisFirehoseInputDescription: KinesisFirehoseInputDescription? = nil,
        kinesisStreamsInputDescription: KinesisStreamsInputDescription? = nil,
        namePrefix: String? = nil
    )
    {
        self.inAppStreamNames = inAppStreamNames
        self.inputId = inputId
        self.inputParallelism = inputParallelism
        self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
        self.inputSchema = inputSchema
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
        self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
        self.namePrefix = namePrefix
    }
}

extension InputLambdaProcessor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension InputLambdaProcessor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputLambdaProcessor(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>An object that contains the Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a> function that
///             is used to preprocess records in the stream, and the ARN of the IAM role that is used to
///             access the AWS Lambda function. </p>
public struct InputLambdaProcessor: Equatable {
    /// <p>The ARN of the <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a> function that operates
    ///             on records in the stream.</p>
    ///             <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that is used to access the AWS Lambda function.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension InputLambdaProcessorDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension InputLambdaProcessorDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputLambdaProcessorDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>An object that contains the Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a> function that
///             is used to preprocess records in the stream, and the ARN of the IAM role that is  used
///             to access the AWS Lambda expression.</p>
public struct InputLambdaProcessorDescription: Equatable {
    /// <p>The ARN of the <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a> function that is used to preprocess the records in the stream.</p>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that is used to access the AWS Lambda function.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension InputLambdaProcessorUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension InputLambdaProcessorUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputLambdaProcessorUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)), roleARNUpdate: \(String(describing: roleARNUpdate)))"}
}

/// <p>Represents an update to the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html">InputLambdaProcessor</a> that is used to preprocess the records in the stream.</p>
public struct InputLambdaProcessorUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the new <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a> function that
    ///             is used to preprocess the records in the stream.</p>
    ///         <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARNUpdate: String?
    /// <p>The ARN of the new IAM role that is used to access the AWS Lambda
    ///             function.</p>
    public let roleARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil,
        roleARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
        self.roleARNUpdate = roleARNUpdate
    }
}

extension InputParallelism: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension InputParallelism: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputParallelism(count: \(String(describing: count)))"}
}

/// <p>Describes the number of in-application streams to create for a given
///             streaming source. For information about parallelism,
///             see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html">Configuring Application Input</a>.
///         </p>
public struct InputParallelism: Equatable {
    /// <p>Number of in-application streams to create.
    ///             For more information, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/limits.html">Limits</a>.
    ///         </p>
    public let count: Int?

    public init (
        count: Int? = nil
    )
    {
        self.count = count
    }
}

extension InputParallelismUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countUpdate = "CountUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countUpdate = countUpdate {
            try encodeContainer.encode(countUpdate, forKey: .countUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countUpdateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countUpdate)
        countUpdate = countUpdateDecoded
    }
}

extension InputParallelismUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputParallelismUpdate(countUpdate: \(String(describing: countUpdate)))"}
}

/// <p>Provides updates to the parallelism count.</p>
public struct InputParallelismUpdate: Equatable {
    /// <p>Number of in-application streams to create for the specified
    ///             streaming source.</p>
    public let countUpdate: Int?

    public init (
        countUpdate: Int? = nil
    )
    {
        self.countUpdate = countUpdate
    }
}

extension InputProcessingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputLambdaProcessor = "InputLambdaProcessor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessor = inputLambdaProcessor {
            try encodeContainer.encode(inputLambdaProcessor, forKey: .inputLambdaProcessor)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDecoded = try containerValues.decodeIfPresent(InputLambdaProcessor.self, forKey: .inputLambdaProcessor)
        inputLambdaProcessor = inputLambdaProcessorDecoded
    }
}

extension InputProcessingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputProcessingConfiguration(inputLambdaProcessor: \(String(describing: inputLambdaProcessor)))"}
}

/// <p>Provides a description of a processor that is used to preprocess the records in the
///             stream before being processed by your application code. Currently, the only input
///             processor available is <a href="https://docs.aws.amazon.com/lambda/">AWS
///                 Lambda</a>.</p>
public struct InputProcessingConfiguration: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html">InputLambdaProcessor</a> that is used to preprocess the records
    ///             in the stream before being processed by your application code.</p>
    public let inputLambdaProcessor: InputLambdaProcessor?

    public init (
        inputLambdaProcessor: InputLambdaProcessor? = nil
    )
    {
        self.inputLambdaProcessor = inputLambdaProcessor
    }
}

extension InputProcessingConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputLambdaProcessorDescription = "InputLambdaProcessorDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorDescription = inputLambdaProcessorDescription {
            try encodeContainer.encode(inputLambdaProcessorDescription, forKey: .inputLambdaProcessorDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDescriptionDecoded = try containerValues.decodeIfPresent(InputLambdaProcessorDescription.self, forKey: .inputLambdaProcessorDescription)
        inputLambdaProcessorDescription = inputLambdaProcessorDescriptionDecoded
    }
}

extension InputProcessingConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputProcessingConfigurationDescription(inputLambdaProcessorDescription: \(String(describing: inputLambdaProcessorDescription)))"}
}

/// <p>Provides configuration information about an input processor. Currently, the only input processor available is
///             <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a>.</p>
public struct InputProcessingConfigurationDescription: Equatable {
    /// <p>Provides configuration information about the associated <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessorDescription.html">InputLambdaProcessorDescription</a>.</p>
    public let inputLambdaProcessorDescription: InputLambdaProcessorDescription?

    public init (
        inputLambdaProcessorDescription: InputLambdaProcessorDescription? = nil
    )
    {
        self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
    }
}

extension InputProcessingConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputLambdaProcessorUpdate = "InputLambdaProcessorUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorUpdate = inputLambdaProcessorUpdate {
            try encodeContainer.encode(inputLambdaProcessorUpdate, forKey: .inputLambdaProcessorUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorUpdateDecoded = try containerValues.decodeIfPresent(InputLambdaProcessorUpdate.self, forKey: .inputLambdaProcessorUpdate)
        inputLambdaProcessorUpdate = inputLambdaProcessorUpdateDecoded
    }
}

extension InputProcessingConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputProcessingConfigurationUpdate(inputLambdaProcessorUpdate: \(String(describing: inputLambdaProcessorUpdate)))"}
}

/// <p>Describes updates to an <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html">InputProcessingConfiguration</a>. </p>
public struct InputProcessingConfigurationUpdate: Equatable {
    /// <p>Provides update information for an <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html">InputLambdaProcessor</a>.</p>
    public let inputLambdaProcessorUpdate: InputLambdaProcessorUpdate?

    public init (
        inputLambdaProcessorUpdate: InputLambdaProcessorUpdate? = nil
    )
    {
        self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
    }
}

extension InputSchemaUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordColumnUpdates = "RecordColumnUpdates"
        case recordEncodingUpdate = "RecordEncodingUpdate"
        case recordFormatUpdate = "RecordFormatUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnUpdates = recordColumnUpdates {
            var recordColumnUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumnUpdates)
            for recordcolumns0 in recordColumnUpdates {
                try recordColumnUpdatesContainer.encode(recordcolumns0)
            }
        }
        if let recordEncodingUpdate = recordEncodingUpdate {
            try encodeContainer.encode(recordEncodingUpdate, forKey: .recordEncodingUpdate)
        }
        if let recordFormatUpdate = recordFormatUpdate {
            try encodeContainer.encode(recordFormatUpdate, forKey: .recordFormatUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatUpdateDecoded = try containerValues.decodeIfPresent(RecordFormat.self, forKey: .recordFormatUpdate)
        recordFormatUpdate = recordFormatUpdateDecoded
        let recordEncodingUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordEncodingUpdate)
        recordEncodingUpdate = recordEncodingUpdateDecoded
        let recordColumnUpdatesContainer = try containerValues.decodeIfPresent([RecordColumn?].self, forKey: .recordColumnUpdates)
        var recordColumnUpdatesDecoded0:[RecordColumn]? = nil
        if let recordColumnUpdatesContainer = recordColumnUpdatesContainer {
            recordColumnUpdatesDecoded0 = [RecordColumn]()
            for structure0 in recordColumnUpdatesContainer {
                if let structure0 = structure0 {
                    recordColumnUpdatesDecoded0?.append(structure0)
                }
            }
        }
        recordColumnUpdates = recordColumnUpdatesDecoded0
    }
}

extension InputSchemaUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputSchemaUpdate(recordColumnUpdates: \(String(describing: recordColumnUpdates)), recordEncodingUpdate: \(String(describing: recordEncodingUpdate)), recordFormatUpdate: \(String(describing: recordFormatUpdate)))"}
}

/// <p>Describes updates for the application's input schema.</p>
public struct InputSchemaUpdate: Equatable {
    /// <p>A list of <code>RecordColumn</code> objects. Each object describes the mapping
    ///             of the streaming source element to the corresponding column in the in-application stream. </p>
    public let recordColumnUpdates: [RecordColumn]?
    /// <p>Specifies the encoding of the records in the streaming source. For example, UTF-8.</p>
    public let recordEncodingUpdate: String?
    /// <p>Specifies the format of the records on the streaming source.</p>
    public let recordFormatUpdate: RecordFormat?

    public init (
        recordColumnUpdates: [RecordColumn]? = nil,
        recordEncodingUpdate: String? = nil,
        recordFormatUpdate: RecordFormat? = nil
    )
    {
        self.recordColumnUpdates = recordColumnUpdates
        self.recordEncodingUpdate = recordEncodingUpdate
        self.recordFormatUpdate = recordFormatUpdate
    }
}

public enum InputStartingPosition {
    case lastStoppedPoint
    case now
    case trimHorizon
    case sdkUnknown(String)
}

extension InputStartingPosition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InputStartingPosition] {
        return [
            .lastStoppedPoint,
            .now,
            .trimHorizon,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastStoppedPoint: return "LAST_STOPPED_POINT"
        case .now: return "NOW"
        case .trimHorizon: return "TRIM_HORIZON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InputStartingPosition(rawValue: rawValue) ?? InputStartingPosition.sdkUnknown(rawValue)
    }
}

extension InputStartingPositionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputStartingPosition = "InputStartingPosition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStartingPosition = inputStartingPosition {
            try encodeContainer.encode(inputStartingPosition.rawValue, forKey: .inputStartingPosition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStartingPositionDecoded = try containerValues.decodeIfPresent(InputStartingPosition.self, forKey: .inputStartingPosition)
        inputStartingPosition = inputStartingPositionDecoded
    }
}

extension InputStartingPositionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputStartingPositionConfiguration(inputStartingPosition: \(String(describing: inputStartingPosition)))"}
}

/// <p>Describes the point at which the application reads from
///             the streaming source.</p>
public struct InputStartingPositionConfiguration: Equatable {
    /// <p>The starting position on the stream.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>NOW</code> - Start reading just after the most recent record in the
    ///                     stream, start at the request time stamp that the customer issued.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TRIM_HORIZON</code> - Start reading at the last untrimmed record in the stream,
    ///                     which is the oldest record available in the stream. This option is not available
    ///                     for an Amazon Kinesis Firehose delivery stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LAST_STOPPED_POINT</code> - Resume reading from where the application last stopped reading.</p>
    ///             </li>
    ///          </ul>
    public let inputStartingPosition: InputStartingPosition?

    public init (
        inputStartingPosition: InputStartingPosition? = nil
    )
    {
        self.inputStartingPosition = inputStartingPosition
    }
}

extension InputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputId = "InputId"
        case inputParallelismUpdate = "InputParallelismUpdate"
        case inputProcessingConfigurationUpdate = "InputProcessingConfigurationUpdate"
        case inputSchemaUpdate = "InputSchemaUpdate"
        case kinesisFirehoseInputUpdate = "KinesisFirehoseInputUpdate"
        case kinesisStreamsInputUpdate = "KinesisStreamsInputUpdate"
        case namePrefixUpdate = "NamePrefixUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelismUpdate = inputParallelismUpdate {
            try encodeContainer.encode(inputParallelismUpdate, forKey: .inputParallelismUpdate)
        }
        if let inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate {
            try encodeContainer.encode(inputProcessingConfigurationUpdate, forKey: .inputProcessingConfigurationUpdate)
        }
        if let inputSchemaUpdate = inputSchemaUpdate {
            try encodeContainer.encode(inputSchemaUpdate, forKey: .inputSchemaUpdate)
        }
        if let kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate {
            try encodeContainer.encode(kinesisFirehoseInputUpdate, forKey: .kinesisFirehoseInputUpdate)
        }
        if let kinesisStreamsInputUpdate = kinesisStreamsInputUpdate {
            try encodeContainer.encode(kinesisStreamsInputUpdate, forKey: .kinesisStreamsInputUpdate)
        }
        if let namePrefixUpdate = namePrefixUpdate {
            try encodeContainer.encode(namePrefixUpdate, forKey: .namePrefixUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefixUpdate)
        namePrefixUpdate = namePrefixUpdateDecoded
        let inputProcessingConfigurationUpdateDecoded = try containerValues.decodeIfPresent(InputProcessingConfigurationUpdate.self, forKey: .inputProcessingConfigurationUpdate)
        inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdateDecoded
        let kinesisStreamsInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisStreamsInputUpdate.self, forKey: .kinesisStreamsInputUpdate)
        kinesisStreamsInputUpdate = kinesisStreamsInputUpdateDecoded
        let kinesisFirehoseInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisFirehoseInputUpdate.self, forKey: .kinesisFirehoseInputUpdate)
        kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdateDecoded
        let inputSchemaUpdateDecoded = try containerValues.decodeIfPresent(InputSchemaUpdate.self, forKey: .inputSchemaUpdate)
        inputSchemaUpdate = inputSchemaUpdateDecoded
        let inputParallelismUpdateDecoded = try containerValues.decodeIfPresent(InputParallelismUpdate.self, forKey: .inputParallelismUpdate)
        inputParallelismUpdate = inputParallelismUpdateDecoded
    }
}

extension InputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputUpdate(inputId: \(String(describing: inputId)), inputParallelismUpdate: \(String(describing: inputParallelismUpdate)), inputProcessingConfigurationUpdate: \(String(describing: inputProcessingConfigurationUpdate)), inputSchemaUpdate: \(String(describing: inputSchemaUpdate)), kinesisFirehoseInputUpdate: \(String(describing: kinesisFirehoseInputUpdate)), kinesisStreamsInputUpdate: \(String(describing: kinesisStreamsInputUpdate)), namePrefixUpdate: \(String(describing: namePrefixUpdate)))"}
}

/// <p>Describes updates to a specific input configuration (identified by the
///             <code>InputId</code> of an application). </p>
public struct InputUpdate: Equatable {
    /// <p>Input ID of the application input to be updated.</p>
    public let inputId: String?
    /// <p>Describes the parallelism updates (the number in-application
    ///             streams Amazon Kinesis Analytics creates for the specific streaming source).</p>
    public let inputParallelismUpdate: InputParallelismUpdate?
    /// <p>Describes updates for an input processing configuration.</p>
    public let inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate?
    /// <p>Describes the data format on the streaming source, and
    ///             how record elements on the streaming source map to columns of the in-application stream that is created.</p>
    public let inputSchemaUpdate: InputSchemaUpdate?
    /// <p>If an Amazon Kinesis Firehose delivery stream is the streaming source to be
    ///             updated, provides an updated stream ARN and IAM role ARN.</p>
    public let kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate?
    /// <p>If an Amazon Kinesis stream is the streaming source to be updated, provides an
    ///             updated stream Amazon Resource Name (ARN) and IAM role ARN.</p>
    public let kinesisStreamsInputUpdate: KinesisStreamsInputUpdate?
    /// <p>Name prefix for in-application streams that Amazon Kinesis Analytics creates
    ///             for the specific streaming source.</p>
    public let namePrefixUpdate: String?

    public init (
        inputId: String? = nil,
        inputParallelismUpdate: InputParallelismUpdate? = nil,
        inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate? = nil,
        inputSchemaUpdate: InputSchemaUpdate? = nil,
        kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate? = nil,
        kinesisStreamsInputUpdate: KinesisStreamsInputUpdate? = nil,
        namePrefixUpdate: String? = nil
    )
    {
        self.inputId = inputId
        self.inputParallelismUpdate = inputParallelismUpdate
        self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
        self.inputSchemaUpdate = inputSchemaUpdate
        self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
        self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
        self.namePrefixUpdate = namePrefixUpdate
    }
}

extension InvalidApplicationConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApplicationConfigurationException(message: \(String(describing: message)))"}
}

extension InvalidApplicationConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApplicationConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User-provided application configuration is not valid.</p>
public struct InvalidApplicationConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>test</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApplicationConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApplicationConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified input parameter value is invalid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JSONMappingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordRowPath = "RecordRowPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordRowPath = recordRowPath {
            try encodeContainer.encode(recordRowPath, forKey: .recordRowPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordRowPath)
        recordRowPath = recordRowPathDecoded
    }
}

extension JSONMappingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JSONMappingParameters(recordRowPath: \(String(describing: recordRowPath)))"}
}

/// <p>Provides additional mapping information when JSON is the record format on the streaming source.</p>
public struct JSONMappingParameters: Equatable {
    /// <p>Path to the top-level parent that contains the records.</p>
    public let recordRowPath: String?

    public init (
        recordRowPath: String? = nil
    )
    {
        self.recordRowPath = recordRowPath
    }
}

extension KinesisFirehoseInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisFirehoseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseInput(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p> Identifies an Amazon Kinesis Firehose delivery stream as the streaming source. You
///             provide the delivery stream's Amazon Resource Name (ARN) and an IAM role ARN that
///             enables Amazon Kinesis Analytics to access the stream on your behalf.</p>
public struct KinesisFirehoseInput: Equatable {
    /// <p>ARN of the input delivery stream.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream
    ///             on your behalf. You need to make sure that the role has the necessary permissions to
    ///             access the stream.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisFirehoseInputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisFirehoseInputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseInputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>
///             Describes the Amazon Kinesis Firehose delivery stream that is configured as the streaming source
///             in the application input configuration.
///         </p>
public struct KinesisFirehoseInputDescription: Equatable {
    /// <p>Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics assumes to access the stream.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisFirehoseInputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisFirehoseInputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseInputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)), roleARNUpdate: \(String(describing: roleARNUpdate)))"}
}

/// <p>When updating application input configuration, provides information about an
///             Amazon Kinesis Firehose delivery stream as the streaming source.</p>
public struct KinesisFirehoseInputUpdate: Equatable {
    /// <p>Amazon Resource Name (ARN) of the input Amazon Kinesis Firehose delivery stream to
    ///             read.</p>
    public let resourceARNUpdate: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream
    ///             on your behalf. You need to grant the necessary permissions to this role.</p>
    public let roleARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil,
        roleARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
        self.roleARNUpdate = roleARNUpdate
    }
}

extension KinesisFirehoseOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisFirehoseOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseOutput(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>When configuring application output,
///             identifies an Amazon Kinesis Firehose delivery stream as the destination.
///             You provide the stream Amazon Resource Name (ARN) and an IAM role
///             that enables Amazon Kinesis Analytics to write to the stream on your behalf.</p>
public struct KinesisFirehoseOutput: Equatable {
    /// <p>ARN of the destination Amazon Kinesis Firehose delivery stream to write to.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination stream on your behalf. You need to grant the necessary permissions to this role.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisFirehoseOutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisFirehoseOutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseOutputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>
///             For an application output, describes
///             the Amazon Kinesis Firehose delivery stream configured as its destination.
///         </p>
public struct KinesisFirehoseOutputDescription: Equatable {
    /// <p>Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisFirehoseOutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisFirehoseOutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseOutputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)), roleARNUpdate: \(String(describing: roleARNUpdate)))"}
}

/// <p>
///             When updating an output configuration using the
///             <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html">UpdateApplication</a> operation,
///             provides information about an Amazon Kinesis Firehose delivery stream configured as
///             the destination.
///         </p>
public struct KinesisFirehoseOutputUpdate: Equatable {
    /// <p>Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream to write to.</p>
    public let resourceARNUpdate: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream
    ///             on your behalf. You need to grant the necessary permissions to this role.</p>
    public let roleARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil,
        roleARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
        self.roleARNUpdate = roleARNUpdate
    }
}

extension KinesisStreamsInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsInput(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p> Identifies an Amazon Kinesis stream as the streaming source. You provide the
///             stream's Amazon Resource Name (ARN) and an IAM role ARN that enables Amazon Kinesis
///             Analytics to access the stream on your behalf.</p>
public struct KinesisStreamsInput: Equatable {
    /// <p>ARN of the input Amazon Kinesis stream to read.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisStreamsInputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisStreamsInputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsInputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>
///             Describes the Amazon Kinesis stream that is configured as the streaming source
///             in the application input configuration.
///           </p>
public struct KinesisStreamsInputDescription: Equatable {
    /// <p>Amazon Resource Name (ARN) of the Amazon Kinesis stream.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisStreamsInputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisStreamsInputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsInputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)), roleARNUpdate: \(String(describing: roleARNUpdate)))"}
}

/// <p>When updating application input configuration, provides information about an
///             Amazon Kinesis stream as the streaming source.</p>
public struct KinesisStreamsInputUpdate: Equatable {
    /// <p>Amazon Resource Name (ARN) of the input Amazon Kinesis stream to read.</p>
    public let resourceARNUpdate: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.</p>
    public let roleARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil,
        roleARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
        self.roleARNUpdate = roleARNUpdate
    }
}

extension KinesisStreamsOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisStreamsOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsOutput(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>When configuring application output, identifies an Amazon Kinesis stream as the
///             destination. You provide the stream Amazon Resource Name (ARN) and also an IAM role ARN
///             that Amazon Kinesis Analytics can use to write to the stream on your behalf.</p>
public struct KinesisStreamsOutput: Equatable {
    /// <p>ARN of the destination Amazon Kinesis stream to write to.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination stream on your behalf. You need to grant the necessary permissions to this role.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisStreamsOutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisStreamsOutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsOutputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>
///             For an application output, describes
///             the Amazon Kinesis stream configured as its destination.
///         </p>
public struct KinesisStreamsOutputDescription: Equatable {
    /// <p>Amazon Resource Name (ARN) of the Amazon Kinesis stream.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisStreamsOutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisStreamsOutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsOutputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)), roleARNUpdate: \(String(describing: roleARNUpdate)))"}
}

/// <p>
///             When updating an output configuration using the
///             <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html">UpdateApplication</a>  operation,
///             provides information about an Amazon Kinesis stream configured as
///             the destination.
///         </p>
public struct KinesisStreamsOutputUpdate: Equatable {
    /// <p>Amazon Resource Name (ARN) of the Amazon Kinesis stream where you want to write the output.</p>
    public let resourceARNUpdate: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.</p>
    public let roleARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil,
        roleARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
        self.roleARNUpdate = roleARNUpdate
    }
}

extension LambdaOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension LambdaOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaOutput(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>When configuring application output, identifies an AWS Lambda function as the
///             destination. You provide the function Amazon Resource Name (ARN) and also an IAM role
///             ARN that Amazon Kinesis Analytics can use to write to the function on your behalf. </p>
public struct LambdaOutput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the destination Lambda function to write
    ///             to.</p>
    ///         <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function on your behalf. You need to grant the necessary permissions to this role. </p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension LambdaOutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension LambdaOutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaOutputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>For an application output, describes the AWS Lambda function configured as its
///             destination. </p>
public struct LambdaOutputDescription: Equatable {
    /// <p>Amazon Resource Name (ARN) of the destination Lambda function.</p>
    public let resourceARN: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function.</p>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension LambdaOutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension LambdaOutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaOutputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)), roleARNUpdate: \(String(describing: roleARNUpdate)))"}
}

/// <p>When updating an output configuration using the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html">UpdateApplication</a>
///             operation, provides information about an AWS Lambda function configured as the
///             destination.</p>
public struct LambdaOutputUpdate: Equatable {
    /// <p>Amazon Resource Name (ARN) of the destination Lambda function.</p>
    ///         <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARNUpdate: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function on your behalf. You need to grant the necessary permissions to this role. </p>
    public let roleARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil,
        roleARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
        self.roleARNUpdate = roleARNUpdate
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exceeded the number of applications allowed.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "ListApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

extension ListApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsInput(exclusiveStartApplicationName: \(String(describing: exclusiveStartApplicationName)), limit: \(String(describing: limit)))"}
}

extension ListApplicationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartApplicationName = "ExclusiveStartApplicationName"
        case limit = "Limit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartApplicationName = exclusiveStartApplicationName {
            try encodeContainer.encode(exclusiveStartApplicationName, forKey: .exclusiveStartApplicationName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }
}

public struct ListApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

/// <p></p>
public struct ListApplicationsInput: Equatable {
    /// <p>Name of the application to start the list with. When using pagination to retrieve the list, you don't need to specify this parameter in the first request. However, in subsequent requests, you add the last application name from the previous response to get the next page of applications.</p>
    public let exclusiveStartApplicationName: String?
    /// <p>Maximum number of applications to list.</p>
    public let limit: Int?

    public init (
        exclusiveStartApplicationName: String? = nil,
        limit: Int? = nil
    )
    {
        self.exclusiveStartApplicationName = exclusiveStartApplicationName
        self.limit = limit
    }
}

struct ListApplicationsInputBody: Equatable {
    public let limit: Int?
    public let exclusiveStartApplicationName: String?
}

extension ListApplicationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartApplicationName = "ExclusiveStartApplicationName"
        case limit = "Limit"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartApplicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exclusiveStartApplicationName)
        exclusiveStartApplicationName = exclusiveStartApplicationNameDecoded
    }
}

extension ListApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsOutputResponse(applicationSummaries: \(String(describing: applicationSummaries)), hasMoreApplications: \(String(describing: hasMoreApplications)))"}
}

extension ListApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationSummaries = output.applicationSummaries
            self.hasMoreApplications = output.hasMoreApplications
        } else {
            self.applicationSummaries = nil
            self.hasMoreApplications = nil
        }
    }
}

/// <p></p>
public struct ListApplicationsOutputResponse: Equatable {
    /// <p>List of <code>ApplicationSummary</code> objects. </p>
    public let applicationSummaries: [ApplicationSummary]?
    /// <p>Returns true if there are more applications to retrieve.</p>
    public let hasMoreApplications: Bool?

    public init (
        applicationSummaries: [ApplicationSummary]? = nil,
        hasMoreApplications: Bool? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.hasMoreApplications = hasMoreApplications
    }
}

struct ListApplicationsOutputResponseBody: Equatable {
    public let applicationSummaries: [ApplicationSummary]?
    public let hasMoreApplications: Bool?
}

extension ListApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSummaries = "ApplicationSummaries"
        case hasMoreApplications = "HasMoreApplications"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummariesContainer = try containerValues.decodeIfPresent([ApplicationSummary?].self, forKey: .applicationSummaries)
        var applicationSummariesDecoded0:[ApplicationSummary]? = nil
        if let applicationSummariesContainer = applicationSummariesContainer {
            applicationSummariesDecoded0 = [ApplicationSummary]()
            for structure0 in applicationSummariesContainer {
                if let structure0 = structure0 {
                    applicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        applicationSummaries = applicationSummariesDecoded0
        let hasMoreApplicationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasMoreApplications)
        hasMoreApplications = hasMoreApplicationsDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the application for which to retrieve tags.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The key-value tags assigned to the application.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MappingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cSVMappingParameters = "CSVMappingParameters"
        case jSONMappingParameters = "JSONMappingParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cSVMappingParameters = cSVMappingParameters {
            try encodeContainer.encode(cSVMappingParameters, forKey: .cSVMappingParameters)
        }
        if let jSONMappingParameters = jSONMappingParameters {
            try encodeContainer.encode(jSONMappingParameters, forKey: .jSONMappingParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jSONMappingParametersDecoded = try containerValues.decodeIfPresent(JSONMappingParameters.self, forKey: .jSONMappingParameters)
        jSONMappingParameters = jSONMappingParametersDecoded
        let cSVMappingParametersDecoded = try containerValues.decodeIfPresent(CSVMappingParameters.self, forKey: .cSVMappingParameters)
        cSVMappingParameters = cSVMappingParametersDecoded
    }
}

extension MappingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MappingParameters(cSVMappingParameters: \(String(describing: cSVMappingParameters)), jSONMappingParameters: \(String(describing: jSONMappingParameters)))"}
}

/// <p>When configuring application input
///             at the time of creating or updating an application,
///             provides additional mapping information specific to
///             the record format (such as JSON, CSV, or record fields delimited
///             by some delimiter) on the streaming source.</p>
public struct MappingParameters: Equatable {
    /// <p>Provides additional mapping information when the record format uses delimiters
    ///             (for example, CSV).</p>
    public let cSVMappingParameters: CSVMappingParameters?
    /// <p>Provides additional mapping information when JSON is the record format on the streaming source.</p>
    public let jSONMappingParameters: JSONMappingParameters?

    public init (
        cSVMappingParameters: CSVMappingParameters? = nil,
        jSONMappingParameters: JSONMappingParameters? = nil
    )
    {
        self.cSVMappingParameters = cSVMappingParameters
        self.jSONMappingParameters = jSONMappingParameters
    }
}

extension Output: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutput = "KinesisFirehoseOutput"
        case kinesisStreamsOutput = "KinesisStreamsOutput"
        case lambdaOutput = "LambdaOutput"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutput = kinesisFirehoseOutput {
            try encodeContainer.encode(kinesisFirehoseOutput, forKey: .kinesisFirehoseOutput)
        }
        if let kinesisStreamsOutput = kinesisStreamsOutput {
            try encodeContainer.encode(kinesisStreamsOutput, forKey: .kinesisStreamsOutput)
        }
        if let lambdaOutput = lambdaOutput {
            try encodeContainer.encode(lambdaOutput, forKey: .lambdaOutput)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDecoded = try containerValues.decodeIfPresent(KinesisStreamsOutput.self, forKey: .kinesisStreamsOutput)
        kinesisStreamsOutput = kinesisStreamsOutputDecoded
        let kinesisFirehoseOutputDecoded = try containerValues.decodeIfPresent(KinesisFirehoseOutput.self, forKey: .kinesisFirehoseOutput)
        kinesisFirehoseOutput = kinesisFirehoseOutputDecoded
        let lambdaOutputDecoded = try containerValues.decodeIfPresent(LambdaOutput.self, forKey: .lambdaOutput)
        lambdaOutput = lambdaOutputDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension Output: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Output(destinationSchema: \(String(describing: destinationSchema)), kinesisFirehoseOutput: \(String(describing: kinesisFirehoseOutput)), kinesisStreamsOutput: \(String(describing: kinesisStreamsOutput)), lambdaOutput: \(String(describing: lambdaOutput)), name: \(String(describing: name)))"}
}

/// <p>
///             Describes application output configuration in which you identify
///             an in-application stream and a destination where you want the
///             in-application stream data to be written. The destination can be
///             an Amazon Kinesis stream or an Amazon Kinesis Firehose delivery stream.
///         </p>
///
///         <p></p>
///         <p>For limits on how many destinations an application can write and other
///             limitations, see
///             <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/limits.html">Limits</a>.
///         </p>
public struct Output: Equatable {
    /// <p>Describes the data format when records are written to the destination. For more information, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html">Configuring Application Output</a>.</p>
    public let destinationSchema: DestinationSchema?
    /// <p>Identifies an Amazon Kinesis Firehose delivery stream as the destination.</p>
    public let kinesisFirehoseOutput: KinesisFirehoseOutput?
    /// <p>Identifies an Amazon Kinesis stream
    ///             as the destination.</p>
    public let kinesisStreamsOutput: KinesisStreamsOutput?
    /// <p>Identifies an AWS Lambda function as the destination.</p>
    public let lambdaOutput: LambdaOutput?
    /// <p>Name of the in-application stream.</p>
    public let name: String?

    public init (
        destinationSchema: DestinationSchema? = nil,
        kinesisFirehoseOutput: KinesisFirehoseOutput? = nil,
        kinesisStreamsOutput: KinesisStreamsOutput? = nil,
        lambdaOutput: LambdaOutput? = nil,
        name: String? = nil
    )
    {
        self.destinationSchema = destinationSchema
        self.kinesisFirehoseOutput = kinesisFirehoseOutput
        self.kinesisStreamsOutput = kinesisStreamsOutput
        self.lambdaOutput = lambdaOutput
        self.name = name
    }
}

extension OutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutputDescription = "KinesisFirehoseOutputDescription"
        case kinesisStreamsOutputDescription = "KinesisStreamsOutputDescription"
        case lambdaOutputDescription = "LambdaOutputDescription"
        case name = "Name"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription {
            try encodeContainer.encode(kinesisFirehoseOutputDescription, forKey: .kinesisFirehoseOutputDescription)
        }
        if let kinesisStreamsOutputDescription = kinesisStreamsOutputDescription {
            try encodeContainer.encode(kinesisStreamsOutputDescription, forKey: .kinesisStreamsOutputDescription)
        }
        if let lambdaOutputDescription = lambdaOutputDescription {
            try encodeContainer.encode(lambdaOutputDescription, forKey: .lambdaOutputDescription)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputId = outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisStreamsOutputDescription.self, forKey: .kinesisStreamsOutputDescription)
        kinesisStreamsOutputDescription = kinesisStreamsOutputDescriptionDecoded
        let kinesisFirehoseOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisFirehoseOutputDescription.self, forKey: .kinesisFirehoseOutputDescription)
        kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescriptionDecoded
        let lambdaOutputDescriptionDecoded = try containerValues.decodeIfPresent(LambdaOutputDescription.self, forKey: .lambdaOutputDescription)
        lambdaOutputDescription = lambdaOutputDescriptionDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension OutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputDescription(destinationSchema: \(String(describing: destinationSchema)), kinesisFirehoseOutputDescription: \(String(describing: kinesisFirehoseOutputDescription)), kinesisStreamsOutputDescription: \(String(describing: kinesisStreamsOutputDescription)), lambdaOutputDescription: \(String(describing: lambdaOutputDescription)), name: \(String(describing: name)), outputId: \(String(describing: outputId)))"}
}

/// <p>Describes the application output configuration, which includes
///             the in-application stream name and the destination where the stream data
///             is written. The destination can be an Amazon Kinesis stream or an
///             Amazon Kinesis Firehose delivery stream.
///         </p>
public struct OutputDescription: Equatable {
    /// <p>Data format used for writing data to the destination.</p>
    public let destinationSchema: DestinationSchema?
    /// <p>Describes the Amazon Kinesis Firehose delivery stream configured as the
    ///             destination where output is written.</p>
    public let kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription?
    /// <p>Describes Amazon Kinesis stream configured as the
    ///             destination where output is written.</p>
    public let kinesisStreamsOutputDescription: KinesisStreamsOutputDescription?
    /// <p>Describes the AWS Lambda function configured as the destination where output is
    ///             written.</p>
    public let lambdaOutputDescription: LambdaOutputDescription?
    /// <p>Name of the in-application stream configured as output.</p>
    public let name: String?
    /// <p>A unique identifier for the output configuration.</p>
    public let outputId: String?

    public init (
        destinationSchema: DestinationSchema? = nil,
        kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription? = nil,
        kinesisStreamsOutputDescription: KinesisStreamsOutputDescription? = nil,
        lambdaOutputDescription: LambdaOutputDescription? = nil,
        name: String? = nil,
        outputId: String? = nil
    )
    {
        self.destinationSchema = destinationSchema
        self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
        self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
        self.lambdaOutputDescription = lambdaOutputDescription
        self.name = name
        self.outputId = outputId
    }
}

extension OutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationSchemaUpdate = "DestinationSchemaUpdate"
        case kinesisFirehoseOutputUpdate = "KinesisFirehoseOutputUpdate"
        case kinesisStreamsOutputUpdate = "KinesisStreamsOutputUpdate"
        case lambdaOutputUpdate = "LambdaOutputUpdate"
        case nameUpdate = "NameUpdate"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchemaUpdate = destinationSchemaUpdate {
            try encodeContainer.encode(destinationSchemaUpdate, forKey: .destinationSchemaUpdate)
        }
        if let kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate {
            try encodeContainer.encode(kinesisFirehoseOutputUpdate, forKey: .kinesisFirehoseOutputUpdate)
        }
        if let kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate {
            try encodeContainer.encode(kinesisStreamsOutputUpdate, forKey: .kinesisStreamsOutputUpdate)
        }
        if let lambdaOutputUpdate = lambdaOutputUpdate {
            try encodeContainer.encode(lambdaOutputUpdate, forKey: .lambdaOutputUpdate)
        }
        if let nameUpdate = nameUpdate {
            try encodeContainer.encode(nameUpdate, forKey: .nameUpdate)
        }
        if let outputId = outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nameUpdate)
        nameUpdate = nameUpdateDecoded
        let kinesisStreamsOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisStreamsOutputUpdate.self, forKey: .kinesisStreamsOutputUpdate)
        kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdateDecoded
        let kinesisFirehoseOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisFirehoseOutputUpdate.self, forKey: .kinesisFirehoseOutputUpdate)
        kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdateDecoded
        let lambdaOutputUpdateDecoded = try containerValues.decodeIfPresent(LambdaOutputUpdate.self, forKey: .lambdaOutputUpdate)
        lambdaOutputUpdate = lambdaOutputUpdateDecoded
        let destinationSchemaUpdateDecoded = try containerValues.decodeIfPresent(DestinationSchema.self, forKey: .destinationSchemaUpdate)
        destinationSchemaUpdate = destinationSchemaUpdateDecoded
    }
}

extension OutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputUpdate(destinationSchemaUpdate: \(String(describing: destinationSchemaUpdate)), kinesisFirehoseOutputUpdate: \(String(describing: kinesisFirehoseOutputUpdate)), kinesisStreamsOutputUpdate: \(String(describing: kinesisStreamsOutputUpdate)), lambdaOutputUpdate: \(String(describing: lambdaOutputUpdate)), nameUpdate: \(String(describing: nameUpdate)), outputId: \(String(describing: outputId)))"}
}

/// <p>
///             Describes updates to the output configuration identified by
///             the <code>OutputId</code>.
///         </p>
public struct OutputUpdate: Equatable {
    /// <p>Describes the data format when records are written to the destination. For more information, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html">Configuring Application Output</a>.</p>
    public let destinationSchemaUpdate: DestinationSchema?
    /// <p>Describes an Amazon Kinesis Firehose delivery stream as the destination for the
    ///             output.</p>
    public let kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate?
    /// <p>Describes an Amazon Kinesis stream as the destination for the output.</p>
    public let kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate?
    /// <p>Describes an AWS Lambda function as the destination for the output.</p>
    public let lambdaOutputUpdate: LambdaOutputUpdate?
    /// <p>If you want to specify a different in-application stream
    ///             for this output configuration, use this field to
    ///             specify the new in-application stream name.</p>
    public let nameUpdate: String?
    /// <p>Identifies the specific output configuration that you want to update.</p>
    public let outputId: String?

    public init (
        destinationSchemaUpdate: DestinationSchema? = nil,
        kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate? = nil,
        kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate? = nil,
        lambdaOutputUpdate: LambdaOutputUpdate? = nil,
        nameUpdate: String? = nil,
        outputId: String? = nil
    )
    {
        self.destinationSchemaUpdate = destinationSchemaUpdate
        self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
        self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
        self.lambdaOutputUpdate = lambdaOutputUpdate
        self.nameUpdate = nameUpdate
        self.outputId = outputId
    }
}

extension RecordColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mapping = "Mapping"
        case name = "Name"
        case sqlType = "SqlType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mapping = mapping {
            try encodeContainer.encode(mapping, forKey: .mapping)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlType = sqlType {
            try encodeContainer.encode(sqlType, forKey: .sqlType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let mappingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mapping)
        mapping = mappingDecoded
        let sqlTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlType)
        sqlType = sqlTypeDecoded
    }
}

extension RecordColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordColumn(mapping: \(String(describing: mapping)), name: \(String(describing: name)), sqlType: \(String(describing: sqlType)))"}
}

/// <p>Describes the mapping of each data element in the streaming
///             source to the corresponding column in the in-application stream.</p>
///         <p>Also used to describe the format of the reference data source.</p>
public struct RecordColumn: Equatable {
    /// <p>Reference to the data element in the streaming input or the reference data source. This element
    ///             is required if the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_RecordFormat.html#analytics-Type-RecordFormat-RecordFormatTypel">RecordFormatType</a> is <code>JSON</code>.</p>
    public let mapping: String?
    /// <p>Name of the column created in the in-application input stream or reference table.</p>
    public let name: String?
    /// <p>Type of column created in the in-application input stream or reference table.</p>
    public let sqlType: String?

    public init (
        mapping: String? = nil,
        name: String? = nil,
        sqlType: String? = nil
    )
    {
        self.mapping = mapping
        self.name = name
        self.sqlType = sqlType
    }
}

extension RecordFormat: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mappingParameters = "MappingParameters"
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mappingParameters = mappingParameters {
            try encodeContainer.encode(mappingParameters, forKey: .mappingParameters)
        }
        if let recordFormatType = recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
        let mappingParametersDecoded = try containerValues.decodeIfPresent(MappingParameters.self, forKey: .mappingParameters)
        mappingParameters = mappingParametersDecoded
    }
}

extension RecordFormat: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordFormat(mappingParameters: \(String(describing: mappingParameters)), recordFormatType: \(String(describing: recordFormatType)))"}
}

/// <p>
///             Describes the record format and relevant mapping information that
///             should be applied to schematize the records on the stream.
///         </p>
public struct RecordFormat: Equatable {
    /// <p>When configuring application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.</p>
    public let mappingParameters: MappingParameters?
    /// <p>The type of record format.</p>
    public let recordFormatType: RecordFormatType?

    public init (
        mappingParameters: MappingParameters? = nil,
        recordFormatType: RecordFormatType? = nil
    )
    {
        self.mappingParameters = mappingParameters
        self.recordFormatType = recordFormatType
    }
}

public enum RecordFormatType {
    case csv
    case json
    case sdkUnknown(String)
}

extension RecordFormatType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecordFormatType] {
        return [
            .csv,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .json: return "JSON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecordFormatType(rawValue: rawValue) ?? RecordFormatType.sdkUnknown(rawValue)
    }
}

extension ReferenceDataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSource = "S3ReferenceDataSource"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceSchema = referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSource = s3ReferenceDataSource {
            try encodeContainer.encode(s3ReferenceDataSource, forKey: .s3ReferenceDataSource)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDecoded = try containerValues.decodeIfPresent(S3ReferenceDataSource.self, forKey: .s3ReferenceDataSource)
        s3ReferenceDataSource = s3ReferenceDataSourceDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension ReferenceDataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceDataSource(referenceSchema: \(String(describing: referenceSchema)), s3ReferenceDataSource: \(String(describing: s3ReferenceDataSource)), tableName: \(String(describing: tableName)))"}
}

/// <p>Describes the reference data source by providing the source information (S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.</p>
public struct ReferenceDataSource: Equatable {
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    public let referenceSchema: SourceSchema?
    /// <p>Identifies the S3 bucket and object that contains the reference data. Also identifies the IAM role Amazon Kinesis Analytics can assume to read this object on your behalf.
    ///
    ///             An Amazon Kinesis Analytics application loads reference data only once. If the data changes, you call the <code>UpdateApplication</code> operation to trigger reloading of data into your application. </p>
    public let s3ReferenceDataSource: S3ReferenceDataSource?
    /// <p>Name of the in-application table to create.</p>
    public let tableName: String?

    public init (
        referenceSchema: SourceSchema? = nil,
        s3ReferenceDataSource: S3ReferenceDataSource? = nil,
        tableName: String? = nil
    )
    {
        self.referenceSchema = referenceSchema
        self.s3ReferenceDataSource = s3ReferenceDataSource
        self.tableName = tableName
    }
}

extension ReferenceDataSourceDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSourceDescription = "S3ReferenceDataSourceDescription"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchema = referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription {
            try encodeContainer.encode(s3ReferenceDataSourceDescription, forKey: .s3ReferenceDataSourceDescription)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDescriptionDecoded = try containerValues.decodeIfPresent(S3ReferenceDataSourceDescription.self, forKey: .s3ReferenceDataSourceDescription)
        s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescriptionDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension ReferenceDataSourceDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceDataSourceDescription(referenceId: \(String(describing: referenceId)), referenceSchema: \(String(describing: referenceSchema)), s3ReferenceDataSourceDescription: \(String(describing: s3ReferenceDataSourceDescription)), tableName: \(String(describing: tableName)))"}
}

/// <p>Describes the reference data source configured for an application.</p>
public struct ReferenceDataSourceDescription: Equatable {
    /// <p>ID of the reference data source. This is the ID
    ///             that Amazon Kinesis Analytics assigns when you add the reference data source
    ///             to your application using the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationReferenceDataSource.html">AddApplicationReferenceDataSource</a> operation.</p>
    public let referenceId: String?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    public let referenceSchema: SourceSchema?
    /// <p>Provides the S3 bucket name, the object key name that contains the reference data. It also provides the Amazon Resource Name (ARN) of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object and populate the in-application reference table.</p>
    public let s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription?
    /// <p>The in-application table name created by the specific reference data source configuration.</p>
    public let tableName: String?

    public init (
        referenceId: String? = nil,
        referenceSchema: SourceSchema? = nil,
        s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription? = nil,
        tableName: String? = nil
    )
    {
        self.referenceId = referenceId
        self.referenceSchema = referenceSchema
        self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
        self.tableName = tableName
    }
}

extension ReferenceDataSourceUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchemaUpdate = "ReferenceSchemaUpdate"
        case s3ReferenceDataSourceUpdate = "S3ReferenceDataSourceUpdate"
        case tableNameUpdate = "TableNameUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchemaUpdate = referenceSchemaUpdate {
            try encodeContainer.encode(referenceSchemaUpdate, forKey: .referenceSchemaUpdate)
        }
        if let s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate {
            try encodeContainer.encode(s3ReferenceDataSourceUpdate, forKey: .s3ReferenceDataSourceUpdate)
        }
        if let tableNameUpdate = tableNameUpdate {
            try encodeContainer.encode(tableNameUpdate, forKey: .tableNameUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableNameUpdate)
        tableNameUpdate = tableNameUpdateDecoded
        let s3ReferenceDataSourceUpdateDecoded = try containerValues.decodeIfPresent(S3ReferenceDataSourceUpdate.self, forKey: .s3ReferenceDataSourceUpdate)
        s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdateDecoded
        let referenceSchemaUpdateDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .referenceSchemaUpdate)
        referenceSchemaUpdate = referenceSchemaUpdateDecoded
    }
}

extension ReferenceDataSourceUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceDataSourceUpdate(referenceId: \(String(describing: referenceId)), referenceSchemaUpdate: \(String(describing: referenceSchemaUpdate)), s3ReferenceDataSourceUpdate: \(String(describing: s3ReferenceDataSourceUpdate)), tableNameUpdate: \(String(describing: tableNameUpdate)))"}
}

/// <p>When you update a reference data source configuration for an application, this object provides all the updated values (such as the source bucket name and object key name), the in-application table name that is created, and updated mapping information that maps the data in the Amazon S3 object to the in-application reference table that is created.</p>
public struct ReferenceDataSourceUpdate: Equatable {
    /// <p>ID of the reference data source being updated. You can use the
    ///             <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get this value.</p>
    public let referenceId: String?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream. </p>
    public let referenceSchemaUpdate: SourceSchema?
    /// <p>Describes the S3 bucket name, object key name, and IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.</p>
    public let s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate?
    /// <p>In-application table name that is created by this update.</p>
    public let tableNameUpdate: String?

    public init (
        referenceId: String? = nil,
        referenceSchemaUpdate: SourceSchema? = nil,
        s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate? = nil,
        tableNameUpdate: String? = nil
    )
    {
        self.referenceId = referenceId
        self.referenceSchemaUpdate = referenceSchemaUpdate
        self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
        self.tableNameUpdate = tableNameUpdate
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Application is not available for this operation.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified application can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceProvisionedThroughputExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceProvisionedThroughputExceededException(message: \(String(describing: message)))"}
}

extension ResourceProvisionedThroughputExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Discovery failed to get a record from the
///             streaming source because of the Amazon Kinesis Streams
///             ProvisionedThroughputExceededException. For more information,
///             see <a href="https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html">GetRecords</a>
///             in the Amazon Kinesis Streams API Reference.</p>
public struct ResourceProvisionedThroughputExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceProvisionedThroughputExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceProvisionedThroughputExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Configuration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
    }
}

extension S3Configuration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Configuration(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>Provides a description of an Amazon S3 data source, including the Amazon Resource
///             Name (ARN) of the S3 bucket, the ARN of the IAM role that is used to access the bucket,
///             and the name of the Amazon S3 object that contains the data.</p>
public struct S3Configuration: Equatable {
    /// <p>ARN of the S3 bucket that contains the data.</p>
    public let bucketARN: String?
    /// <p>The name of the object that contains the data.</p>
    public let fileKey: String?
    /// <p>IAM ARN of the role used to access the data.</p>
    public let roleARN: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil,
        roleARN: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
        self.roleARN = roleARN
    }
}

extension S3ReferenceDataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case referenceRoleARN = "ReferenceRoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let referenceRoleARN = referenceRoleARN {
            try encodeContainer.encode(referenceRoleARN, forKey: .referenceRoleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let referenceRoleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceRoleARN)
        referenceRoleARN = referenceRoleARNDecoded
    }
}

extension S3ReferenceDataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ReferenceDataSource(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)), referenceRoleARN: \(String(describing: referenceRoleARN)))"}
}

/// <p>Identifies the S3 bucket and object that contains the reference data. Also identifies the IAM role Amazon Kinesis Analytics can assume to read this object on your behalf.</p>
///         <p>An Amazon Kinesis Analytics application loads reference data only once. If the data changes,
///             you call the <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html">UpdateApplication</a> operation to trigger
///             reloading of data into your application.</p>
public struct S3ReferenceDataSource: Equatable {
    /// <p>Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARN: String?
    /// <p>Object key name containing reference data.</p>
    public let fileKey: String?
    /// <p>ARN of the IAM role that the service can assume to read data on your behalf. This role must have permission for the <code>s3:GetObject</code> action on the object and trust policy that allows Amazon Kinesis Analytics service principal to assume this role.</p>
    public let referenceRoleARN: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil,
        referenceRoleARN: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
        self.referenceRoleARN = referenceRoleARN
    }
}

extension S3ReferenceDataSourceDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case referenceRoleARN = "ReferenceRoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let referenceRoleARN = referenceRoleARN {
            try encodeContainer.encode(referenceRoleARN, forKey: .referenceRoleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let referenceRoleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceRoleARN)
        referenceRoleARN = referenceRoleARNDecoded
    }
}

extension S3ReferenceDataSourceDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ReferenceDataSourceDescription(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)), referenceRoleARN: \(String(describing: referenceRoleARN)))"}
}

/// <p>Provides the bucket name and object key name that stores the reference data.</p>
public struct S3ReferenceDataSourceDescription: Equatable {
    /// <p>Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARN: String?
    /// <p>Amazon S3 object key name.</p>
    public let fileKey: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf to populate the in-application reference table.</p>
    public let referenceRoleARN: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil,
        referenceRoleARN: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
        self.referenceRoleARN = referenceRoleARN
    }
}

extension S3ReferenceDataSourceUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARNUpdate = "BucketARNUpdate"
        case fileKeyUpdate = "FileKeyUpdate"
        case referenceRoleARNUpdate = "ReferenceRoleARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARNUpdate = bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
        if let fileKeyUpdate = fileKeyUpdate {
            try encodeContainer.encode(fileKeyUpdate, forKey: .fileKeyUpdate)
        }
        if let referenceRoleARNUpdate = referenceRoleARNUpdate {
            try encodeContainer.encode(referenceRoleARNUpdate, forKey: .referenceRoleARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let fileKeyUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKeyUpdate)
        fileKeyUpdate = fileKeyUpdateDecoded
        let referenceRoleARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceRoleARNUpdate)
        referenceRoleARNUpdate = referenceRoleARNUpdateDecoded
    }
}

extension S3ReferenceDataSourceUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ReferenceDataSourceUpdate(bucketARNUpdate: \(String(describing: bucketARNUpdate)), fileKeyUpdate: \(String(describing: fileKeyUpdate)), referenceRoleARNUpdate: \(String(describing: referenceRoleARNUpdate)))"}
}

/// <p>Describes the S3 bucket name, object key name, and IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.</p>
public struct S3ReferenceDataSourceUpdate: Equatable {
    /// <p>Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARNUpdate: String?
    /// <p>Object key name.</p>
    public let fileKeyUpdate: String?
    /// <p>ARN of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object and populate the in-application.</p>
    public let referenceRoleARNUpdate: String?

    public init (
        bucketARNUpdate: String? = nil,
        fileKeyUpdate: String? = nil,
        referenceRoleARNUpdate: String? = nil
    )
    {
        self.bucketARNUpdate = bucketARNUpdate
        self.fileKeyUpdate = fileKeyUpdate
        self.referenceRoleARNUpdate = referenceRoleARNUpdate
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is unavailable. Back off and retry the operation. </p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordColumns = "RecordColumns"
        case recordEncoding = "RecordEncoding"
        case recordFormat = "RecordFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumns = recordColumns {
            var recordColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumns)
            for recordcolumns0 in recordColumns {
                try recordColumnsContainer.encode(recordcolumns0)
            }
        }
        if let recordEncoding = recordEncoding {
            try encodeContainer.encode(recordEncoding, forKey: .recordEncoding)
        }
        if let recordFormat = recordFormat {
            try encodeContainer.encode(recordFormat, forKey: .recordFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatDecoded = try containerValues.decodeIfPresent(RecordFormat.self, forKey: .recordFormat)
        recordFormat = recordFormatDecoded
        let recordEncodingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordEncoding)
        recordEncoding = recordEncodingDecoded
        let recordColumnsContainer = try containerValues.decodeIfPresent([RecordColumn?].self, forKey: .recordColumns)
        var recordColumnsDecoded0:[RecordColumn]? = nil
        if let recordColumnsContainer = recordColumnsContainer {
            recordColumnsDecoded0 = [RecordColumn]()
            for structure0 in recordColumnsContainer {
                if let structure0 = structure0 {
                    recordColumnsDecoded0?.append(structure0)
                }
            }
        }
        recordColumns = recordColumnsDecoded0
    }
}

extension SourceSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceSchema(recordColumns: \(String(describing: recordColumns)), recordEncoding: \(String(describing: recordEncoding)), recordFormat: \(String(describing: recordFormat)))"}
}

/// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
public struct SourceSchema: Equatable {
    /// <p>A list of <code>RecordColumn</code> objects.</p>
    public let recordColumns: [RecordColumn]?
    /// <p>Specifies the encoding of the records in the streaming source. For example, UTF-8.</p>
    public let recordEncoding: String?
    /// <p>Specifies the format of the records on the streaming source.</p>
    public let recordFormat: RecordFormat?

    public init (
        recordColumns: [RecordColumn]? = nil,
        recordEncoding: String? = nil,
        recordFormat: RecordFormat? = nil
    )
    {
        self.recordColumns = recordColumns
        self.recordEncoding = recordEncoding
        self.recordFormat = recordFormat
    }
}

public struct StartApplicationInputBodyMiddleware: Middleware {
    public let id: String = "StartApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartApplicationInput>
    public typealias MOutput = OperationOutput<StartApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartApplicationOutputError>
}

extension StartApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartApplicationInput(applicationName: \(String(describing: applicationName)), inputConfigurations: \(String(describing: inputConfigurations)))"}
}

extension StartApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case inputConfigurations = "InputConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for inputconfigurations0 in inputConfigurations {
                try inputConfigurationsContainer.encode(inputconfigurations0)
            }
        }
    }
}

public struct StartApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StartApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartApplicationInput>
    public typealias MOutput = OperationOutput<StartApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartApplicationOutputError>
}

public struct StartApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartApplicationInput>
    public typealias MOutput = OperationOutput<StartApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartApplicationOutputError>
}

/// <p></p>
public struct StartApplicationInput: Equatable {
    /// <p>Name of the application.</p>
    public let applicationName: String?
    /// <p>Identifies the specific input, by ID, that the application starts consuming. Amazon Kinesis Analytics starts reading the streaming source associated with the input. You can also specify where in the streaming source you want Amazon Kinesis Analytics to start reading.</p>
    public let inputConfigurations: [InputConfiguration]?

    public init (
        applicationName: String? = nil,
        inputConfigurations: [InputConfiguration]? = nil
    )
    {
        self.applicationName = applicationName
        self.inputConfigurations = inputConfigurations
    }
}

struct StartApplicationInputBody: Equatable {
    public let applicationName: String?
    public let inputConfigurations: [InputConfiguration]?
}

extension StartApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case inputConfigurations = "InputConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([InputConfiguration?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[InputConfiguration]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [InputConfiguration]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
    }
}

extension StartApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartApplicationOutputError: Swift.Error, Equatable {
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartApplicationOutputResponse()"}
}

extension StartApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct StartApplicationOutputResponse: Equatable {

    public init() {}
}

struct StartApplicationOutputResponseBody: Equatable {
}

extension StartApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopApplicationInputBodyMiddleware: Middleware {
    public let id: String = "StopApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopApplicationInput>
    public typealias MOutput = OperationOutput<StopApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopApplicationOutputError>
}

extension StopApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopApplicationInput(applicationName: \(String(describing: applicationName)))"}
}

extension StopApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
    }
}

public struct StopApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StopApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopApplicationInput>
    public typealias MOutput = OperationOutput<StopApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopApplicationOutputError>
}

public struct StopApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StopApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopApplicationInput>
    public typealias MOutput = OperationOutput<StopApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopApplicationOutputError>
}

/// <p></p>
public struct StopApplicationInput: Equatable {
    /// <p>Name of the running application to stop.</p>
    public let applicationName: String?

    public init (
        applicationName: String? = nil
    )
    {
        self.applicationName = applicationName
    }
}

struct StopApplicationInputBody: Equatable {
    public let applicationName: String?
}

extension StopApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
    }
}

extension StopApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopApplicationOutputError: Swift.Error, Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopApplicationOutputResponse()"}
}

extension StopApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct StopApplicationOutputResponse: Equatable {

    public init() {}
}

struct StopApplicationOutputResponseBody: Equatable {
}

extension StopApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key-value pair (the value is optional) that you can define and assign to AWS resources. If you specify a tag that already exists, the tag value is replaced with the value that you specify in the request. Note that
///         the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
///       For more information, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-tagging.html">Using Tagging</a>.</p>
public struct Tag: Equatable {
    /// <p>The key of the key-value tag.</p>
    public let key: String?
    /// <p>The value of the key-value tag. The value is optional.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the application to assign the tags.</p>
    public let resourceARN: String?
    /// <p>The key-value tags to assign to the application.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Application created with too many tags, or too many tags added to an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnableToDetectSchemaException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnableToDetectSchemaException(processedInputRecords: \(String(describing: processedInputRecords)), rawInputRecords: \(String(describing: rawInputRecords)), message: \(String(describing: message)))"}
}

extension UnableToDetectSchemaException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnableToDetectSchemaExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.processedInputRecords = nil
            self.rawInputRecords = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Data format is not valid. Amazon Kinesis Analytics is not able to detect schema for
///             the given streaming source.</p>
public struct UnableToDetectSchemaException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var processedInputRecords: [String]?
    public var rawInputRecords: [String]?

    public init (
        message: String? = nil,
        processedInputRecords: [String]? = nil,
        rawInputRecords: [String]? = nil
    )
    {
        self.message = message
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct UnableToDetectSchemaExceptionBody: Equatable {
    public let message: String?
    public let rawInputRecords: [String]?
    public let processedInputRecords: [String]?
}

extension UnableToDetectSchemaExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because a specified parameter is not supported or a specified resource is not valid for this operation. </p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the Kinesis Analytics application from which to remove the tags.</p>
    public let resourceARN: String?
    /// <p>A list of keys of tags to remove from the specified application.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(applicationName: \(String(describing: applicationName)), applicationUpdate: \(String(describing: applicationUpdate)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case applicationUpdate = "ApplicationUpdate"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationUpdate = applicationUpdate {
            try encodeContainer.encode(applicationUpdate, forKey: .applicationUpdate)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>Name of the Amazon Kinesis Analytics application to update.</p>
    public let applicationName: String?
    /// <p>Describes application updates.</p>
    public let applicationUpdate: ApplicationUpdate?
    /// <p>The current application version ID. You can use the
    ///             <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html">DescribeApplication</a> operation to get this value.</p>
    public let currentApplicationVersionId: Int?

    public init (
        applicationName: String? = nil,
        applicationUpdate: ApplicationUpdate? = nil,
        currentApplicationVersionId: Int? = nil
    )
    {
        self.applicationName = applicationName
        self.applicationUpdate = applicationUpdate
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let applicationUpdate: ApplicationUpdate?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case applicationUpdate = "ApplicationUpdate"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let applicationUpdateDecoded = try containerValues.decodeIfPresent(ApplicationUpdate.self, forKey: .applicationUpdate)
        applicationUpdate = applicationUpdateDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse()"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateApplicationOutputResponse: Equatable {

    public init() {}
}

struct UpdateApplicationOutputResponseBody: Equatable {
}

extension UpdateApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
