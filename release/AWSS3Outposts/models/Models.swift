// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access was denied for this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict with this action, and it could not be completed.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case outpostId = "OutpostId"
        case securityGroupId = "SecurityGroupId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessType = accessType {
            try encodeContainer.encode(accessType.rawValue, forKey: .accessType)
        }
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try encodeContainer.encode(customerOwnedIpv4Pool, forKey: .customerOwnedIpv4Pool)
        }
        if let outpostId = outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let securityGroupId = securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }
}

extension CreateEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/CreateEndpoint"
    }
}

public struct CreateEndpointInput: Swift.Equatable {
    /// The type of access for the on-premise network connectivity for the Outpost endpoint. To access the endpoint from an on-premises network, you must specify the access type and provide the customer owned IPv4 pool.
    public var accessType: S3OutpostsClientTypes.EndpointAccessType?
    /// The ID of the customer-owned IPv4 pool for the endpoint. IP addresses will be allocated from this pool for the endpoint.
    public var customerOwnedIpv4Pool: Swift.String?
    /// The ID of the AWS Outposts.
    /// This member is required.
    public var outpostId: Swift.String?
    /// The ID of the security group to use with the endpoint.
    /// This member is required.
    public var securityGroupId: Swift.String?
    /// The ID of the subnet in the selected VPC. The endpoint subnet must belong to the Outpost that has the Amazon S3 on Outposts provisioned.
    /// This member is required.
    public var subnetId: Swift.String?

    public init (
        accessType: S3OutpostsClientTypes.EndpointAccessType? = nil,
        customerOwnedIpv4Pool: Swift.String? = nil,
        outpostId: Swift.String? = nil,
        securityGroupId: Swift.String? = nil,
        subnetId: Swift.String? = nil
    )
    {
        self.accessType = accessType
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.outpostId = outpostId
        self.securityGroupId = securityGroupId
        self.subnetId = subnetId
    }
}

struct CreateEndpointInputBody: Swift.Equatable {
    let outpostId: Swift.String?
    let subnetId: Swift.String?
    let securityGroupId: Swift.String?
    let accessType: S3OutpostsClientTypes.EndpointAccessType?
    let customerOwnedIpv4Pool: Swift.String?
}

extension CreateEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case outpostId = "OutpostId"
        case securityGroupId = "SecurityGroupId"
        case subnetId = "SubnetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let accessTypeDecoded = try containerValues.decodeIfPresent(S3OutpostsClientTypes.EndpointAccessType.self, forKey: .accessType)
        accessType = accessTypeDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
    }
}

extension CreateEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointArn = output.endpointArn
        } else {
            self.endpointArn = nil
        }
    }
}

public struct CreateEndpointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint.
    public var endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct CreateEndpointOutputResponseBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension CreateEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DeleteEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let outpostId = outpostId {
            let outpostIdQueryItem = ClientRuntime.URLQueryItem(name: "outpostId".urlPercentEncoding(), value: Swift.String(outpostId).urlPercentEncoding())
            items.append(outpostIdQueryItem)
        }
        if let endpointId = endpointId {
            let endpointIdQueryItem = ClientRuntime.URLQueryItem(name: "endpointId".urlPercentEncoding(), value: Swift.String(endpointId).urlPercentEncoding())
            items.append(endpointIdQueryItem)
        }
        return items
    }
}

extension DeleteEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/DeleteEndpoint"
    }
}

public struct DeleteEndpointInput: Swift.Equatable {
    /// The ID of the endpoint.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The ID of the AWS Outposts.
    /// This member is required.
    public var outpostId: Swift.String?

    public init (
        endpointId: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.endpointId = endpointId
        self.outpostId = outpostId
    }
}

struct DeleteEndpointInputBody: Swift.Equatable {
}

extension DeleteEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointOutputResponse: Swift.Equatable {

}

extension S3OutpostsClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case cidrBlock = "CidrBlock"
        case creationTime = "CreationTime"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case endpointArn = "EndpointArn"
        case networkInterfaces = "NetworkInterfaces"
        case outpostsId = "OutpostsId"
        case securityGroupId = "SecurityGroupId"
        case status = "Status"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessType = accessType {
            try encodeContainer.encode(accessType.rawValue, forKey: .accessType)
        }
        if let cidrBlock = cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try encodeContainer.encode(customerOwnedIpv4Pool, forKey: .customerOwnedIpv4Pool)
        }
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if let outpostsId = outpostsId {
            try encodeContainer.encode(outpostsId, forKey: .outpostsId)
        }
        if let securityGroupId = securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let outpostsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostsId)
        outpostsId = outpostsIdDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3OutpostsClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([S3OutpostsClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[S3OutpostsClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [S3OutpostsClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let accessTypeDecoded = try containerValues.decodeIfPresent(S3OutpostsClientTypes.EndpointAccessType.self, forKey: .accessType)
        accessType = accessTypeDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
    }
}

extension S3OutpostsClientTypes {
    /// Amazon S3 on Outposts Access Points simplify managing data access at scale for shared datasets in S3 on Outposts. S3 on Outposts uses endpoints to connect to Outposts buckets so that you can perform actions within your virtual private cloud (VPC). For more information, see [ Accessing S3 on Outposts using VPC only access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/AccessingS3Outposts.html).
    public struct Endpoint: Swift.Equatable {
        ///
        public var accessType: S3OutpostsClientTypes.EndpointAccessType?
        /// The VPC CIDR committed by this endpoint.
        public var cidrBlock: Swift.String?
        /// The time the endpoint was created.
        public var creationTime: ClientRuntime.Date?
        /// The ID of the customer-owned IPv4 pool used for the endpoint.
        public var customerOwnedIpv4Pool: Swift.String?
        /// The Amazon Resource Name (ARN) of the endpoint.
        public var endpointArn: Swift.String?
        /// The network interface of the endpoint.
        public var networkInterfaces: [S3OutpostsClientTypes.NetworkInterface]?
        /// The ID of the AWS Outposts.
        public var outpostsId: Swift.String?
        /// The ID of the security group used for the endpoint.
        public var securityGroupId: Swift.String?
        /// The status of the endpoint.
        public var status: S3OutpostsClientTypes.EndpointStatus?
        /// The ID of the subnet used for the endpoint.
        public var subnetId: Swift.String?
        /// The ID of the VPC used for the endpoint.
        public var vpcId: Swift.String?

        public init (
            accessType: S3OutpostsClientTypes.EndpointAccessType? = nil,
            cidrBlock: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customerOwnedIpv4Pool: Swift.String? = nil,
            endpointArn: Swift.String? = nil,
            networkInterfaces: [S3OutpostsClientTypes.NetworkInterface]? = nil,
            outpostsId: Swift.String? = nil,
            securityGroupId: Swift.String? = nil,
            status: S3OutpostsClientTypes.EndpointStatus? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.accessType = accessType
            self.cidrBlock = cidrBlock
            self.creationTime = creationTime
            self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
            self.endpointArn = endpointArn
            self.networkInterfaces = networkInterfaces
            self.outpostsId = outpostsId
            self.securityGroupId = securityGroupId
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension S3OutpostsClientTypes {
    public enum EndpointAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerOwnedIp
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointAccessType] {
            return [
                .customerOwnedIp,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerOwnedIp: return "CustomerOwnedIp"
            case .private: return "Private"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointAccessType(rawValue: rawValue) ?? EndpointAccessType.sdkUnknown(rawValue)
        }
    }
}

extension S3OutpostsClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .available,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .deleting: return "Deleting"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an exception with the internal server.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/ListEndpoints"
    }
}

public struct ListEndpointsInput: Swift.Equatable {
    /// The max number of endpoints that can be returned on the request.
    public var maxResults: Swift.Int
    /// The next endpoint requested in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEndpointsInputBody: Swift.Equatable {
}

extension ListEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointsOutputResponse: Swift.Equatable {
    /// Returns an array of endpoints associated with AWS Outposts.
    public var endpoints: [S3OutpostsClientTypes.Endpoint]?
    /// The next endpoint returned in the list.
    public var nextToken: Swift.String?

    public init (
        endpoints: [S3OutpostsClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointsOutputResponseBody: Swift.Equatable {
    let endpoints: [S3OutpostsClientTypes.Endpoint]?
    let nextToken: Swift.String?
}

extension ListEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([S3OutpostsClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[S3OutpostsClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [S3OutpostsClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension S3OutpostsClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaceId = "NetworkInterfaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
    }
}

extension S3OutpostsClientTypes {
    /// The container for the network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The ID for the network interface.
        public var networkInterfaceId: Swift.String?

        public init (
            networkInterfaceId: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an exception validating this data.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
