// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Application: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Application: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Application(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>Represents a Service Catalog AppRegistry application that is the top-level node in a hierarchy of related
///        cloud resource abstractions.</p>
public struct Application: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application across services.</p>
    public let arn: String?
    /// <p>The ISO-8601 formatted timestamp of the moment when the application was created.</p>
    public let creationTime: Date?
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The identifier of the application.</p>
    public let id: String?
    /// <p> The ISO-8601 formatted timestamp of the moment when the application was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
    public let name: String?
    /// <p>Key-value pairs you can use to associate with the application.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

extension ApplicationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ApplicationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSummary(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)))"}
}

/// <p>Summary of a Service Catalog AppRegistry application.</p>
public struct ApplicationSummary: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application across services.</p>
    public let arn: String?
    /// <p>The ISO-8601 formatted timestamp of the moment when the application was created.</p>
    public let creationTime: Date?
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The identifier of the application.</p>
    public let id: String?
    /// <p> The ISO-8601 formatted timestamp of the moment when the application was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
    }
}

extension AssociateAttributeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAttributeGroupInput(application: \(String(describing: application)), attributeGroup: \(String(describing: attributeGroup)))"}
}

extension AssociateAttributeGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AssociateAttributeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAttributeGroupInput>
    public typealias MOutput = OperationOutput<AssociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAttributeGroupOutputError>
}

public struct AssociateAttributeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAttributeGroupInput>
    public typealias MOutput = OperationOutput<AssociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAttributeGroupOutputError>
}

public struct AssociateAttributeGroupInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: String?

    public init (
        application: String? = nil,
        attributeGroup: String? = nil
    )
    {
        self.application = application
        self.attributeGroup = attributeGroup
    }
}

struct AssociateAttributeGroupInputBody: Equatable {
}

extension AssociateAttributeGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AssociateAttributeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAttributeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAttributeGroupOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAttributeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAttributeGroupOutputResponse(applicationArn: \(String(describing: applicationArn)), attributeGroupArn: \(String(describing: attributeGroupArn)))"}
}

extension AssociateAttributeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationArn = output.applicationArn
            self.attributeGroupArn = output.attributeGroupArn
        } else {
            self.applicationArn = nil
            self.attributeGroupArn = nil
        }
    }
}

public struct AssociateAttributeGroupOutputResponse: Equatable {
    /// <p>The Amazon resource name (ARN) of the application that was augmented with attributes.</p>
    public let applicationArn: String?
    /// <p>The Amazon resource name (ARN) of the attribute group that contains the application's new attributes.</p>
    public let attributeGroupArn: String?

    public init (
        applicationArn: String? = nil,
        attributeGroupArn: String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.attributeGroupArn = attributeGroupArn
    }
}

struct AssociateAttributeGroupOutputResponseBody: Equatable {
    public let applicationArn: String?
    public let attributeGroupArn: String?
}

extension AssociateAttributeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationArn
        case attributeGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let attributeGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeGroupArn)
        attributeGroupArn = attributeGroupArnDecoded
    }
}

extension AssociateResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResourceInput(application: \(String(describing: application)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

extension AssociateResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AssociateResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceInput>
    public typealias MOutput = OperationOutput<AssociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceOutputError>
}

public struct AssociateResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceInput>
    public typealias MOutput = OperationOutput<AssociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceOutputError>
}

public struct AssociateResourceInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?
    /// <p>The name or ID of the resource of which the application will be associated.</p>
    public let resource: String?
    /// <p>The type of resource of which the application will be associated.</p>
    public let resourceType: ResourceType?

    public init (
        application: String? = nil,
        resource: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.application = application
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct AssociateResourceInputBody: Equatable {
}

extension AssociateResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AssociateResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResourceOutputResponse(applicationArn: \(String(describing: applicationArn)), resourceArn: \(String(describing: resourceArn)))"}
}

extension AssociateResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct AssociateResourceOutputResponse: Equatable {
    /// <p>The Amazon resource name (ARN) of the application that was augmented with attributes.</p>
    public let applicationArn: String?
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: String?

    public init (
        applicationArn: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct AssociateResourceOutputResponseBody: Equatable {
    public let applicationArn: String?
    public let resourceArn: String?
}

extension AssociateResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationArn
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension AttributeGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AttributeGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeGroup(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>Represents a Service Catalog AppRegistry attribute group that is rich metadata which describes an application and its components.</p>
public struct AttributeGroup: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the attribute group across services.</p>
    public let arn: String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was created.</p>
    public let creationTime: Date?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: String?
    /// <p>The globally unique attribute group identifier of the attribute group.</p>
    public let id: String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the attribute group.</p>
    public let name: String?
    /// <p>Key-value pairs you can use to associate with the attribute group.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

extension AttributeGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension AttributeGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeGroupSummary(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)))"}
}

/// <p>Summary of a Service Catalog AppRegistry attribute group.</p>
public struct AttributeGroupSummary: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the attribute group across services.</p>
    public let arn: String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was created.</p>
    public let creationTime: Date?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: String?
    /// <p>The globally unique attribute group identifier of the attribute group.</p>
    public let id: String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the attribute group.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a conflict when processing the request (for example, a resource with the given name already
///       exists within the account).</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Equatable {
    /// <p>A unique identifier that you provide to ensure idempotency. If you retry a request that
    ///       completed successfully using the same client token and the same parameters, the retry succeeds
    ///       without performing any further actions. If you retry a successful request using the same
    ///       client token, but one or more of the parameters are different, the retry fails.</p>
    public var clientToken: String?
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
    public let name: String?
    /// <p>Key-value pairs you can use to associate with the application.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(application: \(String(describing: application)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Equatable {
    /// <p>Information about the application.</p>
    public let application: Application?

    public init (
        application: Application? = nil
    )
    {
        self.application = application
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let application: Application?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Application.self, forKey: .application)
        application = applicationDecoded
    }
}

public struct CreateAttributeGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateAttributeGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAttributeGroupInput>
    public typealias MOutput = OperationOutput<CreateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAttributeGroupOutputError>
}

extension CreateAttributeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAttributeGroupInput(attributes: \(String(describing: attributes)), clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateAttributeGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAttributeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAttributeGroupInput>
    public typealias MOutput = OperationOutput<CreateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAttributeGroupOutputError>
}

public struct CreateAttributeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAttributeGroupInput>
    public typealias MOutput = OperationOutput<CreateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAttributeGroupOutputError>
}

public struct CreateAttributeGroupInput: Equatable {
    /// <p>A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.</p>
    public let attributes: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If you retry a request that
    ///       completed successfully using the same client token and the same parameters, the retry succeeds
    ///       without performing any further actions. If you retry a successful request using the same
    ///       client token, but one or more of the parameters are different, the retry fails.</p>
    public var clientToken: String?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: String?
    /// <p>The name of the attribute group.</p>
    public let name: String?
    /// <p>Key-value pairs you can use to associate with the attribute group.</p>
    public let tags: [String:String]?

    public init (
        attributes: String? = nil,
        clientToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAttributeGroupInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let attributes: String?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateAttributeGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes
        case clientToken
        case description
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributes)
        attributes = attributesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAttributeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAttributeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAttributeGroupOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAttributeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAttributeGroupOutputResponse(attributeGroup: \(String(describing: attributeGroup)))"}
}

extension CreateAttributeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct CreateAttributeGroupOutputResponse: Equatable {
    /// <p>Information about the attribute group.</p>
    public let attributeGroup: AttributeGroup?

    public init (
        attributeGroup: AttributeGroup? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct CreateAttributeGroupOutputResponseBody: Equatable {
    public let attributeGroup: AttributeGroup?
}

extension CreateAttributeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(AttributeGroup.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(application: \(String(describing: application)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?

    public init (
        application: String? = nil
    )
    {
        self.application = application
    }
}

struct DeleteApplicationInputBody: Equatable {
}

extension DeleteApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse(application: \(String(describing: application)))"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct DeleteApplicationOutputResponse: Equatable {
    /// <p>Information about the deleted application.</p>
    public let application: ApplicationSummary?

    public init (
        application: ApplicationSummary? = nil
    )
    {
        self.application = application
    }
}

struct DeleteApplicationOutputResponseBody: Equatable {
    public let application: ApplicationSummary?
}

extension DeleteApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(ApplicationSummary.self, forKey: .application)
        application = applicationDecoded
    }
}

extension DeleteAttributeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAttributeGroupInput(attributeGroup: \(String(describing: attributeGroup)))"}
}

extension DeleteAttributeGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAttributeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAttributeGroupInput>
    public typealias MOutput = OperationOutput<DeleteAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAttributeGroupOutputError>
}

public struct DeleteAttributeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAttributeGroupInput>
    public typealias MOutput = OperationOutput<DeleteAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAttributeGroupOutputError>
}

public struct DeleteAttributeGroupInput: Equatable {
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: String?

    public init (
        attributeGroup: String? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct DeleteAttributeGroupInputBody: Equatable {
}

extension DeleteAttributeGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAttributeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAttributeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAttributeGroupOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAttributeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAttributeGroupOutputResponse(attributeGroup: \(String(describing: attributeGroup)))"}
}

extension DeleteAttributeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct DeleteAttributeGroupOutputResponse: Equatable {
    /// <p>Information about the deleted attribute group.</p>
    public let attributeGroup: AttributeGroupSummary?

    public init (
        attributeGroup: AttributeGroupSummary? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct DeleteAttributeGroupOutputResponseBody: Equatable {
    public let attributeGroup: AttributeGroupSummary?
}

extension DeleteAttributeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(AttributeGroupSummary.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

extension DisassociateAttributeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAttributeGroupInput(application: \(String(describing: application)), attributeGroup: \(String(describing: attributeGroup)))"}
}

extension DisassociateAttributeGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateAttributeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAttributeGroupInput>
    public typealias MOutput = OperationOutput<DisassociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAttributeGroupOutputError>
}

public struct DisassociateAttributeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAttributeGroupInput>
    public typealias MOutput = OperationOutput<DisassociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAttributeGroupOutputError>
}

public struct DisassociateAttributeGroupInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: String?

    public init (
        application: String? = nil,
        attributeGroup: String? = nil
    )
    {
        self.application = application
        self.attributeGroup = attributeGroup
    }
}

struct DisassociateAttributeGroupInputBody: Equatable {
}

extension DisassociateAttributeGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateAttributeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAttributeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAttributeGroupOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAttributeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAttributeGroupOutputResponse(applicationArn: \(String(describing: applicationArn)), attributeGroupArn: \(String(describing: attributeGroupArn)))"}
}

extension DisassociateAttributeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationArn = output.applicationArn
            self.attributeGroupArn = output.attributeGroupArn
        } else {
            self.applicationArn = nil
            self.attributeGroupArn = nil
        }
    }
}

public struct DisassociateAttributeGroupOutputResponse: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application.</p>
    public let applicationArn: String?
    /// <p>The Amazon resource name (ARN) that specifies the attribute group.</p>
    public let attributeGroupArn: String?

    public init (
        applicationArn: String? = nil,
        attributeGroupArn: String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.attributeGroupArn = attributeGroupArn
    }
}

struct DisassociateAttributeGroupOutputResponseBody: Equatable {
    public let applicationArn: String?
    public let attributeGroupArn: String?
}

extension DisassociateAttributeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationArn
        case attributeGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let attributeGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeGroupArn)
        attributeGroupArn = attributeGroupArnDecoded
    }
}

extension DisassociateResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResourceInput(application: \(String(describing: application)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

extension DisassociateResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceInput>
    public typealias MOutput = OperationOutput<DisassociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceOutputError>
}

public struct DisassociateResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceInput>
    public typealias MOutput = OperationOutput<DisassociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceOutputError>
}

public struct DisassociateResourceInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?
    /// <p>The name or ID of the resource.</p>
    public let resource: String?
    /// <p>The type of the resource that is being disassociated.</p>
    public let resourceType: ResourceType?

    public init (
        application: String? = nil,
        resource: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.application = application
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct DisassociateResourceInputBody: Equatable {
}

extension DisassociateResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResourceOutputResponse(applicationArn: \(String(describing: applicationArn)), resourceArn: \(String(describing: resourceArn)))"}
}

extension DisassociateResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct DisassociateResourceOutputResponse: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application.</p>
    public let applicationArn: String?
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: String?

    public init (
        applicationArn: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct DisassociateResourceOutputResponseBody: Equatable {
    public let applicationArn: String?
    public let resourceArn: String?
}

extension DisassociateResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationArn
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationInput(application: \(String(describing: application)))"}
}

extension GetApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "GetApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationInput>
    public typealias MOutput = OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationInput>
    public typealias MOutput = OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationOutputError>
}

public struct GetApplicationInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?

    public init (
        application: String? = nil
    )
    {
        self.application = application
    }
}

struct GetApplicationInputBody: Equatable {
}

extension GetApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationOutputResponse(arn: \(String(describing: arn)), associatedResourceCount: \(String(describing: associatedResourceCount)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.associatedResourceCount = output.associatedResourceCount
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastUpdateTime = output.lastUpdateTime
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.associatedResourceCount = 0
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastUpdateTime = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetApplicationOutputResponse: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application across services.</p>
    public let arn: String?
    /// <p>The number of top-level resources that were registered as part of this application.</p>
    public let associatedResourceCount: Int
    /// <p>The ISO-8601 formatted timestamp of the moment when the application was created.</p>
    public let creationTime: Date?
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The identifier of the application.</p>
    public let id: String?
    /// <p>The ISO-8601 formatted timestamp of the moment when the application was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
    public let name: String?
    /// <p>Key-value pairs associated with the application.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        associatedResourceCount: Int = 0,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.associatedResourceCount = associatedResourceCount
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

struct GetApplicationOutputResponseBody: Equatable {
    public let id: String?
    public let arn: String?
    public let name: String?
    public let description: String?
    public let creationTime: Date?
    public let lastUpdateTime: Date?
    public let associatedResourceCount: Int
    public let tags: [String:String]?
}

extension GetApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case associatedResourceCount
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let associatedResourceCountDecoded = try containerValues.decode(Int.self, forKey: .associatedResourceCount)
        associatedResourceCount = associatedResourceCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetAttributeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAttributeGroupInput(attributeGroup: \(String(describing: attributeGroup)))"}
}

extension GetAttributeGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAttributeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttributeGroupInput>
    public typealias MOutput = OperationOutput<GetAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttributeGroupOutputError>
}

public struct GetAttributeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttributeGroupInput>
    public typealias MOutput = OperationOutput<GetAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttributeGroupOutputError>
}

public struct GetAttributeGroupInput: Equatable {
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: String?

    public init (
        attributeGroup: String? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct GetAttributeGroupInputBody: Equatable {
}

extension GetAttributeGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAttributeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttributeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttributeGroupOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttributeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAttributeGroupOutputResponse(arn: \(String(describing: arn)), attributes: \(String(describing: attributes)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetAttributeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.attributes = output.attributes
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastUpdateTime = output.lastUpdateTime
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.attributes = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastUpdateTime = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetAttributeGroupOutputResponse: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the attribute group across services.</p>
    public let arn: String?
    /// <p>A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.</p>
    public let attributes: String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was created.</p>
    public let creationTime: Date?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: String?
    /// <p>The identifier of the attribute group.</p>
    public let id: String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the attribute group.</p>
    public let name: String?
    /// <p>Key-value pairs associated with the attribute group.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        attributes: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

struct GetAttributeGroupOutputResponseBody: Equatable {
    public let id: String?
    public let arn: String?
    public let name: String?
    public let description: String?
    public let attributes: String?
    public let creationTime: Date?
    public let lastUpdateTime: Date?
    public let tags: [String:String]?
}

extension GetAttributeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case attributes
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributes)
        attributes = attributesDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is experiencing internal problems.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Equatable {
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Equatable {
}

extension ListApplicationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsOutputResponse(applications: \(String(describing: applications)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Equatable {
    /// <p>This list of applications.</p>
    public let applications: [ApplicationSummary]?
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?

    public init (
        applications: [ApplicationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Equatable {
    public let applications: [ApplicationSummary]?
    public let nextToken: String?
}

extension ListApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applications
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedAttributeGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedAttributeGroupsInput(application: \(String(describing: application)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedAttributeGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssociatedAttributeGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociatedAttributeGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedAttributeGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedAttributeGroupsInput>
    public typealias MOutput = OperationOutput<ListAssociatedAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedAttributeGroupsOutputError>
}

public struct ListAssociatedAttributeGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociatedAttributeGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedAttributeGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedAttributeGroupsInput>
    public typealias MOutput = OperationOutput<ListAssociatedAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedAttributeGroupsOutputError>
}

public struct ListAssociatedAttributeGroupsInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?

    public init (
        application: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.application = application
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociatedAttributeGroupsInputBody: Equatable {
}

extension ListAssociatedAttributeGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssociatedAttributeGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedAttributeGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedAttributeGroupsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedAttributeGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedAttributeGroupsOutputResponse(attributeGroups: \(String(describing: attributeGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedAttributeGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociatedAttributeGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributeGroups = output.attributeGroups
            self.nextToken = output.nextToken
        } else {
            self.attributeGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedAttributeGroupsOutputResponse: Equatable {
    /// <p>A list of attribute group IDs.</p>
    public let attributeGroups: [String]?
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?

    public init (
        attributeGroups: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributeGroups = attributeGroups
        self.nextToken = nextToken
    }
}

struct ListAssociatedAttributeGroupsOutputResponseBody: Equatable {
    public let attributeGroups: [String]?
    public let nextToken: String?
}

extension ListAssociatedAttributeGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeGroups
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeGroups)
        var attributeGroupsDecoded0:[String]? = nil
        if let attributeGroupsContainer = attributeGroupsContainer {
            attributeGroupsDecoded0 = [String]()
            for string0 in attributeGroupsContainer {
                if let string0 = string0 {
                    attributeGroupsDecoded0?.append(string0)
                }
            }
        }
        attributeGroups = attributeGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedResourcesInput(application: \(String(describing: application)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedResourcesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssociatedResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociatedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedResourcesInput>
    public typealias MOutput = OperationOutput<ListAssociatedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedResourcesOutputError>
}

public struct ListAssociatedResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociatedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedResourcesInput>
    public typealias MOutput = OperationOutput<ListAssociatedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedResourcesOutputError>
}

public struct ListAssociatedResourcesInput: Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: String?
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?

    public init (
        application: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.application = application
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociatedResourcesInputBody: Equatable {
}

extension ListAssociatedResourcesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssociatedResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedResourcesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resources: \(String(describing: resources)))"}
}

extension ListAssociatedResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociatedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListAssociatedResourcesOutputResponse: Equatable {
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?
    /// <p>Information about the resources.</p>
    public let resources: [ResourceInfo]?

    public init (
        nextToken: String? = nil,
        resources: [ResourceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListAssociatedResourcesOutputResponseBody: Equatable {
    public let resources: [ResourceInfo]?
    public let nextToken: String?
}

extension ListAssociatedResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([ResourceInfo?].self, forKey: .resources)
        var resourcesDecoded0:[ResourceInfo]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [ResourceInfo]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAttributeGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttributeGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAttributeGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAttributeGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAttributeGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttributeGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttributeGroupsInput>
    public typealias MOutput = OperationOutput<ListAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttributeGroupsOutputError>
}

public struct ListAttributeGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAttributeGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttributeGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttributeGroupsInput>
    public typealias MOutput = OperationOutput<ListAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttributeGroupsOutputError>
}

public struct ListAttributeGroupsInput: Equatable {
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsInputBody: Equatable {
}

extension ListAttributeGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAttributeGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttributeGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttributeGroupsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttributeGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttributeGroupsOutputResponse(attributeGroups: \(String(describing: attributeGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAttributeGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAttributeGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributeGroups = output.attributeGroups
            self.nextToken = output.nextToken
        } else {
            self.attributeGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttributeGroupsOutputResponse: Equatable {
    /// <p>This list of attribute groups.</p>
    public let attributeGroups: [AttributeGroupSummary]?
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: String?

    public init (
        attributeGroups: [AttributeGroupSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributeGroups = attributeGroups
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsOutputResponseBody: Equatable {
    public let attributeGroups: [AttributeGroupSummary]?
    public let nextToken: String?
}

extension ListAttributeGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeGroups
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupsContainer = try containerValues.decodeIfPresent([AttributeGroupSummary?].self, forKey: .attributeGroups)
        var attributeGroupsDecoded0:[AttributeGroupSummary]? = nil
        if let attributeGroupsContainer = attributeGroupsContainer {
            attributeGroupsDecoded0 = [AttributeGroupSummary]()
            for structure0 in attributeGroupsContainer {
                if let structure0 = structure0 {
                    attributeGroupsDecoded0?.append(structure0)
                }
            }
        }
        attributeGroups = attributeGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags on the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ResourceInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInfo(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>Information about the resource.</p>
public struct ResourceInfo: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the resource across services.</p>
    public let arn: String?
    /// <p>The name of the resource.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case cfnStack
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .cfnStack,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cfnStack: return "CFN_STACK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of resources per account has been reached.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SyncAction {
    case noAction
    case startSync
    case sdkUnknown(String)
}

extension SyncAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SyncAction] {
        return [
            .noAction,
            .startSync,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .noAction: return "NO_ACTION"
        case .startSync: return "START_SYNC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SyncAction(rawValue: rawValue) ?? SyncAction.sdkUnknown(rawValue)
    }
}

extension SyncResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SyncResourceInput(resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

extension SyncResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct SyncResourceInputHeadersMiddleware: Middleware {
    public let id: String = "SyncResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SyncResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SyncResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SyncResourceInput>
    public typealias MOutput = OperationOutput<SyncResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SyncResourceOutputError>
}

public struct SyncResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "SyncResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SyncResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SyncResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SyncResourceInput>
    public typealias MOutput = OperationOutput<SyncResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SyncResourceOutputError>
}

public struct SyncResourceInput: Equatable {
    /// <p>An entity you can work with and specify with a name or ID. Examples include an Amazon EC2 instance, an AWS CloudFormation stack, or an Amazon S3 bucket.</p>
    public let resource: String?
    /// <p>The type of resource of which the application will be associated.</p>
    public let resourceType: ResourceType?

    public init (
        resource: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct SyncResourceInputBody: Equatable {
}

extension SyncResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SyncResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SyncResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SyncResourceOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SyncResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SyncResourceOutputResponse(actionTaken: \(String(describing: actionTaken)), applicationArn: \(String(describing: applicationArn)), resourceArn: \(String(describing: resourceArn)))"}
}

extension SyncResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SyncResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionTaken = output.actionTaken
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.actionTaken = nil
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct SyncResourceOutputResponse: Equatable {
    /// <p>The results of the output if an application is associated with an ARN value, which could be <code>syncStarted</code> or None.</p>
    public let actionTaken: SyncAction?
    /// <p>The Amazon resource name (ARN) that specifies the application.</p>
    public let applicationArn: String?
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: String?

    public init (
        actionTaken: SyncAction? = nil,
        applicationArn: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.actionTaken = actionTaken
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct SyncResourceOutputResponseBody: Equatable {
    public let applicationArn: String?
    public let resourceArn: String?
    public let actionTaken: SyncAction?
}

extension SyncResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTaken
        case applicationArn
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let actionTakenDecoded = try containerValues.decodeIfPresent(SyncAction.self, forKey: .actionTaken)
        actionTaken = actionTakenDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: String?
    /// <p>A list of the tag keys to remove from the specified resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(application: \(String(describing: application)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>The name or ID of the application that will be updated.</p>
    public let application: String?
    /// <p>The new description of the application.</p>
    public let description: String?
    /// <p>The new name of the application. The name must be unique in the region in which you are updating the application.</p>
    public let name: String?

    public init (
        application: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.application = application
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse(application: \(String(describing: application)))"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Equatable {
    /// <p>The updated information of the application.</p>
    public let application: Application?

    public init (
        application: Application? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputResponseBody: Equatable {
    public let application: Application?
}

extension UpdateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Application.self, forKey: .application)
        application = applicationDecoded
    }
}

public struct UpdateAttributeGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAttributeGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAttributeGroupInput>
    public typealias MOutput = OperationOutput<UpdateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAttributeGroupOutputError>
}

extension UpdateAttributeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAttributeGroupInput(attributeGroup: \(String(describing: attributeGroup)), attributes: \(String(describing: attributes)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateAttributeGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case description
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAttributeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAttributeGroupInput>
    public typealias MOutput = OperationOutput<UpdateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAttributeGroupOutputError>
}

public struct UpdateAttributeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAttributeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAttributeGroupInput>
    public typealias MOutput = OperationOutput<UpdateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAttributeGroupOutputError>
}

public struct UpdateAttributeGroupInput: Equatable {
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: String?
    /// <p>A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.</p>
    public let attributes: String?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: String?
    /// <p>The new name of the attribute group. The name must be unique in the region in which you are
    ///        updating the attribute group.</p>
    public let name: String?

    public init (
        attributeGroup: String? = nil,
        attributes: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.attributeGroup = attributeGroup
        self.attributes = attributes
        self.description = description
        self.name = name
    }
}

struct UpdateAttributeGroupInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let attributes: String?
}

extension UpdateAttributeGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes
        case description
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension UpdateAttributeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAttributeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAttributeGroupOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAttributeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAttributeGroupOutputResponse(attributeGroup: \(String(describing: attributeGroup)))"}
}

extension UpdateAttributeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct UpdateAttributeGroupOutputResponse: Equatable {
    /// <p>The updated information of the attribute group.</p>
    public let attributeGroup: AttributeGroup?

    public init (
        attributeGroup: AttributeGroup? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct UpdateAttributeGroupOutputResponseBody: Equatable {
    public let attributeGroup: AttributeGroup?
}

extension UpdateAttributeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(AttributeGroup.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has invalid or missing parameters.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
