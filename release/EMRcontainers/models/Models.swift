// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CancelJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobRunInput(id: \(String(describing: id)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension CancelJobRunInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "CancelJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobRunInput>
    public typealias MOutput = OperationOutput<CancelJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobRunOutputError>
}

public struct CancelJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobRunInput>
    public typealias MOutput = OperationOutput<CancelJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobRunOutputError>
}

public struct CancelJobRunInput: Equatable {
    /// <p>The ID of the job run to cancel.</p>
    public let id: String?
    /// <p>The ID of the virtual cluster for which the job run will be canceled.</p>
    public let virtualClusterId: String?

    public init (
        id: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunInputBody: Equatable {
}

extension CancelJobRunInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobRunOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobRunOutputResponse(id: \(String(describing: id)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension CancelJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CancelJobRunOutputResponse: Equatable {
    /// <p>The output contains the ID of the cancelled job run.</p>
    public let id: String?
    /// <p>The output contains the virtual cluster ID for which the job run is cancelled.</p>
    public let virtualClusterId: String?

    public init (
        id: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunOutputResponseBody: Equatable {
    public let id: String?
    public let virtualClusterId: String?
}

extension CancelJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case virtualClusterId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension CloudWatchMonitoringConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logGroupName
        case logStreamNamePrefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logStreamNamePrefix = logStreamNamePrefix {
            try encodeContainer.encode(logStreamNamePrefix, forKey: .logStreamNamePrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let logStreamNamePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamNamePrefix)
        logStreamNamePrefix = logStreamNamePrefixDecoded
    }
}

extension CloudWatchMonitoringConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchMonitoringConfiguration(logGroupName: \(String(describing: logGroupName)), logStreamNamePrefix: \(String(describing: logStreamNamePrefix)))"}
}

/// <p>A configuration for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs.</p>
public struct CloudWatchMonitoringConfiguration: Equatable {
    /// <p>The name of the log group for log publishing.</p>
    public let logGroupName: String?
    /// <p>The specified name prefix for log streams.</p>
    public let logStreamNamePrefix: String?

    public init (
        logGroupName: String? = nil,
        logStreamNamePrefix: String? = nil
    )
    {
        self.logGroupName = logGroupName
        self.logStreamNamePrefix = logStreamNamePrefix
    }
}

extension Configuration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classification
        case configurations
        case properties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for configurationlist0 in configurations {
                try configurationsContainer.encode(configurationlist0)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .properties)
            for (dictKey0, sensitivepropertiesmap0) in properties {
                try propertiesContainer.encode(sensitivepropertiesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .properties)
        var propertiesDecoded0: [String:String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [String:String]()
            for (key0, string10240) in propertiesContainer {
                if let string10240 = string10240 {
                    propertiesDecoded0?[key0] = string10240
                }
            }
        }
        properties = propertiesDecoded0
        let configurationsContainer = try containerValues.decodeIfPresent([Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension Configuration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Configuration(classification: \(String(describing: classification)), configurations: \(String(describing: configurations)), properties: \(String(describing: properties)))"}
}

/// <p>A configuration specification to be used when provisioning virtual clusters, which can include configurations for applications and software bundled with Amazon EMR on EKS. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.</p>
public struct Configuration: Equatable {
    /// <p>The classification within a configuration.</p>
    public let classification: String?
    /// <p>A list of additional configurations to apply within a configuration object.</p>
    public let configurations: [Configuration]?
    /// <p>A set of properties specified within a configuration classification.</p>
    public let properties: [String:String]?

    public init (
        classification: String? = nil,
        configurations: [Configuration]? = nil,
        properties: [String:String]? = nil
    )
    {
        self.classification = classification
        self.configurations = configurations
        self.properties = properties
    }
}

extension ConfigurationOverrides: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationConfiguration
        case monitoringConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            var applicationConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationConfiguration)
            for configurationlist0 in applicationConfiguration {
                try applicationConfigurationContainer.encode(configurationlist0)
            }
        }
        if let monitoringConfiguration = monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationContainer = try containerValues.decodeIfPresent([Configuration?].self, forKey: .applicationConfiguration)
        var applicationConfigurationDecoded0:[Configuration]? = nil
        if let applicationConfigurationContainer = applicationConfigurationContainer {
            applicationConfigurationDecoded0 = [Configuration]()
            for structure0 in applicationConfigurationContainer {
                if let structure0 = structure0 {
                    applicationConfigurationDecoded0?.append(structure0)
                }
            }
        }
        applicationConfiguration = applicationConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension ConfigurationOverrides: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationOverrides(applicationConfiguration: \(String(describing: applicationConfiguration)), monitoringConfiguration: \(String(describing: monitoringConfiguration)))"}
}

/// <p>A configuration specification to be used to override existing configurations.</p>
public struct ConfigurationOverrides: Equatable {
    /// <p>The configurations for the application running by the job run. </p>
    public let applicationConfiguration: [Configuration]?
    /// <p>The configurations for monitoring.</p>
    public let monitoringConfiguration: MonitoringConfiguration?

    public init (
        applicationConfiguration: [Configuration]? = nil,
        monitoringConfiguration: MonitoringConfiguration? = nil
    )
    {
        self.applicationConfiguration = applicationConfiguration
        self.monitoringConfiguration = monitoringConfiguration
    }
}

extension ContainerInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eksInfo
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .eksInfo(eksInfo):
                if let eksInfo = eksInfo {
                    try container.encode(eksInfo, forKey: .eksInfo)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let eksInfoDecoded = try values.decodeIfPresent(EksInfo.self, forKey: .eksInfo)
        if let eksInfo = eksInfoDecoded {
            self = .eksInfo(eksInfo)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The information about the container used for a job run or a managed endpoint.</p>
public enum ContainerInfo: Equatable {
    /// <p>The information about the EKS cluster.</p>
    case eksInfo(EksInfo?)
    case sdkUnknown(String?)
}

extension ContainerProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case info
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let info = info {
            try encodeContainer.encode(info, forKey: .info)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ContainerProviderType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let infoDecoded = try containerValues.decodeIfPresent(ContainerInfo.self, forKey: .info)
        info = infoDecoded
    }
}

extension ContainerProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerProvider(id: \(String(describing: id)), info: \(String(describing: info)), type: \(String(describing: type)))"}
}

/// <p>The information about the container provider.</p>
public struct ContainerProvider: Equatable {
    /// <p>The ID of the container cluster.</p>
    public let id: String?
    /// <p>The information about the container cluster.</p>
    public let info: ContainerInfo?
    /// <p>The type of the container provider. EKS is the only supported type as of now.</p>
    public let type: ContainerProviderType?

    public init (
        id: String? = nil,
        info: ContainerInfo? = nil,
        type: ContainerProviderType? = nil
    )
    {
        self.id = id
        self.info = info
        self.type = type
    }
}

public enum ContainerProviderType {
    case eks
    case sdkUnknown(String)
}

extension ContainerProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContainerProviderType] {
        return [
            .eks,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eks: return "EKS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContainerProviderType(rawValue: rawValue) ?? ContainerProviderType.sdkUnknown(rawValue)
    }
}

public struct CreateManagedEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateManagedEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateManagedEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateManagedEndpointInput>
    public typealias MOutput = OperationOutput<CreateManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateManagedEndpointOutputError>
}

extension CreateManagedEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateManagedEndpointInput(certificateArn: \(String(describing: certificateArn)), clientToken: \(String(describing: clientToken)), configurationOverrides: \(String(describing: configurationOverrides)), executionRoleArn: \(String(describing: executionRoleArn)), name: \(String(describing: name)), releaseLabel: \(String(describing: releaseLabel)), tags: \(String(describing: tags)), type: \(String(describing: type)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension CreateManagedEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateManagedEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateManagedEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateManagedEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateManagedEndpointInput>
    public typealias MOutput = OperationOutput<CreateManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateManagedEndpointOutputError>
}

public struct CreateManagedEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateManagedEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateManagedEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateManagedEndpointInput>
    public typealias MOutput = OperationOutput<CreateManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateManagedEndpointOutputError>
}

public struct CreateManagedEndpointInput: Equatable {
    /// <p>The certificate ARN of the managed endpoint.</p>
    public let certificateArn: String?
    /// <p>The client idempotency token for this create call.</p>
    public var clientToken: String?
    /// <p>The configuration settings that will be used to override existing configurations.</p>
    public let configurationOverrides: ConfigurationOverrides?
    /// <p>The ARN of the execution role.</p>
    public let executionRoleArn: String?
    /// <p>The name of the managed endpoint.</p>
    public let name: String?
    /// <p>The Amazon EMR release version.</p>
    public let releaseLabel: String?
    /// <p>The tags of the managed endpoint.
    ///       </p>
    public let tags: [String:String]?
    /// <p>The type of the managed endpoint.</p>
    public let type: String?
    /// <p>The ID of the virtual cluster for which a managed endpoint is created.</p>
    public let virtualClusterId: String?

    public init (
        certificateArn: String? = nil,
        clientToken: String? = nil,
        configurationOverrides: ConfigurationOverrides? = nil,
        executionRoleArn: String? = nil,
        name: String? = nil,
        releaseLabel: String? = nil,
        tags: [String:String]? = nil,
        type: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.name = name
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.type = type
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointInputBody: Equatable {
    public let name: String?
    public let type: String?
    public let releaseLabel: String?
    public let executionRoleArn: String?
    public let certificateArn: String?
    public let configurationOverrides: ConfigurationOverrides?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateManagedEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateManagedEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateManagedEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateManagedEndpointOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateManagedEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateManagedEndpointOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension CreateManagedEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CreateManagedEndpointOutputResponse: Equatable {
    /// <p>The output contains the ARN of the managed endpoint.</p>
    public let arn: String?
    /// <p>The output contains the ID of the managed endpoint.</p>
    public let id: String?
    /// <p>The output contains the name of the managed endpoint.</p>
    public let name: String?
    /// <p>The output contains the ID of the virtual cluster.</p>
    public let virtualClusterId: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let arn: String?
    public let virtualClusterId: String?
}

extension CreateManagedEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

public struct CreateVirtualClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateVirtualClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualClusterInput>
    public typealias MOutput = OperationOutput<CreateVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualClusterOutputError>
}

extension CreateVirtualClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualClusterInput(clientToken: \(String(describing: clientToken)), containerProvider: \(String(describing: containerProvider)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateVirtualClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerProvider = containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateVirtualClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVirtualClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualClusterInput>
    public typealias MOutput = OperationOutput<CreateVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualClusterOutputError>
}

public struct CreateVirtualClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVirtualClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualClusterInput>
    public typealias MOutput = OperationOutput<CreateVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualClusterOutputError>
}

public struct CreateVirtualClusterInput: Equatable {
    /// <p>The client token of the virtual cluster.</p>
    public var clientToken: String?
    /// <p>The container provider of the virtual cluster.</p>
    public let containerProvider: ContainerProvider?
    /// <p>The specified name of the virtual cluster.</p>
    public let name: String?
    /// <p>The tags assigned to the virtual cluster.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        containerProvider: ContainerProvider? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerProvider = containerProvider
        self.name = name
        self.tags = tags
    }
}

struct CreateVirtualClusterInputBody: Equatable {
    public let name: String?
    public let containerProvider: ContainerProvider?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateVirtualClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVirtualClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualClusterOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualClusterOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension CreateVirtualClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateVirtualClusterOutputResponse: Equatable {
    /// <p>This output contains the ARN of virtual cluster.</p>
    public let arn: String?
    /// <p>This output contains the virtual cluster ID.</p>
    public let id: String?
    /// <p>This output contains the name of the virtual cluster.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

struct CreateVirtualClusterOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let arn: String?
}

extension CreateVirtualClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case id
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteManagedEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteManagedEndpointInput(id: \(String(describing: id)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension DeleteManagedEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteManagedEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteManagedEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteManagedEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteManagedEndpointInput>
    public typealias MOutput = OperationOutput<DeleteManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteManagedEndpointOutputError>
}

public struct DeleteManagedEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteManagedEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteManagedEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteManagedEndpointInput>
    public typealias MOutput = OperationOutput<DeleteManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteManagedEndpointOutputError>
}

public struct DeleteManagedEndpointInput: Equatable {
    /// <p>The ID of the managed endpoint.</p>
    public let id: String?
    /// <p>The ID of the endpoint's virtual cluster.</p>
    public let virtualClusterId: String?

    public init (
        id: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointInputBody: Equatable {
}

extension DeleteManagedEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteManagedEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteManagedEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteManagedEndpointOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteManagedEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteManagedEndpointOutputResponse(id: \(String(describing: id)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension DeleteManagedEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct DeleteManagedEndpointOutputResponse: Equatable {
    /// <p>The output displays the ID of the managed endpoint.</p>
    public let id: String?
    /// <p>The output displays the ID of the endpoint's virtual cluster.</p>
    public let virtualClusterId: String?

    public init (
        id: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointOutputResponseBody: Equatable {
    public let id: String?
    public let virtualClusterId: String?
}

extension DeleteManagedEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case virtualClusterId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension DeleteVirtualClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualClusterInput(id: \(String(describing: id)))"}
}

extension DeleteVirtualClusterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVirtualClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVirtualClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualClusterInput>
    public typealias MOutput = OperationOutput<DeleteVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualClusterOutputError>
}

public struct DeleteVirtualClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVirtualClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualClusterInput>
    public typealias MOutput = OperationOutput<DeleteVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualClusterOutputError>
}

public struct DeleteVirtualClusterInput: Equatable {
    /// <p>The ID of the virtual cluster that will be deleted.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterInputBody: Equatable {
}

extension DeleteVirtualClusterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVirtualClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualClusterOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualClusterOutputResponse(id: \(String(describing: id)))"}
}

extension DeleteVirtualClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteVirtualClusterOutputResponse: Equatable {
    /// <p>This output contains the ID of the virtual cluster that will be deleted. </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterOutputResponseBody: Equatable {
    public let id: String?
}

extension DeleteVirtualClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobRunInput(id: \(String(describing: id)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension DescribeJobRunInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobRunInput>
    public typealias MOutput = OperationOutput<DescribeJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobRunOutputError>
}

public struct DescribeJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobRunInput>
    public typealias MOutput = OperationOutput<DescribeJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobRunOutputError>
}

public struct DescribeJobRunInput: Equatable {
    /// <p>The ID of the job run request. </p>
    public let id: String?
    /// <p>The ID of the virtual cluster for which the job run is submitted.</p>
    public let virtualClusterId: String?

    public init (
        id: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeJobRunInputBody: Equatable {
}

extension DescribeJobRunInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobRunOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobRunOutputResponse(jobRun: \(String(describing: jobRun)))"}
}

extension DescribeJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobRun = output.jobRun
        } else {
            self.jobRun = nil
        }
    }
}

public struct DescribeJobRunOutputResponse: Equatable {
    /// <p>The output displays information about a job run.</p>
    public let jobRun: JobRun?

    public init (
        jobRun: JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

struct DescribeJobRunOutputResponseBody: Equatable {
    public let jobRun: JobRun?
}

extension DescribeJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobRun
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunDecoded = try containerValues.decodeIfPresent(JobRun.self, forKey: .jobRun)
        jobRun = jobRunDecoded
    }
}

extension DescribeManagedEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeManagedEndpointInput(id: \(String(describing: id)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension DescribeManagedEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeManagedEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeManagedEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeManagedEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeManagedEndpointInput>
    public typealias MOutput = OperationOutput<DescribeManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeManagedEndpointOutputError>
}

public struct DescribeManagedEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeManagedEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeManagedEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeManagedEndpointInput>
    public typealias MOutput = OperationOutput<DescribeManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeManagedEndpointOutputError>
}

public struct DescribeManagedEndpointInput: Equatable {
    /// <p>This output displays ID of the managed endpoint.</p>
    public let id: String?
    /// <p>The ID of the endpoint's virtual cluster.</p>
    public let virtualClusterId: String?

    public init (
        id: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeManagedEndpointInputBody: Equatable {
}

extension DescribeManagedEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeManagedEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeManagedEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeManagedEndpointOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeManagedEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeManagedEndpointOutputResponse(endpoint: \(String(describing: endpoint)))"}
}

extension DescribeManagedEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct DescribeManagedEndpointOutputResponse: Equatable {
    /// <p>This output displays information about a managed endpoint.</p>
    public let endpoint: Endpoint?

    public init (
        endpoint: Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DescribeManagedEndpointOutputResponseBody: Equatable {
    public let endpoint: Endpoint?
}

extension DescribeManagedEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoint
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension DescribeVirtualClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualClusterInput(id: \(String(describing: id)))"}
}

extension DescribeVirtualClusterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVirtualClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVirtualClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualClusterInput>
    public typealias MOutput = OperationOutput<DescribeVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualClusterOutputError>
}

public struct DescribeVirtualClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVirtualClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualClusterInput>
    public typealias MOutput = OperationOutput<DescribeVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualClusterOutputError>
}

public struct DescribeVirtualClusterInput: Equatable {
    /// <p>The ID of the virtual cluster that will be described.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeVirtualClusterInputBody: Equatable {
}

extension DescribeVirtualClusterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVirtualClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualClusterOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualClusterOutputResponse(virtualCluster: \(String(describing: virtualCluster)))"}
}

extension DescribeVirtualClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.virtualCluster = output.virtualCluster
        } else {
            self.virtualCluster = nil
        }
    }
}

public struct DescribeVirtualClusterOutputResponse: Equatable {
    /// <p>This output displays information about the specified virtual cluster.</p>
    public let virtualCluster: VirtualCluster?

    public init (
        virtualCluster: VirtualCluster? = nil
    )
    {
        self.virtualCluster = virtualCluster
    }
}

struct DescribeVirtualClusterOutputResponseBody: Equatable {
    public let virtualCluster: VirtualCluster?
}

extension DescribeVirtualClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualCluster
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClusterDecoded = try containerValues.decodeIfPresent(VirtualCluster.self, forKey: .virtualCluster)
        virtualCluster = virtualClusterDecoded
    }
}

extension EksInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namespace
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension EksInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EksInfo(namespace: \(String(describing: namespace)))"}
}

/// <p>The information about the EKS cluster.</p>
public struct EksInfo: Equatable {
    /// <p>The namespaces of the EKS cluster.</p>
    public let namespace: String?

    public init (
        namespace: String? = nil
    )
    {
        self.namespace = namespace
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case certificateArn
        case configurationOverrides
        case createdAt
        case executionRoleArn
        case id
        case name
        case releaseLabel
        case securityGroup
        case serverUrl
        case state
        case subnetIds
        case tags
        case type
        case virtualClusterId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let securityGroup = securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let serverUrl = serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let virtualClusterId = virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EndpointState.self, forKey: .state)
        state = stateDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(arn: \(String(describing: arn)), certificateArn: \(String(describing: certificateArn)), configurationOverrides: \(String(describing: configurationOverrides)), createdAt: \(String(describing: createdAt)), executionRoleArn: \(String(describing: executionRoleArn)), id: \(String(describing: id)), name: \(String(describing: name)), releaseLabel: \(String(describing: releaseLabel)), securityGroup: \(String(describing: securityGroup)), serverUrl: \(String(describing: serverUrl)), state: \(String(describing: state)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), type: \(String(describing: type)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

/// <p>This entity represents the endpoint that is managed by Amazon EMR on EKS.</p>
public struct Endpoint: Equatable {
    /// <p>The ARN of the endpoint.</p>
    public let arn: String?
    /// <p>The certificate ARN of the endpoint.</p>
    public let certificateArn: String?
    /// <p>The configuration settings that are used to override existing configurations for endpoints.</p>
    public let configurationOverrides: ConfigurationOverrides?
    /// <p>The date and time when the endpoint was created.</p>
    public let createdAt: Date?
    /// <p>The execution role ARN of the endpoint.</p>
    public let executionRoleArn: String?
    /// <p>The ID of the endpoint.</p>
    public let id: String?
    /// <p>The name of the endpoint.</p>
    public let name: String?
    /// <p>The EMR release version to be used for the endpoint.</p>
    public let releaseLabel: String?
    /// <p>The security group configuration of the endpoint.
    ///       </p>
    public let securityGroup: String?
    /// <p>The server URL of the endpoint.</p>
    public let serverUrl: String?
    /// <p>The state of the endpoint.</p>
    public let state: EndpointState?
    /// <p>The subnet IDs of the endpoint.
    ///       </p>
    public let subnetIds: [String]?
    /// <p>The tags of the endpoint.
    ///       </p>
    public let tags: [String:String]?
    /// <p>The type of the endpoint.</p>
    public let type: String?
    /// <p>The ID of the endpoint's virtual cluster.</p>
    public let virtualClusterId: String?

    public init (
        arn: String? = nil,
        certificateArn: String? = nil,
        configurationOverrides: ConfigurationOverrides? = nil,
        createdAt: Date? = nil,
        executionRoleArn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        releaseLabel: String? = nil,
        securityGroup: String? = nil,
        serverUrl: String? = nil,
        state: EndpointState? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil,
        type: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.arn = arn
        self.certificateArn = certificateArn
        self.configurationOverrides = configurationOverrides
        self.createdAt = createdAt
        self.executionRoleArn = executionRoleArn
        self.id = id
        self.name = name
        self.releaseLabel = releaseLabel
        self.securityGroup = securityGroup
        self.serverUrl = serverUrl
        self.state = state
        self.subnetIds = subnetIds
        self.tags = tags
        self.type = type
        self.virtualClusterId = virtualClusterId
    }
}

public enum EndpointState {
    case active
    case creating
    case terminated
    case terminatedWithErrors
    case terminating
    case sdkUnknown(String)
}

extension EndpointState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointState] {
        return [
            .active,
            .creating,
            .terminated,
            .terminatedWithErrors,
            .terminating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .terminated: return "TERMINATED"
        case .terminatedWithErrors: return "TERMINATED_WITH_ERRORS"
        case .terminating: return "TERMINATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointState(rawValue: rawValue) ?? EndpointState.sdkUnknown(rawValue)
    }
}

public enum FailureReason {
    case clusterUnavailable
    case internalError
    case userError
    case validationError
    case sdkUnknown(String)
}

extension FailureReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailureReason] {
        return [
            .clusterUnavailable,
            .internalError,
            .userError,
            .validationError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clusterUnavailable: return "CLUSTER_UNAVAILABLE"
        case .internalError: return "INTERNAL_ERROR"
        case .userError: return "USER_ERROR"
        case .validationError: return "VALIDATION_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailureReason(rawValue: rawValue) ?? FailureReason.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This is an internal server exception.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobDriver: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sparkSubmitJobDriver
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sparkSubmitJobDriver = sparkSubmitJobDriver {
            try encodeContainer.encode(sparkSubmitJobDriver, forKey: .sparkSubmitJobDriver)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sparkSubmitJobDriverDecoded = try containerValues.decodeIfPresent(SparkSubmitJobDriver.self, forKey: .sparkSubmitJobDriver)
        sparkSubmitJobDriver = sparkSubmitJobDriverDecoded
    }
}

extension JobDriver: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobDriver(sparkSubmitJobDriver: \(String(describing: sparkSubmitJobDriver)))"}
}

/// <p>Specify the driver that the job runs on.</p>
public struct JobDriver: Equatable {
    /// <p>The job driver parameters specified for spark submit.</p>
    public let sparkSubmitJobDriver: SparkSubmitJobDriver?

    public init (
        sparkSubmitJobDriver: SparkSubmitJobDriver? = nil
    )
    {
        self.sparkSubmitJobDriver = sparkSubmitJobDriver
    }
}

extension JobRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientToken
        case configurationOverrides
        case createdAt
        case createdBy
        case executionRoleArn
        case failureReason
        case finishedAt
        case id
        case jobDriver
        case name
        case releaseLabel
        case state
        case stateDetails
        case tags
        case virtualClusterId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let finishedAt = finishedAt {
            try encodeContainer.encode(finishedAt.timeIntervalSince1970, forKey: .finishedAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobDriver = jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let virtualClusterId = virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(JobRunState.self, forKey: .state)
        state = stateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let finishedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .finishedAt)
        finishedAt = finishedAtDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension JobRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobRun(arn: \(String(describing: arn)), clientToken: \(String(describing: clientToken)), configurationOverrides: \(String(describing: configurationOverrides)), createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), executionRoleArn: \(String(describing: executionRoleArn)), failureReason: \(String(describing: failureReason)), finishedAt: \(String(describing: finishedAt)), id: \(String(describing: id)), jobDriver: \(String(describing: jobDriver)), name: \(String(describing: name)), releaseLabel: \(String(describing: releaseLabel)), state: \(String(describing: state)), stateDetails: \(String(describing: stateDetails)), tags: \(String(describing: tags)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

/// <p>This entity describes a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS. </p>
public struct JobRun: Equatable {
    /// <p>The ARN of job run.</p>
    public let arn: String?
    /// <p>The client token used to start a job run.</p>
    public let clientToken: String?
    /// <p>The configuration settings that are used to override default configuration.</p>
    public let configurationOverrides: ConfigurationOverrides?
    /// <p>The date and time when the job run was created.</p>
    public let createdAt: Date?
    /// <p>The user who created the job run.</p>
    public let createdBy: String?
    /// <p>The execution role ARN of the job run.</p>
    public let executionRoleArn: String?
    /// <p>The reasons why the job run has failed.</p>
    public let failureReason: FailureReason?
    /// <p>The date and time when the job run has finished.</p>
    public let finishedAt: Date?
    /// <p>The ID of the job run.</p>
    public let id: String?
    /// <p>Parameters of job driver for the job run.</p>
    public let jobDriver: JobDriver?
    /// <p>The name of the job run.</p>
    public let name: String?
    /// <p>The release version of Amazon EMR.</p>
    public let releaseLabel: String?
    /// <p>The state of the job run. </p>
    public let state: JobRunState?
    /// <p>Additional details of the job run state.</p>
    public let stateDetails: String?
    /// <p>The assigned tags of the job run.</p>
    public let tags: [String:String]?
    /// <p>The ID of the job run's virtual cluster.</p>
    public let virtualClusterId: String?

    public init (
        arn: String? = nil,
        clientToken: String? = nil,
        configurationOverrides: ConfigurationOverrides? = nil,
        createdAt: Date? = nil,
        createdBy: String? = nil,
        executionRoleArn: String? = nil,
        failureReason: FailureReason? = nil,
        finishedAt: Date? = nil,
        id: String? = nil,
        jobDriver: JobDriver? = nil,
        name: String? = nil,
        releaseLabel: String? = nil,
        state: JobRunState? = nil,
        stateDetails: String? = nil,
        tags: [String:String]? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.executionRoleArn = executionRoleArn
        self.failureReason = failureReason
        self.finishedAt = finishedAt
        self.id = id
        self.jobDriver = jobDriver
        self.name = name
        self.releaseLabel = releaseLabel
        self.state = state
        self.stateDetails = stateDetails
        self.tags = tags
        self.virtualClusterId = virtualClusterId
    }
}

public enum JobRunState {
    case cancelled
    case cancelPending
    case completed
    case failed
    case pending
    case running
    case submitted
    case sdkUnknown(String)
}

extension JobRunState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobRunState] {
        return [
            .cancelled,
            .cancelPending,
            .completed,
            .failed,
            .pending,
            .running,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .cancelPending: return "CANCEL_PENDING"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .submitted: return "SUBMITTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
    }
}

extension ListJobRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobRunsInput(createdAfter: \(String(describing: createdAfter)), createdBefore: \(String(describing: createdBefore)), maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), states: \(String(describing: states)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension ListJobRunsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobRunsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobRunsInput>
    public typealias MOutput = OperationOutput<ListJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobRunsOutputError>
}

public struct ListJobRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = URLQueryItem(name: "name".urlPercentEncoding(), value: String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        if let createdBefore = input.operationInput.createdBefore {
            let createdBeforeQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdBeforeQueryItem)
        }
        if let createdAfter = input.operationInput.createdAfter {
            let createdAfterQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdAfterQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "states".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobRunsInput>
    public typealias MOutput = OperationOutput<ListJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobRunsOutputError>
}

public struct ListJobRunsInput: Equatable {
    /// <p>The date and time after which the job runs were submitted.</p>
    public let createdAfter: Date?
    /// <p>The date and time before which the job runs were submitted.</p>
    public let createdBefore: Date?
    /// <p>The maximum number of job runs that can be listed.</p>
    public let maxResults: Int?
    /// <p>The name of the job run.</p>
    public let name: String?
    /// <p>The token for the next set of job runs to return.</p>
    public let nextToken: String?
    /// <p>The states of the job run.</p>
    public let states: [JobRunState]?
    /// <p>The ID of the virtual cluster for which to list the job run. </p>
    public let virtualClusterId: String?

    public init (
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        states: [JobRunState]? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.states = states
        self.virtualClusterId = virtualClusterId
    }
}

struct ListJobRunsInputBody: Equatable {
}

extension ListJobRunsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobRunsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobRunsOutputResponse(jobRuns: \(String(describing: jobRuns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutputResponse: Equatable {
    /// <p>This output lists information about the specified job runs.</p>
    public let jobRuns: [JobRun]?
    /// <p>This output displays the token for the next set of job runs.</p>
    public let nextToken: String?

    public init (
        jobRuns: [JobRun]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputResponseBody: Equatable {
    public let jobRuns: [JobRun]?
    public let nextToken: String?
}

extension ListJobRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobRuns
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListManagedEndpointsInput(createdAfter: \(String(describing: createdAfter)), createdBefore: \(String(describing: createdBefore)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), states: \(String(describing: states)), types: \(String(describing: types)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension ListManagedEndpointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListManagedEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "ListManagedEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedEndpointsInput>
    public typealias MOutput = OperationOutput<ListManagedEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedEndpointsOutputError>
}

public struct ListManagedEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListManagedEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let types = input.operationInput.types {
            types.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "types".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let createdBefore = input.operationInput.createdBefore {
            let createdBeforeQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdBeforeQueryItem)
        }
        if let createdAfter = input.operationInput.createdAfter {
            let createdAfterQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdAfterQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "states".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedEndpointsInput>
    public typealias MOutput = OperationOutput<ListManagedEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedEndpointsOutputError>
}

public struct ListManagedEndpointsInput: Equatable {
    /// <p> The date and time after which the endpoints are created.</p>
    public let createdAfter: Date?
    /// <p>The date and time before which the endpoints are created.</p>
    public let createdBefore: Date?
    /// <p>The maximum number of managed endpoints that can be listed.</p>
    public let maxResults: Int?
    /// <p> The token for the next set of managed endpoints to return. </p>
    public let nextToken: String?
    /// <p>The states of the managed endpoints.</p>
    public let states: [EndpointState]?
    /// <p>The types of the managed endpoints.</p>
    public let types: [String]?
    /// <p>The ID of the virtual cluster.</p>
    public let virtualClusterId: String?

    public init (
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        states: [EndpointState]? = nil,
        types: [String]? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.types = types
        self.virtualClusterId = virtualClusterId
    }
}

struct ListManagedEndpointsInputBody: Equatable {
}

extension ListManagedEndpointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListManagedEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListManagedEndpointsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListManagedEndpointsOutputResponse(endpoints: \(String(describing: endpoints)), nextToken: \(String(describing: nextToken)))"}
}

extension ListManagedEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListManagedEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedEndpointsOutputResponse: Equatable {
    /// <p>The managed endpoints to be listed.</p>
    public let endpoints: [Endpoint]?
    /// <p> The token for the next set of endpoints to return. </p>
    public let nextToken: String?

    public init (
        endpoints: [Endpoint]? = nil,
        nextToken: String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListManagedEndpointsOutputResponseBody: Equatable {
    public let endpoints: [Endpoint]?
    public let nextToken: String?
}

extension ListManagedEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoints
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of tagged resources.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags assigned to resources.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVirtualClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualClustersInput(containerProviderId: \(String(describing: containerProviderId)), containerProviderType: \(String(describing: containerProviderType)), createdAfter: \(String(describing: createdAfter)), createdBefore: \(String(describing: createdBefore)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), states: \(String(describing: states)))"}
}

extension ListVirtualClustersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVirtualClustersInputHeadersMiddleware: Middleware {
    public let id: String = "ListVirtualClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualClustersInput>
    public typealias MOutput = OperationOutput<ListVirtualClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualClustersOutputError>
}

public struct ListVirtualClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVirtualClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerProviderId = input.operationInput.containerProviderId {
            let containerProviderIdQueryItem = URLQueryItem(name: "containerProviderId".urlPercentEncoding(), value: String(containerProviderId).urlPercentEncoding())
            input.builder.withQueryItem(containerProviderIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let containerProviderType = input.operationInput.containerProviderType {
            let containerProviderTypeQueryItem = URLQueryItem(name: "containerProviderType".urlPercentEncoding(), value: String(containerProviderType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(containerProviderTypeQueryItem)
        }
        if let createdBefore = input.operationInput.createdBefore {
            let createdBeforeQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdBeforeQueryItem)
        }
        if let createdAfter = input.operationInput.createdAfter {
            let createdAfterQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdAfterQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "states".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualClustersInput>
    public typealias MOutput = OperationOutput<ListVirtualClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualClustersOutputError>
}

public struct ListVirtualClustersInput: Equatable {
    /// <p>The container provider ID of the virtual cluster.</p>
    public let containerProviderId: String?
    /// <p>The container provider type of the virtual cluster. EKS is the only supported type as of now.</p>
    public let containerProviderType: ContainerProviderType?
    /// <p>The date and time after which the virtual clusters are created.</p>
    public let createdAfter: Date?
    /// <p>The date and time before which the virtual clusters are created.</p>
    public let createdBefore: Date?
    /// <p>The maximum number of virtual clusters that can be listed.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of virtual clusters to return. </p>
    public let nextToken: String?
    /// <p>The states of the requested virtual clusters.</p>
    public let states: [VirtualClusterState]?

    public init (
        containerProviderId: String? = nil,
        containerProviderType: ContainerProviderType? = nil,
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        states: [VirtualClusterState]? = nil
    )
    {
        self.containerProviderId = containerProviderId
        self.containerProviderType = containerProviderType
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListVirtualClustersInputBody: Equatable {
}

extension ListVirtualClustersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVirtualClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualClustersOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualClustersOutputResponse(nextToken: \(String(describing: nextToken)), virtualClusters: \(String(describing: virtualClusters)))"}
}

extension ListVirtualClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVirtualClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.virtualClusters = output.virtualClusters
        } else {
            self.nextToken = nil
            self.virtualClusters = nil
        }
    }
}

public struct ListVirtualClustersOutputResponse: Equatable {
    /// <p>This output displays the token for the next set of virtual clusters.</p>
    public let nextToken: String?
    /// <p>This output lists the specified virtual clusters.</p>
    public let virtualClusters: [VirtualCluster]?

    public init (
        nextToken: String? = nil,
        virtualClusters: [VirtualCluster]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualClusters = virtualClusters
    }
}

struct ListVirtualClustersOutputResponseBody: Equatable {
    public let virtualClusters: [VirtualCluster]?
    public let nextToken: String?
}

extension ListVirtualClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case virtualClusters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClustersContainer = try containerValues.decodeIfPresent([VirtualCluster?].self, forKey: .virtualClusters)
        var virtualClustersDecoded0:[VirtualCluster]? = nil
        if let virtualClustersContainer = virtualClustersContainer {
            virtualClustersDecoded0 = [VirtualCluster]()
            for structure0 in virtualClustersContainer {
                if let structure0 = structure0 {
                    virtualClustersDecoded0?.append(structure0)
                }
            }
        }
        virtualClusters = virtualClustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MonitoringConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchMonitoringConfiguration
        case persistentAppUI
        case s3MonitoringConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfiguration {
            try encodeContainer.encode(cloudWatchMonitoringConfiguration, forKey: .cloudWatchMonitoringConfiguration)
        }
        if let persistentAppUI = persistentAppUI {
            try encodeContainer.encode(persistentAppUI.rawValue, forKey: .persistentAppUI)
        }
        if let s3MonitoringConfiguration = s3MonitoringConfiguration {
            try encodeContainer.encode(s3MonitoringConfiguration, forKey: .s3MonitoringConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let persistentAppUIDecoded = try containerValues.decodeIfPresent(PersistentAppUI.self, forKey: .persistentAppUI)
        persistentAppUI = persistentAppUIDecoded
        let cloudWatchMonitoringConfigurationDecoded = try containerValues.decodeIfPresent(CloudWatchMonitoringConfiguration.self, forKey: .cloudWatchMonitoringConfiguration)
        cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfigurationDecoded
        let s3MonitoringConfigurationDecoded = try containerValues.decodeIfPresent(S3MonitoringConfiguration.self, forKey: .s3MonitoringConfiguration)
        s3MonitoringConfiguration = s3MonitoringConfigurationDecoded
    }
}

extension MonitoringConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonitoringConfiguration(cloudWatchMonitoringConfiguration: \(String(describing: cloudWatchMonitoringConfiguration)), persistentAppUI: \(String(describing: persistentAppUI)), s3MonitoringConfiguration: \(String(describing: s3MonitoringConfiguration)))"}
}

/// <p>Configuration setting for monitoring.</p>
public struct MonitoringConfiguration: Equatable {
    /// <p>Monitoring configurations for CloudWatch.</p>
    public let cloudWatchMonitoringConfiguration: CloudWatchMonitoringConfiguration?
    /// <p>Monitoring configurations for the persistent application UI. </p>
    public let persistentAppUI: PersistentAppUI?
    /// <p>Amazon S3 configuration for monitoring log publishing.</p>
    public let s3MonitoringConfiguration: S3MonitoringConfiguration?

    public init (
        cloudWatchMonitoringConfiguration: CloudWatchMonitoringConfiguration? = nil,
        persistentAppUI: PersistentAppUI? = nil,
        s3MonitoringConfiguration: S3MonitoringConfiguration? = nil
    )
    {
        self.cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfiguration
        self.persistentAppUI = persistentAppUI
        self.s3MonitoringConfiguration = s3MonitoringConfiguration
    }
}

public enum PersistentAppUI {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension PersistentAppUI : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PersistentAppUI] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PersistentAppUI(rawValue: rawValue) ?? PersistentAppUI.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3MonitoringConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logUri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logUri = logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUri)
        logUri = logUriDecoded
    }
}

extension S3MonitoringConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3MonitoringConfiguration(logUri: \(String(describing: logUri)))"}
}

/// <p> Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.</p>
public struct S3MonitoringConfiguration: Equatable {
    /// <p>Amazon S3 destination URI for log publishing.</p>
    public let logUri: String?

    public init (
        logUri: String? = nil
    )
    {
        self.logUri = logUri
    }
}

extension SparkSubmitJobDriver: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entryPoint
        case entryPointArguments
        case sparkSubmitParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let entryPointArguments = entryPointArguments {
            var entryPointArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPointArguments)
            for entrypointarguments0 in entryPointArguments {
                try entryPointArgumentsContainer.encode(entrypointarguments0)
            }
        }
        if let sparkSubmitParameters = sparkSubmitParameters {
            try encodeContainer.encode(sparkSubmitParameters, forKey: .sparkSubmitParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let entryPointArgumentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entryPointArguments)
        var entryPointArgumentsDecoded0:[String]? = nil
        if let entryPointArgumentsContainer = entryPointArgumentsContainer {
            entryPointArgumentsDecoded0 = [String]()
            for string0 in entryPointArgumentsContainer {
                if let string0 = string0 {
                    entryPointArgumentsDecoded0?.append(string0)
                }
            }
        }
        entryPointArguments = entryPointArgumentsDecoded0
        let sparkSubmitParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sparkSubmitParameters)
        sparkSubmitParameters = sparkSubmitParametersDecoded
    }
}

extension SparkSubmitJobDriver: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SparkSubmitJobDriver(entryPoint: \(String(describing: entryPoint)), entryPointArguments: \(String(describing: entryPointArguments)), sparkSubmitParameters: \(String(describing: sparkSubmitParameters)))"}
}

/// <p>The information about job driver for Spark submit.</p>
public struct SparkSubmitJobDriver: Equatable {
    /// <p>The entry point of job application.</p>
    public let entryPoint: String?
    /// <p>The arguments for job application.</p>
    public let entryPointArguments: [String]?
    /// <p>The Spark submit parameters that are used for job runs.</p>
    public let sparkSubmitParameters: String?

    public init (
        entryPoint: String? = nil,
        entryPointArguments: [String]? = nil,
        sparkSubmitParameters: String? = nil
    )
    {
        self.entryPoint = entryPoint
        self.entryPointArguments = entryPointArguments
        self.sparkSubmitParameters = sparkSubmitParameters
    }
}

public struct StartJobRunInputBodyMiddleware: Middleware {
    public let id: String = "StartJobRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

extension StartJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobRunInput(clientToken: \(String(describing: clientToken)), configurationOverrides: \(String(describing: configurationOverrides)), executionRoleArn: \(String(describing: executionRoleArn)), jobDriver: \(String(describing: jobDriver)), name: \(String(describing: name)), releaseLabel: \(String(describing: releaseLabel)), tags: \(String(describing: tags)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension StartJobRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case name
        case releaseLabel
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let jobDriver = jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

public struct StartJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

public struct StartJobRunInput: Equatable {
    /// <p>The client idempotency token of the job run request. </p>
    public var clientToken: String?
    /// <p>The configuration overrides for the job run.</p>
    public let configurationOverrides: ConfigurationOverrides?
    /// <p>The execution role ARN for the job run.</p>
    public let executionRoleArn: String?
    /// <p>The job driver for the job run.</p>
    public let jobDriver: JobDriver?
    /// <p>The name of the job run.</p>
    public let name: String?
    /// <p>The Amazon EMR release version to use for the job run.</p>
    public let releaseLabel: String?
    /// <p>The tags assigned to job runs.</p>
    public let tags: [String:String]?
    /// <p>The virtual cluster ID for which the job run request is submitted.</p>
    public let virtualClusterId: String?

    public init (
        clientToken: String? = nil,
        configurationOverrides: ConfigurationOverrides? = nil,
        executionRoleArn: String? = nil,
        jobDriver: JobDriver? = nil,
        name: String? = nil,
        releaseLabel: String? = nil,
        tags: [String:String]? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.jobDriver = jobDriver
        self.name = name
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunInputBody: Equatable {
    public let name: String?
    public let clientToken: String?
    public let executionRoleArn: String?
    public let releaseLabel: String?
    public let jobDriver: JobDriver?
    public let configurationOverrides: ConfigurationOverrides?
    public let tags: [String:String]?
}

extension StartJobRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case name
        case releaseLabel
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobRunOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobRunOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)), virtualClusterId: \(String(describing: virtualClusterId)))"}
}

extension StartJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct StartJobRunOutputResponse: Equatable {
    /// <p>This output lists the ARN of job run.</p>
    public let arn: String?
    /// <p>This output displays the started job run ID.</p>
    public let id: String?
    /// <p>This output displays the name of the started job run.</p>
    public let name: String?
    /// <p>This output displays the virtual cluster ID for which the job run was submitted.</p>
    public let virtualClusterId: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        virtualClusterId: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let arn: String?
    public let virtualClusterId: String?
}

extension StartJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of resources.</p>
    public let resourceArn: String?
    /// <p>The tags assigned to resources.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of resources.</p>
    public let resourceArn: String?
    /// <p>The tag keys of the resources.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are invalid parameters in the client request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VirtualCluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case containerProvider
        case createdAt
        case id
        case name
        case state
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerProvider = containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(VirtualClusterState.self, forKey: .state)
        state = stateDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension VirtualCluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualCluster(arn: \(String(describing: arn)), containerProvider: \(String(describing: containerProvider)), createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), name: \(String(describing: name)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>This entity describes a virtual cluster. A virtual cluster is a Kubernetes namespace that Amazon EMR is registered with. Amazon EMR uses virtual clusters to run jobs and host endpoints. Multiple virtual clusters can be backed by the same physical cluster. However, each virtual cluster maps to one namespace on an EKS cluster. Virtual clusters do not create any active resources that contribute to your bill or that require lifecycle management outside the service.</p>
public struct VirtualCluster: Equatable {
    /// <p>The ARN of the virtual cluster.</p>
    public let arn: String?
    /// <p>The container provider of the virtual cluster.</p>
    public let containerProvider: ContainerProvider?
    /// <p>The date and time when the virtual cluster is created.</p>
    public let createdAt: Date?
    /// <p>The ID of the virtual cluster.</p>
    public let id: String?
    /// <p>The name of the virtual cluster.</p>
    public let name: String?
    /// <p>The state of the virtual cluster.</p>
    public let state: VirtualClusterState?
    /// <p>The assigned tags of the virtual cluster.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        containerProvider: ContainerProvider? = nil,
        createdAt: Date? = nil,
        id: String? = nil,
        name: String? = nil,
        state: VirtualClusterState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.containerProvider = containerProvider
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
    }
}

public enum VirtualClusterState {
    case arrested
    case running
    case terminated
    case terminating
    case sdkUnknown(String)
}

extension VirtualClusterState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualClusterState] {
        return [
            .arrested,
            .running,
            .terminated,
            .terminating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .arrested: return "ARRESTED"
        case .running: return "RUNNING"
        case .terminated: return "TERMINATED"
        case .terminating: return "TERMINATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualClusterState(rawValue: rawValue) ?? VirtualClusterState.sdkUnknown(rawValue)
    }
}
