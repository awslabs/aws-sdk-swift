// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
        case eventType
        case eventValue
        case impression
        case itemId
        case properties
        case recommendationId
        case sentAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let eventValue = eventValue {
            try encodeContainer.encode(eventValue, forKey: .eventValue)
        }
        if let impression = impression {
            var impressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .impression)
            for impression0 in impression {
                try impressionContainer.encode(impression0)
            }
        }
        if let itemId = itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let sentAt = sentAt {
            try encodeContainer.encode(sentAt.timeIntervalSince1970, forKey: .sentAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventValueDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .eventValue)
        eventValue = eventValueDecoded
        let itemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
        let sentAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .sentAt)
        sentAt = sentAtDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let impressionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .impression)
        var impressionDecoded0:[String]? = nil
        if let impressionContainer = impressionContainer {
            impressionDecoded0 = [String]()
            for string0 in impressionContainer {
                if let string0 = string0 {
                    impressionDecoded0?.append(string0)
                }
            }
        }
        impression = impressionDecoded0
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(eventId: \(String(describing: eventId)), eventType: \(String(describing: eventType)), eventValue: \(String(describing: eventValue)), impression: \(String(describing: impression)), itemId: \(String(describing: itemId)), properties: \(String(describing: properties)), recommendationId: \(String(describing: recommendationId)), sentAt: \(String(describing: sentAt)))"}
}

/// <p>Represents user interaction event information sent using the
///       <code>PutEvents</code> API.</p>
public struct Event: Equatable {
    /// <p>An ID associated with the event. If an event ID is not provided, Amazon Personalize generates
    ///       a unique ID for the event. An event ID is not used as an input to the model. Amazon Personalize uses
    ///       the event ID to distinquish unique events. Any subsequent events after the first with the
    ///       same event ID are not used in model training.</p>
    public let eventId: String?
    /// <p>The type of event, such as click or download. This property corresponds to the <code>EVENT_TYPE</code>
    ///       field of your Interactions schema and depends on the types of events you are tracking.</p>
    public let eventType: String?
    /// <p>The event value that corresponds to the <code>EVENT_VALUE</code> field of the Interactions schema.</p>
    public let eventValue: Float?
    /// <p>A list of item IDs that represents the sequence of items you have shown the user. For example, <code>["itemId1", "itemId2", "itemId3"]</code>.</p>
    public let impression: [String]?
    /// <p>The item ID key that corresponds to the <code>ITEM_ID</code> field of the Interactions schema.</p>
    public let itemId: String?
    /// <p>A string map of event-specific data that you might choose to record. For example, if a
    ///       user rates a movie on your site, other than movie ID (<code>itemId</code>) and rating (<code>eventValue</code>)
    ///       , you might also send the number of movie ratings made by the user.</p>
    ///          <p>Each item in the map consists of a key-value pair. For example,</p>
    ///
    ///          <p>
    ///             <code>{"numberOfRatings": "12"}</code>
    ///          </p>
    ///          <p>The keys use camel case names that match the fields in the Interactions
    ///       schema. In the above example, the <code>numberOfRatings</code> would match the
    ///       'NUMBER_OF_RATINGS' field defined in the Interactions schema.</p>
    public let properties: String?
    /// <p>The ID of the recommendation.</p>
    public let recommendationId: String?
    /// <p>The timestamp (in Unix time) on the client side when the event occurred.</p>
    public let sentAt: Date?

    public init (
        eventId: String? = nil,
        eventType: String? = nil,
        eventValue: Float? = nil,
        impression: [String]? = nil,
        itemId: String? = nil,
        properties: String? = nil,
        recommendationId: String? = nil,
        sentAt: Date? = nil
    )
    {
        self.eventId = eventId
        self.eventType = eventType
        self.eventValue = eventValue
        self.impression = impression
        self.itemId = itemId
        self.properties = properties
        self.recommendationId = recommendationId
        self.sentAt = sentAt
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provide a valid value for the field or parameter.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Item: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case itemId
        case properties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemId = itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension Item: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Item(itemId: \(String(describing: itemId)), properties: \(String(describing: properties)))"}
}

/// <p>Represents item metadata added to an Items dataset using the
///       <code>PutItems</code> API. For more information see
///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/importing-items.html">Importing Items Incrementally</a>.
///     </p>
public struct Item: Equatable {
    /// <p>The ID associated with the item.</p>
    public let itemId: String?
    /// <p>A string map of item-specific metadata. Each element in the map consists of a key-value pair.
    ///       For example, <code>{"numberOfRatings": "12"}</code>.</p>
    ///          <p>The keys use camel case names that match the fields in the schema for the Items
    ///       dataset. In the previous example, the <code>numberOfRatings</code> matches the
    ///       'NUMBER_OF_RATINGS' field defined in the Items schema. For categorical string data, to include multiple categories for a single item,
    ///       separate each category with a pipe separator (<code>|</code>). For example, <code>\"Horror|Action\"</code>.</p>
    public let properties: String?

    public init (
        itemId: String? = nil,
        properties: String? = nil
    )
    {
        self.itemId = itemId
        self.properties = properties
    }
}

public struct PutEventsInputBodyMiddleware: Middleware {
    public let id: String = "PutEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

extension PutEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsInput(eventList: \(String(describing: eventList)), sessionId: \(String(describing: sessionId)), trackingId: \(String(describing: trackingId)), userId: \(String(describing: userId)))"}
}

extension PutEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventList
        case sessionId
        case trackingId
        case userId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventList = eventList {
            var eventListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventList)
            for eventlist0 in eventList {
                try eventListContainer.encode(eventlist0)
            }
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let trackingId = trackingId {
            try encodeContainer.encode(trackingId, forKey: .trackingId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct PutEventsInputHeadersMiddleware: Middleware {
    public let id: String = "PutEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

public struct PutEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

public struct PutEventsInput: Equatable {
    /// <p>A list of event data from the session.</p>
    public let eventList: [Event]?
    /// <p>The session ID associated with the user's visit. Your application generates the sessionId when a user first visits your website or uses your application.
    ///       Amazon Personalize uses the sessionId to associate events with the user before they log in. For more information, see
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/recording-events.html">Recording Events</a>.</p>
    public let sessionId: String?
    /// <p>The tracking ID for the event.
    ///       The ID is generated by a call to the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_CreateEventTracker.html">CreateEventTracker</a> API.</p>
    public let trackingId: String?
    /// <p>The user associated with the event.</p>
    public let userId: String?

    public init (
        eventList: [Event]? = nil,
        sessionId: String? = nil,
        trackingId: String? = nil,
        userId: String? = nil
    )
    {
        self.eventList = eventList
        self.sessionId = sessionId
        self.trackingId = trackingId
        self.userId = userId
    }
}

struct PutEventsInputBody: Equatable {
    public let trackingId: String?
    public let userId: String?
    public let sessionId: String?
    public let eventList: [Event]?
}

extension PutEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventList
        case sessionId
        case trackingId
        case userId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let eventListContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .eventList)
        var eventListDecoded0:[Event]? = nil
        if let eventListContainer = eventListContainer {
            eventListDecoded0 = [Event]()
            for structure0 in eventListContainer {
                if let structure0 = structure0 {
                    eventListDecoded0?.append(structure0)
                }
            }
        }
        eventList = eventListDecoded0
    }
}

extension PutEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsOutputResponse()"}
}

extension PutEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutEventsOutputResponse: Equatable {

    public init() {}
}

struct PutEventsOutputResponseBody: Equatable {
}

extension PutEventsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutItemsInputBodyMiddleware: Middleware {
    public let id: String = "PutItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutItemsInput>
    public typealias MOutput = OperationOutput<PutItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutItemsOutputError>
}

extension PutItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutItemsInput(datasetArn: \(String(describing: datasetArn)), items: \(String(describing: items)))"}
}

extension PutItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case items
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for itemlist0 in items {
                try itemsContainer.encode(itemlist0)
            }
        }
    }
}

public struct PutItemsInputHeadersMiddleware: Middleware {
    public let id: String = "PutItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutItemsInput>
    public typealias MOutput = OperationOutput<PutItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutItemsOutputError>
}

public struct PutItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutItemsInput>
    public typealias MOutput = OperationOutput<PutItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutItemsOutputError>
}

public struct PutItemsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Items dataset you are adding the item or items to.</p>
    public let datasetArn: String?
    /// <p>A list of item data.</p>
    public let items: [Item]?

    public init (
        datasetArn: String? = nil,
        items: [Item]? = nil
    )
    {
        self.datasetArn = datasetArn
        self.items = items
    }
}

struct PutItemsInputBody: Equatable {
    public let datasetArn: String?
    public let items: [Item]?
}

extension PutItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case items
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Item?].self, forKey: .items)
        var itemsDecoded0:[Item]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Item]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension PutItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutItemsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutItemsOutputResponse()"}
}

extension PutItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutItemsOutputResponse: Equatable {

    public init() {}
}

struct PutItemsOutputResponseBody: Equatable {
}

extension PutItemsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutUsersInputBodyMiddleware: Middleware {
    public let id: String = "PutUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUsersInput>
    public typealias MOutput = OperationOutput<PutUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUsersOutputError>
}

extension PutUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutUsersInput(datasetArn: \(String(describing: datasetArn)), users: \(String(describing: users)))"}
}

extension PutUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case users
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for userlist0 in users {
                try usersContainer.encode(userlist0)
            }
        }
    }
}

public struct PutUsersInputHeadersMiddleware: Middleware {
    public let id: String = "PutUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUsersInput>
    public typealias MOutput = OperationOutput<PutUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUsersOutputError>
}

public struct PutUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "PutUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutUsersInput>
    public typealias MOutput = OperationOutput<PutUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutUsersOutputError>
}

public struct PutUsersInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Users dataset you are adding the user or users to.</p>
    public let datasetArn: String?
    /// <p>A list of user data.</p>
    public let users: [User]?

    public init (
        datasetArn: String? = nil,
        users: [User]? = nil
    )
    {
        self.datasetArn = datasetArn
        self.users = users
    }
}

struct PutUsersInputBody: Equatable {
    public let datasetArn: String?
    public let users: [User]?
}

extension PutUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case users
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let usersContainer = try containerValues.decodeIfPresent([User?].self, forKey: .users)
        var usersDecoded0:[User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension PutUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutUsersOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutUsersOutputResponse()"}
}

extension PutUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutUsersOutputResponse: Equatable {

    public init() {}
}

struct PutUsersOutputResponseBody: Equatable {
}

extension PutUsersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Could not find the specified resource.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case properties
        case userId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(properties: \(String(describing: properties)), userId: \(String(describing: userId)))"}
}

/// <p>Represents user metadata added to a Users dataset using the
///       <code>PutUsers</code> API. For more information see
///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/importing-users.html">Importing Users Incrementally</a>.</p>
public struct User: Equatable {
    /// <p>A string map of user-specific metadata. Each element in the map consists of a key-value pair.
    ///       For example, <code>{"numberOfVideosWatched": "45"}</code>.</p>
    ///          <p>The keys use camel case names that match the fields in the schema for the Users
    ///       dataset. In the previous example, the <code>numberOfVideosWatched</code> matches the
    ///       'NUMBER_OF_VIDEOS_WATCHED' field defined in the Users schema. For categorical string data,
    ///       to include multiple categories for a single user, separate each category with a pipe separator (<code>|</code>).
    ///       For example, <code>\"Member|Frequent shopper\"</code>.</p>
    public let properties: String?
    /// <p>The ID associated with the user.</p>
    public let userId: String?

    public init (
        properties: String? = nil,
        userId: String? = nil
    )
    {
        self.properties = properties
        self.userId = userId
    }
}
