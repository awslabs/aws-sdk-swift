// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension AddProfilePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case principal
        case profileVersion
        case revisionId
        case statementId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension AddProfilePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions"
    }
}

public struct AddProfilePermissionInput: Swift.Equatable {
    /// The AWS Signer action permitted as part of cross-account permissions.
    /// This member is required.
    public var action: Swift.String?
    /// The AWS principal receiving cross-account permissions. This may be an IAM role or another AWS account ID.
    /// This member is required.
    public var principal: Swift.String?
    /// The human-readable name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The version of the signing profile.
    public var profileVersion: Swift.String?
    /// A unique identifier for the current profile revision.
    public var revisionId: Swift.String?
    /// A unique identifier for the cross-account permission statement.
    /// This member is required.
    public var statementId: Swift.String?

    public init (
        action: Swift.String? = nil,
        principal: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.principal = principal
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct AddProfilePermissionInputBody: Swift.Equatable {
    let profileVersion: Swift.String?
    let action: Swift.String?
    let principal: Swift.String?
    let revisionId: Swift.String?
    let statementId: Swift.String?
}

extension AddProfilePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case principal
        case profileVersion
        case revisionId
        case statementId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension AddProfilePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddProfilePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddProfilePermissionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddProfilePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddProfilePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.revisionId = output.revisionId
        } else {
            self.revisionId = nil
        }
    }
}

public struct AddProfilePermissionOutputResponse: Swift.Equatable {
    /// A unique identifier for the current profile revision.
    public var revisionId: Swift.String?

    public init (
        revisionId: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

struct AddProfilePermissionOutputResponseBody: Swift.Equatable {
    let revisionId: Swift.String?
}

extension AddProfilePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request contains invalid parameters for the ARN or tags. This exception also occurs when you call a tagging API on a cancelled signing profile.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CancelSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

public struct CancelSigningProfileInput: Swift.Equatable {
    /// The name of the signing profile to be canceled.
    /// This member is required.
    public var profileName: Swift.String?

    public init (
        profileName: Swift.String? = nil
    )
    {
        self.profileName = profileName
    }
}

struct CancelSigningProfileInputBody: Swift.Equatable {
}

extension CancelSigningProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelSigningProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSigningProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelSigningProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSigningProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelSigningProfileOutputResponse: Swift.Equatable {

}

extension SignerClientTypes {
    public enum Category: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsiot
        case sdkUnknown(Swift.String)

        public static var allCases: [Category] {
            return [
                .awsiot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsiot: return "AWSIoT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Category(rawValue: rawValue) ?? Category.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource encountered a conflicting state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DescribeSigningJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/signing-jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeSigningJobInput: Swift.Equatable {
    /// The ID of the signing job on input.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeSigningJobInputBody: Swift.Equatable {
}

extension DescribeSigningJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSigningJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSigningJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSigningJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSigningJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSigningJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completedAt = output.completedAt
            self.createdAt = output.createdAt
            self.jobId = output.jobId
            self.jobInvoker = output.jobInvoker
            self.jobOwner = output.jobOwner
            self.overrides = output.overrides
            self.platformDisplayName = output.platformDisplayName
            self.platformId = output.platformId
            self.profileName = output.profileName
            self.profileVersion = output.profileVersion
            self.requestedBy = output.requestedBy
            self.revocationRecord = output.revocationRecord
            self.signatureExpiresAt = output.signatureExpiresAt
            self.signedObject = output.signedObject
            self.signingMaterial = output.signingMaterial
            self.signingParameters = output.signingParameters
            self.source = output.source
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.completedAt = nil
            self.createdAt = nil
            self.jobId = nil
            self.jobInvoker = nil
            self.jobOwner = nil
            self.overrides = nil
            self.platformDisplayName = nil
            self.platformId = nil
            self.profileName = nil
            self.profileVersion = nil
            self.requestedBy = nil
            self.revocationRecord = nil
            self.signatureExpiresAt = nil
            self.signedObject = nil
            self.signingMaterial = nil
            self.signingParameters = nil
            self.source = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DescribeSigningJobOutputResponse: Swift.Equatable {
    /// Date and time that the signing job was completed.
    public var completedAt: ClientRuntime.Date?
    /// Date and time that the signing job was created.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the signing job on output.
    public var jobId: Swift.String?
    /// The IAM entity that initiated the signing job.
    public var jobInvoker: Swift.String?
    /// The AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// A list of any overrides that were applied to the signing operation.
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// A human-readable name for the signing platform associated with the signing job.
    public var platformDisplayName: Swift.String?
    /// The microcontroller platform to which your signed code image will be distributed.
    public var platformId: Swift.String?
    /// The name of the profile that initiated the signing operation.
    public var profileName: Swift.String?
    /// The version of the signing profile used to initiate the signing job.
    public var profileVersion: Swift.String?
    /// The IAM principal that requested the signing job.
    public var requestedBy: Swift.String?
    /// A revocation record if the signature generated by the signing job has been revoked. Contains a timestamp and the ID of the IAM entity that revoked the signature.
    public var revocationRecord: SignerClientTypes.SigningJobRevocationRecord?
    /// Thr expiration timestamp for the signature generated by the signing job.
    public var signatureExpiresAt: ClientRuntime.Date?
    /// Name of the S3 bucket where the signed code image is saved by code signing.
    public var signedObject: SignerClientTypes.SignedObject?
    /// The Amazon Resource Name (ARN) of your code signing certificate.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// Map of user-assigned key-value pairs used during signing. These values contain any information that you specified for use in your signing job.
    public var signingParameters: [Swift.String:Swift.String]?
    /// The object that contains the name of your S3 bucket or your raw code.
    public var source: SignerClientTypes.Source?
    /// Status of the signing job.
    public var status: SignerClientTypes.SigningStatus?
    /// String value that contains the status reason.
    public var statusReason: Swift.String?

    public init (
        completedAt: ClientRuntime.Date? = nil,
        createdAt: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobInvoker: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformDisplayName: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        requestedBy: Swift.String? = nil,
        revocationRecord: SignerClientTypes.SigningJobRevocationRecord? = nil,
        signatureExpiresAt: ClientRuntime.Date? = nil,
        signedObject: SignerClientTypes.SignedObject? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String:Swift.String]? = nil,
        source: SignerClientTypes.Source? = nil,
        status: SignerClientTypes.SigningStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.jobId = jobId
        self.jobInvoker = jobInvoker
        self.jobOwner = jobOwner
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.requestedBy = requestedBy
        self.revocationRecord = revocationRecord
        self.signatureExpiresAt = signatureExpiresAt
        self.signedObject = signedObject
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.source = source
        self.status = status
        self.statusReason = statusReason
    }
}

struct DescribeSigningJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let source: SignerClientTypes.Source?
    let signingMaterial: SignerClientTypes.SigningMaterial?
    let platformId: Swift.String?
    let platformDisplayName: Swift.String?
    let profileName: Swift.String?
    let profileVersion: Swift.String?
    let overrides: SignerClientTypes.SigningPlatformOverrides?
    let signingParameters: [Swift.String:Swift.String]?
    let createdAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
    let signatureExpiresAt: ClientRuntime.Date?
    let requestedBy: Swift.String?
    let status: SignerClientTypes.SigningStatus?
    let statusReason: Swift.String?
    let revocationRecord: SignerClientTypes.SigningJobRevocationRecord?
    let signedObject: SignerClientTypes.SignedObject?
    let jobOwner: Swift.String?
    let jobInvoker: Swift.String?
}

extension DescribeSigningJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt
        case createdAt
        case jobId
        case jobInvoker
        case jobOwner
        case overrides
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case requestedBy
        case revocationRecord
        case signatureExpiresAt
        case signedObject
        case signingMaterial
        case signingParameters
        case source
        case status
        case statusReason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let signatureExpiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .signatureExpiresAt)
        signatureExpiresAt = signatureExpiresAtDecoded
        let requestedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestedBy)
        requestedBy = requestedByDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let revocationRecordDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningJobRevocationRecord.self, forKey: .revocationRecord)
        revocationRecord = revocationRecordDecoded
        let signedObjectDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignedObject.self, forKey: .signedObject)
        signedObject = signedObjectDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let jobInvokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobInvoker)
        jobInvoker = jobInvokerDecoded
    }
}

extension SignerClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(SignerClientTypes.S3Destination.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension SignerClientTypes {
    /// Points to an S3Destination object that contains information about your S3 bucket.
    public struct Destination: Swift.Equatable {
        /// The S3Destination object.
        public var s3: SignerClientTypes.S3Destination?

        public init (
            s3: SignerClientTypes.S3Destination? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension SignerClientTypes {
    public enum EncryptionAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecdsa
        case rsa
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionAlgorithm] {
            return [
                .ecdsa,
                .rsa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecdsa: return "ECDSA"
            case .rsa: return "RSA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionAlgorithm(rawValue: rawValue) ?? EncryptionAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes.EncryptionAlgorithmOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for encryptionalgorithms0 in allowedValues {
                try allowedValuesContainer.encode(encryptionalgorithms0.rawValue)
            }
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue.rawValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([SignerClientTypes.EncryptionAlgorithm?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[SignerClientTypes.EncryptionAlgorithm]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [SignerClientTypes.EncryptionAlgorithm]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(SignerClientTypes.EncryptionAlgorithm.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SignerClientTypes {
    /// The encryption algorithm options that are available to a code signing job.
    public struct EncryptionAlgorithmOptions: Swift.Equatable {
        /// The set of accepted encryption algorithms that are allowed in a code signing job.
        /// This member is required.
        public var allowedValues: [SignerClientTypes.EncryptionAlgorithm]?
        /// The default encryption algorithm that is used by a code signing job.
        /// This member is required.
        public var defaultValue: SignerClientTypes.EncryptionAlgorithm?

        public init (
            allowedValues: [SignerClientTypes.EncryptionAlgorithm]? = nil,
            defaultValue: SignerClientTypes.EncryptionAlgorithm? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }
    }

}

extension GetSigningPlatformInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let platformId = platformId else {
            return nil
        }
        return "/signing-platforms/\(platformId.urlPercentEncoding())"
    }
}

public struct GetSigningPlatformInput: Swift.Equatable {
    /// The ID of the target signing platform.
    /// This member is required.
    public var platformId: Swift.String?

    public init (
        platformId: Swift.String? = nil
    )
    {
        self.platformId = platformId
    }
}

struct GetSigningPlatformInputBody: Swift.Equatable {
}

extension GetSigningPlatformInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSigningPlatformOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSigningPlatformOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSigningPlatformOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSigningPlatformOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSigningPlatformOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.category = output.category
            self.displayName = output.displayName
            self.maxSizeInMB = output.maxSizeInMB
            self.partner = output.partner
            self.platformId = output.platformId
            self.revocationSupported = output.revocationSupported
            self.signingConfiguration = output.signingConfiguration
            self.signingImageFormat = output.signingImageFormat
            self.target = output.target
        } else {
            self.category = nil
            self.displayName = nil
            self.maxSizeInMB = 0
            self.partner = nil
            self.platformId = nil
            self.revocationSupported = false
            self.signingConfiguration = nil
            self.signingImageFormat = nil
            self.target = nil
        }
    }
}

public struct GetSigningPlatformOutputResponse: Swift.Equatable {
    /// The category type of the target signing platform.
    public var category: SignerClientTypes.Category?
    /// The display name of the target signing platform.
    public var displayName: Swift.String?
    /// The maximum size (in MB) of the payload that can be signed by the target platform.
    public var maxSizeInMB: Swift.Int
    /// A list of partner entities that use the target signing platform.
    public var partner: Swift.String?
    /// The ID of the target signing platform.
    public var platformId: Swift.String?
    /// A flag indicating whether signatures generated for the signing platform can be revoked.
    public var revocationSupported: Swift.Bool
    /// A list of configurations applied to the target platform at signing.
    public var signingConfiguration: SignerClientTypes.SigningConfiguration?
    /// The format of the target platform's signing image.
    public var signingImageFormat: SignerClientTypes.SigningImageFormat?
    /// The validation template that is used by the target signing platform.
    public var target: Swift.String?

    public init (
        category: SignerClientTypes.Category? = nil,
        displayName: Swift.String? = nil,
        maxSizeInMB: Swift.Int = 0,
        partner: Swift.String? = nil,
        platformId: Swift.String? = nil,
        revocationSupported: Swift.Bool = false,
        signingConfiguration: SignerClientTypes.SigningConfiguration? = nil,
        signingImageFormat: SignerClientTypes.SigningImageFormat? = nil,
        target: Swift.String? = nil
    )
    {
        self.category = category
        self.displayName = displayName
        self.maxSizeInMB = maxSizeInMB
        self.partner = partner
        self.platformId = platformId
        self.revocationSupported = revocationSupported
        self.signingConfiguration = signingConfiguration
        self.signingImageFormat = signingImageFormat
        self.target = target
    }
}

struct GetSigningPlatformOutputResponseBody: Swift.Equatable {
    let platformId: Swift.String?
    let displayName: Swift.String?
    let partner: Swift.String?
    let target: Swift.String?
    let category: SignerClientTypes.Category?
    let signingConfiguration: SignerClientTypes.SigningConfiguration?
    let signingImageFormat: SignerClientTypes.SigningImageFormat?
    let maxSizeInMB: Swift.Int
    let revocationSupported: Swift.Bool
}

extension GetSigningPlatformOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case displayName
        case maxSizeInMB
        case partner
        case platformId
        case revocationSupported
        case signingConfiguration
        case signingImageFormat
        case target
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let partnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partner)
        partner = partnerDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Category.self, forKey: .category)
        category = categoryDecoded
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningConfiguration.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
        let maxSizeInMBDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxSizeInMB)
        maxSizeInMB = maxSizeInMBDecoded
        let revocationSupportedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .revocationSupported)
        revocationSupported = revocationSupportedDecoded
    }
}

extension GetSigningProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let profileOwner = profileOwner {
            let profileOwnerQueryItem = ClientRuntime.URLQueryItem(name: "profileOwner".urlPercentEncoding(), value: Swift.String(profileOwner).urlPercentEncoding())
            items.append(profileOwnerQueryItem)
        }
        return items
    }
}

extension GetSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

public struct GetSigningProfileInput: Swift.Equatable {
    /// The name of the target signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the profile owner.
    public var profileOwner: Swift.String?

    public init (
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil
    )
    {
        self.profileName = profileName
        self.profileOwner = profileOwner
    }
}

struct GetSigningProfileInputBody: Swift.Equatable {
}

extension GetSigningProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSigningProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSigningProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSigningProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSigningProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSigningProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.overrides = output.overrides
            self.platformDisplayName = output.platformDisplayName
            self.platformId = output.platformId
            self.profileName = output.profileName
            self.profileVersion = output.profileVersion
            self.profileVersionArn = output.profileVersionArn
            self.revocationRecord = output.revocationRecord
            self.signatureValidityPeriod = output.signatureValidityPeriod
            self.signingMaterial = output.signingMaterial
            self.signingParameters = output.signingParameters
            self.status = output.status
            self.statusReason = output.statusReason
            self.tags = output.tags
        } else {
            self.arn = nil
            self.overrides = nil
            self.platformDisplayName = nil
            self.platformId = nil
            self.profileName = nil
            self.profileVersion = nil
            self.profileVersionArn = nil
            self.revocationRecord = nil
            self.signatureValidityPeriod = nil
            self.signingMaterial = nil
            self.signingParameters = nil
            self.status = nil
            self.statusReason = nil
            self.tags = nil
        }
    }
}

public struct GetSigningProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    public var arn: Swift.String?
    /// A list of overrides applied by the target signing profile for signing operations.
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// A human-readable name for the signing platform associated with the signing profile.
    public var platformDisplayName: Swift.String?
    /// The ID of the platform that is used by the target signing profile.
    public var platformId: Swift.String?
    /// The name of the target signing profile.
    public var profileName: Swift.String?
    /// The current version of the signing profile.
    public var profileVersion: Swift.String?
    /// The signing profile ARN, including the profile version.
    public var profileVersionArn: Swift.String?
    /// Revocation information for a signing profile.
    public var revocationRecord: SignerClientTypes.SigningProfileRevocationRecord?
    /// The validity period for a signing job.
    public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    /// The ARN of the certificate that the target profile uses for signing operations.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// A map of key-value pairs for signing operations that is attached to the target signing profile.
    public var signingParameters: [Swift.String:Swift.String]?
    /// The status of the target signing profile.
    public var status: SignerClientTypes.SigningProfileStatus?
    /// Reason for the status of the target signing profile.
    public var statusReason: Swift.String?
    /// A list of tags associated with the signing profile.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformDisplayName: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil,
        revocationRecord: SignerClientTypes.SigningProfileRevocationRecord? = nil,
        signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String:Swift.String]? = nil,
        status: SignerClientTypes.SigningProfileStatus? = nil,
        statusReason: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
        self.revocationRecord = revocationRecord
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
    }
}

struct GetSigningProfileOutputResponseBody: Swift.Equatable {
    let profileName: Swift.String?
    let profileVersion: Swift.String?
    let profileVersionArn: Swift.String?
    let revocationRecord: SignerClientTypes.SigningProfileRevocationRecord?
    let signingMaterial: SignerClientTypes.SigningMaterial?
    let platformId: Swift.String?
    let platformDisplayName: Swift.String?
    let signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    let overrides: SignerClientTypes.SigningPlatformOverrides?
    let signingParameters: [Swift.String:Swift.String]?
    let status: SignerClientTypes.SigningProfileStatus?
    let statusReason: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetSigningProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case overrides
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case profileVersionArn
        case revocationRecord
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case status
        case statusReason
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
        let revocationRecordDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningProfileRevocationRecord.self, forKey: .revocationRecord)
        revocationRecord = revocationRecordDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningProfileStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SignerClientTypes {
    public enum HashAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [HashAlgorithm] {
            return [
                .sha1,
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HashAlgorithm(rawValue: rawValue) ?? HashAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes.HashAlgorithmOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for hashalgorithms0 in allowedValues {
                try allowedValuesContainer.encode(hashalgorithms0.rawValue)
            }
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue.rawValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([SignerClientTypes.HashAlgorithm?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[SignerClientTypes.HashAlgorithm]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [SignerClientTypes.HashAlgorithm]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(SignerClientTypes.HashAlgorithm.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SignerClientTypes {
    /// The hash algorithms that are available to a code signing job.
    public struct HashAlgorithmOptions: Swift.Equatable {
        /// The set of accepted hash algorithms allowed in a code signing job.
        /// This member is required.
        public var allowedValues: [SignerClientTypes.HashAlgorithm]?
        /// The default hash algorithm that is used in a code signing job.
        /// This member is required.
        public var defaultValue: SignerClientTypes.HashAlgorithm?

        public init (
            allowedValues: [SignerClientTypes.HashAlgorithm]? = nil,
            defaultValue: SignerClientTypes.HashAlgorithm? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }
    }

}

extension SignerClientTypes {
    public enum ImageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case jsondetached
        case jsonembedded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFormat] {
            return [
                .json,
                .jsondetached,
                .jsonembedded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .jsondetached: return "JSONDetached"
            case .jsonembedded: return "JSONEmbedded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFormat(rawValue: rawValue) ?? ImageFormat.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error occurred.
public struct InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ListProfilePermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListProfilePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions"
    }
}

public struct ListProfilePermissionsInput: Swift.Equatable {
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?
    /// Name of the signing profile containing the cross-account permissions.
    /// This member is required.
    public var profileName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        profileName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.profileName = profileName
    }
}

struct ListProfilePermissionsInputBody: Swift.Equatable {
}

extension ListProfilePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfilePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfilePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfilePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProfilePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
            self.policySizeBytes = output.policySizeBytes
            self.revisionId = output.revisionId
        } else {
            self.nextToken = nil
            self.permissions = nil
            self.policySizeBytes = 0
            self.revisionId = nil
        }
    }
}

public struct ListProfilePermissionsOutputResponse: Swift.Equatable {
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?
    /// List of permissions associated with the Signing Profile.
    public var permissions: [SignerClientTypes.Permission]?
    /// Total size of the policy associated with the Signing Profile in bytes.
    public var policySizeBytes: Swift.Int
    /// The identifier for the current revision of profile permissions.
    public var revisionId: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [SignerClientTypes.Permission]? = nil,
        policySizeBytes: Swift.Int = 0,
        revisionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
        self.policySizeBytes = policySizeBytes
        self.revisionId = revisionId
    }
}

struct ListProfilePermissionsOutputResponseBody: Swift.Equatable {
    let revisionId: Swift.String?
    let policySizeBytes: Swift.Int
    let permissions: [SignerClientTypes.Permission]?
    let nextToken: Swift.String?
}

extension ListProfilePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
        case policySizeBytes
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let policySizeBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .policySizeBytes)
        policySizeBytes = policySizeBytesDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([SignerClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[SignerClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [SignerClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSigningJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if isRevoked != false {
            let isRevokedQueryItem = ClientRuntime.URLQueryItem(name: "isRevoked".urlPercentEncoding(), value: Swift.String(isRevoked).urlPercentEncoding())
            items.append(isRevokedQueryItem)
        }
        if let requestedBy = requestedBy {
            let requestedByQueryItem = ClientRuntime.URLQueryItem(name: "requestedBy".urlPercentEncoding(), value: Swift.String(requestedBy).urlPercentEncoding())
            items.append(requestedByQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let signatureExpiresBefore = signatureExpiresBefore {
            let signatureExpiresBeforeQueryItem = ClientRuntime.URLQueryItem(name: "signatureExpiresBefore".urlPercentEncoding(), value: Swift.String(signatureExpiresBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(signatureExpiresBeforeQueryItem)
        }
        if let jobInvoker = jobInvoker {
            let jobInvokerQueryItem = ClientRuntime.URLQueryItem(name: "jobInvoker".urlPercentEncoding(), value: Swift.String(jobInvoker).urlPercentEncoding())
            items.append(jobInvokerQueryItem)
        }
        if let platformId = platformId {
            let platformIdQueryItem = ClientRuntime.URLQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
            items.append(platformIdQueryItem)
        }
        if let signatureExpiresAfter = signatureExpiresAfter {
            let signatureExpiresAfterQueryItem = ClientRuntime.URLQueryItem(name: "signatureExpiresAfter".urlPercentEncoding(), value: Swift.String(signatureExpiresAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(signatureExpiresAfterQueryItem)
        }
        if let status = status {
            let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSigningJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-jobs"
    }
}

public struct ListSigningJobsInput: Swift.Equatable {
    /// Filters results to return only signing jobs with revoked signatures.
    public var isRevoked: Swift.Bool
    /// Filters results to return only signing jobs initiated by a specified IAM entity.
    public var jobInvoker: Swift.String?
    /// Specifies the maximum number of items to return in the response. Use this parameter when paginating results. If additional items exist beyond the number you specify, the nextToken element is set in the response. Use the nextToken value in a subsequent request to retrieve additional items.
    public var maxResults: Swift.Int?
    /// String for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// The ID of microcontroller platform that you specified for the distribution of your code image.
    public var platformId: Swift.String?
    /// The IAM principal that requested the signing job.
    public var requestedBy: Swift.String?
    /// Filters results to return only signing jobs with signatures expiring after a specified timestamp.
    public var signatureExpiresAfter: ClientRuntime.Date?
    /// Filters results to return only signing jobs with signatures expiring before a specified timestamp.
    public var signatureExpiresBefore: ClientRuntime.Date?
    /// A status value with which to filter your results.
    public var status: SignerClientTypes.SigningStatus?

    public init (
        isRevoked: Swift.Bool = false,
        jobInvoker: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        platformId: Swift.String? = nil,
        requestedBy: Swift.String? = nil,
        signatureExpiresAfter: ClientRuntime.Date? = nil,
        signatureExpiresBefore: ClientRuntime.Date? = nil,
        status: SignerClientTypes.SigningStatus? = nil
    )
    {
        self.isRevoked = isRevoked
        self.jobInvoker = jobInvoker
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.requestedBy = requestedBy
        self.signatureExpiresAfter = signatureExpiresAfter
        self.signatureExpiresBefore = signatureExpiresBefore
        self.status = status
    }
}

struct ListSigningJobsInputBody: Swift.Equatable {
}

extension ListSigningJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSigningJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSigningJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSigningJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSigningJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListSigningJobsOutputResponse: Swift.Equatable {
    /// A list of your signing jobs.
    public var jobs: [SignerClientTypes.SigningJob]?
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        jobs: [SignerClientTypes.SigningJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListSigningJobsOutputResponseBody: Swift.Equatable {
    let jobs: [SignerClientTypes.SigningJob]?
    let nextToken: Swift.String?
}

extension ListSigningJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([SignerClientTypes.SigningJob?].self, forKey: .jobs)
        var jobsDecoded0:[SignerClientTypes.SigningJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [SignerClientTypes.SigningJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSigningPlatformsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let partner = partner {
            let partnerQueryItem = ClientRuntime.URLQueryItem(name: "partner".urlPercentEncoding(), value: Swift.String(partner).urlPercentEncoding())
            items.append(partnerQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let category = category {
            let categoryQueryItem = ClientRuntime.URLQueryItem(name: "category".urlPercentEncoding(), value: Swift.String(category).urlPercentEncoding())
            items.append(categoryQueryItem)
        }
        if let target = target {
            let targetQueryItem = ClientRuntime.URLQueryItem(name: "target".urlPercentEncoding(), value: Swift.String(target).urlPercentEncoding())
            items.append(targetQueryItem)
        }
        return items
    }
}

extension ListSigningPlatformsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-platforms"
    }
}

public struct ListSigningPlatformsInput: Swift.Equatable {
    /// The category type of a signing platform.
    public var category: Swift.String?
    /// The maximum number of results to be returned by this operation.
    public var maxResults: Swift.Int?
    /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// Any partner entities connected to a signing platform.
    public var partner: Swift.String?
    /// The validation template that is used by the target signing platform.
    public var target: Swift.String?

    public init (
        category: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        partner: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.category = category
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partner = partner
        self.target = target
    }
}

struct ListSigningPlatformsInputBody: Swift.Equatable {
}

extension ListSigningPlatformsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSigningPlatformsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSigningPlatformsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSigningPlatformsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningPlatformsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSigningPlatformsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.platforms = output.platforms
        } else {
            self.nextToken = nil
            self.platforms = nil
        }
    }
}

public struct ListSigningPlatformsOutputResponse: Swift.Equatable {
    /// Value for specifying the next set of paginated results to return.
    public var nextToken: Swift.String?
    /// A list of all platforms that match the request parameters.
    public var platforms: [SignerClientTypes.SigningPlatform]?

    public init (
        nextToken: Swift.String? = nil,
        platforms: [SignerClientTypes.SigningPlatform]? = nil
    )
    {
        self.nextToken = nextToken
        self.platforms = platforms
    }
}

struct ListSigningPlatformsOutputResponseBody: Swift.Equatable {
    let platforms: [SignerClientTypes.SigningPlatform]?
    let nextToken: Swift.String?
}

extension ListSigningPlatformsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case platforms
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformsContainer = try containerValues.decodeIfPresent([SignerClientTypes.SigningPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[SignerClientTypes.SigningPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [SignerClientTypes.SigningPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSigningProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if includeCanceled != false {
            let includeCanceledQueryItem = ClientRuntime.URLQueryItem(name: "includeCanceled".urlPercentEncoding(), value: Swift.String(includeCanceled).urlPercentEncoding())
            items.append(includeCanceledQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let statuses = statuses {
            statuses.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "statuses".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let platformId = platformId {
            let platformIdQueryItem = ClientRuntime.URLQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
            items.append(platformIdQueryItem)
        }
        return items
    }
}

extension ListSigningProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-profiles"
    }
}

public struct ListSigningProfilesInput: Swift.Equatable {
    /// Designates whether to include profiles with the status of CANCELED.
    public var includeCanceled: Swift.Bool
    /// The maximum number of profiles to be returned.
    public var maxResults: Swift.Int?
    /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// Filters results to return only signing jobs initiated for a specified signing platform.
    public var platformId: Swift.String?
    /// Filters results to return only signing jobs with statuses in the specified list.
    public var statuses: [SignerClientTypes.SigningProfileStatus]?

    public init (
        includeCanceled: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        platformId: Swift.String? = nil,
        statuses: [SignerClientTypes.SigningProfileStatus]? = nil
    )
    {
        self.includeCanceled = includeCanceled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.statuses = statuses
    }
}

struct ListSigningProfilesInputBody: Swift.Equatable {
}

extension ListSigningProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSigningProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSigningProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSigningProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSigningProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListSigningProfilesOutputResponse: Swift.Equatable {
    /// Value for specifying the next set of paginated results to return.
    public var nextToken: Swift.String?
    /// A list of profiles that are available in the AWS account. This includes profiles with the status of CANCELED if the includeCanceled parameter is set to true.
    public var profiles: [SignerClientTypes.SigningProfile]?

    public init (
        nextToken: Swift.String? = nil,
        profiles: [SignerClientTypes.SigningProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListSigningProfilesOutputResponseBody: Swift.Equatable {
    let profiles: [SignerClientTypes.SigningProfile]?
    let nextToken: Swift.String?
}

extension ListSigningProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profiles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilesContainer = try containerValues.decodeIfPresent([SignerClientTypes.SigningProfile?].self, forKey: .profiles)
        var profilesDecoded0:[SignerClientTypes.SigningProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [SignerClientTypes.SigningProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags associated with the signing profile.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The signing profile was not found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SignerClientTypes.Permission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case principal
        case profileVersion
        case statementId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
    }
}

extension SignerClientTypes {
    /// A cross-account permission for a signing profile.
    public struct Permission: Swift.Equatable {
        /// An AWS Signer action permitted as part of cross-account permissions.
        public var action: Swift.String?
        /// The AWS principal that has been granted a cross-account permission.
        public var principal: Swift.String?
        /// The signing profile version that a permission applies to.
        public var profileVersion: Swift.String?
        /// A unique identifier for a cross-account permission statement.
        public var statementId: Swift.String?

        public init (
            action: Swift.String? = nil,
            principal: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            statementId: Swift.String? = nil
        )
        {
            self.action = action
            self.principal = principal
            self.profileVersion = profileVersion
            self.statementId = statementId
        }
    }

}

extension PutSigningProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
        case platformId
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            try encodeContainer.encode(overrides, forKey: .overrides)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let signatureValidityPeriod = signatureValidityPeriod {
            try encodeContainer.encode(signatureValidityPeriod, forKey: .signatureValidityPeriod)
        }
        if let signingMaterial = signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let signingParameters = signingParameters {
            var signingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signingParameters)
            for (dictKey0, signingparameters0) in signingParameters {
                try signingParametersContainer.encode(signingparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension PutSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

public struct PutSigningProfileInput: Swift.Equatable {
    /// A subfield of platform. This specifies any different configuration options that you want to apply to the chosen platform (such as a different hash-algorithm or signing-algorithm).
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// The ID of the signing platform to be created.
    /// This member is required.
    public var platformId: Swift.String?
    /// The name of the signing profile to be created.
    /// This member is required.
    public var profileName: Swift.String?
    /// The default validity period override for any signature generated using this signing profile. If unspecified, the default is 135 months.
    public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    /// The AWS Certificate Manager certificate that will be used to sign code with the new signing profile.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// Map of key-value pairs for signing. These can include any information that you want to use during signing.
    public var signingParameters: [Swift.String:Swift.String]?
    /// Tags to be associated with the signing profile that is being created.
    public var tags: [Swift.String:Swift.String]?

    public init (
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.overrides = overrides
        self.platformId = platformId
        self.profileName = profileName
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.tags = tags
    }
}

struct PutSigningProfileInputBody: Swift.Equatable {
    let signingMaterial: SignerClientTypes.SigningMaterial?
    let signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    let platformId: Swift.String?
    let overrides: SignerClientTypes.SigningPlatformOverrides?
    let signingParameters: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension PutSigningProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
        case platformId
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutSigningProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSigningProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSigningProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSigningProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutSigningProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.profileVersion = output.profileVersion
            self.profileVersionArn = output.profileVersionArn
        } else {
            self.arn = nil
            self.profileVersion = nil
            self.profileVersionArn = nil
        }
    }
}

public struct PutSigningProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signing profile created.
    public var arn: Swift.String?
    /// The version of the signing profile being created.
    public var profileVersion: Swift.String?
    /// The signing profile ARN, including the profile version.
    public var profileVersionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
    }
}

struct PutSigningProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let profileVersion: Swift.String?
    let profileVersionArn: Swift.String?
}

extension PutSigningProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case profileVersion
        case profileVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
    }
}

extension RemoveProfilePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let revisionId = revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "revisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension RemoveProfilePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        guard let statementId = statementId else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions/\(statementId.urlPercentEncoding())"
    }
}

public struct RemoveProfilePermissionInput: Swift.Equatable {
    /// A human-readable name for the signing profile with permissions to be removed.
    /// This member is required.
    public var profileName: Swift.String?
    /// An identifier for the current revision of the signing profile permissions.
    /// This member is required.
    public var revisionId: Swift.String?
    /// A unique identifier for the cross-account permissions statement.
    /// This member is required.
    public var statementId: Swift.String?

    public init (
        profileName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.profileName = profileName
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct RemoveProfilePermissionInputBody: Swift.Equatable {
}

extension RemoveProfilePermissionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveProfilePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveProfilePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveProfilePermissionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveProfilePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveProfilePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.revisionId = output.revisionId
        } else {
            self.revisionId = nil
        }
    }
}

public struct RemoveProfilePermissionOutputResponse: Swift.Equatable {
    /// An identifier for the current revision of the profile permissions.
    public var revisionId: Swift.String?

    public init (
        revisionId: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

struct RemoveProfilePermissionOutputResponseBody: Swift.Equatable {
    let revisionId: Swift.String?
}

extension RemoveProfilePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension RevokeSignatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobOwner
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobOwner = jobOwner {
            try encodeContainer.encode(jobOwner, forKey: .jobOwner)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension RevokeSignatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/signing-jobs/\(jobId.urlPercentEncoding())/revoke"
    }
}

public struct RevokeSignatureInput: Swift.Equatable {
    /// ID of the signing job to be revoked.
    /// This member is required.
    public var jobId: Swift.String?
    /// AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// The reason for revoking the signing job.
    /// This member is required.
    public var reason: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
        self.reason = reason
    }
}

struct RevokeSignatureInputBody: Swift.Equatable {
    let jobOwner: Swift.String?
    let reason: Swift.String?
}

extension RevokeSignatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobOwner
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RevokeSignatureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeSignatureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeSignatureOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeSignatureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeSignatureOutputResponse: Swift.Equatable {

}

extension RevokeSigningProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveTime
        case profileVersion
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveTime = effectiveTime {
            try encodeContainer.encode(effectiveTime.timeIntervalSince1970, forKey: .effectiveTime)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension RevokeSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/revoke"
    }
}

public struct RevokeSigningProfileInput: Swift.Equatable {
    /// A timestamp for when revocation of a Signing Profile should become effective. Signatures generated using the signing profile after this timestamp are not trusted.
    /// This member is required.
    public var effectiveTime: ClientRuntime.Date?
    /// The name of the signing profile to be revoked.
    /// This member is required.
    public var profileName: Swift.String?
    /// The version of the signing profile to be revoked.
    /// This member is required.
    public var profileVersion: Swift.String?
    /// The reason for revoking a signing profile.
    /// This member is required.
    public var reason: Swift.String?

    public init (
        effectiveTime: ClientRuntime.Date? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.effectiveTime = effectiveTime
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.reason = reason
    }
}

struct RevokeSigningProfileInputBody: Swift.Equatable {
    let profileVersion: Swift.String?
    let reason: Swift.String?
    let effectiveTime: ClientRuntime.Date?
}

extension RevokeSigningProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveTime
        case profileVersion
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let effectiveTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .effectiveTime)
        effectiveTime = effectiveTimeDecoded
    }
}

extension RevokeSigningProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeSigningProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeSigningProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeSigningProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeSigningProfileOutputResponse: Swift.Equatable {

}

extension SignerClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension SignerClientTypes {
    /// The name and prefix of the S3 bucket where code signing saves your signed objects.
    public struct S3Destination: Swift.Equatable {
        /// Name of the S3 bucket.
        public var bucketName: Swift.String?
        /// An Amazon S3 prefix that you can use to limit responses to those that begin with the specified prefix.
        public var `prefix`: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension SignerClientTypes.S3SignedObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension SignerClientTypes {
    /// The S3 bucket name and key where code signing saved your signed code image.
    public struct S3SignedObject: Swift.Equatable {
        /// Name of the S3 bucket.
        public var bucketName: Swift.String?
        /// Key name that uniquely identifies a signed code image in your bucket.
        public var key: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }

}

extension SignerClientTypes.S3Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case key
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SignerClientTypes {
    /// Information about the S3 bucket where you saved your unsigned code.
    public struct S3Source: Swift.Equatable {
        /// Name of the S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Key name of the bucket object that contains your unsigned code.
        /// This member is required.
        public var key: Swift.String?
        /// Version of your source image in your version enabled S3 bucket.
        /// This member is required.
        public var version: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
            self.version = version
        }
    }

}

extension ServiceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is making a request that exceeds service limits.
public struct ServiceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SignerClientTypes.SignatureValidityPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decode(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SignerClientTypes.ValidityType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SignerClientTypes {
    /// The validity period for a signing job.
    public struct SignatureValidityPeriod: Swift.Equatable {
        /// The time unit for signature validity.
        public var type: SignerClientTypes.ValidityType?
        /// The numerical value of the time unit for signature validity.
        public var value: Swift.Int

        public init (
            type: SignerClientTypes.ValidityType? = nil,
            value: Swift.Int = 0
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SignerClientTypes.SignedObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(SignerClientTypes.S3SignedObject.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension SignerClientTypes {
    /// Points to an S3SignedObject object that contains information about your signed code image.
    public struct SignedObject: Swift.Equatable {
        /// The S3SignedObject.
        public var s3: SignerClientTypes.S3SignedObject?

        public init (
            s3: SignerClientTypes.S3SignedObject? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension SignerClientTypes.SigningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAlgorithmOptions
        case hashAlgorithmOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAlgorithmOptions = encryptionAlgorithmOptions {
            try encodeContainer.encode(encryptionAlgorithmOptions, forKey: .encryptionAlgorithmOptions)
        }
        if let hashAlgorithmOptions = hashAlgorithmOptions {
            try encodeContainer.encode(hashAlgorithmOptions, forKey: .hashAlgorithmOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAlgorithmOptionsDecoded = try containerValues.decodeIfPresent(SignerClientTypes.EncryptionAlgorithmOptions.self, forKey: .encryptionAlgorithmOptions)
        encryptionAlgorithmOptions = encryptionAlgorithmOptionsDecoded
        let hashAlgorithmOptionsDecoded = try containerValues.decodeIfPresent(SignerClientTypes.HashAlgorithmOptions.self, forKey: .hashAlgorithmOptions)
        hashAlgorithmOptions = hashAlgorithmOptionsDecoded
    }
}

extension SignerClientTypes {
    /// The configuration of a code signing operation.
    public struct SigningConfiguration: Swift.Equatable {
        /// The encryption algorithm options that are available for a code signing job.
        /// This member is required.
        public var encryptionAlgorithmOptions: SignerClientTypes.EncryptionAlgorithmOptions?
        /// The hash algorithm options that are available for a code signing job.
        /// This member is required.
        public var hashAlgorithmOptions: SignerClientTypes.HashAlgorithmOptions?

        public init (
            encryptionAlgorithmOptions: SignerClientTypes.EncryptionAlgorithmOptions? = nil,
            hashAlgorithmOptions: SignerClientTypes.HashAlgorithmOptions? = nil
        )
        {
            self.encryptionAlgorithmOptions = encryptionAlgorithmOptions
            self.hashAlgorithmOptions = hashAlgorithmOptions
        }
    }

}

extension SignerClientTypes.SigningConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAlgorithm
        case hashAlgorithm
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAlgorithm = encryptionAlgorithm {
            try encodeContainer.encode(encryptionAlgorithm.rawValue, forKey: .encryptionAlgorithm)
        }
        if let hashAlgorithm = hashAlgorithm {
            try encodeContainer.encode(hashAlgorithm.rawValue, forKey: .hashAlgorithm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(SignerClientTypes.EncryptionAlgorithm.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
        let hashAlgorithmDecoded = try containerValues.decodeIfPresent(SignerClientTypes.HashAlgorithm.self, forKey: .hashAlgorithm)
        hashAlgorithm = hashAlgorithmDecoded
    }
}

extension SignerClientTypes {
    /// A signing configuration that overrides the default encryption or hash algorithm of a signing job.
    public struct SigningConfigurationOverrides: Swift.Equatable {
        /// A specified override of the default encryption algorithm that is used in a code signing job.
        public var encryptionAlgorithm: SignerClientTypes.EncryptionAlgorithm?
        /// A specified override of the default hash algorithm that is used in a code signing job.
        public var hashAlgorithm: SignerClientTypes.HashAlgorithm?

        public init (
            encryptionAlgorithm: SignerClientTypes.EncryptionAlgorithm? = nil,
            hashAlgorithm: SignerClientTypes.HashAlgorithm? = nil
        )
        {
            self.encryptionAlgorithm = encryptionAlgorithm
            self.hashAlgorithm = hashAlgorithm
        }
    }

}

extension SignerClientTypes.SigningImageFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultFormat
        case supportedFormats
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultFormat = defaultFormat {
            try encodeContainer.encode(defaultFormat.rawValue, forKey: .defaultFormat)
        }
        if let supportedFormats = supportedFormats {
            var supportedFormatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedFormats)
            for imageformats0 in supportedFormats {
                try supportedFormatsContainer.encode(imageformats0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedFormatsContainer = try containerValues.decodeIfPresent([SignerClientTypes.ImageFormat?].self, forKey: .supportedFormats)
        var supportedFormatsDecoded0:[SignerClientTypes.ImageFormat]? = nil
        if let supportedFormatsContainer = supportedFormatsContainer {
            supportedFormatsDecoded0 = [SignerClientTypes.ImageFormat]()
            for string0 in supportedFormatsContainer {
                if let string0 = string0 {
                    supportedFormatsDecoded0?.append(string0)
                }
            }
        }
        supportedFormats = supportedFormatsDecoded0
        let defaultFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.ImageFormat.self, forKey: .defaultFormat)
        defaultFormat = defaultFormatDecoded
    }
}

extension SignerClientTypes {
    /// The image format of a code signing platform or profile.
    public struct SigningImageFormat: Swift.Equatable {
        /// The default format of a code signing image.
        /// This member is required.
        public var defaultFormat: SignerClientTypes.ImageFormat?
        /// The supported formats of a code signing image.
        /// This member is required.
        public var supportedFormats: [SignerClientTypes.ImageFormat]?

        public init (
            defaultFormat: SignerClientTypes.ImageFormat? = nil,
            supportedFormats: [SignerClientTypes.ImageFormat]? = nil
        )
        {
            self.defaultFormat = defaultFormat
            self.supportedFormats = supportedFormats
        }
    }

}

extension SignerClientTypes.SigningJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case isRevoked
        case jobId
        case jobInvoker
        case jobOwner
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case signatureExpiresAt
        case signedObject
        case signingMaterial
        case source
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if isRevoked != false {
            try encodeContainer.encode(isRevoked, forKey: .isRevoked)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobInvoker = jobInvoker {
            try encodeContainer.encode(jobInvoker, forKey: .jobInvoker)
        }
        if let jobOwner = jobOwner {
            try encodeContainer.encode(jobOwner, forKey: .jobOwner)
        }
        if let platformDisplayName = platformDisplayName {
            try encodeContainer.encode(platformDisplayName, forKey: .platformDisplayName)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let signatureExpiresAt = signatureExpiresAt {
            try encodeContainer.encode(signatureExpiresAt.timeIntervalSince1970, forKey: .signatureExpiresAt)
        }
        if let signedObject = signedObject {
            try encodeContainer.encode(signedObject, forKey: .signedObject)
        }
        if let signingMaterial = signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let signedObjectDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignedObject.self, forKey: .signedObject)
        signedObject = signedObjectDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningStatus.self, forKey: .status)
        status = statusDecoded
        let isRevokedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRevoked)
        isRevoked = isRevokedDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signatureExpiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .signatureExpiresAt)
        signatureExpiresAt = signatureExpiresAtDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let jobInvokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobInvoker)
        jobInvoker = jobInvokerDecoded
    }
}

extension SignerClientTypes {
    /// Contains information about a signing job.
    public struct SigningJob: Swift.Equatable {
        /// The date and time that the signing job was created.
        public var createdAt: ClientRuntime.Date?
        /// Indicates whether the signing job is revoked.
        public var isRevoked: Swift.Bool
        /// The ID of the signing job.
        public var jobId: Swift.String?
        /// The AWS account ID of the job invoker.
        public var jobInvoker: Swift.String?
        /// The AWS account ID of the job owner.
        public var jobOwner: Swift.String?
        /// The name of a signing platform.
        public var platformDisplayName: Swift.String?
        /// The unique identifier for a signing platform.
        public var platformId: Swift.String?
        /// The name of the signing profile that created a signing job.
        public var profileName: Swift.String?
        /// The version of the signing profile that created a signing job.
        public var profileVersion: Swift.String?
        /// The time when the signature of a signing job expires.
        public var signatureExpiresAt: ClientRuntime.Date?
        /// A SignedObject structure that contains information about a signing job's signed code image.
        public var signedObject: SignerClientTypes.SignedObject?
        /// A SigningMaterial object that contains the Amazon Resource Name (ARN) of the certificate used for the signing job.
        public var signingMaterial: SignerClientTypes.SigningMaterial?
        /// A Source that contains information about a signing job's code image source.
        public var source: SignerClientTypes.Source?
        /// The status of the signing job.
        public var status: SignerClientTypes.SigningStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            isRevoked: Swift.Bool = false,
            jobId: Swift.String? = nil,
            jobInvoker: Swift.String? = nil,
            jobOwner: Swift.String? = nil,
            platformDisplayName: Swift.String? = nil,
            platformId: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            signatureExpiresAt: ClientRuntime.Date? = nil,
            signedObject: SignerClientTypes.SignedObject? = nil,
            signingMaterial: SignerClientTypes.SigningMaterial? = nil,
            source: SignerClientTypes.Source? = nil,
            status: SignerClientTypes.SigningStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.isRevoked = isRevoked
            self.jobId = jobId
            self.jobInvoker = jobInvoker
            self.jobOwner = jobOwner
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.signatureExpiresAt = signatureExpiresAt
            self.signedObject = signedObject
            self.signingMaterial = signingMaterial
            self.source = source
            self.status = status
        }
    }

}

extension SignerClientTypes.SigningJobRevocationRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case revokedAt
        case revokedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let revokedAt = revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let revokedBy = revokedBy {
            try encodeContainer.encode(revokedBy, forKey: .revokedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revokedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revokedBy)
        revokedBy = revokedByDecoded
    }
}

extension SignerClientTypes {
    /// Revocation information for a signing job.
    public struct SigningJobRevocationRecord: Swift.Equatable {
        /// A caller-supplied reason for revocation.
        public var reason: Swift.String?
        /// The time of revocation.
        public var revokedAt: ClientRuntime.Date?
        /// The identity of the revoker.
        public var revokedBy: Swift.String?

        public init (
            reason: Swift.String? = nil,
            revokedAt: ClientRuntime.Date? = nil,
            revokedBy: Swift.String? = nil
        )
        {
            self.reason = reason
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }
    }

}

extension SignerClientTypes.SigningMaterial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension SignerClientTypes {
    /// The ACM certificate that is used to sign your code.
    public struct SigningMaterial: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the certificates that is used to sign your code.
        /// This member is required.
        public var certificateArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
        }
    }

}

extension SignerClientTypes.SigningPlatform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case displayName
        case maxSizeInMB
        case partner
        case platformId
        case revocationSupported
        case signingConfiguration
        case signingImageFormat
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if maxSizeInMB != 0 {
            try encodeContainer.encode(maxSizeInMB, forKey: .maxSizeInMB)
        }
        if let partner = partner {
            try encodeContainer.encode(partner, forKey: .partner)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if revocationSupported != false {
            try encodeContainer.encode(revocationSupported, forKey: .revocationSupported)
        }
        if let signingConfiguration = signingConfiguration {
            try encodeContainer.encode(signingConfiguration, forKey: .signingConfiguration)
        }
        if let signingImageFormat = signingImageFormat {
            try encodeContainer.encode(signingImageFormat, forKey: .signingImageFormat)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let partnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partner)
        partner = partnerDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Category.self, forKey: .category)
        category = categoryDecoded
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningConfiguration.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
        let maxSizeInMBDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxSizeInMB)
        maxSizeInMB = maxSizeInMBDecoded
        let revocationSupportedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .revocationSupported)
        revocationSupported = revocationSupportedDecoded
    }
}

extension SignerClientTypes {
    /// Contains information about the signing configurations and parameters that are used to perform a code signing job.
    public struct SigningPlatform: Swift.Equatable {
        /// The category of a code signing platform.
        public var category: SignerClientTypes.Category?
        /// The display name of a code signing platform.
        public var displayName: Swift.String?
        /// The maximum size (in MB) of code that can be signed by a code signing platform.
        public var maxSizeInMB: Swift.Int
        /// Any partner entities linked to a code signing platform.
        public var partner: Swift.String?
        /// The ID of a code signing; platform.
        public var platformId: Swift.String?
        /// Indicates whether revocation is supported for the platform.
        public var revocationSupported: Swift.Bool
        /// The configuration of a code signing platform. This includes the designated hash algorithm and encryption algorithm of a signing platform.
        public var signingConfiguration: SignerClientTypes.SigningConfiguration?
        /// The image format of a code signing platform or profile.
        public var signingImageFormat: SignerClientTypes.SigningImageFormat?
        /// The types of targets that can be signed by a code signing platform.
        public var target: Swift.String?

        public init (
            category: SignerClientTypes.Category? = nil,
            displayName: Swift.String? = nil,
            maxSizeInMB: Swift.Int = 0,
            partner: Swift.String? = nil,
            platformId: Swift.String? = nil,
            revocationSupported: Swift.Bool = false,
            signingConfiguration: SignerClientTypes.SigningConfiguration? = nil,
            signingImageFormat: SignerClientTypes.SigningImageFormat? = nil,
            target: Swift.String? = nil
        )
        {
            self.category = category
            self.displayName = displayName
            self.maxSizeInMB = maxSizeInMB
            self.partner = partner
            self.platformId = platformId
            self.revocationSupported = revocationSupported
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
            self.target = target
        }
    }

}

extension SignerClientTypes.SigningPlatformOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingConfiguration
        case signingImageFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingConfiguration = signingConfiguration {
            try encodeContainer.encode(signingConfiguration, forKey: .signingConfiguration)
        }
        if let signingImageFormat = signingImageFormat {
            try encodeContainer.encode(signingImageFormat.rawValue, forKey: .signingImageFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningConfigurationOverrides.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.ImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
    }
}

extension SignerClientTypes {
    /// Any overrides that are applied to the signing configuration of a code signing platform.
    public struct SigningPlatformOverrides: Swift.Equatable {
        /// A signing configuration that overrides the default encryption or hash algorithm of a signing job.
        public var signingConfiguration: SignerClientTypes.SigningConfigurationOverrides?
        /// A signed image is a JSON object. When overriding the default signing platform configuration, a customer can select either of two signing formats, JSONEmbedded or JSONDetached. (A third format value, JSON, is reserved for future use.) With JSONEmbedded, the signing image has the payload embedded in it. With JSONDetached, the payload is not be embedded in the signing image.
        public var signingImageFormat: SignerClientTypes.ImageFormat?

        public init (
            signingConfiguration: SignerClientTypes.SigningConfigurationOverrides? = nil,
            signingImageFormat: SignerClientTypes.ImageFormat? = nil
        )
        {
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
        }
    }

}

extension SignerClientTypes.SigningProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case profileVersionArn
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let platformDisplayName = platformDisplayName {
            try encodeContainer.encode(platformDisplayName, forKey: .platformDisplayName)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let profileVersionArn = profileVersionArn {
            try encodeContainer.encode(profileVersionArn, forKey: .profileVersionArn)
        }
        if let signatureValidityPeriod = signatureValidityPeriod {
            try encodeContainer.encode(signatureValidityPeriod, forKey: .signatureValidityPeriod)
        }
        if let signingMaterial = signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let signingParameters = signingParameters {
            var signingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signingParameters)
            for (dictKey0, signingparameters0) in signingParameters {
                try signingParametersContainer.encode(signingparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningProfileStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SignerClientTypes {
    /// Contains information about the ACM certificates and code signing configuration parameters that can be used by a given code signing user.
    public struct SigningProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public var arn: Swift.String?
        /// The name of the signing platform.
        public var platformDisplayName: Swift.String?
        /// The ID of a platform that is available for use by a signing profile.
        public var platformId: Swift.String?
        /// The name of the signing profile.
        public var profileName: Swift.String?
        /// The version of a signing profile.
        public var profileVersion: Swift.String?
        /// The ARN of a signing profile, including the profile version.
        public var profileVersionArn: Swift.String?
        /// The validity period for a signing job created using this signing profile.
        public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
        /// The ACM certificate that is available for use by a signing profile.
        public var signingMaterial: SignerClientTypes.SigningMaterial?
        /// The parameters that are available for use by a code signing user.
        public var signingParameters: [Swift.String:Swift.String]?
        /// The status of a code signing profile.
        public var status: SignerClientTypes.SigningProfileStatus?
        /// A list of tags associated with the signing profile.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            platformDisplayName: Swift.String? = nil,
            platformId: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            profileVersionArn: Swift.String? = nil,
            signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
            signingMaterial: SignerClientTypes.SigningMaterial? = nil,
            signingParameters: [Swift.String:Swift.String]? = nil,
            status: SignerClientTypes.SigningProfileStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.status = status
            self.tags = tags
        }
    }

}

extension SignerClientTypes.SigningProfileRevocationRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revocationEffectiveFrom
        case revokedAt
        case revokedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revocationEffectiveFrom = revocationEffectiveFrom {
            try encodeContainer.encode(revocationEffectiveFrom.timeIntervalSince1970, forKey: .revocationEffectiveFrom)
        }
        if let revokedAt = revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let revokedBy = revokedBy {
            try encodeContainer.encode(revokedBy, forKey: .revokedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revocationEffectiveFromDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .revocationEffectiveFrom)
        revocationEffectiveFrom = revocationEffectiveFromDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revokedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revokedBy)
        revokedBy = revokedByDecoded
    }
}

extension SignerClientTypes {
    /// Revocation information for a signing profile.
    public struct SigningProfileRevocationRecord: Swift.Equatable {
        /// The time when revocation becomes effective.
        public var revocationEffectiveFrom: ClientRuntime.Date?
        /// The time when the signing profile was revoked.
        public var revokedAt: ClientRuntime.Date?
        /// The identity of the revoker.
        public var revokedBy: Swift.String?

        public init (
            revocationEffectiveFrom: ClientRuntime.Date? = nil,
            revokedAt: ClientRuntime.Date? = nil,
            revokedBy: Swift.String? = nil
        )
        {
            self.revocationEffectiveFrom = revocationEffectiveFrom
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }
    }

}

extension SignerClientTypes {
    public enum SigningProfileStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningProfileStatus] {
            return [
                .active,
                .canceled,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .canceled: return "Canceled"
            case .revoked: return "Revoked"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningProfileStatus(rawValue: rawValue) ?? SigningProfileStatus.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes {
    public enum SigningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningStatus] {
            return [
                .failed,
                .inprogress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningStatus(rawValue: rawValue) ?? SigningStatus.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(SignerClientTypes.S3Source.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension SignerClientTypes {
    /// An S3Source object that contains information about the S3 bucket where you saved your unsigned code.
    public struct Source: Swift.Equatable {
        /// The S3Source object.
        public var s3: SignerClientTypes.S3Source?

        public init (
            s3: SignerClientTypes.S3Source? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension StartSigningJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case destination
        case profileName
        case profileOwner
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileOwner = profileOwner {
            try encodeContainer.encode(profileOwner, forKey: .profileOwner)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

extension StartSigningJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-jobs"
    }
}

public struct StartSigningJobInput: Swift.Equatable {
    /// String that identifies the signing request. All calls after the first that use this token return the same response as the first call.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The S3 bucket in which to save your signed object. The destination contains the name of your bucket and an optional prefix.
    /// This member is required.
    public var destination: SignerClientTypes.Destination?
    /// The name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the signing profile owner.
    public var profileOwner: Swift.String?
    /// The S3 bucket that contains the object to sign or a BLOB that contains your raw code.
    /// This member is required.
    public var source: SignerClientTypes.Source?

    public init (
        clientRequestToken: Swift.String? = nil,
        destination: SignerClientTypes.Destination? = nil,
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil,
        source: SignerClientTypes.Source? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destination = destination
        self.profileName = profileName
        self.profileOwner = profileOwner
        self.source = source
    }
}

struct StartSigningJobInputBody: Swift.Equatable {
    let source: SignerClientTypes.Source?
    let destination: SignerClientTypes.Destination?
    let profileName: Swift.String?
    let clientRequestToken: Swift.String?
    let profileOwner: Swift.String?
}

extension StartSigningJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case destination
        case profileName
        case profileOwner
        case source
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let profileOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileOwner)
        profileOwner = profileOwnerDecoded
    }
}

extension StartSigningJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSigningJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSigningJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSigningJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSigningJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobOwner = output.jobOwner
        } else {
            self.jobId = nil
            self.jobOwner = nil
        }
    }
}

public struct StartSigningJobOutputResponse: Swift.Equatable {
    /// The ID of your signing job.
    public var jobId: Swift.String?
    /// The AWS account ID of the signing job owner.
    public var jobOwner: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
    }
}

struct StartSigningJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobOwner: Swift.String?
}

extension StartSigningJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case jobOwner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be associated with the signing profile.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling. Instead of this error, TooManyRequestsException should be used.
@available(*, deprecated, message: "Instead of this error, TooManyRequestsException should be used.")
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The allowed number of job-signing requests has been exceeded. This error supersedes the error ThrottlingException.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to be removed from the signing profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You signing certificate could not be validated.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SignerClientTypes {
    public enum ValidityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case months
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidityType] {
            return [
                .days,
                .months,
                .years,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .months: return "MONTHS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidityType(rawValue: rawValue) ?? ValidityType.sdkUnknown(rawValue)
        }
    }
}
