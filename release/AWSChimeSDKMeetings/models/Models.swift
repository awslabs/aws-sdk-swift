// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSdkMeetingsClientTypes.Attendee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeId = "AttendeeId"
        case externalUserId = "ExternalUserId"
        case joinToken = "JoinToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeId = attendeeId {
            try encodeContainer.encode(attendeeId, forKey: .attendeeId)
        }
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let joinToken = joinToken {
            try encodeContainer.encode(joinToken, forKey: .joinToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let attendeeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attendeeId)
        attendeeId = attendeeIdDecoded
        let joinTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinToken)
        joinToken = joinTokenDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// An Amazon Chime SDK meeting attendee. Includes a unique AttendeeId and JoinToken. The JoinToken allows a client to authenticate and join as the specified attendee. The JoinToken expires when the meeting ends, or when [DeleteAttendee] is called. After that, the attendee is unable to join the meeting. We recommend securely transferring each JoinToken from your server application to the client so that no other client has access to the token except for the one authorized to represent the attendee.
    public struct Attendee: Swift.Equatable {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init (
            attendeeId: Swift.String? = nil,
            externalUserId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.externalUserId = externalUserId
            self.joinToken = joinToken
        }
    }

}

extension ChimeSdkMeetingsClientTypes.AudioFeatures: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case echoReduction = "EchoReduction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let echoReduction = echoReduction {
            try encodeContainer.encode(echoReduction.rawValue, forKey: .echoReduction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let echoReductionDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.MeetingFeatureStatus.self, forKey: .echoReduction)
        echoReduction = echoReductionDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// An optional category of meeting features that contains audio-specific configurations, such as operating parameters for Amazon Voice Focus.
    public struct AudioFeatures: Swift.Equatable {
        /// Makes echo reduction available to clients who connect to the meeting.
        public var echoReduction: ChimeSdkMeetingsClientTypes.MeetingFeatureStatus?

        public init (
            echoReduction: ChimeSdkMeetingsClientTypes.MeetingFeatureStatus? = nil
        )
        {
            self.echoReduction = echoReduction
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension BatchCreateAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createattendeerequestitemlist0 in attendees {
                try attendeesContainer.encode(createattendeerequestitemlist0)
            }
        }
    }
}

extension BatchCreateAttendeeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
        return items
    }
}

extension BatchCreateAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct BatchCreateAttendeeInput: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    /// This member is required.
    public var attendees: [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]?
    /// The Amazon Chime SDK ID of the meeting to which you're adding attendees.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        attendees: [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.meetingId = meetingId
    }
}

struct BatchCreateAttendeeInputBody: Swift.Equatable {
    let attendees: [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]?
}

extension BatchCreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
    }
}

extension BatchCreateAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCreateAttendeeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
        } else {
            self.attendees = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateAttendeeOutputResponse: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    public var attendees: [ChimeSdkMeetingsClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeSdkMeetingsClientTypes.CreateAttendeeError]?

    public init (
        attendees: [ChimeSdkMeetingsClientTypes.Attendee]? = nil,
        errors: [ChimeSdkMeetingsClientTypes.CreateAttendeeError]? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
    }
}

struct BatchCreateAttendeeOutputResponseBody: Swift.Equatable {
    let attendees: [ChimeSdkMeetingsClientTypes.Attendee]?
    let errors: [ChimeSdkMeetingsClientTypes.CreateAttendeeError]?
}

extension BatchCreateAttendeeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSdkMeetingsClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSdkMeetingsClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSdkMeetingsClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeSdkMeetingsClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeSdkMeetingsClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeSdkMeetingsClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ChimeSdkMeetingsClientTypes.CreateAttendeeError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// The list of errors returned when errors are encountered during the BatchCreateAttendee and CreateAttendee actions. This includes external user IDs, error codes, and error messages.
    public struct CreateAttendeeError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.externalUserId = externalUserId
        }
    }

}

extension CreateAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }
}

extension CreateAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct CreateAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
    /// This member is required.
    public var externalUserId: Swift.String?
    /// The unique ID of the meeting.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        externalUserId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.externalUserId = externalUserId
        self.meetingId = meetingId
    }
}

struct CreateAttendeeInputBody: Swift.Equatable {
    let externalUserId: Swift.String?
}

extension CreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
    }
}

extension CreateAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAttendeeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct CreateAttendeeOutputResponse: Swift.Equatable {
    /// The attendee information, including attendee ID and join token.
    public var attendee: ChimeSdkMeetingsClientTypes.Attendee?

    public init (
        attendee: ChimeSdkMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct CreateAttendeeOutputResponseBody: Swift.Equatable {
    let attendee: ChimeSdkMeetingsClientTypes.Attendee?
}

extension CreateAttendeeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

extension ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// The Amazon Chime SDK attendee fields to create, used with the BatchCreateAttendee action.
    public struct CreateAttendeeRequestItem: Swift.Equatable {
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        /// This member is required.
        public var externalUserId: Swift.String?

        public init (
            externalUserId: Swift.String? = nil
        )
        {
            self.externalUserId = externalUserId
        }
    }

}

extension CreateMeetingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingFeatures = meetingFeatures {
            try encodeContainer.encode(meetingFeatures, forKey: .meetingFeatures)
        }
        if let meetingHostId = meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
    }
}

extension CreateMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/meetings"
    }
}

public struct CreateMeetingInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    /// This member is required.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Available values: af-south-1 , ap-northeast-1 , ap-northeast-2 , ap-south-1 , ap-southeast-1 , ap-southeast-2 , ca-central-1 , eu-central-1 , eu-north-1 , eu-south-1 , eu-west-1 , eu-west-2 , eu-west-3 , sa-east-1 , us-east-1 , us-east-2 , us-west-1 , us-west-2 .
    /// This member is required.
    public var mediaRegion: Swift.String?
    /// Lists the audio and video features enabled for a meeting, such as echo reduction.
    public var meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeSdkMeetingsClientTypes.NotificationsConfiguration?

    public init (
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeSdkMeetingsClientTypes.NotificationsConfiguration? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingFeatures = meetingFeatures
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
    }
}

struct CreateMeetingInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let mediaRegion: Swift.String?
    let meetingHostId: Swift.String?
    let externalMeetingId: Swift.String?
    let notificationsConfiguration: ChimeSdkMeetingsClientTypes.NotificationsConfiguration?
    let meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration?
}

extension CreateMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.NotificationsConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
        let meetingFeaturesDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration.self, forKey: .meetingFeatures)
        meetingFeatures = meetingFeaturesDecoded
    }
}

extension CreateMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMeetingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct CreateMeetingOutputResponse: Swift.Equatable {
    /// The meeting information, including the meeting ID and MediaPlacement.
    public var meeting: ChimeSdkMeetingsClientTypes.Meeting?

    public init (
        meeting: ChimeSdkMeetingsClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct CreateMeetingOutputResponseBody: Swift.Equatable {
    let meeting: ChimeSdkMeetingsClientTypes.Meeting?
}

extension CreateMeetingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

extension CreateMeetingWithAttendeesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createmeetingwithattendeesrequestitemlist0 in attendees {
                try attendeesContainer.encode(createmeetingwithattendeesrequestitemlist0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingFeatures = meetingFeatures {
            try encodeContainer.encode(meetingFeatures, forKey: .meetingFeatures)
        }
        if let meetingHostId = meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
    }
}

extension CreateMeetingWithAttendeesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "create-attendees"))
        return items
    }
}

extension CreateMeetingWithAttendeesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/meetings"
    }
}

public struct CreateMeetingWithAttendeesInput: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    /// This member is required.
    public var attendees: [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]?
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    /// This member is required.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting.
    /// This member is required.
    public var mediaRegion: Swift.String?
    /// Lists the audio and video features enabled for a meeting, such as echo reduction.
    public var meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeSdkMeetingsClientTypes.NotificationsConfiguration?

    public init (
        attendees: [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]? = nil,
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeSdkMeetingsClientTypes.NotificationsConfiguration? = nil
    )
    {
        self.attendees = attendees
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingFeatures = meetingFeatures
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
    }
}

struct CreateMeetingWithAttendeesInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let mediaRegion: Swift.String?
    let meetingHostId: Swift.String?
    let externalMeetingId: Swift.String?
    let meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration?
    let notificationsConfiguration: ChimeSdkMeetingsClientTypes.NotificationsConfiguration?
    let attendees: [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]?
}

extension CreateMeetingWithAttendeesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let meetingFeaturesDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration.self, forKey: .meetingFeatures)
        meetingFeatures = meetingFeaturesDecoded
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.NotificationsConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSdkMeetingsClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
    }
}

extension CreateMeetingWithAttendeesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMeetingWithAttendeesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMeetingWithAttendeesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMeetingWithAttendeesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMeetingWithAttendeesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
            self.meeting = output.meeting
        } else {
            self.attendees = nil
            self.errors = nil
            self.meeting = nil
        }
    }
}

public struct CreateMeetingWithAttendeesOutputResponse: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    public var attendees: [ChimeSdkMeetingsClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeSdkMeetingsClientTypes.CreateAttendeeError]?
    /// The meeting information, including the meeting ID and MediaPlacement.
    public var meeting: ChimeSdkMeetingsClientTypes.Meeting?

    public init (
        attendees: [ChimeSdkMeetingsClientTypes.Attendee]? = nil,
        errors: [ChimeSdkMeetingsClientTypes.CreateAttendeeError]? = nil,
        meeting: ChimeSdkMeetingsClientTypes.Meeting? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
        self.meeting = meeting
    }
}

struct CreateMeetingWithAttendeesOutputResponseBody: Swift.Equatable {
    let meeting: ChimeSdkMeetingsClientTypes.Meeting?
    let attendees: [ChimeSdkMeetingsClientTypes.Attendee]?
    let errors: [ChimeSdkMeetingsClientTypes.CreateAttendeeError]?
}

extension CreateMeetingWithAttendeesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
        case meeting = "Meeting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSdkMeetingsClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSdkMeetingsClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSdkMeetingsClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeSdkMeetingsClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeSdkMeetingsClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeSdkMeetingsClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension DeleteAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

public struct DeleteAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct DeleteAttendeeInputBody: Swift.Equatable {
}

extension DeleteAttendeeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAttendeeOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAttendeeOutputResponse: Swift.Equatable {

}

extension DeleteMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

public struct DeleteMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct DeleteMeetingInputBody: Swift.Equatable {
}

extension DeleteMeetingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMeetingOutputResponse: Swift.Equatable {

}

extension ChimeSdkMeetingsClientTypes.EngineTranscribeMedicalSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case languageCode = "LanguageCode"
        case region = "Region"
        case specialty = "Specialty"
        case type = "Type"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let region = region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let specialty = specialty {
            try encodeContainer.encode(specialty.rawValue, forKey: .specialty)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vocabularyName = vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeMedicalLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let specialtyDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeMedicalSpecialty.self, forKey: .specialty)
        specialty = specialtyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeMedicalType.self, forKey: .type)
        type = typeDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeMedicalRegion.self, forKey: .region)
        region = regionDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeMedicalContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// Settings specific to the Amazon Transcribe Medical engine.
    public struct EngineTranscribeMedicalSettings: Swift.Equatable {
        /// Set this field to PHI to identify personal health information in the transcription output.
        public var contentIdentificationType: ChimeSdkMeetingsClientTypes.TranscribeMedicalContentIdentificationType?
        /// The language code specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var languageCode: ChimeSdkMeetingsClientTypes.TranscribeMedicalLanguageCode?
        /// The AWS Region passed to Amazon Transcribe Medical. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeSdkMeetingsClientTypes.TranscribeMedicalRegion?
        /// The specialty specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var specialty: ChimeSdkMeetingsClientTypes.TranscribeMedicalSpecialty?
        /// The type of transcription.
        /// This member is required.
        public var type: ChimeSdkMeetingsClientTypes.TranscribeMedicalType?
        /// The name of the vocabulary passed to Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init (
            contentIdentificationType: ChimeSdkMeetingsClientTypes.TranscribeMedicalContentIdentificationType? = nil,
            languageCode: ChimeSdkMeetingsClientTypes.TranscribeMedicalLanguageCode? = nil,
            region: ChimeSdkMeetingsClientTypes.TranscribeMedicalRegion? = nil,
            specialty: ChimeSdkMeetingsClientTypes.TranscribeMedicalSpecialty? = nil,
            type: ChimeSdkMeetingsClientTypes.TranscribeMedicalType? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.languageCode = languageCode
            self.region = region
            self.specialty = specialty
            self.type = type
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeSdkMeetingsClientTypes.EngineTranscribeSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case contentRedactionType = "ContentRedactionType"
        case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
        case languageCode = "LanguageCode"
        case languageModelName = "LanguageModelName"
        case partialResultsStability = "PartialResultsStability"
        case piiEntityTypes = "PiiEntityTypes"
        case region = "Region"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let contentRedactionType = contentRedactionType {
            try encodeContainer.encode(contentRedactionType.rawValue, forKey: .contentRedactionType)
        }
        if enablePartialResultsStabilization != false {
            try encodeContainer.encode(enablePartialResultsStabilization, forKey: .enablePartialResultsStabilization)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageModelName = languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
        if let partialResultsStability = partialResultsStability {
            try encodeContainer.encode(partialResultsStability.rawValue, forKey: .partialResultsStability)
        }
        if let piiEntityTypes = piiEntityTypes {
            try encodeContainer.encode(piiEntityTypes, forKey: .piiEntityTypes)
        }
        if let region = region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let vocabularyFilterMethod = vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyName = vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeVocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeRegion.self, forKey: .region)
        region = regionDecoded
        let enablePartialResultsStabilizationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enablePartialResultsStabilization)
        enablePartialResultsStabilization = enablePartialResultsStabilizationDecoded
        let partialResultsStabilityDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribePartialResultsStability.self, forKey: .partialResultsStability)
        partialResultsStability = partialResultsStabilityDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let contentRedactionTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscribeContentRedactionType.self, forKey: .contentRedactionType)
        contentRedactionType = contentRedactionTypeDecoded
        let piiEntityTypesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .piiEntityTypes)
        piiEntityTypes = piiEntityTypesDecoded
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// Settings specific to the Amazon Transcribe engine.
    public struct EngineTranscribeSettings: Swift.Equatable {
        /// Set this field to PII to identify personally identifiable information in the transcription output.
        public var contentIdentificationType: ChimeSdkMeetingsClientTypes.TranscribeContentIdentificationType?
        /// Set this field to PII to redact personally identifiable information in the transcription output. Content redaction is performed only upon complete transcription of the audio segments. You cant set ContentRedactionType and ContentIdentificationType in the same request. If you set both, your request returns a BadRequestException.
        public var contentRedactionType: ChimeSdkMeetingsClientTypes.TranscribeContentRedactionType?
        /// Generates partial transcription results that are less likely to change as meeting attendees speak. It does so by only allowing the last few words from the partial results to change.
        public var enablePartialResultsStabilization: Swift.Bool
        /// The language code specified for the Amazon Transcribe engine.
        /// This member is required.
        public var languageCode: ChimeSdkMeetingsClientTypes.TranscribeLanguageCode?
        /// The name of the language model used during transcription.
        public var languageModelName: Swift.String?
        /// The stabity level of a partial results transcription. Determines how stable you want the transcription results to be. A higher level means the transcription results are less likely to change.
        public var partialResultsStability: ChimeSdkMeetingsClientTypes.TranscribePartialResultsStability?
        /// Lists the PII entity types you want to identify or redact. To specify entity types, you must enable ContentIdentificationType or ContentRedactionType. PIIEntityTypes must be comma-separated. The available values are: BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_NUMBER, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRY, PIN, EMAIL, ADDRESS, NAME, PHONE, SSN, and ALL. PiiEntityTypes is an optional parameter with a default value of ALL.
        public var piiEntityTypes: Swift.String?
        /// The AWS Region passed to Amazon Transcribe. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeSdkMeetingsClientTypes.TranscribeRegion?
        /// The filtering method passed to Amazon Transcribe.
        public var vocabularyFilterMethod: ChimeSdkMeetingsClientTypes.TranscribeVocabularyFilterMethod?
        /// The name of the vocabulary filter passed to Amazon Transcribe.
        public var vocabularyFilterName: Swift.String?
        /// The name of the vocabulary passed to Amazon Transcribe.
        public var vocabularyName: Swift.String?

        public init (
            contentIdentificationType: ChimeSdkMeetingsClientTypes.TranscribeContentIdentificationType? = nil,
            contentRedactionType: ChimeSdkMeetingsClientTypes.TranscribeContentRedactionType? = nil,
            enablePartialResultsStabilization: Swift.Bool = false,
            languageCode: ChimeSdkMeetingsClientTypes.TranscribeLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            partialResultsStability: ChimeSdkMeetingsClientTypes.TranscribePartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            region: ChimeSdkMeetingsClientTypes.TranscribeRegion? = nil,
            vocabularyFilterMethod: ChimeSdkMeetingsClientTypes.TranscribeVocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.region = region
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }

}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

public struct GetAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct GetAttendeeInputBody: Swift.Equatable {
}

extension GetAttendeeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAttendeeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct GetAttendeeOutputResponse: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendee: ChimeSdkMeetingsClientTypes.Attendee?

    public init (
        attendee: ChimeSdkMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct GetAttendeeOutputResponseBody: Swift.Equatable {
    let attendee: ChimeSdkMeetingsClientTypes.Attendee?
}

extension GetAttendeeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

extension GetMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

public struct GetMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct GetMeetingInputBody: Swift.Equatable {
}

extension GetMeetingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMeetingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct GetMeetingOutputResponse: Swift.Equatable {
    /// The Amazon Chime SDK meeting information.
    public var meeting: ChimeSdkMeetingsClientTypes.Meeting?

    public init (
        meeting: ChimeSdkMeetingsClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct GetMeetingOutputResponseBody: Swift.Equatable {
    let meeting: ChimeSdkMeetingsClientTypes.Meeting?
}

extension GetMeetingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListAttendeesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAttendeesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct ListAttendeesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        meetingId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.meetingId = meetingId
        self.nextToken = nextToken
    }
}

struct ListAttendeesInputBody: Swift.Equatable {
}

extension ListAttendeesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAttendeesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttendeesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttendeesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttendeesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAttendeesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.nextToken = output.nextToken
        } else {
            self.attendees = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttendeesOutputResponse: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendees: [ChimeSdkMeetingsClientTypes.Attendee]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        attendees: [ChimeSdkMeetingsClientTypes.Attendee]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.nextToken = nextToken
    }
}

struct ListAttendeesOutputResponseBody: Swift.Equatable {
    let attendees: [ChimeSdkMeetingsClientTypes.Attendee]?
    let nextToken: Swift.String?
}

extension ListAttendeesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSdkMeetingsClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSdkMeetingsClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSdkMeetingsClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ChimeSdkMeetingsClientTypes.MediaPlacement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioFallbackUrl = "AudioFallbackUrl"
        case audioHostUrl = "AudioHostUrl"
        case eventIngestionUrl = "EventIngestionUrl"
        case screenDataUrl = "ScreenDataUrl"
        case screenSharingUrl = "ScreenSharingUrl"
        case screenViewingUrl = "ScreenViewingUrl"
        case signalingUrl = "SignalingUrl"
        case turnControlUrl = "TurnControlUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioFallbackUrl = audioFallbackUrl {
            try encodeContainer.encode(audioFallbackUrl, forKey: .audioFallbackUrl)
        }
        if let audioHostUrl = audioHostUrl {
            try encodeContainer.encode(audioHostUrl, forKey: .audioHostUrl)
        }
        if let eventIngestionUrl = eventIngestionUrl {
            try encodeContainer.encode(eventIngestionUrl, forKey: .eventIngestionUrl)
        }
        if let screenDataUrl = screenDataUrl {
            try encodeContainer.encode(screenDataUrl, forKey: .screenDataUrl)
        }
        if let screenSharingUrl = screenSharingUrl {
            try encodeContainer.encode(screenSharingUrl, forKey: .screenSharingUrl)
        }
        if let screenViewingUrl = screenViewingUrl {
            try encodeContainer.encode(screenViewingUrl, forKey: .screenViewingUrl)
        }
        if let signalingUrl = signalingUrl {
            try encodeContainer.encode(signalingUrl, forKey: .signalingUrl)
        }
        if let turnControlUrl = turnControlUrl {
            try encodeContainer.encode(turnControlUrl, forKey: .turnControlUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioHostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioHostUrl)
        audioHostUrl = audioHostUrlDecoded
        let audioFallbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioFallbackUrl)
        audioFallbackUrl = audioFallbackUrlDecoded
        let signalingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalingUrl)
        signalingUrl = signalingUrlDecoded
        let turnControlUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .turnControlUrl)
        turnControlUrl = turnControlUrlDecoded
        let screenDataUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenDataUrl)
        screenDataUrl = screenDataUrlDecoded
        let screenViewingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenViewingUrl)
        screenViewingUrl = screenViewingUrlDecoded
        let screenSharingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenSharingUrl)
        screenSharingUrl = screenSharingUrlDecoded
        let eventIngestionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIngestionUrl)
        eventIngestionUrl = eventIngestionUrlDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement: Swift.Equatable {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The event ingestion URL.
        public var eventIngestionUrl: Swift.String?
        /// The screen data URL.
        public var screenDataUrl: Swift.String?
        /// The screen sharing URL.
        public var screenSharingUrl: Swift.String?
        /// The screen viewing URL.
        public var screenViewingUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL.
        public var turnControlUrl: Swift.String?

        public init (
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            screenDataUrl: Swift.String? = nil,
            screenSharingUrl: Swift.String? = nil,
            screenViewingUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.screenDataUrl = screenDataUrl
            self.screenSharingUrl = screenSharingUrl
            self.screenViewingUrl = screenViewingUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ChimeSdkMeetingsClientTypes.Meeting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalMeetingId = "ExternalMeetingId"
        case mediaPlacement = "MediaPlacement"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case meetingId = "MeetingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalMeetingId = externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaPlacement = mediaPlacement {
            try encodeContainer.encode(mediaPlacement, forKey: .mediaPlacement)
        }
        if let mediaRegion = mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingFeatures = meetingFeatures {
            try encodeContainer.encode(meetingFeatures, forKey: .meetingFeatures)
        }
        if let meetingHostId = meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let meetingId = meetingId {
            try encodeContainer.encode(meetingId, forKey: .meetingId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingId)
        meetingId = meetingIdDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let mediaPlacementDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.MediaPlacement.self, forKey: .mediaPlacement)
        mediaPlacement = mediaPlacementDecoded
        let meetingFeaturesDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration.self, forKey: .meetingFeatures)
        meetingFeatures = meetingFeaturesDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting: Swift.Equatable {
        /// The external meeting ID.
        public var externalMeetingId: Swift.String?
        /// The media placement for the meeting.
        public var mediaPlacement: ChimeSdkMeetingsClientTypes.MediaPlacement?
        /// The Region in which you create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2.
        public var mediaRegion: Swift.String?
        /// The features available to a meeting, such as Amazon Voice Focus.
        public var meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration?
        /// Reserved.
        public var meetingHostId: Swift.String?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?

        public init (
            externalMeetingId: Swift.String? = nil,
            mediaPlacement: ChimeSdkMeetingsClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingFeatures: ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
            meetingHostId: Swift.String? = nil,
            meetingId: Swift.String? = nil
        )
        {
            self.externalMeetingId = externalMeetingId
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingFeatures = meetingFeatures
            self.meetingHostId = meetingHostId
            self.meetingId = meetingId
        }
    }

}

extension ChimeSdkMeetingsClientTypes {
    public enum MeetingFeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [MeetingFeatureStatus] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MeetingFeatureStatus(rawValue: rawValue) ?? MeetingFeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes.MeetingFeaturesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.AudioFeatures.self, forKey: .audio)
        audio = audioDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// The configuration settings of the features available to a meeting.
    public struct MeetingFeaturesConfiguration: Swift.Equatable {
        /// The configuration settings for the audio features available to a meeting.
        public var audio: ChimeSdkMeetingsClientTypes.AudioFeatures?

        public init (
            audio: ChimeSdkMeetingsClientTypes.AudioFeatures? = nil
        )
        {
            self.audio = audio
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSdkMeetingsClientTypes.NotificationsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn = "LambdaFunctionArn"
        case snsTopicArn = "SnsTopicArn"
        case sqsQueueArn = "SqsQueueArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sqsQueueArn = sqsQueueArn {
            try encodeContainer.encode(sqsQueueArn, forKey: .sqsQueueArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sqsQueueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqsQueueArn)
        sqsQueueArn = sqsQueueArnDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public struct NotificationsConfiguration: Swift.Equatable {
        /// The ARN of the AWS Lambda function in the notifications configuration.
        public var lambdaFunctionArn: Swift.String?
        /// The ARN of the SNS topic.
        public var snsTopicArn: Swift.String?
        /// The ARN of the SQS queue.
        public var sqsQueueArn: Swift.String?

        public init (
            lambdaFunctionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sqsQueueArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
            self.snsTopicArn = snsTopicArn
            self.sqsQueueArn = sqsQueueArn
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?
    /// The number of seconds the caller should wait before retrying.
    public var retryAfterSeconds: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension StartMeetingTranscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcriptionConfiguration = transcriptionConfiguration {
            try encodeContainer.encode(transcriptionConfiguration, forKey: .transcriptionConfiguration)
        }
    }
}

extension StartMeetingTranscriptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "start"))
        return items
    }
}

extension StartMeetingTranscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

public struct StartMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting being transcribed.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    /// This member is required.
    public var transcriptionConfiguration: ChimeSdkMeetingsClientTypes.TranscriptionConfiguration?

    public init (
        meetingId: Swift.String? = nil,
        transcriptionConfiguration: ChimeSdkMeetingsClientTypes.TranscriptionConfiguration? = nil
    )
    {
        self.meetingId = meetingId
        self.transcriptionConfiguration = transcriptionConfiguration
    }
}

struct StartMeetingTranscriptionInputBody: Swift.Equatable {
    let transcriptionConfiguration: ChimeSdkMeetingsClientTypes.TranscriptionConfiguration?
}

extension StartMeetingTranscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.TranscriptionConfiguration.self, forKey: .transcriptionConfiguration)
        transcriptionConfiguration = transcriptionConfigurationDecoded
    }
}

extension StartMeetingTranscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMeetingTranscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMeetingTranscriptionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMeetingTranscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartMeetingTranscriptionOutputResponse: Swift.Equatable {

}

extension StopMeetingTranscriptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
        return items
    }
}

extension StopMeetingTranscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

public struct StopMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting for which you stop transcription.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct StopMeetingTranscriptionInputBody: Swift.Equatable {
}

extension StopMeetingTranscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopMeetingTranscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopMeetingTranscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopMeetingTranscriptionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopMeetingTranscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopMeetingTranscriptionOutputResponse: Swift.Equatable {

}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentIdentificationType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeContentIdentificationType(rawValue: rawValue) ?? TranscribeContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeContentRedactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentRedactionType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeContentRedactionType(rawValue: rawValue) ?? TranscribeContentRedactionType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeLanguageCode(rawValue: rawValue) ?? TranscribeLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeMedicalContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalContentIdentificationType] {
            return [
                .phi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalContentIdentificationType(rawValue: rawValue) ?? TranscribeMedicalContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeMedicalLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalLanguageCode] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalLanguageCode(rawValue: rawValue) ?? TranscribeMedicalLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeMedicalRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apSoutheast2
        case auto
        case caCentral1
        case euWest1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalRegion] {
            return [
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euWest1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euWest1: return "eu-west-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalRegion(rawValue: rawValue) ?? TranscribeMedicalRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeMedicalSpecialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cardiology
        case neurology
        case oncology
        case primarycare
        case radiology
        case urology
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalSpecialty] {
            return [
                .cardiology,
                .neurology,
                .oncology,
                .primarycare,
                .radiology,
                .urology,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cardiology: return "CARDIOLOGY"
            case .neurology: return "NEUROLOGY"
            case .oncology: return "ONCOLOGY"
            case .primarycare: return "PRIMARYCARE"
            case .radiology: return "RADIOLOGY"
            case .urology: return "UROLOGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalSpecialty(rawValue: rawValue) ?? TranscribeMedicalSpecialty.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeMedicalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalType] {
            return [
                .conversation,
                .dictation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalType(rawValue: rawValue) ?? TranscribeMedicalType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribePartialResultsStability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribePartialResultsStability] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribePartialResultsStability(rawValue: rawValue) ?? TranscribePartialResultsStability.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast2
        case auto
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case saEast1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .saEast1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeRegion(rawValue: rawValue) ?? TranscribeRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes {
    public enum TranscribeVocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeVocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeVocabularyFilterMethod(rawValue: rawValue) ?? TranscribeVocabularyFilterMethod.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMeetingsClientTypes.TranscriptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineTranscribeMedicalSettings = "EngineTranscribeMedicalSettings"
        case engineTranscribeSettings = "EngineTranscribeSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineTranscribeMedicalSettings = engineTranscribeMedicalSettings {
            try encodeContainer.encode(engineTranscribeMedicalSettings, forKey: .engineTranscribeMedicalSettings)
        }
        if let engineTranscribeSettings = engineTranscribeSettings {
            try encodeContainer.encode(engineTranscribeSettings, forKey: .engineTranscribeSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTranscribeSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.EngineTranscribeSettings.self, forKey: .engineTranscribeSettings)
        engineTranscribeSettings = engineTranscribeSettingsDecoded
        let engineTranscribeMedicalSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkMeetingsClientTypes.EngineTranscribeMedicalSettings.self, forKey: .engineTranscribeMedicalSettings)
        engineTranscribeMedicalSettings = engineTranscribeMedicalSettingsDecoded
    }
}

extension ChimeSdkMeetingsClientTypes {
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    public struct TranscriptionConfiguration: Swift.Equatable {
        /// The transcription configuration settings passed to Amazon Transcribe Medical.
        public var engineTranscribeMedicalSettings: ChimeSdkMeetingsClientTypes.EngineTranscribeMedicalSettings?
        /// The transcription configuration settings passed to Amazon Transcribe.
        public var engineTranscribeSettings: ChimeSdkMeetingsClientTypes.EngineTranscribeSettings?

        public init (
            engineTranscribeMedicalSettings: ChimeSdkMeetingsClientTypes.EngineTranscribeMedicalSettings? = nil,
            engineTranscribeSettings: ChimeSdkMeetingsClientTypes.EngineTranscribeSettings? = nil
        )
        {
            self.engineTranscribeMedicalSettings = engineTranscribeMedicalSettings
            self.engineTranscribeSettings = engineTranscribeSettings
        }
    }

}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user isn't authorized to request a resource.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UnprocessableEntityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was well-formed but was unable to be followed due to semantic errors.
public struct UnprocessableEntityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}
