// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum DataSetType {
    case customerProfileByGeography
    case customerProfileByIndustry
    case customerProfileByRevenue
    case customerSubscriberAnnualSubscriptions
    case customerSubscriberHourlyMonthlySubscriptions
    case dailyBusinessCanceledProductSubscribers
    case dailyBusinessFees
    case dailyBusinessFreeTrialConversions
    case dailyBusinessNewInstances
    case dailyBusinessNewProductSubscribers
    case dailyBusinessUsageByInstanceType
    case disbursedAmountByAgeOfDisbursedFunds
    case disbursedAmountByAgeOfPastDueFunds
    case disbursedAmountByAgeOfUncollectedFunds
    case disbursedAmountByCustomerGeo
    case disbursedAmountByInstanceHours
    case disbursedAmountByProduct
    case disbursedAmountByProductWithUncollectedFunds
    case disbursedAmountByUncollectedFundsBreakdown
    case monthlyRevenueAnnualSubscriptions
    case monthlyRevenueBillingAndRevenueData
    case monthlyRevenueFieldDemonstrationUsage
    case monthlyRevenueFlexiblePaymentSchedule
    case salesCompensationBilledRevenue
    case usSalesAndUseTaxRecords
    case sdkUnknown(String)
}

extension DataSetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSetType] {
        return [
            .customerProfileByGeography,
            .customerProfileByIndustry,
            .customerProfileByRevenue,
            .customerSubscriberAnnualSubscriptions,
            .customerSubscriberHourlyMonthlySubscriptions,
            .dailyBusinessCanceledProductSubscribers,
            .dailyBusinessFees,
            .dailyBusinessFreeTrialConversions,
            .dailyBusinessNewInstances,
            .dailyBusinessNewProductSubscribers,
            .dailyBusinessUsageByInstanceType,
            .disbursedAmountByAgeOfDisbursedFunds,
            .disbursedAmountByAgeOfPastDueFunds,
            .disbursedAmountByAgeOfUncollectedFunds,
            .disbursedAmountByCustomerGeo,
            .disbursedAmountByInstanceHours,
            .disbursedAmountByProduct,
            .disbursedAmountByProductWithUncollectedFunds,
            .disbursedAmountByUncollectedFundsBreakdown,
            .monthlyRevenueAnnualSubscriptions,
            .monthlyRevenueBillingAndRevenueData,
            .monthlyRevenueFieldDemonstrationUsage,
            .monthlyRevenueFlexiblePaymentSchedule,
            .salesCompensationBilledRevenue,
            .usSalesAndUseTaxRecords,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customerProfileByGeography: return "customer_profile_by_geography"
        case .customerProfileByIndustry: return "customer_profile_by_industry"
        case .customerProfileByRevenue: return "customer_profile_by_revenue"
        case .customerSubscriberAnnualSubscriptions: return "customer_subscriber_annual_subscriptions"
        case .customerSubscriberHourlyMonthlySubscriptions: return "customer_subscriber_hourly_monthly_subscriptions"
        case .dailyBusinessCanceledProductSubscribers: return "daily_business_canceled_product_subscribers"
        case .dailyBusinessFees: return "daily_business_fees"
        case .dailyBusinessFreeTrialConversions: return "daily_business_free_trial_conversions"
        case .dailyBusinessNewInstances: return "daily_business_new_instances"
        case .dailyBusinessNewProductSubscribers: return "daily_business_new_product_subscribers"
        case .dailyBusinessUsageByInstanceType: return "daily_business_usage_by_instance_type"
        case .disbursedAmountByAgeOfDisbursedFunds: return "disbursed_amount_by_age_of_disbursed_funds"
        case .disbursedAmountByAgeOfPastDueFunds: return "disbursed_amount_by_age_of_past_due_funds"
        case .disbursedAmountByAgeOfUncollectedFunds: return "disbursed_amount_by_age_of_uncollected_funds"
        case .disbursedAmountByCustomerGeo: return "disbursed_amount_by_customer_geo"
        case .disbursedAmountByInstanceHours: return "disbursed_amount_by_instance_hours"
        case .disbursedAmountByProduct: return "disbursed_amount_by_product"
        case .disbursedAmountByProductWithUncollectedFunds: return "disbursed_amount_by_product_with_uncollected_funds"
        case .disbursedAmountByUncollectedFundsBreakdown: return "disbursed_amount_by_uncollected_funds_breakdown"
        case .monthlyRevenueAnnualSubscriptions: return "monthly_revenue_annual_subscriptions"
        case .monthlyRevenueBillingAndRevenueData: return "monthly_revenue_billing_and_revenue_data"
        case .monthlyRevenueFieldDemonstrationUsage: return "monthly_revenue_field_demonstration_usage"
        case .monthlyRevenueFlexiblePaymentSchedule: return "monthly_revenue_flexible_payment_schedule"
        case .salesCompensationBilledRevenue: return "sales_compensation_billed_revenue"
        case .usSalesAndUseTaxRecords: return "us_sales_and_use_tax_records"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSetType(rawValue: rawValue) ?? DataSetType.sdkUnknown(rawValue)
    }
}

public struct GenerateDataSetInputBodyMiddleware: Middleware {
    public let id: String = "GenerateDataSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataSetInput>
    public typealias MOutput = OperationOutput<GenerateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataSetOutputError>
}

extension GenerateDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataSetInput(customerDefinedValues: \(String(describing: customerDefinedValues)), dataSetPublicationDate: \(String(describing: dataSetPublicationDate)), dataSetType: \(String(describing: dataSetType)), destinationS3BucketName: \(String(describing: destinationS3BucketName)), destinationS3Prefix: \(String(describing: destinationS3Prefix)), roleNameArn: \(String(describing: roleNameArn)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

extension GenerateDataSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerDefinedValues
        case dataSetPublicationDate
        case dataSetType
        case destinationS3BucketName
        case destinationS3Prefix
        case roleNameArn
        case snsTopicArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerDefinedValues = customerDefinedValues {
            var customerDefinedValuesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customerDefinedValues)
            for (dictKey0, customerdefinedvalues0) in customerDefinedValues {
                try customerDefinedValuesContainer.encode(customerdefinedvalues0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dataSetPublicationDate = dataSetPublicationDate {
            try encodeContainer.encode(dataSetPublicationDate.timeIntervalSince1970, forKey: .dataSetPublicationDate)
        }
        if let dataSetType = dataSetType {
            try encodeContainer.encode(dataSetType.rawValue, forKey: .dataSetType)
        }
        if let destinationS3BucketName = destinationS3BucketName {
            try encodeContainer.encode(destinationS3BucketName, forKey: .destinationS3BucketName)
        }
        if let destinationS3Prefix = destinationS3Prefix {
            try encodeContainer.encode(destinationS3Prefix, forKey: .destinationS3Prefix)
        }
        if let roleNameArn = roleNameArn {
            try encodeContainer.encode(roleNameArn, forKey: .roleNameArn)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

public struct GenerateDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataSetInput>
    public typealias MOutput = OperationOutput<GenerateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataSetOutputError>
}

public struct GenerateDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataSetInput>
    public typealias MOutput = OperationOutput<GenerateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataSetOutputError>
}

/// Container for the parameters to the GenerateDataSet operation.
public struct GenerateDataSetInput: Equatable {
    /// (Optional) Key-value pairs which will be returned, unmodified, in the
    ///         Amazon SNS notification message and the data set metadata file. These
    ///         key-value pairs can be used to correlated responses with tracking
    ///         information from other systems.
    public let customerDefinedValues: [String:String]?
    /// The date a data set was published.
    ///         For daily data sets, provide a date with day-level granularity for the desired day.
    ///         For monthly data sets except those with prefix disbursed_amount, provide a date with month-level granularity for the desired month (the day value will be ignored).
    ///         For data sets with prefix disbursed_amount, provide a date with day-level granularity for the desired day. For these data sets we will look backwards in time over the range of 31 days until the first data set is found (the latest one).
    public let dataSetPublicationDate: Date?
    /// <p>The desired data set type.</p>
    ///         <p>
    ///             <ul>
    ///                 <li>
    ///                     <strong>customer_subscriber_hourly_monthly_subscriptions</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>customer_subscriber_annual_subscriptions</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>daily_business_usage_by_instance_type</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>daily_business_fees</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>daily_business_free_trial_conversions</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>daily_business_new_instances</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>daily_business_new_product_subscribers</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>daily_business_canceled_product_subscribers</strong>
    ///                     <p>From 2017-09-15 to present: Available daily by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>monthly_revenue_billing_and_revenue_data</strong>
    ///                     <p>From 2017-09-15 to present: Available monthly on the 15th day of the month by 24:00 UTC. Data includes metered transactions (e.g. hourly) from one month prior.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>monthly_revenue_annual_subscriptions</strong>
    ///                     <p>From 2017-09-15 to present: Available monthly on the 15th day of the month by 24:00 UTC. Data includes up-front software charges (e.g. annual) from one month prior.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>monthly_revenue_field_demonstration_usage</strong>
    ///                     <p>From 2018-03-15 to present: Available monthly on the 15th day of the month by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>monthly_revenue_flexible_payment_schedule</strong>
    ///                     <p>From 2018-11-15 to present: Available monthly on the 15th day of the month by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_product</strong>
    ///                     <p>From 2017-09-15 to present: Available every 30 days by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_instance_hours</strong>
    ///                     <p>From 2017-09-15 to present: Available every 30 days by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_customer_geo</strong>
    ///                     <p>From 2017-09-15 to present: Available every 30 days by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_age_of_uncollected_funds</strong>
    ///                     <p>From 2017-09-15 to present: Available every 30 days by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_age_of_disbursed_funds</strong>
    ///                     <p>From 2017-09-15 to present: Available every 30 days by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_age_of_past_due_funds</strong>
    ///                     <p>From 2018-04-07 to present: Available every 30 days by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_uncollected_funds_breakdown</strong>
    ///                     <p>From 2019-10-04 to present: Available every 30 days by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>sales_compensation_billed_revenue</strong>
    ///                     <p>From 2017-09-15 to present: Available monthly on the 15th day of the month by 24:00 UTC. Data includes metered transactions (e.g. hourly) from one month prior, and up-front software charges (e.g. annual) from one month prior.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>us_sales_and_use_tax_records</strong>
    ///                     <p>From 2017-09-15 to present: Available monthly on the 15th day of the month by 24:00 UTC.</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>disbursed_amount_by_product_with_uncollected_funds</strong>
    ///                     <p>This data set is deprecated. Download related reports from AMMP instead!</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>customer_profile_by_industry</strong>
    ///                     <p>This data set is deprecated. Download related reports from AMMP instead!</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>customer_profile_by_revenue</strong>
    ///                     <p>This data set is deprecated. Download related reports from AMMP instead!</p>
    ///                 </li>
    ///                 <li>
    ///                     <strong>customer_profile_by_geography</strong>
    ///                     <p>This data set is deprecated. Download related reports from AMMP instead!</p>
    ///                 </li>
    ///             </ul>
    ///         </p>
    public let dataSetType: DataSetType?
    /// The name (friendly name, not ARN) of the destination S3 bucket.
    public let destinationS3BucketName: String?
    /// (Optional) The desired S3 prefix for the published data set, similar to a directory path in standard file systems.
    ///         For example, if given the bucket name "mybucket" and the prefix "myprefix/mydatasets", the output file
    ///         "outputfile" would be published to "s3://mybucket/myprefix/mydatasets/outputfile".
    ///         If the prefix directory structure does not exist, it will be created.
    ///         If no prefix is provided, the data set will be published to the S3 bucket root.
    public let destinationS3Prefix: String?
    /// The Amazon Resource Name (ARN) of the Role with an attached permissions policy to interact with the provided
    ///         AWS services.
    public let roleNameArn: String?
    /// Amazon Resource Name (ARN) for the SNS Topic that will be notified when the data set has been published or if an
    ///         error has occurred.
    public let snsTopicArn: String?

    public init (
        customerDefinedValues: [String:String]? = nil,
        dataSetPublicationDate: Date? = nil,
        dataSetType: DataSetType? = nil,
        destinationS3BucketName: String? = nil,
        destinationS3Prefix: String? = nil,
        roleNameArn: String? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.customerDefinedValues = customerDefinedValues
        self.dataSetPublicationDate = dataSetPublicationDate
        self.dataSetType = dataSetType
        self.destinationS3BucketName = destinationS3BucketName
        self.destinationS3Prefix = destinationS3Prefix
        self.roleNameArn = roleNameArn
        self.snsTopicArn = snsTopicArn
    }
}

struct GenerateDataSetInputBody: Equatable {
    public let dataSetType: DataSetType?
    public let dataSetPublicationDate: Date?
    public let roleNameArn: String?
    public let destinationS3BucketName: String?
    public let destinationS3Prefix: String?
    public let snsTopicArn: String?
    public let customerDefinedValues: [String:String]?
}

extension GenerateDataSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerDefinedValues
        case dataSetPublicationDate
        case dataSetType
        case destinationS3BucketName
        case destinationS3Prefix
        case roleNameArn
        case snsTopicArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetTypeDecoded = try containerValues.decodeIfPresent(DataSetType.self, forKey: .dataSetType)
        dataSetType = dataSetTypeDecoded
        let dataSetPublicationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataSetPublicationDate)
        dataSetPublicationDate = dataSetPublicationDateDecoded
        let roleNameArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleNameArn)
        roleNameArn = roleNameArnDecoded
        let destinationS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationS3BucketName)
        destinationS3BucketName = destinationS3BucketNameDecoded
        let destinationS3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationS3Prefix)
        destinationS3Prefix = destinationS3PrefixDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let customerDefinedValuesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .customerDefinedValues)
        var customerDefinedValuesDecoded0: [String:String]? = nil
        if let customerDefinedValuesContainer = customerDefinedValuesContainer {
            customerDefinedValuesDecoded0 = [String:String]()
            for (key0, optionalvalue0) in customerDefinedValuesContainer {
                if let optionalvalue0 = optionalvalue0 {
                    customerDefinedValuesDecoded0?[key0] = optionalvalue0
                }
            }
        }
        customerDefinedValues = customerDefinedValuesDecoded0
    }
}

extension GenerateDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "MarketplaceCommerceAnalyticsException" : self = .marketplaceCommerceAnalyticsException(try MarketplaceCommerceAnalyticsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateDataSetOutputError: Swift.Error, Equatable {
    case marketplaceCommerceAnalyticsException(MarketplaceCommerceAnalyticsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataSetOutputResponse(dataSetRequestId: \(String(describing: dataSetRequestId)))"}
}

extension GenerateDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GenerateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetRequestId = output.dataSetRequestId
        } else {
            self.dataSetRequestId = nil
        }
    }
}

/// Container for the result of the GenerateDataSet operation.
public struct GenerateDataSetOutputResponse: Equatable {
    /// A unique identifier representing a specific request to the GenerateDataSet operation. This identifier can be
    ///         used to correlate a request with notifications from the SNS topic.
    public let dataSetRequestId: String?

    public init (
        dataSetRequestId: String? = nil
    )
    {
        self.dataSetRequestId = dataSetRequestId
    }
}

struct GenerateDataSetOutputResponseBody: Equatable {
    public let dataSetRequestId: String?
}

extension GenerateDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSetRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetRequestId)
        dataSetRequestId = dataSetRequestIdDecoded
    }
}

extension MarketplaceCommerceAnalyticsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarketplaceCommerceAnalyticsException(message: \(String(describing: message)))"}
}

extension MarketplaceCommerceAnalyticsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MarketplaceCommerceAnalyticsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when an internal service error occurs.
public struct MarketplaceCommerceAnalyticsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// This message describes details of the error.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MarketplaceCommerceAnalyticsExceptionBody: Equatable {
    public let message: String?
}

extension MarketplaceCommerceAnalyticsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartSupportDataExportInputBodyMiddleware: Middleware {
    public let id: String = "StartSupportDataExportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSupportDataExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSupportDataExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSupportDataExportInput>
    public typealias MOutput = OperationOutput<StartSupportDataExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSupportDataExportOutputError>
}

extension StartSupportDataExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSupportDataExportInput(customerDefinedValues: \(String(describing: customerDefinedValues)), dataSetType: \(String(describing: dataSetType)), destinationS3BucketName: \(String(describing: destinationS3BucketName)), destinationS3Prefix: \(String(describing: destinationS3Prefix)), fromDate: \(String(describing: fromDate)), roleNameArn: \(String(describing: roleNameArn)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

extension StartSupportDataExportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerDefinedValues
        case dataSetType
        case destinationS3BucketName
        case destinationS3Prefix
        case fromDate
        case roleNameArn
        case snsTopicArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerDefinedValues = customerDefinedValues {
            var customerDefinedValuesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customerDefinedValues)
            for (dictKey0, customerdefinedvalues0) in customerDefinedValues {
                try customerDefinedValuesContainer.encode(customerdefinedvalues0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dataSetType = dataSetType {
            try encodeContainer.encode(dataSetType.rawValue, forKey: .dataSetType)
        }
        if let destinationS3BucketName = destinationS3BucketName {
            try encodeContainer.encode(destinationS3BucketName, forKey: .destinationS3BucketName)
        }
        if let destinationS3Prefix = destinationS3Prefix {
            try encodeContainer.encode(destinationS3Prefix, forKey: .destinationS3Prefix)
        }
        if let fromDate = fromDate {
            try encodeContainer.encode(fromDate.timeIntervalSince1970, forKey: .fromDate)
        }
        if let roleNameArn = roleNameArn {
            try encodeContainer.encode(roleNameArn, forKey: .roleNameArn)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

public struct StartSupportDataExportInputHeadersMiddleware: Middleware {
    public let id: String = "StartSupportDataExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSupportDataExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSupportDataExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSupportDataExportInput>
    public typealias MOutput = OperationOutput<StartSupportDataExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSupportDataExportOutputError>
}

public struct StartSupportDataExportInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSupportDataExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSupportDataExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSupportDataExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSupportDataExportInput>
    public typealias MOutput = OperationOutput<StartSupportDataExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSupportDataExportOutputError>
}

/// Container for the parameters to the StartSupportDataExport operation.
public struct StartSupportDataExportInput: Equatable {
    /// (Optional) Key-value pairs which will be returned, unmodified, in the
    ///         Amazon SNS notification message and the data set metadata file.
    public let customerDefinedValues: [String:String]?
    /// <p>
    ///            Specifies the data set type to be written to the output csv file. The data set types customer_support_contacts_data and
    ///            test_customer_support_contacts_data both result in a csv file containing the following fields: Product Id, Product Code, Customer Guid,
    ///            Subscription Guid, Subscription Start Date, Organization, AWS Account Id, Given Name, Surname, Telephone Number, Email, Title,
    ///            Country Code, ZIP Code, Operation Type, and Operation Time.
    ///         </p>
    ///         <p>
    ///             <ul>
    ///                 <li><i>customer_support_contacts_data</i> Customer support contact data. The data set will contain all changes (Creates, Updates, and Deletes) to customer support contact data from the date specified in the from_date parameter.</li>
    ///                 <li><i>test_customer_support_contacts_data</i> An example data set containing static test data in the same format as customer_support_contacts_data</li>
    ///             </ul>
    ///         </p>
    public let dataSetType: SupportDataSetType?
    /// The name (friendly name, not ARN) of the destination S3 bucket.
    public let destinationS3BucketName: String?
    /// (Optional) The desired S3 prefix for the published data set, similar to a directory path in standard file systems.
    ///         For example, if given the bucket name "mybucket" and the prefix "myprefix/mydatasets", the output file
    ///         "outputfile" would be published to "s3://mybucket/myprefix/mydatasets/outputfile".
    ///         If the prefix directory structure does not exist, it will be created.
    ///         If no prefix is provided, the data set will be published to the S3 bucket root.
    public let destinationS3Prefix: String?
    /// The start date from which to retrieve the data set in UTC.  This parameter only affects the customer_support_contacts_data data set type.
    public let fromDate: Date?
    /// The Amazon Resource Name (ARN) of the Role with an attached permissions policy to interact with the provided
    ///         AWS services.
    public let roleNameArn: String?
    /// Amazon Resource Name (ARN) for the SNS Topic that will be notified when the data set has been published or if an
    ///         error has occurred.
    public let snsTopicArn: String?

    public init (
        customerDefinedValues: [String:String]? = nil,
        dataSetType: SupportDataSetType? = nil,
        destinationS3BucketName: String? = nil,
        destinationS3Prefix: String? = nil,
        fromDate: Date? = nil,
        roleNameArn: String? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.customerDefinedValues = customerDefinedValues
        self.dataSetType = dataSetType
        self.destinationS3BucketName = destinationS3BucketName
        self.destinationS3Prefix = destinationS3Prefix
        self.fromDate = fromDate
        self.roleNameArn = roleNameArn
        self.snsTopicArn = snsTopicArn
    }
}

struct StartSupportDataExportInputBody: Equatable {
    public let dataSetType: SupportDataSetType?
    public let fromDate: Date?
    public let roleNameArn: String?
    public let destinationS3BucketName: String?
    public let destinationS3Prefix: String?
    public let snsTopicArn: String?
    public let customerDefinedValues: [String:String]?
}

extension StartSupportDataExportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerDefinedValues
        case dataSetType
        case destinationS3BucketName
        case destinationS3Prefix
        case fromDate
        case roleNameArn
        case snsTopicArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetTypeDecoded = try containerValues.decodeIfPresent(SupportDataSetType.self, forKey: .dataSetType)
        dataSetType = dataSetTypeDecoded
        let fromDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fromDate)
        fromDate = fromDateDecoded
        let roleNameArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleNameArn)
        roleNameArn = roleNameArnDecoded
        let destinationS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationS3BucketName)
        destinationS3BucketName = destinationS3BucketNameDecoded
        let destinationS3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationS3Prefix)
        destinationS3Prefix = destinationS3PrefixDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let customerDefinedValuesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .customerDefinedValues)
        var customerDefinedValuesDecoded0: [String:String]? = nil
        if let customerDefinedValuesContainer = customerDefinedValuesContainer {
            customerDefinedValuesDecoded0 = [String:String]()
            for (key0, optionalvalue0) in customerDefinedValuesContainer {
                if let optionalvalue0 = optionalvalue0 {
                    customerDefinedValuesDecoded0?[key0] = optionalvalue0
                }
            }
        }
        customerDefinedValues = customerDefinedValuesDecoded0
    }
}

extension StartSupportDataExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSupportDataExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "MarketplaceCommerceAnalyticsException" : self = .marketplaceCommerceAnalyticsException(try MarketplaceCommerceAnalyticsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSupportDataExportOutputError: Swift.Error, Equatable {
    case marketplaceCommerceAnalyticsException(MarketplaceCommerceAnalyticsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSupportDataExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSupportDataExportOutputResponse(dataSetRequestId: \(String(describing: dataSetRequestId)))"}
}

extension StartSupportDataExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSupportDataExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetRequestId = output.dataSetRequestId
        } else {
            self.dataSetRequestId = nil
        }
    }
}

/// Container for the result of the StartSupportDataExport operation.
public struct StartSupportDataExportOutputResponse: Equatable {
    /// A unique identifier representing a specific request to the StartSupportDataExport operation. This identifier can be
    ///         used to correlate a request with notifications from the SNS topic.
    public let dataSetRequestId: String?

    public init (
        dataSetRequestId: String? = nil
    )
    {
        self.dataSetRequestId = dataSetRequestId
    }
}

struct StartSupportDataExportOutputResponseBody: Equatable {
    public let dataSetRequestId: String?
}

extension StartSupportDataExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSetRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetRequestId)
        dataSetRequestId = dataSetRequestIdDecoded
    }
}

public enum SupportDataSetType {
    case customerSupportContactsData
    case testCustomerSupportContactsData
    case sdkUnknown(String)
}

extension SupportDataSetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SupportDataSetType] {
        return [
            .customerSupportContactsData,
            .testCustomerSupportContactsData,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customerSupportContactsData: return "customer_support_contacts_data"
        case .testCustomerSupportContactsData: return "test_customer_support_contacts_data"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SupportDataSetType(rawValue: rawValue) ?? SupportDataSetType.sdkUnknown(rawValue)
    }
}
