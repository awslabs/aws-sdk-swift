// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension NetworkManagerClientTypes.AWSLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetArn = "SubnetArn"
        case zone = "Zone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetArn = self.subnetArn {
            try encodeContainer.encode(subnetArn, forKey: .subnetArn)
        }
        if let zone = self.zone {
            try encodeContainer.encode(zone, forKey: .zone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zone)
        zone = zoneDecoded
        let subnetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Specifies a location in Amazon Web Services.
    public struct AWSLocation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the subnet that the device is located in.
        public var subnetArn: Swift.String?
        /// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
        public var zone: Swift.String?

        public init (
            subnetArn: Swift.String? = nil,
            zone: Swift.String? = nil
        )
        {
            self.subnetArn = subnetArn
            self.zone = zone
        }
    }

}

extension AcceptAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/attachments/\(attachmentId.urlPercentEncoding())/accept"
    }
}

public struct AcceptAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct AcceptAttachmentInputBody: Swift.Equatable {
}

extension AcceptAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcceptAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AcceptAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

public struct AcceptAttachmentOutputResponse: Swift.Equatable {
    /// The response to the attachment request.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init (
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct AcceptAttachmentOutputResponseBody: Swift.Equatable {
    let attachment: NetworkManagerClientTypes.Attachment?
}

extension AcceptAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.AccountStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case slrDeploymentStatus = "SLRDeploymentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let slrDeploymentStatus = self.slrDeploymentStatus {
            try encodeContainer.encode(slrDeploymentStatus, forKey: .slrDeploymentStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let slrDeploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slrDeploymentStatus)
        slrDeploymentStatus = slrDeploymentStatusDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the current status of an account within an Amazon Web Services Organization, including service-linked roles (SLRs).
    public struct AccountStatus: Swift.Equatable {
        /// The ID of an account within the Amazon Web Services Organization.
        public var accountId: Swift.String?
        /// The status of SLR deployment for the account.
        public var slrDeploymentStatus: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            slrDeploymentStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.slrDeploymentStatus = slrDeploymentStatus
        }
    }

}

extension AssociateConnectPeerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerId = "ConnectPeerId"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectPeerId = self.connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

extension AssociateConnectPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations"
    }
}

public struct AssociateConnectPeerInput: Swift.Equatable {
    /// The ID of the Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of your global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateConnectPeerInputBody: Swift.Equatable {
    let connectPeerId: Swift.String?
    let deviceId: Swift.String?
    let linkId: Swift.String?
}

extension AssociateConnectPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerId = "ConnectPeerId"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeerAssociation = output.connectPeerAssociation
        } else {
            self.connectPeerAssociation = nil
        }
    }
}

public struct AssociateConnectPeerOutputResponse: Swift.Equatable {
    /// The response to the Connect peer request.
    public var connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?

    public init (
        connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation? = nil
    )
    {
        self.connectPeerAssociation = connectPeerAssociation
    }
}

struct AssociateConnectPeerOutputResponseBody: Swift.Equatable {
    let connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?
}

extension AssociateConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerAssociation = "ConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerAssociation.self, forKey: .connectPeerAssociation)
        connectPeerAssociation = connectPeerAssociationDecoded
    }
}

extension AssociateCustomerGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = self.customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

extension AssociateCustomerGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
    }
}

public struct AssociateCustomerGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the customer gateway.
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?

    public init (
        customerGatewayArn: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateCustomerGatewayInputBody: Swift.Equatable {
    let customerGatewayArn: Swift.String?
    let deviceId: Swift.String?
    let linkId: Swift.String?
}

extension AssociateCustomerGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateCustomerGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomerGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateCustomerGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomerGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct AssociateCustomerGatewayOutputResponse: Swift.Equatable {
    /// The customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct AssociateCustomerGatewayOutputResponseBody: Swift.Equatable {
    let customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?
}

extension AssociateCustomerGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

extension AssociateLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

extension AssociateLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
    }
}

public struct AssociateLinkInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateLinkInputBody: Swift.Equatable {
    let deviceId: Swift.String?
    let linkId: Swift.String?
}

extension AssociateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct AssociateLinkOutputResponse: Swift.Equatable {
    /// The link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init (
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct AssociateLinkOutputResponseBody: Swift.Equatable {
    let linkAssociation: NetworkManagerClientTypes.LinkAssociation?
}

extension AssociateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

extension AssociateTransitGatewayConnectPeerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let transitGatewayConnectPeerArn = self.transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }
}

extension AssociateTransitGatewayConnectPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
    }
}

public struct AssociateTransitGatewayConnectPeerInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct AssociateTransitGatewayConnectPeerInputBody: Swift.Equatable {
    let transitGatewayConnectPeerArn: Swift.String?
    let deviceId: Swift.String?
    let linkId: Swift.String?
}

extension AssociateTransitGatewayConnectPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateTransitGatewayConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTransitGatewayConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateTransitGatewayConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTransitGatewayConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct AssociateTransitGatewayConnectPeerOutputResponse: Swift.Equatable {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct AssociateTransitGatewayConnectPeerOutputResponseBody: Swift.Equatable {
    let transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?
}

extension AssociateTransitGatewayConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension NetworkManagerClientTypes.Attachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
        case attachmentType = "AttachmentType"
        case coreNetworkArn = "CoreNetworkArn"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case edgeLocation = "EdgeLocation"
        case ownerAccountId = "OwnerAccountId"
        case proposedSegmentChange = "ProposedSegmentChange"
        case resourceArn = "ResourceArn"
        case segmentName = "SegmentName"
        case state = "State"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let attachmentPolicyRuleNumber = self.attachmentPolicyRuleNumber {
            try encodeContainer.encode(attachmentPolicyRuleNumber, forKey: .attachmentPolicyRuleNumber)
        }
        if let attachmentType = self.attachmentType {
            try encodeContainer.encode(attachmentType.rawValue, forKey: .attachmentType)
        }
        if let coreNetworkArn = self.coreNetworkArn {
            try encodeContainer.encode(coreNetworkArn, forKey: .coreNetworkArn)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let proposedSegmentChange = self.proposedSegmentChange {
            try encodeContainer.encode(proposedSegmentChange, forKey: .proposedSegmentChange)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let coreNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkArn)
        coreNetworkArn = coreNetworkArnDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let attachmentTypeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AttachmentType.self, forKey: .attachmentType)
        attachmentType = attachmentTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AttachmentState.self, forKey: .state)
        state = stateDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let attachmentPolicyRuleNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentPolicyRuleNumber)
        attachmentPolicyRuleNumber = attachmentPolicyRuleNumberDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let proposedSegmentChangeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ProposedSegmentChange.self, forKey: .proposedSegmentChange)
        proposedSegmentChange = proposedSegmentChangeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network attachment.
    public struct Attachment: Swift.Equatable {
        /// The ID of the attachment.
        public var attachmentId: Swift.String?
        /// The policy rule number associated with the attachment.
        public var attachmentPolicyRuleNumber: Swift.Int?
        /// The type of attachment.
        public var attachmentType: NetworkManagerClientTypes.AttachmentType?
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the attachment was created.
        public var createdAt: ClientRuntime.Date?
        /// The Region where the edge is located.
        public var edgeLocation: Swift.String?
        /// The ID of the attachment account owner.
        public var ownerAccountId: Swift.String?
        /// The attachment to move from one segment to another.
        public var proposedSegmentChange: NetworkManagerClientTypes.ProposedSegmentChange?
        /// The attachment resource ARN.
        public var resourceArn: Swift.String?
        /// The name of the segment attachment.
        public var segmentName: Swift.String?
        /// The state of the attachment.
        public var state: NetworkManagerClientTypes.AttachmentState?
        /// The tags associated with the attachment.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The timestamp when the attachment was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            attachmentId: Swift.String? = nil,
            attachmentPolicyRuleNumber: Swift.Int? = nil,
            attachmentType: NetworkManagerClientTypes.AttachmentType? = nil,
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            edgeLocation: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            proposedSegmentChange: NetworkManagerClientTypes.ProposedSegmentChange? = nil,
            resourceArn: Swift.String? = nil,
            segmentName: Swift.String? = nil,
            state: NetworkManagerClientTypes.AttachmentState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.attachmentType = attachmentType
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.ownerAccountId = ownerAccountId
            self.proposedSegmentChange = proposedSegmentChange
            self.resourceArn = resourceArn
            self.segmentName = segmentName
            self.state = state
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension NetworkManagerClientTypes {
    public enum AttachmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case pendingAttachmentAcceptance
        case pendingNetworkUpdate
        case pendingTagAcceptance
        case rejected
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .pendingAttachmentAcceptance,
                .pendingNetworkUpdate,
                .pendingTagAcceptance,
                .rejected,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pendingAttachmentAcceptance: return "PENDING_ATTACHMENT_ACCEPTANCE"
            case .pendingNetworkUpdate: return "PENDING_NETWORK_UPDATE"
            case .pendingTagAcceptance: return "PENDING_TAG_ACCEPTANCE"
            case .rejected: return "REJECTED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentState(rawValue: rawValue) ?? AttachmentState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum AttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connect
        case siteToSiteVpn
        case transitGatewayRouteTable
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentType] {
            return [
                .connect,
                .siteToSiteVpn,
                .transitGatewayRouteTable,
                .vpc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connect: return "CONNECT"
            case .siteToSiteVpn: return "SITE_TO_SITE_VPN"
            case .transitGatewayRouteTable: return "TRANSIT_GATEWAY_ROUTE_TABLE"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentType(rawValue: rawValue) ?? AttachmentType.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.Bandwidth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadSpeed = "DownloadSpeed"
        case uploadSpeed = "UploadSpeed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downloadSpeed = self.downloadSpeed {
            try encodeContainer.encode(downloadSpeed, forKey: .downloadSpeed)
        }
        if let uploadSpeed = self.uploadSpeed {
            try encodeContainer.encode(uploadSpeed, forKey: .uploadSpeed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadSpeedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uploadSpeed)
        uploadSpeed = uploadSpeedDecoded
        let downloadSpeedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downloadSpeed)
        downloadSpeed = downloadSpeedDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes bandwidth information.
    public struct Bandwidth: Swift.Equatable {
        /// Download speed in Mbps.
        public var downloadSpeed: Swift.Int?
        /// Upload speed in Mbps.
        public var uploadSpeed: Swift.Int?

        public init (
            downloadSpeed: Swift.Int? = nil,
            uploadSpeed: Swift.Int? = nil
        )
        {
            self.downloadSpeed = downloadSpeed
            self.uploadSpeed = uploadSpeed
        }
    }

}

extension NetworkManagerClientTypes.BgpOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case peerAsn = "PeerAsn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let peerAsn = self.peerAsn {
            try encodeContainer.encode(peerAsn, forKey: .peerAsn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let peerAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .peerAsn)
        peerAsn = peerAsnDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the BGP options.
    public struct BgpOptions: Swift.Equatable {
        /// The Peer ASN of the BGP.
        public var peerAsn: Swift.Int?

        public init (
            peerAsn: Swift.Int? = nil
        )
        {
            self.peerAsn = peerAsn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ChangeAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .add,
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ChangeSetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executing
        case executionSucceeded
        case failedGeneration
        case outOfDate
        case pendingGeneration
        case readyToExecute
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeSetState] {
            return [
                .executing,
                .executionSucceeded,
                .failedGeneration,
                .outOfDate,
                .pendingGeneration,
                .readyToExecute,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executing: return "EXECUTING"
            case .executionSucceeded: return "EXECUTION_SUCCEEDED"
            case .failedGeneration: return "FAILED_GENERATION"
            case .outOfDate: return "OUT_OF_DATE"
            case .pendingGeneration: return "PENDING_GENERATION"
            case .readyToExecute: return "READY_TO_EXECUTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeSetState(rawValue: rawValue) ?? ChangeSetState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ChangeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeStatus(rawValue: rawValue) ?? ChangeStatus.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachmentMapping
        case attachmentPoliciesConfiguration
        case attachmentRoutePropagation
        case attachmentRouteStatic
        case coreNetworkConfiguration
        case coreNetworkEdge
        case coreNetworkSegment
        case segmentsConfiguration
        case segmentActionsConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .attachmentMapping,
                .attachmentPoliciesConfiguration,
                .attachmentRoutePropagation,
                .attachmentRouteStatic,
                .coreNetworkConfiguration,
                .coreNetworkEdge,
                .coreNetworkSegment,
                .segmentsConfiguration,
                .segmentActionsConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachmentMapping: return "ATTACHMENT_MAPPING"
            case .attachmentPoliciesConfiguration: return "ATTACHMENT_POLICIES_CONFIGURATION"
            case .attachmentRoutePropagation: return "ATTACHMENT_ROUTE_PROPAGATION"
            case .attachmentRouteStatic: return "ATTACHMENT_ROUTE_STATIC"
            case .coreNetworkConfiguration: return "CORE_NETWORK_CONFIGURATION"
            case .coreNetworkEdge: return "CORE_NETWORK_EDGE"
            case .coreNetworkSegment: return "CORE_NETWORK_SEGMENT"
            case .segmentsConfiguration: return "SEGMENTS_CONFIGURATION"
            case .segmentActionsConfiguration: return "SEGMENT_ACTIONS_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict processing the request. Updating or deleting the resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension NetworkManagerClientTypes.ConnectAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case options = "Options"
        case transportAttachmentId = "TransportAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = self.attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let transportAttachmentId = self.transportAttachmentId {
            try encodeContainer.encode(transportAttachmentId, forKey: .transportAttachmentId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let transportAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transportAttachmentId)
        transportAttachmentId = transportAttachmentIdDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachmentOptions.self, forKey: .options)
        options = optionsDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect attachment.
    public struct ConnectAttachment: Swift.Equatable {
        /// The attachment details.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// Options for connecting an attachment.
        public var options: NetworkManagerClientTypes.ConnectAttachmentOptions?
        /// The ID of the transport attachment.
        public var transportAttachmentId: Swift.String?

        public init (
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            options: NetworkManagerClientTypes.ConnectAttachmentOptions? = nil,
            transportAttachmentId: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.options = options
            self.transportAttachmentId = transportAttachmentId
        }
    }

}

extension NetworkManagerClientTypes.ConnectAttachmentOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TunnelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect attachment options.
    public struct ConnectAttachmentOptions: Swift.Equatable {
        /// The protocol used for the attachment connection.
        public var `protocol`: NetworkManagerClientTypes.TunnelProtocol?

        public init (
            `protocol`: NetworkManagerClientTypes.TunnelProtocol? = nil
        )
        {
            self.`protocol` = `protocol`
        }
    }

}

extension NetworkManagerClientTypes.ConnectPeer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case connectAttachmentId = "ConnectAttachmentId"
        case connectPeerId = "ConnectPeerId"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case edgeLocation = "EdgeLocation"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let connectAttachmentId = self.connectAttachmentId {
            try encodeContainer.encode(connectAttachmentId, forKey: .connectAttachmentId)
        }
        if let connectPeerId = self.connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let connectAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectAttachmentId)
        connectAttachmentId = connectAttachmentIdDecoded
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer.
    public struct ConnectPeer: Swift.Equatable {
        /// The configuration of the Connect peer.
        public var configuration: NetworkManagerClientTypes.ConnectPeerConfiguration?
        /// The ID of the attachment to connect.
        public var connectAttachmentId: Swift.String?
        /// The ID of the Connect peer.
        public var connectPeerId: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the Connect peer was created.
        public var createdAt: ClientRuntime.Date?
        /// The Connect peer Regions where edges are located.
        public var edgeLocation: Swift.String?
        /// The state of the Connect peer.
        public var state: NetworkManagerClientTypes.ConnectPeerState?
        /// The list of key-value tags associated with the Connect peer.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            configuration: NetworkManagerClientTypes.ConnectPeerConfiguration? = nil,
            connectAttachmentId: Swift.String? = nil,
            connectPeerId: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            edgeLocation: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectPeerState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.configuration = configuration
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.ConnectPeerAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerId = "ConnectPeerId"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectPeerId = self.connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer association.
    public struct ConnectPeerAssociation: Swift.Equatable {
        /// The ID of the Connect peer.
        public var connectPeerId: Swift.String?
        /// The ID of the device to connect to.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The state of the Connect peer association.
        public var state: NetworkManagerClientTypes.ConnectPeerAssociationState?

        public init (
            connectPeerId: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectPeerAssociationState? = nil
        )
        {
            self.connectPeerId = connectPeerId
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ConnectPeerAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectPeerAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectPeerAssociationState(rawValue: rawValue) ?? ConnectPeerAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.ConnectPeerBgpConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkAddress = "CoreNetworkAddress"
        case coreNetworkAsn = "CoreNetworkAsn"
        case peerAddress = "PeerAddress"
        case peerAsn = "PeerAsn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkAddress = self.coreNetworkAddress {
            try encodeContainer.encode(coreNetworkAddress, forKey: .coreNetworkAddress)
        }
        if let coreNetworkAsn = self.coreNetworkAsn {
            try encodeContainer.encode(coreNetworkAsn, forKey: .coreNetworkAsn)
        }
        if let peerAddress = self.peerAddress {
            try encodeContainer.encode(peerAddress, forKey: .peerAddress)
        }
        if let peerAsn = self.peerAsn {
            try encodeContainer.encode(peerAsn, forKey: .peerAsn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .coreNetworkAsn)
        coreNetworkAsn = coreNetworkAsnDecoded
        let peerAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .peerAsn)
        peerAsn = peerAsnDecoded
        let coreNetworkAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAddress)
        coreNetworkAddress = coreNetworkAddressDecoded
        let peerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peerAddress)
        peerAddress = peerAddressDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network BGP configuration.
    public struct ConnectPeerBgpConfiguration: Swift.Equatable {
        /// The address of a core network.
        public var coreNetworkAddress: Swift.String?
        /// The ASN of the Coret Network.
        public var coreNetworkAsn: Swift.Int?
        /// The address of a core network Connect peer.
        public var peerAddress: Swift.String?
        /// The ASN of the Connect peer.
        public var peerAsn: Swift.Int?

        public init (
            coreNetworkAddress: Swift.String? = nil,
            coreNetworkAsn: Swift.Int? = nil,
            peerAddress: Swift.String? = nil,
            peerAsn: Swift.Int? = nil
        )
        {
            self.coreNetworkAddress = coreNetworkAddress
            self.coreNetworkAsn = coreNetworkAsn
            self.peerAddress = peerAddress
            self.peerAsn = peerAsn
        }
    }

}

extension NetworkManagerClientTypes.ConnectPeerConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpConfigurations = "BgpConfigurations"
        case coreNetworkAddress = "CoreNetworkAddress"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpConfigurations = bgpConfigurations {
            var bgpConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpConfigurations)
            for connectpeerbgpconfiguration0 in bgpConfigurations {
                try bgpConfigurationsContainer.encode(connectpeerbgpconfiguration0)
            }
        }
        if let coreNetworkAddress = self.coreNetworkAddress {
            try encodeContainer.encode(coreNetworkAddress, forKey: .coreNetworkAddress)
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstring0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstring0)
            }
        }
        if let peerAddress = self.peerAddress {
            try encodeContainer.encode(peerAddress, forKey: .peerAddress)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAddress)
        coreNetworkAddress = coreNetworkAddressDecoded
        let peerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peerAddress)
        peerAddress = peerAddressDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TunnelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let bgpConfigurationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ConnectPeerBgpConfiguration?].self, forKey: .bgpConfigurations)
        var bgpConfigurationsDecoded0:[NetworkManagerClientTypes.ConnectPeerBgpConfiguration]? = nil
        if let bgpConfigurationsContainer = bgpConfigurationsContainer {
            bgpConfigurationsDecoded0 = [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]()
            for structure0 in bgpConfigurationsContainer {
                if let structure0 = structure0 {
                    bgpConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        bgpConfigurations = bgpConfigurationsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer configuration.
    public struct ConnectPeerConfiguration: Swift.Equatable {
        /// The Connect peer BGP configurations.
        public var bgpConfigurations: [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]?
        /// The IP address of a core network.
        public var coreNetworkAddress: Swift.String?
        /// The inside IP addresses used for a Connect peer configuration.
        public var insideCidrBlocks: [Swift.String]?
        /// The IP address of the Connect peer.
        public var peerAddress: Swift.String?
        /// The protocol used for a Connect peer configuration.
        public var `protocol`: NetworkManagerClientTypes.TunnelProtocol?

        public init (
            bgpConfigurations: [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]? = nil,
            coreNetworkAddress: Swift.String? = nil,
            insideCidrBlocks: [Swift.String]? = nil,
            peerAddress: Swift.String? = nil,
            `protocol`: NetworkManagerClientTypes.TunnelProtocol? = nil
        )
        {
            self.bgpConfigurations = bgpConfigurations
            self.coreNetworkAddress = coreNetworkAddress
            self.insideCidrBlocks = insideCidrBlocks
            self.peerAddress = peerAddress
            self.`protocol` = `protocol`
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ConnectPeerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectPeerState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectPeerState(rawValue: rawValue) ?? ConnectPeerState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.ConnectPeerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectAttachmentId = "ConnectAttachmentId"
        case connectPeerId = "ConnectPeerId"
        case connectPeerState = "ConnectPeerState"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case edgeLocation = "EdgeLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectAttachmentId = self.connectAttachmentId {
            try encodeContainer.encode(connectAttachmentId, forKey: .connectAttachmentId)
        }
        if let connectPeerId = self.connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let connectPeerState = self.connectPeerState {
            try encodeContainer.encode(connectPeerState.rawValue, forKey: .connectPeerState)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let connectAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectAttachmentId)
        connectAttachmentId = connectAttachmentIdDecoded
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let connectPeerStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerState.self, forKey: .connectPeerState)
        connectPeerState = connectPeerStateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Summary description of a Connect peer.
    public struct ConnectPeerSummary: Swift.Equatable {
        /// The ID of a Connect peer attachment.
        public var connectAttachmentId: Swift.String?
        /// The ID of a Connect peer.
        public var connectPeerId: Swift.String?
        /// The state of a Connect peer.
        public var connectPeerState: NetworkManagerClientTypes.ConnectPeerState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a Connect peer was created.
        public var createdAt: ClientRuntime.Date?
        /// The Region where the edge is located.
        public var edgeLocation: Swift.String?
        /// The list of key-value tags associated with the Connect peer summary.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            connectAttachmentId: Swift.String? = nil,
            connectPeerId: Swift.String? = nil,
            connectPeerState: NetworkManagerClientTypes.ConnectPeerState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            edgeLocation: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.connectPeerState = connectPeerState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case connectionArn = "ConnectionArn"
        case connectionId = "ConnectionId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = self.connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = self.connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a connection.
    public struct Connection: Swift.Equatable {
        /// The ID of the second device in the connection.
        public var connectedDeviceId: Swift.String?
        /// The ID of the link for the second device in the connection.
        public var connectedLinkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the connection.
        public var connectionArn: Swift.String?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The date and time that the connection was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the connection.
        public var description: Swift.String?
        /// The ID of the first device in the connection.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link for the first device in the connection.
        public var linkId: Swift.String?
        /// The state of the connection.
        public var state: NetworkManagerClientTypes.ConnectionState?
        /// The tags for the connection.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            connectedDeviceId: Swift.String? = nil,
            connectedLinkId: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectionState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.connectionArn = connectionArn
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.ConnectionHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case timestamp = "Timestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes connection health.
    public struct ConnectionHealth: Swift.Equatable {
        /// The connection status.
        public var status: NetworkManagerClientTypes.ConnectionStatus?
        /// The time the status was last updated.
        public var timestamp: ClientRuntime.Date?
        /// The connection type.
        public var type: NetworkManagerClientTypes.ConnectionType?

        public init (
            status: NetworkManagerClientTypes.ConnectionStatus? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: NetworkManagerClientTypes.ConnectionType? = nil
        )
        {
            self.status = status
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case down
        case up
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .down,
                .up,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .down: return "DOWN"
            case .up: return "UP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bgp
        case ipsec
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .bgp,
                .ipsec,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bgp: return "BGP"
            case .ipsec: return "IPSEC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.CoreNetwork: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkArn = "CoreNetworkArn"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case edges = "Edges"
        case globalNetworkId = "GlobalNetworkId"
        case segments = "Segments"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkArn = self.coreNetworkArn {
            try encodeContainer.encode(coreNetworkArn, forKey: .coreNetworkArn)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let edges = edges {
            var edgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edges)
            for corenetworkedge0 in edges {
                try edgesContainer.encode(corenetworkedge0)
            }
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let segments = segments {
            var segmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segments)
            for corenetworksegment0 in segments {
                try segmentsContainer.encode(corenetworksegment0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let coreNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkArn)
        coreNetworkArn = coreNetworkArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkState.self, forKey: .state)
        state = stateDecoded
        let segmentsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkSegment?].self, forKey: .segments)
        var segmentsDecoded0:[NetworkManagerClientTypes.CoreNetworkSegment]? = nil
        if let segmentsContainer = segmentsContainer {
            segmentsDecoded0 = [NetworkManagerClientTypes.CoreNetworkSegment]()
            for structure0 in segmentsContainer {
                if let structure0 = structure0 {
                    segmentsDecoded0?.append(structure0)
                }
            }
        }
        segments = segmentsDecoded0
        let edgesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkEdge?].self, forKey: .edges)
        var edgesDecoded0:[NetworkManagerClientTypes.CoreNetworkEdge]? = nil
        if let edgesContainer = edgesContainer {
            edgesDecoded0 = [NetworkManagerClientTypes.CoreNetworkEdge]()
            for structure0 in edgesContainer {
                if let structure0 = structure0 {
                    edgesDecoded0?.append(structure0)
                }
            }
        }
        edges = edgesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network.
    public struct CoreNetwork: Swift.Equatable {
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a core network.
        public var description: Swift.String?
        /// The edges within a core network.
        public var edges: [NetworkManagerClientTypes.CoreNetworkEdge]?
        /// The ID of the global network that your core network is a part of.
        public var globalNetworkId: Swift.String?
        /// The segments within a core network.
        public var segments: [NetworkManagerClientTypes.CoreNetworkSegment]?
        /// The current state of a core network.
        public var state: NetworkManagerClientTypes.CoreNetworkState?
        /// The list of key-value tags associated with a core network.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            edges: [NetworkManagerClientTypes.CoreNetworkEdge]? = nil,
            globalNetworkId: Swift.String? = nil,
            segments: [NetworkManagerClientTypes.CoreNetworkSegment]? = nil,
            state: NetworkManagerClientTypes.CoreNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.edges = edges
            self.globalNetworkId = globalNetworkId
            self.segments = segments
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case identifier = "Identifier"
        case identifierPath = "IdentifierPath"
        case newValues = "NewValues"
        case previousValues = "PreviousValues"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let identifierPath = self.identifierPath {
            try encodeContainer.encode(identifierPath, forKey: .identifierPath)
        }
        if let newValues = self.newValues {
            try encodeContainer.encode(newValues, forKey: .newValues)
        }
        if let previousValues = self.previousValues {
            try encodeContainer.encode(previousValues, forKey: .previousValues)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeType.self, forKey: .type)
        type = typeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeAction.self, forKey: .action)
        action = actionDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let previousValuesDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkChangeValues.self, forKey: .previousValues)
        previousValues = previousValuesDecoded
        let newValuesDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkChangeValues.self, forKey: .newValues)
        newValues = newValuesDecoded
        let identifierPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifierPath)
        identifierPath = identifierPathDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Details describing a core network change.
    public struct CoreNetworkChange: Swift.Equatable {
        /// The action to take for a core network.
        public var action: NetworkManagerClientTypes.ChangeAction?
        /// The resource identifier.
        public var identifier: Swift.String?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public var identifierPath: Swift.String?
        /// The new value for a core network
        public var newValues: NetworkManagerClientTypes.CoreNetworkChangeValues?
        /// The previous values for a core network.
        public var previousValues: NetworkManagerClientTypes.CoreNetworkChangeValues?
        /// The type of change.
        public var type: NetworkManagerClientTypes.ChangeType?

        public init (
            action: NetworkManagerClientTypes.ChangeAction? = nil,
            identifier: Swift.String? = nil,
            identifierPath: Swift.String? = nil,
            newValues: NetworkManagerClientTypes.CoreNetworkChangeValues? = nil,
            previousValues: NetworkManagerClientTypes.CoreNetworkChangeValues? = nil,
            type: NetworkManagerClientTypes.ChangeType? = nil
        )
        {
            self.action = action
            self.identifier = identifier
            self.identifierPath = identifierPath
            self.newValues = newValues
            self.previousValues = previousValues
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkChangeEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case eventTime = "EventTime"
        case identifierPath = "IdentifierPath"
        case status = "Status"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let identifierPath = self.identifierPath {
            try encodeContainer.encode(identifierPath, forKey: .identifierPath)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = self.values {
            try encodeContainer.encode(values, forKey: .values)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeType.self, forKey: .type)
        type = typeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeAction.self, forKey: .action)
        action = actionDecoded
        let identifierPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifierPath)
        identifierPath = identifierPathDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeStatus.self, forKey: .status)
        status = statusDecoded
        let valuesDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkChangeEventValues.self, forKey: .values)
        values = valuesDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network change event. This can be a change to a segment, attachment, route, etc.
    public struct CoreNetworkChangeEvent: Swift.Equatable {
        /// The action taken for the change event.
        public var action: NetworkManagerClientTypes.ChangeAction?
        /// The timestamp for an event change in status.
        public var eventTime: ClientRuntime.Date?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public var identifierPath: Swift.String?
        /// The status of the core network change event.
        public var status: NetworkManagerClientTypes.ChangeStatus?
        /// Describes the type of change event.
        public var type: NetworkManagerClientTypes.ChangeType?
        /// Details of the change event.
        public var values: NetworkManagerClientTypes.CoreNetworkChangeEventValues?

        public init (
            action: NetworkManagerClientTypes.ChangeAction? = nil,
            eventTime: ClientRuntime.Date? = nil,
            identifierPath: Swift.String? = nil,
            status: NetworkManagerClientTypes.ChangeStatus? = nil,
            type: NetworkManagerClientTypes.ChangeType? = nil,
            values: NetworkManagerClientTypes.CoreNetworkChangeEventValues? = nil
        )
        {
            self.action = action
            self.eventTime = eventTime
            self.identifierPath = identifierPath
            self.status = status
            self.type = type
            self.values = values
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkChangeEventValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case cidr = "Cidr"
        case edgeLocation = "EdgeLocation"
        case segmentName = "SegmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network change event.
    public struct CoreNetworkChangeEventValues: Swift.Equatable {
        /// The ID of the attachment if the change event is associated with an attachment.
        public var attachmentId: Swift.String?
        /// For a STATIC_ROUTE event, this is the IP address.
        public var cidr: Swift.String?
        /// The edge location for the core network change event.
        public var edgeLocation: Swift.String?
        /// The segment name if the change event is associated with a segment.
        public var segmentName: Swift.String?

        public init (
            attachmentId: Swift.String? = nil,
            cidr: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            segmentName: Swift.String? = nil
        )
        {
            self.attachmentId = attachmentId
            self.cidr = cidr
            self.edgeLocation = edgeLocation
            self.segmentName = segmentName
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkChangeValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "Asn"
        case cidr = "Cidr"
        case destinationIdentifier = "DestinationIdentifier"
        case edgeLocations = "EdgeLocations"
        case insideCidrBlocks = "InsideCidrBlocks"
        case segmentName = "SegmentName"
        case sharedSegments = "SharedSegments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = self.asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let destinationIdentifier = self.destinationIdentifier {
            try encodeContainer.encode(destinationIdentifier, forKey: .destinationIdentifier)
        }
        if let edgeLocations = edgeLocations {
            var edgeLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeLocations)
            for externalregioncode0 in edgeLocations {
                try edgeLocationsContainer.encode(externalregioncode0)
            }
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstring0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstring0)
            }
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let sharedSegments = sharedSegments {
            var sharedSegmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedSegments)
            for constrainedstring0 in sharedSegments {
                try sharedSegmentsContainer.encode(constrainedstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let edgeLocationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeLocations)
        var edgeLocationsDecoded0:[Swift.String]? = nil
        if let edgeLocationsContainer = edgeLocationsContainer {
            edgeLocationsDecoded0 = [Swift.String]()
            for string0 in edgeLocationsContainer {
                if let string0 = string0 {
                    edgeLocationsDecoded0?.append(string0)
                }
            }
        }
        edgeLocations = edgeLocationsDecoded0
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn)
        asn = asnDecoded
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let destinationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIdentifier)
        destinationIdentifier = destinationIdentifierDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
        let sharedSegmentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedSegments)
        var sharedSegmentsDecoded0:[Swift.String]? = nil
        if let sharedSegmentsContainer = sharedSegmentsContainer {
            sharedSegmentsDecoded0 = [Swift.String]()
            for string0 in sharedSegmentsContainer {
                if let string0 = string0 {
                    sharedSegmentsDecoded0?.append(string0)
                }
            }
        }
        sharedSegments = sharedSegmentsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network change.
    public struct CoreNetworkChangeValues: Swift.Equatable {
        /// The ASN of a core network.
        public var asn: Swift.Int?
        /// The IP addresses used for a core network.
        public var cidr: Swift.String?
        /// The ID of the destination.
        public var destinationIdentifier: Swift.String?
        /// The Regions where edges are located in a core network.
        public var edgeLocations: [Swift.String]?
        /// The inside IP addresses used for core network change values.
        public var insideCidrBlocks: [Swift.String]?
        /// The names of the segments in a core network.
        public var segmentName: Swift.String?
        /// The shared segments for a core network change value.
        public var sharedSegments: [Swift.String]?

        public init (
            asn: Swift.Int? = nil,
            cidr: Swift.String? = nil,
            destinationIdentifier: Swift.String? = nil,
            edgeLocations: [Swift.String]? = nil,
            insideCidrBlocks: [Swift.String]? = nil,
            segmentName: Swift.String? = nil,
            sharedSegments: [Swift.String]? = nil
        )
        {
            self.asn = asn
            self.cidr = cidr
            self.destinationIdentifier = destinationIdentifier
            self.edgeLocations = edgeLocations
            self.insideCidrBlocks = insideCidrBlocks
            self.segmentName = segmentName
            self.sharedSegments = sharedSegments
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkEdge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "Asn"
        case edgeLocation = "EdgeLocation"
        case insideCidrBlocks = "InsideCidrBlocks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = self.asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstring0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn)
        asn = asnDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network edge.
    public struct CoreNetworkEdge: Swift.Equatable {
        /// The ASN of a core network edge.
        public var asn: Swift.Int?
        /// The Region where a core network edge is located.
        public var edgeLocation: Swift.String?
        /// The inside IP addresses used for core network edges.
        public var insideCidrBlocks: [Swift.String]?

        public init (
            asn: Swift.Int? = nil,
            edgeLocation: Swift.String? = nil,
            insideCidrBlocks: [Swift.String]? = nil
        )
        {
            self.asn = asn
            self.edgeLocation = edgeLocation
            self.insideCidrBlocks = insideCidrBlocks
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case changeSetState = "ChangeSetState"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case policyDocument = "PolicyDocument"
        case policyErrors = "PolicyErrors"
        case policyVersionId = "PolicyVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias.rawValue, forKey: .alias)
        }
        if let changeSetState = self.changeSetState {
            try encodeContainer.encode(changeSetState.rawValue, forKey: .changeSetState)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyErrors = policyErrors {
            var policyErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyErrors)
            for corenetworkpolicyerror0 in policyErrors {
                try policyErrorsContainer.encode(corenetworkpolicyerror0)
            }
        }
        if let policyVersionId = self.policyVersionId {
            try encodeContainer.encode(policyVersionId, forKey: .policyVersionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicyAlias.self, forKey: .alias)
        alias = aliasDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let changeSetStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeSetState.self, forKey: .changeSetState)
        changeSetState = changeSetStateDecoded
        let policyErrorsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkPolicyError?].self, forKey: .policyErrors)
        var policyErrorsDecoded0:[NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil
        if let policyErrorsContainer = policyErrorsContainer {
            policyErrorsDecoded0 = [NetworkManagerClientTypes.CoreNetworkPolicyError]()
            for structure0 in policyErrorsContainer {
                if let structure0 = structure0 {
                    policyErrorsDecoded0?.append(structure0)
                }
            }
        }
        policyErrors = policyErrorsDecoded0
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network policy. You can have only one LIVE Core Policy.
    public struct CoreNetworkPolicy: Swift.Equatable {
        /// Whether a core network policy is the current LIVE policy or the most recently submitted policy.
        public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
        /// The state of a core network policy.
        public var changeSetState: NetworkManagerClientTypes.ChangeSetState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network policy was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a core network policy.
        public var description: Swift.String?
        /// Describes a core network policy.
        public var policyDocument: Swift.String?
        /// Describes any errors in a core network policy.
        public var policyErrors: [NetworkManagerClientTypes.CoreNetworkPolicyError]?
        /// The ID of the policy version.
        public var policyVersionId: Swift.Int?

        public init (
            alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
            changeSetState: NetworkManagerClientTypes.ChangeSetState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            policyDocument: Swift.String? = nil,
            policyErrors: [NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil,
            policyVersionId: Swift.Int? = nil
        )
        {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyDocument = policyDocument
            self.policyErrors = policyErrors
            self.policyVersionId = policyVersionId
        }
    }

}

extension NetworkManagerClientTypes {
    public enum CoreNetworkPolicyAlias: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latest
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreNetworkPolicyAlias] {
            return [
                .latest,
                .live,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoreNetworkPolicyAlias(rawValue: rawValue) ?? CoreNetworkPolicyAlias.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Provides details about an error in a core network policy.
    public struct CoreNetworkPolicyError: Swift.Equatable {
        /// The error code associated with a core network policy error.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message associated with a core network policy error code.
        /// This member is required.
        public var message: Swift.String?
        /// The JSON path where the error was discovered in the policy document.
        public var path: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.path = path
        }
    }

}

extension CoreNetworkPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CoreNetworkPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.message = output.message
        } else {
            self.errors = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Describes a core network policy exception.
public struct CoreNetworkPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Describes a core network policy exception.
    public var errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]?
    /// This member is required.
    public var message: Swift.String?

    public init (
        errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil,
        message: Swift.String? = nil
    )
    {
        self.errors = errors
        self.message = message
    }
}

struct CoreNetworkPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]?
}

extension CoreNetworkPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkPolicyError?].self, forKey: .errors)
        var errorsDecoded0:[NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [NetworkManagerClientTypes.CoreNetworkPolicyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case changeSetState = "ChangeSetState"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case policyVersionId = "PolicyVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias.rawValue, forKey: .alias)
        }
        if let changeSetState = self.changeSetState {
            try encodeContainer.encode(changeSetState.rawValue, forKey: .changeSetState)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyVersionId = self.policyVersionId {
            try encodeContainer.encode(policyVersionId, forKey: .policyVersionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicyAlias.self, forKey: .alias)
        alias = aliasDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let changeSetStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeSetState.self, forKey: .changeSetState)
        changeSetState = changeSetStateDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network policy version.
    public struct CoreNetworkPolicyVersion: Swift.Equatable {
        /// Whether a core network policy is the current policy or the most recently submitted policy.
        public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
        /// The status of the policy version change set.
        public var changeSetState: NetworkManagerClientTypes.ChangeSetState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network policy version was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a core network policy version.
        public var description: Swift.String?
        /// The ID of the policy version.
        public var policyVersionId: Swift.Int?

        public init (
            alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
            changeSetState: NetworkManagerClientTypes.ChangeSetState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            policyVersionId: Swift.Int? = nil
        )
        {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyVersionId = policyVersionId
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkSegment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeLocations = "EdgeLocations"
        case name = "Name"
        case sharedSegments = "SharedSegments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeLocations = edgeLocations {
            var edgeLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeLocations)
            for externalregioncode0 in edgeLocations {
                try edgeLocationsContainer.encode(externalregioncode0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedSegments = sharedSegments {
            var sharedSegmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedSegments)
            for constrainedstring0 in sharedSegments {
                try sharedSegmentsContainer.encode(constrainedstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let edgeLocationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeLocations)
        var edgeLocationsDecoded0:[Swift.String]? = nil
        if let edgeLocationsContainer = edgeLocationsContainer {
            edgeLocationsDecoded0 = [Swift.String]()
            for string0 in edgeLocationsContainer {
                if let string0 = string0 {
                    edgeLocationsDecoded0?.append(string0)
                }
            }
        }
        edgeLocations = edgeLocationsDecoded0
        let sharedSegmentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedSegments)
        var sharedSegmentsDecoded0:[Swift.String]? = nil
        if let sharedSegmentsContainer = sharedSegmentsContainer {
            sharedSegmentsDecoded0 = [Swift.String]()
            for string0 in sharedSegmentsContainer {
                if let string0 = string0 {
                    sharedSegmentsDecoded0?.append(string0)
                }
            }
        }
        sharedSegments = sharedSegmentsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network segment, which are dedicated routes. Only attachments within this segment can communicate with each other.
    public struct CoreNetworkSegment: Swift.Equatable {
        /// The Regions where the edges are located.
        public var edgeLocations: [Swift.String]?
        /// The name of a core network segment.
        public var name: Swift.String?
        /// The shared segments of a core network.
        public var sharedSegments: [Swift.String]?

        public init (
            edgeLocations: [Swift.String]? = nil,
            name: Swift.String? = nil,
            sharedSegments: [Swift.String]? = nil
        )
        {
            self.edgeLocations = edgeLocations
            self.name = name
            self.sharedSegments = sharedSegments
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkId = "CoreNetworkId"
        case edgeLocation = "EdgeLocation"
        case segmentName = "SegmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Returns details about a core network edge.
    public struct CoreNetworkSegmentEdgeIdentifier: Swift.Equatable {
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The Region where the segment edge is located.
        public var edgeLocation: Swift.String?
        /// The name of the segment edge.
        public var segmentName: Swift.String?

        public init (
            coreNetworkId: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            segmentName: Swift.String? = nil
        )
        {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.segmentName = segmentName
        }
    }

}

extension NetworkManagerClientTypes {
    public enum CoreNetworkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreNetworkState] {
            return [
                .available,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoreNetworkState(rawValue: rawValue) ?? CoreNetworkState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.CoreNetworkSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkArn = "CoreNetworkArn"
        case coreNetworkId = "CoreNetworkId"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkArn = self.coreNetworkArn {
            try encodeContainer.encode(coreNetworkArn, forKey: .coreNetworkArn)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let coreNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkArn)
        coreNetworkArn = coreNetworkArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Returns summary information about a core network.
    public struct CoreNetworkSummary: Swift.Equatable {
        /// a core network ARN.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The description of a core network.
        public var description: Swift.String?
        /// The global network ID.
        public var globalNetworkId: Swift.String?
        /// The ID of the account owner.
        public var ownerAccountId: Swift.String?
        /// The state of a core network.
        public var state: NetworkManagerClientTypes.CoreNetworkState?
        /// The key-value tags associated with a core network summary.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            state: NetworkManagerClientTypes.CoreNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.ownerAccountId = ownerAccountId
            self.state = state
            self.tags = tags
        }
    }

}

extension CreateConnectAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case edgeLocation = "EdgeLocation"
        case options = "Options"
        case tags = "Tags"
        case transportAttachmentId = "TransportAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let transportAttachmentId = self.transportAttachmentId {
            try encodeContainer.encode(transportAttachmentId, forKey: .transportAttachmentId)
        }
    }
}

extension CreateConnectAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/connect-attachments"
    }
}

public struct CreateConnectAttachmentInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network where you want to create the attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The Region where the edge is located.
    /// This member is required.
    public var edgeLocation: Swift.String?
    /// Options for creating an attachment.
    /// This member is required.
    public var options: NetworkManagerClientTypes.ConnectAttachmentOptions?
    /// The list of key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ID of the attachment between the two connections.
    /// This member is required.
    public var transportAttachmentId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        options: NetworkManagerClientTypes.ConnectAttachmentOptions? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        transportAttachmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.options = options
        self.tags = tags
        self.transportAttachmentId = transportAttachmentId
    }
}

struct CreateConnectAttachmentInputBody: Swift.Equatable {
    let coreNetworkId: Swift.String?
    let edgeLocation: Swift.String?
    let transportAttachmentId: Swift.String?
    let options: NetworkManagerClientTypes.ConnectAttachmentOptions?
    let tags: [NetworkManagerClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateConnectAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case edgeLocation = "EdgeLocation"
        case options = "Options"
        case tags = "Tags"
        case transportAttachmentId = "TransportAttachmentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let transportAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transportAttachmentId)
        transportAttachmentId = transportAttachmentIdDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachmentOptions.self, forKey: .options)
        options = optionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateConnectAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectAttachment = output.connectAttachment
        } else {
            self.connectAttachment = nil
        }
    }
}

public struct CreateConnectAttachmentOutputResponse: Swift.Equatable {
    /// The response to a Connect attachment request.
    public var connectAttachment: NetworkManagerClientTypes.ConnectAttachment?

    public init (
        connectAttachment: NetworkManagerClientTypes.ConnectAttachment? = nil
    )
    {
        self.connectAttachment = connectAttachment
    }
}

struct CreateConnectAttachmentOutputResponseBody: Swift.Equatable {
    let connectAttachment: NetworkManagerClientTypes.ConnectAttachment?
}

extension CreateConnectAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectAttachment = "ConnectAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachment.self, forKey: .connectAttachment)
        connectAttachment = connectAttachmentDecoded
    }
}

extension CreateConnectPeerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpOptions = "BgpOptions"
        case clientToken = "ClientToken"
        case connectAttachmentId = "ConnectAttachmentId"
        case coreNetworkAddress = "CoreNetworkAddress"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpOptions = self.bgpOptions {
            try encodeContainer.encode(bgpOptions, forKey: .bgpOptions)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let connectAttachmentId = self.connectAttachmentId {
            try encodeContainer.encode(connectAttachmentId, forKey: .connectAttachmentId)
        }
        if let coreNetworkAddress = self.coreNetworkAddress {
            try encodeContainer.encode(coreNetworkAddress, forKey: .coreNetworkAddress)
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstring0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstring0)
            }
        }
        if let peerAddress = self.peerAddress {
            try encodeContainer.encode(peerAddress, forKey: .peerAddress)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConnectPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/connect-peers"
    }
}

public struct CreateConnectPeerInput: Swift.Equatable {
    /// The Connect peer BGP options.
    public var bgpOptions: NetworkManagerClientTypes.BgpOptions?
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of the connection attachment.
    /// This member is required.
    public var connectAttachmentId: Swift.String?
    /// A Connect peer core network address.
    public var coreNetworkAddress: Swift.String?
    /// The inside IP addresses used for BGP peering.
    /// This member is required.
    public var insideCidrBlocks: [Swift.String]?
    /// The Connect peer address.
    /// This member is required.
    public var peerAddress: Swift.String?
    /// The tags associated with the peer request.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        bgpOptions: NetworkManagerClientTypes.BgpOptions? = nil,
        clientToken: Swift.String? = nil,
        connectAttachmentId: Swift.String? = nil,
        coreNetworkAddress: Swift.String? = nil,
        insideCidrBlocks: [Swift.String]? = nil,
        peerAddress: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.bgpOptions = bgpOptions
        self.clientToken = clientToken
        self.connectAttachmentId = connectAttachmentId
        self.coreNetworkAddress = coreNetworkAddress
        self.insideCidrBlocks = insideCidrBlocks
        self.peerAddress = peerAddress
        self.tags = tags
    }
}

struct CreateConnectPeerInputBody: Swift.Equatable {
    let connectAttachmentId: Swift.String?
    let coreNetworkAddress: Swift.String?
    let peerAddress: Swift.String?
    let bgpOptions: NetworkManagerClientTypes.BgpOptions?
    let insideCidrBlocks: [Swift.String]?
    let tags: [NetworkManagerClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateConnectPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpOptions = "BgpOptions"
        case clientToken = "ClientToken"
        case connectAttachmentId = "ConnectAttachmentId"
        case coreNetworkAddress = "CoreNetworkAddress"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectAttachmentId)
        connectAttachmentId = connectAttachmentIdDecoded
        let coreNetworkAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAddress)
        coreNetworkAddress = coreNetworkAddressDecoded
        let peerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peerAddress)
        peerAddress = peerAddressDecoded
        let bgpOptionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.BgpOptions.self, forKey: .bgpOptions)
        bgpOptions = bgpOptionsDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeer = output.connectPeer
        } else {
            self.connectPeer = nil
        }
    }
}

public struct CreateConnectPeerOutputResponse: Swift.Equatable {
    /// The response to the request.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init (
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

struct CreateConnectPeerOutputResponseBody: Swift.Equatable {
    let connectPeer: NetworkManagerClientTypes.ConnectPeer?
}

extension CreateConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeer = "ConnectPeer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeer.self, forKey: .connectPeer)
        connectPeer = connectPeerDecoded
    }
}

extension CreateConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = self.connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = self.connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
    }
}

public struct CreateConnectionInput: Swift.Equatable {
    /// The ID of the second device in the connection.
    /// This member is required.
    public var connectedDeviceId: Swift.String?
    /// The ID of the link for the second device.
    public var connectedLinkId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the first device in the connection.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device.
    public var linkId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        connectedDeviceId: Swift.String? = nil,
        connectedLinkId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.connectedDeviceId = connectedDeviceId
        self.connectedLinkId = connectedLinkId
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    let deviceId: Swift.String?
    let connectedDeviceId: Swift.String?
    let linkId: Swift.String?
    let connectedLinkId: Swift.String?
    let description: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    let connection: NetworkManagerClientTypes.Connection?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension CreateCoreNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case policyDocument = "PolicyDocument"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateCoreNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/core-networks"
    }
}

public struct CreateCoreNetworkInput: Swift.Equatable {
    /// The client token associated with a core network request.
    public var clientToken: Swift.String?
    /// The description of a core network.
    public var description: Swift.String?
    /// The ID of the global network that a core network will be a part of.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The policy document for creating a core network.
    public var policyDocument: Swift.String?
    /// Key-value tags associated with a core network request.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.policyDocument = policyDocument
        self.tags = tags
    }
}

struct CreateCoreNetworkInputBody: Swift.Equatable {
    let globalNetworkId: Swift.String?
    let description: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
    let policyDocument: Swift.String?
    let clientToken: Swift.String?
}

extension CreateCoreNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case policyDocument = "PolicyDocument"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CoreNetworkPolicyException" : self = .coreNetworkPolicyException(try CoreNetworkPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case coreNetworkPolicyException(CoreNetworkPolicyException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct CreateCoreNetworkOutputResponse: Swift.Equatable {
    /// Returns details about a core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct CreateCoreNetworkOutputResponseBody: Swift.Equatable {
    let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension CreateCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

extension CreateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceInput(awsLocation: \(Swift.String(describing: awsLocation)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)), location: \"CONTENT_REDACTED\")"}
}

extension CreateDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsLocation = self.awsLocation {
            try encodeContainer.encode(awsLocation, forKey: .awsLocation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = self.siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

extension CreateDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
    }
}

public struct CreateDeviceInput: Swift.Equatable {
    /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
    public var awsLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The location of the device.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init (
        awsLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.awsLocation = awsLocation
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.tags = tags
        self.type = type
        self.vendor = vendor
    }
}

struct CreateDeviceInputBody: Swift.Equatable {
    let awsLocation: NetworkManagerClientTypes.AWSLocation?
    let description: Swift.String?
    let type: Swift.String?
    let vendor: Swift.String?
    let model: Swift.String?
    let serialNumber: Swift.String?
    let location: NetworkManagerClientTypes.Location?
    let siteId: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .awsLocation)
        awsLocation = awsLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct CreateDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct CreateDeviceOutputResponseBody: Swift.Equatable {
    let device: NetworkManagerClientTypes.Device?
}

extension CreateDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension CreateGlobalNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateGlobalNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/global-networks"
    }
}

public struct CreateGlobalNetworkInput: Swift.Equatable {
    /// A description of the global network. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

struct CreateGlobalNetworkInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateGlobalNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct CreateGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct CreateGlobalNetworkOutputResponseBody: Swift.Equatable {
    let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension CreateGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

extension CreateLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = self.siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
    }
}

public struct CreateLinkInput: Swift.Equatable {
    /// The upload speed and download speed in Mbps.
    /// This member is required.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The provider of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
    public var provider: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
    public var type: Swift.String?

    public init (
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.provider = provider
        self.siteId = siteId
        self.tags = tags
        self.type = type
    }
}

struct CreateLinkInputBody: Swift.Equatable {
    let description: Swift.String?
    let type: Swift.String?
    let bandwidth: NetworkManagerClientTypes.Bandwidth?
    let provider: Swift.String?
    let siteId: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct CreateLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct CreateLinkOutputResponseBody: Swift.Equatable {
    let link: NetworkManagerClientTypes.Link?
}

extension CreateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

extension CreateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), tags: \(Swift.String(describing: tags)), location: \"CONTENT_REDACTED\")"}
}

extension CreateSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
    }
}

public struct CreateSiteInput: Swift.Equatable {
    /// A description of your site. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.tags = tags
    }
}

struct CreateSiteInputBody: Swift.Equatable {
    let description: Swift.String?
    let location: NetworkManagerClientTypes.Location?
    let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct CreateSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct CreateSiteOutputResponseBody: Swift.Equatable {
    let site: NetworkManagerClientTypes.Site?
}

extension CreateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension CreateSiteToSiteVpnAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case tags = "Tags"
        case vpnConnectionArn = "VpnConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpnConnectionArn = self.vpnConnectionArn {
            try encodeContainer.encode(vpnConnectionArn, forKey: .vpnConnectionArn)
        }
    }
}

extension CreateSiteToSiteVpnAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/site-to-site-vpn-attachments"
    }
}

public struct CreateSiteToSiteVpnAttachmentInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network where you're creating a site-to-site VPN attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN identifying the VPN attachment.
    /// This member is required.
    public var vpnConnectionArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        vpnConnectionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.tags = tags
        self.vpnConnectionArn = vpnConnectionArn
    }
}

struct CreateSiteToSiteVpnAttachmentInputBody: Swift.Equatable {
    let coreNetworkId: Swift.String?
    let vpnConnectionArn: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateSiteToSiteVpnAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case tags = "Tags"
        case vpnConnectionArn = "VpnConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let vpnConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnConnectionArn)
        vpnConnectionArn = vpnConnectionArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSiteToSiteVpnAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteToSiteVpnAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSiteToSiteVpnAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteToSiteVpnAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSiteToSiteVpnAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.siteToSiteVpnAttachment = output.siteToSiteVpnAttachment
        } else {
            self.siteToSiteVpnAttachment = nil
        }
    }
}

public struct CreateSiteToSiteVpnAttachmentOutputResponse: Swift.Equatable {
    /// Details about a site-to-site VPN attachment.
    public var siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?

    public init (
        siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment? = nil
    )
    {
        self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
    }
}

struct CreateSiteToSiteVpnAttachmentOutputResponseBody: Swift.Equatable {
    let siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?
}

extension CreateSiteToSiteVpnAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteToSiteVpnAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.SiteToSiteVpnAttachment.self, forKey: .siteToSiteVpnAttachment)
        siteToSiteVpnAttachment = siteToSiteVpnAttachmentDecoded
    }
}

extension CreateTransitGatewayPeeringInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case tags = "Tags"
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let transitGatewayArn = self.transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }
}

extension CreateTransitGatewayPeeringInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/transit-gateway-peerings"
    }
}

public struct CreateTransitGatewayPeeringInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The list of key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN of the transit gateway for the peering request.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.tags = tags
        self.transitGatewayArn = transitGatewayArn
    }
}

struct CreateTransitGatewayPeeringInputBody: Swift.Equatable {
    let coreNetworkId: Swift.String?
    let transitGatewayArn: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateTransitGatewayPeeringInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case tags = "Tags"
        case transitGatewayArn = "TransitGatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTransitGatewayPeeringOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTransitGatewayPeeringOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTransitGatewayPeeringOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTransitGatewayPeeringOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTransitGatewayPeeringOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayPeering = output.transitGatewayPeering
        } else {
            self.transitGatewayPeering = nil
        }
    }
}

public struct CreateTransitGatewayPeeringOutputResponse: Swift.Equatable {
    /// Returns information about the transit gateway peering connection request.
    public var transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering?

    public init (
        transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering? = nil
    )
    {
        self.transitGatewayPeering = transitGatewayPeering
    }
}

struct CreateTransitGatewayPeeringOutputResponseBody: Swift.Equatable {
    let transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering?
}

extension CreateTransitGatewayPeeringOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayPeering = "TransitGatewayPeering"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayPeeringDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayPeering.self, forKey: .transitGatewayPeering)
        transitGatewayPeering = transitGatewayPeeringDecoded
    }
}

extension CreateTransitGatewayRouteTableAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case peeringId = "PeeringId"
        case tags = "Tags"
        case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let peeringId = self.peeringId {
            try encodeContainer.encode(peeringId, forKey: .peeringId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let transitGatewayRouteTableArn = self.transitGatewayRouteTableArn {
            try encodeContainer.encode(transitGatewayRouteTableArn, forKey: .transitGatewayRouteTableArn)
        }
    }
}

extension CreateTransitGatewayRouteTableAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/transit-gateway-route-table-attachments"
    }
}

public struct CreateTransitGatewayRouteTableAttachmentInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of the peer for the
    /// This member is required.
    public var peeringId: Swift.String?
    /// The list of key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN of the transit gateway route table for the attachment request.
    /// This member is required.
    public var transitGatewayRouteTableArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        peeringId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        transitGatewayRouteTableArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.peeringId = peeringId
        self.tags = tags
        self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
    }
}

struct CreateTransitGatewayRouteTableAttachmentInputBody: Swift.Equatable {
    let peeringId: Swift.String?
    let transitGatewayRouteTableArn: Swift.String?
    let tags: [NetworkManagerClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateTransitGatewayRouteTableAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case peeringId = "PeeringId"
        case tags = "Tags"
        case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let peeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peeringId)
        peeringId = peeringIdDecoded
        let transitGatewayRouteTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayRouteTableArn)
        transitGatewayRouteTableArn = transitGatewayRouteTableArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTransitGatewayRouteTableAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTransitGatewayRouteTableAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTransitGatewayRouteTableAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTransitGatewayRouteTableAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTransitGatewayRouteTableAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRouteTableAttachment = output.transitGatewayRouteTableAttachment
        } else {
            self.transitGatewayRouteTableAttachment = nil
        }
    }
}

public struct CreateTransitGatewayRouteTableAttachmentOutputResponse: Swift.Equatable {
    /// The route table associated with the create transit gateway route table attachment request.
    public var transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment?

    public init (
        transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment? = nil
    )
    {
        self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
    }
}

struct CreateTransitGatewayRouteTableAttachmentOutputResponseBody: Swift.Equatable {
    let transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment?
}

extension CreateTransitGatewayRouteTableAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRouteTableAttachment = "TransitGatewayRouteTableAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRouteTableAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRouteTableAttachment.self, forKey: .transitGatewayRouteTableAttachment)
        transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachmentDecoded
    }
}

extension CreateVpcAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case options = "Options"
        case subnetArns = "SubnetArns"
        case tags = "Tags"
        case vpcArn = "VpcArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let subnetArns = subnetArns {
            var subnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetArns)
            for subnetarn0 in subnetArns {
                try subnetArnsContainer.encode(subnetarn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcArn = self.vpcArn {
            try encodeContainer.encode(vpcArn, forKey: .vpcArn)
        }
    }
}

extension CreateVpcAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vpc-attachments"
    }
}

public struct CreateVpcAttachmentInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network for the VPC attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// Options for the VPC attachment.
    public var options: NetworkManagerClientTypes.VpcOptions?
    /// The subnet ARN of the VPC attachment.
    /// This member is required.
    public var subnetArns: [Swift.String]?
    /// The key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN of the VPC.
    /// This member is required.
    public var vpcArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        options: NetworkManagerClientTypes.VpcOptions? = nil,
        subnetArns: [Swift.String]? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        vpcArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.options = options
        self.subnetArns = subnetArns
        self.tags = tags
        self.vpcArn = vpcArn
    }
}

struct CreateVpcAttachmentInputBody: Swift.Equatable {
    let coreNetworkId: Swift.String?
    let vpcArn: Swift.String?
    let subnetArns: [Swift.String]?
    let options: NetworkManagerClientTypes.VpcOptions?
    let tags: [NetworkManagerClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateVpcAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case options = "Options"
        case subnetArns = "SubnetArns"
        case tags = "Tags"
        case vpcArn = "VpcArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let vpcArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcArn)
        vpcArn = vpcArnDecoded
        let subnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetArns)
        var subnetArnsDecoded0:[Swift.String]? = nil
        if let subnetArnsContainer = subnetArnsContainer {
            subnetArnsDecoded0 = [Swift.String]()
            for string0 in subnetArnsContainer {
                if let string0 = string0 {
                    subnetArnsDecoded0?.append(string0)
                }
            }
        }
        subnetArns = subnetArnsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcOptions.self, forKey: .options)
        options = optionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVpcAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVpcAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVpcAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcAttachment = output.vpcAttachment
        } else {
            self.vpcAttachment = nil
        }
    }
}

public struct CreateVpcAttachmentOutputResponse: Swift.Equatable {
    /// Provides details about the VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init (
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

struct CreateVpcAttachmentOutputResponseBody: Swift.Equatable {
    let vpcAttachment: NetworkManagerClientTypes.VpcAttachment?
}

extension CreateVpcAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcAttachment = "VpcAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcAttachment.self, forKey: .vpcAttachment)
        vpcAttachment = vpcAttachmentDecoded
    }
}

extension NetworkManagerClientTypes.CustomerGatewayAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = self.customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the association between a customer gateway, a device, and a link.
    public struct CustomerGatewayAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public var customerGatewayArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The association state.
        public var state: NetworkManagerClientTypes.CustomerGatewayAssociationState?

        public init (
            customerGatewayArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.CustomerGatewayAssociationState? = nil
        )
        {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }
    }

}

extension NetworkManagerClientTypes {
    public enum CustomerGatewayAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerGatewayAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerGatewayAssociationState(rawValue: rawValue) ?? CustomerGatewayAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/attachments/\(attachmentId.urlPercentEncoding())"
    }
}

public struct DeleteAttachmentInput: Swift.Equatable {
    /// The ID of the attachment to delete.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct DeleteAttachmentInputBody: Swift.Equatable {
}

extension DeleteAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

public struct DeleteAttachmentOutputResponse: Swift.Equatable {
    /// Information about the deleted attachment.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init (
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct DeleteAttachmentOutputResponseBody: Swift.Equatable {
    let attachment: NetworkManagerClientTypes.Attachment?
}

extension DeleteAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

extension DeleteConnectPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectPeerId = connectPeerId else {
            return nil
        }
        return "/connect-peers/\(connectPeerId.urlPercentEncoding())"
    }
}

public struct DeleteConnectPeerInput: Swift.Equatable {
    /// The ID of the deleted Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
    }
}

struct DeleteConnectPeerInputBody: Swift.Equatable {
}

extension DeleteConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeer = output.connectPeer
        } else {
            self.connectPeer = nil
        }
    }
}

public struct DeleteConnectPeerOutputResponse: Swift.Equatable {
    /// Information about the deleted Connect peer.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init (
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

struct DeleteConnectPeerOutputResponseBody: Swift.Equatable {
    let connectPeer: NetworkManagerClientTypes.ConnectPeer?
}

extension DeleteConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeer = "ConnectPeer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeer.self, forKey: .connectPeer)
        connectPeer = connectPeerDecoded
    }
}

extension DeleteConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let connectionId = connectionId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
    }
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
}

extension DeleteConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    let connection: NetworkManagerClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeleteCoreNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())"
    }
}

public struct DeleteCoreNetworkInput: Swift.Equatable {
    /// The network ID of the deleted core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
    }
}

struct DeleteCoreNetworkInputBody: Swift.Equatable {
}

extension DeleteCoreNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct DeleteCoreNetworkOutputResponse: Swift.Equatable {
    /// Information about the deleted core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct DeleteCoreNetworkOutputResponseBody: Swift.Equatable {
    let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension DeleteCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

extension DeleteCoreNetworkPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions/\(policyVersionId)"
    }
}

public struct DeleteCoreNetworkPolicyVersionInput: Swift.Equatable {
    /// The ID of a core network for the deleted policy.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The version ID of the deleted policy.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct DeleteCoreNetworkPolicyVersionInputBody: Swift.Equatable {
}

extension DeleteCoreNetworkPolicyVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreNetworkPolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreNetworkPolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCoreNetworkPolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreNetworkPolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCoreNetworkPolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct DeleteCoreNetworkPolicyVersionOutputResponse: Swift.Equatable {
    /// Returns information about the deleted policy version.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct DeleteCoreNetworkPolicyVersionOutputResponseBody: Swift.Equatable {
    let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension DeleteCoreNetworkPolicyVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

extension DeleteDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let deviceId = deviceId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
}

extension DeleteDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct DeleteDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct DeleteDeviceOutputResponseBody: Swift.Equatable {
    let device: NetworkManagerClientTypes.Device?
}

extension DeleteDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension DeleteGlobalNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())"
    }
}

public struct DeleteGlobalNetworkInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteGlobalNetworkInputBody: Swift.Equatable {
}

extension DeleteGlobalNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct DeleteGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct DeleteGlobalNetworkOutputResponseBody: Swift.Equatable {
    let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension DeleteGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

extension DeleteLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let linkId = linkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
    }
}

public struct DeleteLinkInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DeleteLinkInputBody: Swift.Equatable {
}

extension DeleteLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct DeleteLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct DeleteLinkOutputResponseBody: Swift.Equatable {
    let link: NetworkManagerClientTypes.Link?
}

extension DeleteLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

extension DeletePeeringInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let peeringId = peeringId else {
            return nil
        }
        return "/peerings/\(peeringId.urlPercentEncoding())"
    }
}

public struct DeletePeeringInput: Swift.Equatable {
    /// The ID of the peering connection to delete.
    /// This member is required.
    public var peeringId: Swift.String?

    public init (
        peeringId: Swift.String? = nil
    )
    {
        self.peeringId = peeringId
    }
}

struct DeletePeeringInputBody: Swift.Equatable {
}

extension DeletePeeringInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePeeringOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePeeringOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePeeringOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePeeringOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeletePeeringOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.peering = output.peering
        } else {
            self.peering = nil
        }
    }
}

public struct DeletePeeringOutputResponse: Swift.Equatable {
    /// Information about a deleted peering connection.
    public var peering: NetworkManagerClientTypes.Peering?

    public init (
        peering: NetworkManagerClientTypes.Peering? = nil
    )
    {
        self.peering = peering
    }
}

struct DeletePeeringOutputResponseBody: Swift.Equatable {
    let peering: NetworkManagerClientTypes.Peering?
}

extension DeletePeeringOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case peering = "Peering"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let peeringDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Peering.self, forKey: .peering)
        peering = peeringDecoded
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resource-policy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The ARN of the policy to delete.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let siteId = siteId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
    }
}

public struct DeleteSiteInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.siteId = siteId
    }
}

struct DeleteSiteInputBody: Swift.Equatable {
}

extension DeleteSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct DeleteSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct DeleteSiteOutputResponseBody: Swift.Equatable {
    let site: NetworkManagerClientTypes.Site?
}

extension DeleteSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension DeregisterTransitGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let transitGatewayArn = transitGatewayArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations/\(transitGatewayArn.urlPercentEncoding())"
    }
}

public struct DeregisterTransitGatewayInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct DeregisterTransitGatewayInputBody: Swift.Equatable {
}

extension DeregisterTransitGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterTransitGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTransitGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterTransitGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTransitGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeregisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct DeregisterTransitGatewayOutputResponse: Swift.Equatable {
    /// The transit gateway registration information.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct DeregisterTransitGatewayOutputResponseBody: Swift.Equatable {
    let transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?
}

extension DeregisterTransitGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension DescribeGlobalNetworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let globalNetworkIds = globalNetworkIds {
                globalNetworkIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "globalNetworkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension DescribeGlobalNetworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/global-networks"
    }
}

public struct DescribeGlobalNetworksInput: Swift.Equatable {
    /// The IDs of one or more global networks. The maximum is 10.
    public var globalNetworkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        globalNetworkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworkIds = globalNetworkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksInputBody: Swift.Equatable {
}

extension DescribeGlobalNetworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGlobalNetworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGlobalNetworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGlobalNetworksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalNetworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGlobalNetworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetworks = output.globalNetworks
            self.nextToken = output.nextToken
        } else {
            self.globalNetworks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeGlobalNetworksOutputResponse: Swift.Equatable {
    /// Information about the global networks.
    public var globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworks = globalNetworks
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksOutputResponseBody: Swift.Equatable {
    let globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]?
    let nextToken: Swift.String?
}

extension DescribeGlobalNetworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetworks = "GlobalNetworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.GlobalNetwork?].self, forKey: .globalNetworks)
        var globalNetworksDecoded0:[NetworkManagerClientTypes.GlobalNetwork]? = nil
        if let globalNetworksContainer = globalNetworksContainer {
            globalNetworksDecoded0 = [NetworkManagerClientTypes.GlobalNetwork]()
            for structure0 in globalNetworksContainer {
                if let structure0 = structure0 {
                    globalNetworksDecoded0?.append(structure0)
                }
            }
        }
        globalNetworks = globalNetworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NetworkManagerClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsLocation = "AWSLocation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceArn = "DeviceArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsLocation = self.awsLocation {
            try encodeContainer.encode(awsLocation, forKey: .awsLocation)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = self.siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let awsLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .awsLocation)
        awsLocation = awsLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.DeviceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(awsLocation: \(Swift.String(describing: awsLocation)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), deviceArn: \(Swift.String(describing: deviceArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)), location: \"CONTENT_REDACTED\")"}
}

extension NetworkManagerClientTypes {
    /// Describes a device.
    public struct Device: Swift.Equatable {
        /// The Amazon Web Services location of the device.
        public var awsLocation: NetworkManagerClientTypes.AWSLocation?
        /// The date and time that the site was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the device.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the device.
        public var deviceArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The site location.
        public var location: NetworkManagerClientTypes.Location?
        /// The device model.
        public var model: Swift.String?
        /// The device serial number.
        public var serialNumber: Swift.String?
        /// The site ID.
        public var siteId: Swift.String?
        /// The device state.
        public var state: NetworkManagerClientTypes.DeviceState?
        /// The tags for the device.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The device type.
        public var type: Swift.String?
        /// The device vendor.
        public var vendor: Swift.String?

        public init (
            awsLocation: NetworkManagerClientTypes.AWSLocation? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            model: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.DeviceState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.awsLocation = awsLocation
            self.createdAt = createdAt
            self.description = description
            self.deviceArn = deviceArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }
    }

}

extension NetworkManagerClientTypes {
    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateConnectPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let connectPeerId = connectPeerId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations/\(connectPeerId.urlPercentEncoding())"
    }
}

public struct DisassociateConnectPeerInput: Swift.Equatable {
    /// The ID of the Connect peer to disassociate from a device.
    /// This member is required.
    public var connectPeerId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
        self.globalNetworkId = globalNetworkId
    }
}

struct DisassociateConnectPeerInputBody: Swift.Equatable {
}

extension DisassociateConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeerAssociation = output.connectPeerAssociation
        } else {
            self.connectPeerAssociation = nil
        }
    }
}

public struct DisassociateConnectPeerOutputResponse: Swift.Equatable {
    /// Describes the Connect peer association.
    public var connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?

    public init (
        connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation? = nil
    )
    {
        self.connectPeerAssociation = connectPeerAssociation
    }
}

struct DisassociateConnectPeerOutputResponseBody: Swift.Equatable {
    let connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?
}

extension DisassociateConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerAssociation = "ConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerAssociation.self, forKey: .connectPeerAssociation)
        connectPeerAssociation = connectPeerAssociationDecoded
    }
}

extension DisassociateCustomerGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let customerGatewayArn = customerGatewayArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations/\(customerGatewayArn.urlPercentEncoding())"
    }
}

public struct DisassociateCustomerGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the customer gateway.
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        customerGatewayArn: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.globalNetworkId = globalNetworkId
    }
}

struct DisassociateCustomerGatewayInputBody: Swift.Equatable {
}

extension DisassociateCustomerGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateCustomerGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomerGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateCustomerGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomerGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct DisassociateCustomerGatewayOutputResponse: Swift.Equatable {
    /// Information about the customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct DisassociateCustomerGatewayOutputResponseBody: Swift.Equatable {
    let customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?
}

extension DisassociateCustomerGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

extension DisassociateLinkInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let deviceId = deviceId else {
                let message = "Creating a URL Query Item failed. deviceId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            items.append(deviceIdQueryItem)
            guard let linkId = linkId else {
                let message = "Creating a URL Query Item failed. linkId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let linkIdQueryItem = ClientRuntime.URLQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
            items.append(linkIdQueryItem)
            return items
        }
    }
}

extension DisassociateLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
    }
}

public struct DisassociateLinkInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DisassociateLinkInputBody: Swift.Equatable {
}

extension DisassociateLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct DisassociateLinkOutputResponse: Swift.Equatable {
    /// Information about the link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init (
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct DisassociateLinkOutputResponseBody: Swift.Equatable {
    let linkAssociation: NetworkManagerClientTypes.LinkAssociation?
}

extension DisassociateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

extension DisassociateTransitGatewayConnectPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let transitGatewayConnectPeerArn = transitGatewayConnectPeerArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations/\(transitGatewayConnectPeerArn.urlPercentEncoding())"
    }
}

public struct DisassociateTransitGatewayConnectPeerInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct DisassociateTransitGatewayConnectPeerInputBody: Swift.Equatable {
}

extension DisassociateTransitGatewayConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateTransitGatewayConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTransitGatewayConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct DisassociateTransitGatewayConnectPeerOutputResponse: Swift.Equatable {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct DisassociateTransitGatewayConnectPeerOutputResponseBody: Swift.Equatable {
    let transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?
}

extension DisassociateTransitGatewayConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension ExecuteCoreNetworkChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-sets/\(policyVersionId)/execute"
    }
}

public struct ExecuteCoreNetworkChangeSetInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct ExecuteCoreNetworkChangeSetInputBody: Swift.Equatable {
}

extension ExecuteCoreNetworkChangeSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExecuteCoreNetworkChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteCoreNetworkChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExecuteCoreNetworkChangeSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteCoreNetworkChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ExecuteCoreNetworkChangeSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetConnectAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/connect-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

public struct GetConnectAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct GetConnectAttachmentInputBody: Swift.Equatable {
}

extension GetConnectAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConnectAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConnectAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectAttachment = output.connectAttachment
        } else {
            self.connectAttachment = nil
        }
    }
}

public struct GetConnectAttachmentOutputResponse: Swift.Equatable {
    /// Details about the Connect attachment.
    public var connectAttachment: NetworkManagerClientTypes.ConnectAttachment?

    public init (
        connectAttachment: NetworkManagerClientTypes.ConnectAttachment? = nil
    )
    {
        self.connectAttachment = connectAttachment
    }
}

struct GetConnectAttachmentOutputResponseBody: Swift.Equatable {
    let connectAttachment: NetworkManagerClientTypes.ConnectAttachment?
}

extension GetConnectAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectAttachment = "ConnectAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachment.self, forKey: .connectAttachment)
        connectAttachment = connectAttachmentDecoded
    }
}

extension GetConnectPeerAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let connectPeerIds = connectPeerIds {
                connectPeerIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "connectPeerIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetConnectPeerAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations"
    }
}

public struct GetConnectPeerAssociationsInput: Swift.Equatable {
    /// The IDs of the Connect peers.
    public var connectPeerIds: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectPeerIds: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeerIds = connectPeerIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectPeerAssociationsInputBody: Swift.Equatable {
}

extension GetConnectPeerAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectPeerAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectPeerAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConnectPeerAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectPeerAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConnectPeerAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeerAssociations = output.connectPeerAssociations
            self.nextToken = output.nextToken
        } else {
            self.connectPeerAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectPeerAssociationsOutputResponse: Swift.Equatable {
    /// Displays a list of Connect peer associations.
    public var connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeerAssociations = connectPeerAssociations
        self.nextToken = nextToken
    }
}

struct GetConnectPeerAssociationsOutputResponseBody: Swift.Equatable {
    let connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]?
    let nextToken: Swift.String?
}

extension GetConnectPeerAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerAssociations = "ConnectPeerAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ConnectPeerAssociation?].self, forKey: .connectPeerAssociations)
        var connectPeerAssociationsDecoded0:[NetworkManagerClientTypes.ConnectPeerAssociation]? = nil
        if let connectPeerAssociationsContainer = connectPeerAssociationsContainer {
            connectPeerAssociationsDecoded0 = [NetworkManagerClientTypes.ConnectPeerAssociation]()
            for structure0 in connectPeerAssociationsContainer {
                if let structure0 = structure0 {
                    connectPeerAssociationsDecoded0?.append(structure0)
                }
            }
        }
        connectPeerAssociations = connectPeerAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetConnectPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectPeerId = connectPeerId else {
            return nil
        }
        return "/connect-peers/\(connectPeerId.urlPercentEncoding())"
    }
}

public struct GetConnectPeerInput: Swift.Equatable {
    /// The ID of the Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
    }
}

struct GetConnectPeerInputBody: Swift.Equatable {
}

extension GetConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeer = output.connectPeer
        } else {
            self.connectPeer = nil
        }
    }
}

public struct GetConnectPeerOutputResponse: Swift.Equatable {
    /// Returns information about a core network Connect peer.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init (
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

struct GetConnectPeerOutputResponseBody: Swift.Equatable {
    let connectPeer: NetworkManagerClientTypes.ConnectPeer?
}

extension GetConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeer = "ConnectPeer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeer.self, forKey: .connectPeer)
        connectPeer = connectPeerDecoded
    }
}

extension GetConnectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceId = deviceId {
                let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
                items.append(deviceIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let connectionIds = connectionIds {
                connectionIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "connectionIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
    }
}

public struct GetConnectionsInput: Swift.Equatable {
    /// One or more connection IDs.
    public var connectionIds: [Swift.String]?
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectionIds: [Swift.String]? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionIds = connectionIds
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectionsInputBody: Swift.Equatable {
}

extension GetConnectionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConnectionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectionsOutputResponse: Swift.Equatable {
    /// Information about the connections.
    public var connections: [NetworkManagerClientTypes.Connection]?
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connections: [NetworkManagerClientTypes.Connection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct GetConnectionsOutputResponseBody: Swift.Equatable {
    let connections: [NetworkManagerClientTypes.Connection]?
    let nextToken: Swift.String?
}

extension GetConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[NetworkManagerClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [NetworkManagerClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCoreNetworkChangeEventsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetCoreNetworkChangeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-events/\(policyVersionId)"
    }
}

public struct GetCoreNetworkChangeEventsInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyVersionId = policyVersionId
    }
}

struct GetCoreNetworkChangeEventsInputBody: Swift.Equatable {
}

extension GetCoreNetworkChangeEventsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreNetworkChangeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreNetworkChangeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCoreNetworkChangeEventsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreNetworkChangeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCoreNetworkChangeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkChangeEvents = output.coreNetworkChangeEvents
            self.nextToken = output.nextToken
        } else {
            self.coreNetworkChangeEvents = nil
            self.nextToken = nil
        }
    }
}

public struct GetCoreNetworkChangeEventsOutputResponse: Swift.Equatable {
    /// The response to GetCoreNetworkChangeEventsRequest.
    public var coreNetworkChangeEvents: [NetworkManagerClientTypes.CoreNetworkChangeEvent]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworkChangeEvents: [NetworkManagerClientTypes.CoreNetworkChangeEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkChangeEvents = coreNetworkChangeEvents
        self.nextToken = nextToken
    }
}

struct GetCoreNetworkChangeEventsOutputResponseBody: Swift.Equatable {
    let coreNetworkChangeEvents: [NetworkManagerClientTypes.CoreNetworkChangeEvent]?
    let nextToken: Swift.String?
}

extension GetCoreNetworkChangeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkChangeEvents = "CoreNetworkChangeEvents"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkChangeEventsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkChangeEvent?].self, forKey: .coreNetworkChangeEvents)
        var coreNetworkChangeEventsDecoded0:[NetworkManagerClientTypes.CoreNetworkChangeEvent]? = nil
        if let coreNetworkChangeEventsContainer = coreNetworkChangeEventsContainer {
            coreNetworkChangeEventsDecoded0 = [NetworkManagerClientTypes.CoreNetworkChangeEvent]()
            for structure0 in coreNetworkChangeEventsContainer {
                if let structure0 = structure0 {
                    coreNetworkChangeEventsDecoded0?.append(structure0)
                }
            }
        }
        coreNetworkChangeEvents = coreNetworkChangeEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCoreNetworkChangeSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetCoreNetworkChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-sets/\(policyVersionId)"
    }
}

public struct GetCoreNetworkChangeSetInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyVersionId = policyVersionId
    }
}

struct GetCoreNetworkChangeSetInputBody: Swift.Equatable {
}

extension GetCoreNetworkChangeSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreNetworkChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreNetworkChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCoreNetworkChangeSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreNetworkChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCoreNetworkChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkChanges = output.coreNetworkChanges
            self.nextToken = output.nextToken
        } else {
            self.coreNetworkChanges = nil
            self.nextToken = nil
        }
    }
}

public struct GetCoreNetworkChangeSetOutputResponse: Swift.Equatable {
    /// Describes a core network changes.
    public var coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkChanges = coreNetworkChanges
        self.nextToken = nextToken
    }
}

struct GetCoreNetworkChangeSetOutputResponseBody: Swift.Equatable {
    let coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]?
    let nextToken: Swift.String?
}

extension GetCoreNetworkChangeSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkChanges = "CoreNetworkChanges"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkChangesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkChange?].self, forKey: .coreNetworkChanges)
        var coreNetworkChangesDecoded0:[NetworkManagerClientTypes.CoreNetworkChange]? = nil
        if let coreNetworkChangesContainer = coreNetworkChangesContainer {
            coreNetworkChangesDecoded0 = [NetworkManagerClientTypes.CoreNetworkChange]()
            for structure0 in coreNetworkChangesContainer {
                if let structure0 = structure0 {
                    coreNetworkChangesDecoded0?.append(structure0)
                }
            }
        }
        coreNetworkChanges = coreNetworkChangesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCoreNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())"
    }
}

public struct GetCoreNetworkInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
    }
}

struct GetCoreNetworkInputBody: Swift.Equatable {
}

extension GetCoreNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct GetCoreNetworkOutputResponse: Swift.Equatable {
    /// Details about a core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct GetCoreNetworkOutputResponseBody: Swift.Equatable {
    let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension GetCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

extension GetCoreNetworkPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let alias = alias {
                let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias.rawValue).urlPercentEncoding())
                items.append(aliasQueryItem)
            }
            if let policyVersionId = policyVersionId {
                let policyVersionIdQueryItem = ClientRuntime.URLQueryItem(name: "policyVersionId".urlPercentEncoding(), value: Swift.String(policyVersionId).urlPercentEncoding())
                items.append(policyVersionIdQueryItem)
            }
            return items
        }
    }
}

extension GetCoreNetworkPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy"
    }
}

public struct GetCoreNetworkPolicyInput: Swift.Equatable {
    /// The alias of a core network policy
    public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of a core network policy version.
    public var policyVersionId: Swift.Int?

    public init (
        alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct GetCoreNetworkPolicyInputBody: Swift.Equatable {
}

extension GetCoreNetworkPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreNetworkPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreNetworkPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCoreNetworkPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreNetworkPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCoreNetworkPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct GetCoreNetworkPolicyOutputResponse: Swift.Equatable {
    /// The details about a core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct GetCoreNetworkPolicyOutputResponseBody: Swift.Equatable {
    let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension GetCoreNetworkPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

extension GetCustomerGatewayAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let customerGatewayArns = customerGatewayArns {
                customerGatewayArns.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "customerGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetCustomerGatewayAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
    }
}

public struct GetCustomerGatewayAssociationsInput: Swift.Equatable {
    /// One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.
    public var customerGatewayArns: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        customerGatewayArns: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayArns = customerGatewayArns
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsInputBody: Swift.Equatable {
}

extension GetCustomerGatewayAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCustomerGatewayAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCustomerGatewayAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCustomerGatewayAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomerGatewayAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCustomerGatewayAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociations = output.customerGatewayAssociations
            self.nextToken = output.nextToken
        } else {
            self.customerGatewayAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetCustomerGatewayAssociationsOutputResponse: Swift.Equatable {
    /// The customer gateway associations.
    public var customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayAssociations = customerGatewayAssociations
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsOutputResponseBody: Swift.Equatable {
    let customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]?
    let nextToken: Swift.String?
}

extension GetCustomerGatewayAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociations = "CustomerGatewayAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CustomerGatewayAssociation?].self, forKey: .customerGatewayAssociations)
        var customerGatewayAssociationsDecoded0:[NetworkManagerClientTypes.CustomerGatewayAssociation]? = nil
        if let customerGatewayAssociationsContainer = customerGatewayAssociationsContainer {
            customerGatewayAssociationsDecoded0 = [NetworkManagerClientTypes.CustomerGatewayAssociation]()
            for structure0 in customerGatewayAssociationsContainer {
                if let structure0 = structure0 {
                    customerGatewayAssociationsDecoded0?.append(structure0)
                }
            }
        }
        customerGatewayAssociations = customerGatewayAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let deviceIds = deviceIds {
                deviceIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "deviceIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let siteId = siteId {
                let siteIdQueryItem = ClientRuntime.URLQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
                items.append(siteIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
    }
}

public struct GetDevicesInput: Swift.Equatable {
    /// One or more device IDs. The maximum is 10.
    public var deviceIds: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?

    public init (
        deviceIds: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteId = siteId
    }
}

struct GetDevicesInputBody: Swift.Equatable {
}

extension GetDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevicesOutputResponse: Swift.Equatable {
    /// The devices.
    public var devices: [NetworkManagerClientTypes.Device]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        devices: [NetworkManagerClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct GetDevicesOutputResponseBody: Swift.Equatable {
    let devices: [NetworkManagerClientTypes.Device]?
    let nextToken: Swift.String?
}

extension GetDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[NetworkManagerClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [NetworkManagerClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinkAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceId = deviceId {
                let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
                items.append(deviceIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let linkId = linkId {
                let linkIdQueryItem = ClientRuntime.URLQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
                items.append(linkIdQueryItem)
            }
            return items
        }
    }
}

extension GetLinkAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
    }
}

public struct GetLinkAssociationsInput: Swift.Equatable {
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsInputBody: Swift.Equatable {
}

extension GetLinkAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLinkAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinkAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLinkAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinkAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLinkAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociations = output.linkAssociations
            self.nextToken = output.nextToken
        } else {
            self.linkAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinkAssociationsOutputResponse: Swift.Equatable {
    /// The link associations.
    public var linkAssociations: [NetworkManagerClientTypes.LinkAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        linkAssociations: [NetworkManagerClientTypes.LinkAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkAssociations = linkAssociations
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsOutputResponseBody: Swift.Equatable {
    let linkAssociations: [NetworkManagerClientTypes.LinkAssociation]?
    let nextToken: Swift.String?
}

extension GetLinkAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociations = "LinkAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.LinkAssociation?].self, forKey: .linkAssociations)
        var linkAssociationsDecoded0:[NetworkManagerClientTypes.LinkAssociation]? = nil
        if let linkAssociationsContainer = linkAssociationsContainer {
            linkAssociationsDecoded0 = [NetworkManagerClientTypes.LinkAssociation]()
            for structure0 in linkAssociationsContainer {
                if let structure0 = structure0 {
                    linkAssociationsDecoded0?.append(structure0)
                }
            }
        }
        linkAssociations = linkAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let siteId = siteId {
                let siteIdQueryItem = ClientRuntime.URLQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
                items.append(siteIdQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let linkIds = linkIds {
                linkIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "linkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let provider = provider {
                let providerQueryItem = ClientRuntime.URLQueryItem(name: "provider".urlPercentEncoding(), value: Swift.String(provider).urlPercentEncoding())
                items.append(providerQueryItem)
            }
            return items
        }
    }
}

extension GetLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
    }
}

public struct GetLinksInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// One or more link IDs. The maximum is 10.
    public var linkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The link provider.
    public var provider: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The link type.
    public var type: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        linkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkIds = linkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provider = provider
        self.siteId = siteId
        self.type = type
    }
}

struct GetLinksInputBody: Swift.Equatable {
}

extension GetLinksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLinksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLinksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLinksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.links = output.links
            self.nextToken = output.nextToken
        } else {
            self.links = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinksOutputResponse: Swift.Equatable {
    /// The links.
    public var links: [NetworkManagerClientTypes.Link]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        links: [NetworkManagerClientTypes.Link]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.links = links
        self.nextToken = nextToken
    }
}

struct GetLinksOutputResponseBody: Swift.Equatable {
    let links: [NetworkManagerClientTypes.Link]?
    let nextToken: Swift.String?
}

extension GetLinksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case links = "Links"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Link?].self, forKey: .links)
        var linksDecoded0:[NetworkManagerClientTypes.Link]? = nil
        if let linksContainer = linksContainer {
            linksDecoded0 = [NetworkManagerClientTypes.Link]()
            for structure0 in linksContainer {
                if let structure0 = structure0 {
                    linksDecoded0?.append(structure0)
                }
            }
        }
        links = linksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNetworkResourceCountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension GetNetworkResourceCountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resource-count"
    }
}

public struct GetNetworkResourceCountsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection
    ///
    /// * device
    ///
    /// * link
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct GetNetworkResourceCountsInputBody: Swift.Equatable {
}

extension GetNetworkResourceCountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourceCountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkResourceCountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkResourceCountsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkResourceCountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkResourceCountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkResourceCounts = output.networkResourceCounts
            self.nextToken = output.nextToken
        } else {
            self.networkResourceCounts = nil
            self.nextToken = nil
        }
    }
}

public struct GetNetworkResourceCountsOutputResponse: Swift.Equatable {
    /// The count of resources.
    public var networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResourceCounts = networkResourceCounts
        self.nextToken = nextToken
    }
}

struct GetNetworkResourceCountsOutputResponseBody: Swift.Equatable {
    let networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]?
    let nextToken: Swift.String?
}

extension GetNetworkResourceCountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResourceCounts = "NetworkResourceCounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceCountsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkResourceCount?].self, forKey: .networkResourceCounts)
        var networkResourceCountsDecoded0:[NetworkManagerClientTypes.NetworkResourceCount]? = nil
        if let networkResourceCountsContainer = networkResourceCountsContainer {
            networkResourceCountsDecoded0 = [NetworkManagerClientTypes.NetworkResourceCount]()
            for structure0 in networkResourceCountsContainer {
                if let structure0 = structure0 {
                    networkResourceCountsDecoded0?.append(structure0)
                }
            }
        }
        networkResourceCounts = networkResourceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNetworkResourceRelationshipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let resourceArn = resourceArn {
                let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
                items.append(resourceArnQueryItem)
            }
            if let coreNetworkId = coreNetworkId {
                let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
                items.append(coreNetworkIdQueryItem)
            }
            if let accountId = accountId {
                let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
                items.append(accountIdQueryItem)
            }
            if let registeredGatewayArn = registeredGatewayArn {
                let registeredGatewayArnQueryItem = ClientRuntime.URLQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
                items.append(registeredGatewayArnQueryItem)
            }
            if let awsRegion = awsRegion {
                let awsRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
                items.append(awsRegionQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension GetNetworkResourceRelationshipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resource-relationships"
    }
}

public struct GetNetworkResourceRelationshipsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the registered gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the gateway.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection
    ///
    /// * device
    ///
    /// * link
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct GetNetworkResourceRelationshipsInputBody: Swift.Equatable {
}

extension GetNetworkResourceRelationshipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourceRelationshipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkResourceRelationshipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkResourceRelationshipsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkResourceRelationshipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkResourceRelationshipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.relationships = output.relationships
        } else {
            self.nextToken = nil
            self.relationships = nil
        }
    }
}

public struct GetNetworkResourceRelationshipsOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The resource relationships.
    public var relationships: [NetworkManagerClientTypes.Relationship]?

    public init (
        nextToken: Swift.String? = nil,
        relationships: [NetworkManagerClientTypes.Relationship]? = nil
    )
    {
        self.nextToken = nextToken
        self.relationships = relationships
    }
}

struct GetNetworkResourceRelationshipsOutputResponseBody: Swift.Equatable {
    let relationships: [NetworkManagerClientTypes.Relationship]?
    let nextToken: Swift.String?
}

extension GetNetworkResourceRelationshipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case relationships = "Relationships"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationshipsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Relationship?].self, forKey: .relationships)
        var relationshipsDecoded0:[NetworkManagerClientTypes.Relationship]? = nil
        if let relationshipsContainer = relationshipsContainer {
            relationshipsDecoded0 = [NetworkManagerClientTypes.Relationship]()
            for structure0 in relationshipsContainer {
                if let structure0 = structure0 {
                    relationshipsDecoded0?.append(structure0)
                }
            }
        }
        relationships = relationshipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNetworkResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let resourceArn = resourceArn {
                let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
                items.append(resourceArnQueryItem)
            }
            if let coreNetworkId = coreNetworkId {
                let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
                items.append(coreNetworkIdQueryItem)
            }
            if let accountId = accountId {
                let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
                items.append(accountIdQueryItem)
            }
            if let registeredGatewayArn = registeredGatewayArn {
                let registeredGatewayArnQueryItem = ClientRuntime.URLQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
                items.append(registeredGatewayArnQueryItem)
            }
            if let awsRegion = awsRegion {
                let awsRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
                items.append(awsRegionQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension GetNetworkResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resources"
    }
}

public struct GetNetworkResourcesInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon - The definition model is [Connection](https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html).
    ///
    /// * dx-gateway - The definition model is [DirectConnectGateway](https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html).
    ///
    /// * dx-vif - The definition model is [VirtualInterface](https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html).
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection - The definition model is [Connection](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html).
    ///
    /// * device - The definition model is [Device](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html).
    ///
    /// * link - The definition model is [Link](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html).
    ///
    /// * site - The definition model is [Site](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html).
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway - The definition model is [CustomerGateway](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html).
    ///
    /// * transit-gateway - The definition model is [TransitGateway](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html).
    ///
    /// * transit-gateway-attachment - The definition model is [TransitGatewayAttachment](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html).
    ///
    /// * transit-gateway-connect-peer - The definition model is [TransitGatewayConnectPeer](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html).
    ///
    /// * transit-gateway-route-table - The definition model is [TransitGatewayRouteTable](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html).
    ///
    /// * vpn-connection - The definition model is [VpnConnection](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html).
    public var resourceType: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct GetNetworkResourcesInputBody: Swift.Equatable {
}

extension GetNetworkResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkResources = output.networkResources
            self.nextToken = output.nextToken
        } else {
            self.networkResources = nil
            self.nextToken = nil
        }
    }
}

public struct GetNetworkResourcesOutputResponse: Swift.Equatable {
    /// The network resources.
    public var networkResources: [NetworkManagerClientTypes.NetworkResource]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkResources: [NetworkManagerClientTypes.NetworkResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResources = networkResources
        self.nextToken = nextToken
    }
}

struct GetNetworkResourcesOutputResponseBody: Swift.Equatable {
    let networkResources: [NetworkManagerClientTypes.NetworkResource]?
    let nextToken: Swift.String?
}

extension GetNetworkResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResources = "NetworkResources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourcesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkResource?].self, forKey: .networkResources)
        var networkResourcesDecoded0:[NetworkManagerClientTypes.NetworkResource]? = nil
        if let networkResourcesContainer = networkResourcesContainer {
            networkResourcesDecoded0 = [NetworkManagerClientTypes.NetworkResource]()
            for structure0 in networkResourcesContainer {
                if let structure0 = structure0 {
                    networkResourcesDecoded0?.append(structure0)
                }
            }
        }
        networkResources = networkResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNetworkRoutesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFilters = "DestinationFilters"
        case exactCidrMatches = "ExactCidrMatches"
        case longestPrefixMatches = "LongestPrefixMatches"
        case prefixListIds = "PrefixListIds"
        case routeTableIdentifier = "RouteTableIdentifier"
        case states = "States"
        case subnetOfMatches = "SubnetOfMatches"
        case supernetOfMatches = "SupernetOfMatches"
        case types = "Types"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationFilters = destinationFilters {
            var destinationFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .destinationFilters)
            for (dictKey0, filterMap0) in destinationFilters {
                var filterMap0Container = destinationFiltersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for filtervalue1 in filterMap0 {
                    try filterMap0Container.encode(filtervalue1)
                }
            }
        }
        if let exactCidrMatches = exactCidrMatches {
            var exactCidrMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exactCidrMatches)
            for constrainedstring0 in exactCidrMatches {
                try exactCidrMatchesContainer.encode(constrainedstring0)
            }
        }
        if let longestPrefixMatches = longestPrefixMatches {
            var longestPrefixMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .longestPrefixMatches)
            for constrainedstring0 in longestPrefixMatches {
                try longestPrefixMatchesContainer.encode(constrainedstring0)
            }
        }
        if let prefixListIds = prefixListIds {
            var prefixListIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .prefixListIds)
            for constrainedstring0 in prefixListIds {
                try prefixListIdsContainer.encode(constrainedstring0)
            }
        }
        if let routeTableIdentifier = self.routeTableIdentifier {
            try encodeContainer.encode(routeTableIdentifier, forKey: .routeTableIdentifier)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for routestate0 in states {
                try statesContainer.encode(routestate0.rawValue)
            }
        }
        if let subnetOfMatches = subnetOfMatches {
            var subnetOfMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetOfMatches)
            for constrainedstring0 in subnetOfMatches {
                try subnetOfMatchesContainer.encode(constrainedstring0)
            }
        }
        if let supernetOfMatches = supernetOfMatches {
            var supernetOfMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supernetOfMatches)
            for constrainedstring0 in supernetOfMatches {
                try supernetOfMatchesContainer.encode(constrainedstring0)
            }
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for routetype0 in types {
                try typesContainer.encode(routetype0.rawValue)
            }
        }
    }
}

extension GetNetworkRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-routes"
    }
}

public struct GetNetworkRoutesInput: Swift.Equatable {
    /// Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.
    public var destinationFilters: [Swift.String:[Swift.String]]?
    /// An exact CIDR block.
    public var exactCidrMatches: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The most specific route that matches the traffic (longest prefix match).
    public var longestPrefixMatches: [Swift.String]?
    /// The IDs of the prefix lists.
    public var prefixListIds: [Swift.String]?
    /// The ID of the route table.
    /// This member is required.
    public var routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier?
    /// The route states.
    public var states: [NetworkManagerClientTypes.RouteState]?
    /// The routes with a subnet that match the specified CIDR filter.
    public var subnetOfMatches: [Swift.String]?
    /// The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.
    public var supernetOfMatches: [Swift.String]?
    /// The route types.
    public var types: [NetworkManagerClientTypes.RouteType]?

    public init (
        destinationFilters: [Swift.String:[Swift.String]]? = nil,
        exactCidrMatches: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        longestPrefixMatches: [Swift.String]? = nil,
        prefixListIds: [Swift.String]? = nil,
        routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier? = nil,
        states: [NetworkManagerClientTypes.RouteState]? = nil,
        subnetOfMatches: [Swift.String]? = nil,
        supernetOfMatches: [Swift.String]? = nil,
        types: [NetworkManagerClientTypes.RouteType]? = nil
    )
    {
        self.destinationFilters = destinationFilters
        self.exactCidrMatches = exactCidrMatches
        self.globalNetworkId = globalNetworkId
        self.longestPrefixMatches = longestPrefixMatches
        self.prefixListIds = prefixListIds
        self.routeTableIdentifier = routeTableIdentifier
        self.states = states
        self.subnetOfMatches = subnetOfMatches
        self.supernetOfMatches = supernetOfMatches
        self.types = types
    }
}

struct GetNetworkRoutesInputBody: Swift.Equatable {
    let routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier?
    let exactCidrMatches: [Swift.String]?
    let longestPrefixMatches: [Swift.String]?
    let subnetOfMatches: [Swift.String]?
    let supernetOfMatches: [Swift.String]?
    let prefixListIds: [Swift.String]?
    let states: [NetworkManagerClientTypes.RouteState]?
    let types: [NetworkManagerClientTypes.RouteType]?
    let destinationFilters: [Swift.String:[Swift.String]]?
}

extension GetNetworkRoutesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFilters = "DestinationFilters"
        case exactCidrMatches = "ExactCidrMatches"
        case longestPrefixMatches = "LongestPrefixMatches"
        case prefixListIds = "PrefixListIds"
        case routeTableIdentifier = "RouteTableIdentifier"
        case states = "States"
        case subnetOfMatches = "SubnetOfMatches"
        case supernetOfMatches = "SupernetOfMatches"
        case types = "Types"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeTableIdentifierDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteTableIdentifier.self, forKey: .routeTableIdentifier)
        routeTableIdentifier = routeTableIdentifierDecoded
        let exactCidrMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exactCidrMatches)
        var exactCidrMatchesDecoded0:[Swift.String]? = nil
        if let exactCidrMatchesContainer = exactCidrMatchesContainer {
            exactCidrMatchesDecoded0 = [Swift.String]()
            for string0 in exactCidrMatchesContainer {
                if let string0 = string0 {
                    exactCidrMatchesDecoded0?.append(string0)
                }
            }
        }
        exactCidrMatches = exactCidrMatchesDecoded0
        let longestPrefixMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .longestPrefixMatches)
        var longestPrefixMatchesDecoded0:[Swift.String]? = nil
        if let longestPrefixMatchesContainer = longestPrefixMatchesContainer {
            longestPrefixMatchesDecoded0 = [Swift.String]()
            for string0 in longestPrefixMatchesContainer {
                if let string0 = string0 {
                    longestPrefixMatchesDecoded0?.append(string0)
                }
            }
        }
        longestPrefixMatches = longestPrefixMatchesDecoded0
        let subnetOfMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetOfMatches)
        var subnetOfMatchesDecoded0:[Swift.String]? = nil
        if let subnetOfMatchesContainer = subnetOfMatchesContainer {
            subnetOfMatchesDecoded0 = [Swift.String]()
            for string0 in subnetOfMatchesContainer {
                if let string0 = string0 {
                    subnetOfMatchesDecoded0?.append(string0)
                }
            }
        }
        subnetOfMatches = subnetOfMatchesDecoded0
        let supernetOfMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supernetOfMatches)
        var supernetOfMatchesDecoded0:[Swift.String]? = nil
        if let supernetOfMatchesContainer = supernetOfMatchesContainer {
            supernetOfMatchesDecoded0 = [Swift.String]()
            for string0 in supernetOfMatchesContainer {
                if let string0 = string0 {
                    supernetOfMatchesDecoded0?.append(string0)
                }
            }
        }
        supernetOfMatches = supernetOfMatchesDecoded0
        let prefixListIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .prefixListIds)
        var prefixListIdsDecoded0:[Swift.String]? = nil
        if let prefixListIdsContainer = prefixListIdsContainer {
            prefixListIdsDecoded0 = [Swift.String]()
            for string0 in prefixListIdsContainer {
                if let string0 = string0 {
                    prefixListIdsDecoded0?.append(string0)
                }
            }
        }
        prefixListIds = prefixListIdsDecoded0
        let statesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.RouteState?].self, forKey: .states)
        var statesDecoded0:[NetworkManagerClientTypes.RouteState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [NetworkManagerClientTypes.RouteState]()
            for enum0 in statesContainer {
                if let enum0 = enum0 {
                    statesDecoded0?.append(enum0)
                }
            }
        }
        states = statesDecoded0
        let typesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.RouteType?].self, forKey: .types)
        var typesDecoded0:[NetworkManagerClientTypes.RouteType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [NetworkManagerClientTypes.RouteType]()
            for enum0 in typesContainer {
                if let enum0 = enum0 {
                    typesDecoded0?.append(enum0)
                }
            }
        }
        types = typesDecoded0
        let destinationFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .destinationFilters)
        var destinationFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let destinationFiltersContainer = destinationFiltersContainer {
            destinationFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, filtervalues0) in destinationFiltersContainer {
                var filtervalues0Decoded0: [Swift.String]? = nil
                if let filtervalues0 = filtervalues0 {
                    filtervalues0Decoded0 = [Swift.String]()
                    for string1 in filtervalues0 {
                        if let string1 = string1 {
                            filtervalues0Decoded0?.append(string1)
                        }
                    }
                }
                destinationFiltersDecoded0?[key0] = filtervalues0Decoded0
            }
        }
        destinationFilters = destinationFiltersDecoded0
    }
}

extension GetNetworkRoutesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkRoutesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkRoutesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkRoutesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkRoutesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkSegmentEdge = output.coreNetworkSegmentEdge
            self.networkRoutes = output.networkRoutes
            self.routeTableArn = output.routeTableArn
            self.routeTableTimestamp = output.routeTableTimestamp
            self.routeTableType = output.routeTableType
        } else {
            self.coreNetworkSegmentEdge = nil
            self.networkRoutes = nil
            self.routeTableArn = nil
            self.routeTableTimestamp = nil
            self.routeTableType = nil
        }
    }
}

public struct GetNetworkRoutesOutputResponse: Swift.Equatable {
    /// Describes a core network segment edge.
    public var coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
    /// The network routes.
    public var networkRoutes: [NetworkManagerClientTypes.NetworkRoute]?
    /// The ARN of the route table.
    public var routeTableArn: Swift.String?
    /// The route table creation time.
    public var routeTableTimestamp: ClientRuntime.Date?
    /// The route table type.
    public var routeTableType: NetworkManagerClientTypes.RouteTableType?

    public init (
        coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier? = nil,
        networkRoutes: [NetworkManagerClientTypes.NetworkRoute]? = nil,
        routeTableArn: Swift.String? = nil,
        routeTableTimestamp: ClientRuntime.Date? = nil,
        routeTableType: NetworkManagerClientTypes.RouteTableType? = nil
    )
    {
        self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
        self.networkRoutes = networkRoutes
        self.routeTableArn = routeTableArn
        self.routeTableTimestamp = routeTableTimestamp
        self.routeTableType = routeTableType
    }
}

struct GetNetworkRoutesOutputResponseBody: Swift.Equatable {
    let routeTableArn: Swift.String?
    let coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
    let routeTableType: NetworkManagerClientTypes.RouteTableType?
    let routeTableTimestamp: ClientRuntime.Date?
    let networkRoutes: [NetworkManagerClientTypes.NetworkRoute]?
}

extension GetNetworkRoutesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
        case networkRoutes = "NetworkRoutes"
        case routeTableArn = "RouteTableArn"
        case routeTableTimestamp = "RouteTableTimestamp"
        case routeTableType = "RouteTableType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableArn)
        routeTableArn = routeTableArnDecoded
        let coreNetworkSegmentEdgeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier.self, forKey: .coreNetworkSegmentEdge)
        coreNetworkSegmentEdge = coreNetworkSegmentEdgeDecoded
        let routeTableTypeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteTableType.self, forKey: .routeTableType)
        routeTableType = routeTableTypeDecoded
        let routeTableTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .routeTableTimestamp)
        routeTableTimestamp = routeTableTimestampDecoded
        let networkRoutesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkRoute?].self, forKey: .networkRoutes)
        var networkRoutesDecoded0:[NetworkManagerClientTypes.NetworkRoute]? = nil
        if let networkRoutesContainer = networkRoutesContainer {
            networkRoutesDecoded0 = [NetworkManagerClientTypes.NetworkRoute]()
            for structure0 in networkRoutesContainer {
                if let structure0 = structure0 {
                    networkRoutesDecoded0?.append(structure0)
                }
            }
        }
        networkRoutes = networkRoutesDecoded0
    }
}

extension GetNetworkTelemetryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let resourceArn = resourceArn {
                let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
                items.append(resourceArnQueryItem)
            }
            if let coreNetworkId = coreNetworkId {
                let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
                items.append(coreNetworkIdQueryItem)
            }
            if let accountId = accountId {
                let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
                items.append(accountIdQueryItem)
            }
            if let registeredGatewayArn = registeredGatewayArn {
                let registeredGatewayArnQueryItem = ClientRuntime.URLQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
                items.append(registeredGatewayArnQueryItem)
            }
            if let awsRegion = awsRegion {
                let awsRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
                items.append(awsRegionQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension GetNetworkTelemetryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-telemetry"
    }
}

public struct GetNetworkTelemetryInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection
    ///
    /// * device
    ///
    /// * link
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct GetNetworkTelemetryInputBody: Swift.Equatable {
}

extension GetNetworkTelemetryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkTelemetryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkTelemetryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkTelemetryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkTelemetryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkTelemetryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkTelemetry = output.networkTelemetry
            self.nextToken = output.nextToken
        } else {
            self.networkTelemetry = nil
            self.nextToken = nil
        }
    }
}

public struct GetNetworkTelemetryOutputResponse: Swift.Equatable {
    /// The network telemetry.
    public var networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkTelemetry = networkTelemetry
        self.nextToken = nextToken
    }
}

struct GetNetworkTelemetryOutputResponseBody: Swift.Equatable {
    let networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]?
    let nextToken: Swift.String?
}

extension GetNetworkTelemetryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkTelemetry = "NetworkTelemetry"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkTelemetryContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkTelemetry?].self, forKey: .networkTelemetry)
        var networkTelemetryDecoded0:[NetworkManagerClientTypes.NetworkTelemetry]? = nil
        if let networkTelemetryContainer = networkTelemetryContainer {
            networkTelemetryDecoded0 = [NetworkManagerClientTypes.NetworkTelemetry]()
            for structure0 in networkTelemetryContainer {
                if let structure0 = structure0 {
                    networkTelemetryDecoded0?.append(structure0)
                }
            }
        }
        networkTelemetry = networkTelemetryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resource-policy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyDocument = output.policyDocument
        } else {
            self.policyDocument = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// The resource policy document.
    public var policyDocument: Swift.String?

    public init (
        policyDocument: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    let policyDocument: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension GetRouteAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let routeAnalysisId = routeAnalysisId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/route-analyses/\(routeAnalysisId.urlPercentEncoding())"
    }
}

public struct GetRouteAnalysisInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the route analysis.
    /// This member is required.
    public var routeAnalysisId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        routeAnalysisId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.routeAnalysisId = routeAnalysisId
    }
}

struct GetRouteAnalysisInputBody: Swift.Equatable {
}

extension GetRouteAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRouteAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRouteAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routeAnalysis = output.routeAnalysis
        } else {
            self.routeAnalysis = nil
        }
    }
}

public struct GetRouteAnalysisOutputResponse: Swift.Equatable {
    /// The route analysis.
    public var routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?

    public init (
        routeAnalysis: NetworkManagerClientTypes.RouteAnalysis? = nil
    )
    {
        self.routeAnalysis = routeAnalysis
    }
}

struct GetRouteAnalysisOutputResponseBody: Swift.Equatable {
    let routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?
}

extension GetRouteAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeAnalysis = "RouteAnalysis"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeAnalysisDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysis.self, forKey: .routeAnalysis)
        routeAnalysis = routeAnalysisDecoded
    }
}

extension GetSiteToSiteVpnAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/site-to-site-vpn-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

public struct GetSiteToSiteVpnAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct GetSiteToSiteVpnAttachmentInputBody: Swift.Equatable {
}

extension GetSiteToSiteVpnAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSiteToSiteVpnAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSiteToSiteVpnAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSiteToSiteVpnAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSiteToSiteVpnAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSiteToSiteVpnAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.siteToSiteVpnAttachment = output.siteToSiteVpnAttachment
        } else {
            self.siteToSiteVpnAttachment = nil
        }
    }
}

public struct GetSiteToSiteVpnAttachmentOutputResponse: Swift.Equatable {
    /// Describes the site-to-site attachment.
    public var siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?

    public init (
        siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment? = nil
    )
    {
        self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
    }
}

struct GetSiteToSiteVpnAttachmentOutputResponseBody: Swift.Equatable {
    let siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?
}

extension GetSiteToSiteVpnAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteToSiteVpnAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.SiteToSiteVpnAttachment.self, forKey: .siteToSiteVpnAttachment)
        siteToSiteVpnAttachment = siteToSiteVpnAttachmentDecoded
    }
}

extension GetSitesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let siteIds = siteIds {
                siteIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "siteIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetSitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
    }
}

public struct GetSitesInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more site IDs. The maximum is 10.
    public var siteIds: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteIds: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteIds = siteIds
    }
}

struct GetSitesInputBody: Swift.Equatable {
}

extension GetSitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSitesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct GetSitesOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The sites.
    public var sites: [NetworkManagerClientTypes.Site]?

    public init (
        nextToken: Swift.String? = nil,
        sites: [NetworkManagerClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct GetSitesOutputResponseBody: Swift.Equatable {
    let sites: [NetworkManagerClientTypes.Site]?
    let nextToken: Swift.String?
}

extension GetSitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sites = "Sites"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sitesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Site?].self, forKey: .sites)
        var sitesDecoded0:[NetworkManagerClientTypes.Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [NetworkManagerClientTypes.Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let transitGatewayConnectPeerArns = transitGatewayConnectPeerArns {
                transitGatewayConnectPeerArns.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "transitGatewayConnectPeerArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
    }
}

public struct GetTransitGatewayConnectPeerAssociationsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more transit gateway Connect peer Amazon Resource Names (ARNs).
    public var transitGatewayConnectPeerArns: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayConnectPeerArns = transitGatewayConnectPeerArns
    }
}

struct GetTransitGatewayConnectPeerAssociationsInputBody: Swift.Equatable {
}

extension GetTransitGatewayConnectPeerAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTransitGatewayConnectPeerAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTransitGatewayConnectPeerAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transitGatewayConnectPeerAssociations = output.transitGatewayConnectPeerAssociations
        } else {
            self.nextToken = nil
            self.transitGatewayConnectPeerAssociations = nil
        }
    }
}

public struct GetTransitGatewayConnectPeerAssociationsOutputResponse: Swift.Equatable {
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the transit gateway Connect peer associations.
    public var transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociations
    }
}

struct GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Swift.Equatable {
    let transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]?
    let nextToken: Swift.String?
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case transitGatewayConnectPeerAssociations = "TransitGatewayConnectPeerAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?].self, forKey: .transitGatewayConnectPeerAssociations)
        var transitGatewayConnectPeerAssociationsDecoded0:[NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]? = nil
        if let transitGatewayConnectPeerAssociationsContainer = transitGatewayConnectPeerAssociationsContainer {
            transitGatewayConnectPeerAssociationsDecoded0 = [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]()
            for structure0 in transitGatewayConnectPeerAssociationsContainer {
                if let structure0 = structure0 {
                    transitGatewayConnectPeerAssociationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayPeeringInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let peeringId = peeringId else {
            return nil
        }
        return "/transit-gateway-peerings/\(peeringId.urlPercentEncoding())"
    }
}

public struct GetTransitGatewayPeeringInput: Swift.Equatable {
    /// The ID of the peering request.
    /// This member is required.
    public var peeringId: Swift.String?

    public init (
        peeringId: Swift.String? = nil
    )
    {
        self.peeringId = peeringId
    }
}

struct GetTransitGatewayPeeringInputBody: Swift.Equatable {
}

extension GetTransitGatewayPeeringInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayPeeringOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayPeeringOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTransitGatewayPeeringOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayPeeringOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTransitGatewayPeeringOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayPeering = output.transitGatewayPeering
        } else {
            self.transitGatewayPeering = nil
        }
    }
}

public struct GetTransitGatewayPeeringOutputResponse: Swift.Equatable {
    /// Returns information about a transit gateway peering.
    public var transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering?

    public init (
        transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering? = nil
    )
    {
        self.transitGatewayPeering = transitGatewayPeering
    }
}

struct GetTransitGatewayPeeringOutputResponseBody: Swift.Equatable {
    let transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering?
}

extension GetTransitGatewayPeeringOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayPeering = "TransitGatewayPeering"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayPeeringDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayPeering.self, forKey: .transitGatewayPeering)
        transitGatewayPeering = transitGatewayPeeringDecoded
    }
}

extension GetTransitGatewayRegistrationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let transitGatewayArns = transitGatewayArns {
                transitGatewayArns.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "transitGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetTransitGatewayRegistrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
    }
}

public struct GetTransitGatewayRegistrationsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.
    public var transitGatewayArns: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayArns = transitGatewayArns
    }
}

struct GetTransitGatewayRegistrationsInputBody: Swift.Equatable {
}

extension GetTransitGatewayRegistrationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayRegistrationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayRegistrationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTransitGatewayRegistrationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayRegistrationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTransitGatewayRegistrationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transitGatewayRegistrations = output.transitGatewayRegistrations
        } else {
            self.nextToken = nil
            self.transitGatewayRegistrations = nil
        }
    }
}

public struct GetTransitGatewayRegistrationsOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The transit gateway registrations.
    public var transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]?

    public init (
        nextToken: Swift.String? = nil,
        transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayRegistrations = transitGatewayRegistrations
    }
}

struct GetTransitGatewayRegistrationsOutputResponseBody: Swift.Equatable {
    let transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]?
    let nextToken: Swift.String?
}

extension GetTransitGatewayRegistrationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case transitGatewayRegistrations = "TransitGatewayRegistrations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.TransitGatewayRegistration?].self, forKey: .transitGatewayRegistrations)
        var transitGatewayRegistrationsDecoded0:[NetworkManagerClientTypes.TransitGatewayRegistration]? = nil
        if let transitGatewayRegistrationsContainer = transitGatewayRegistrationsContainer {
            transitGatewayRegistrationsDecoded0 = [NetworkManagerClientTypes.TransitGatewayRegistration]()
            for structure0 in transitGatewayRegistrationsContainer {
                if let structure0 = structure0 {
                    transitGatewayRegistrationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayRegistrations = transitGatewayRegistrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayRouteTableAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/transit-gateway-route-table-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

public struct GetTransitGatewayRouteTableAttachmentInput: Swift.Equatable {
    /// The ID of the transit gateway route table attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct GetTransitGatewayRouteTableAttachmentInputBody: Swift.Equatable {
}

extension GetTransitGatewayRouteTableAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayRouteTableAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayRouteTableAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTransitGatewayRouteTableAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayRouteTableAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTransitGatewayRouteTableAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRouteTableAttachment = output.transitGatewayRouteTableAttachment
        } else {
            self.transitGatewayRouteTableAttachment = nil
        }
    }
}

public struct GetTransitGatewayRouteTableAttachmentOutputResponse: Swift.Equatable {
    /// Returns information about the transit gateway route table attachment.
    public var transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment?

    public init (
        transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment? = nil
    )
    {
        self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
    }
}

struct GetTransitGatewayRouteTableAttachmentOutputResponseBody: Swift.Equatable {
    let transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment?
}

extension GetTransitGatewayRouteTableAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRouteTableAttachment = "TransitGatewayRouteTableAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRouteTableAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRouteTableAttachment.self, forKey: .transitGatewayRouteTableAttachment)
        transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachmentDecoded
    }
}

extension GetVpcAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/vpc-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

public struct GetVpcAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct GetVpcAttachmentInputBody: Swift.Equatable {
}

extension GetVpcAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVpcAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVpcAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcAttachment = output.vpcAttachment
        } else {
            self.vpcAttachment = nil
        }
    }
}

public struct GetVpcAttachmentOutputResponse: Swift.Equatable {
    /// Returns details about a VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init (
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

struct GetVpcAttachmentOutputResponseBody: Swift.Equatable {
    let vpcAttachment: NetworkManagerClientTypes.VpcAttachment?
}

extension GetVpcAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcAttachment = "VpcAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcAttachment.self, forKey: .vpcAttachment)
        vpcAttachment = vpcAttachmentDecoded
    }
}

extension NetworkManagerClientTypes.GlobalNetwork: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkArn = "GlobalNetworkArn"
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkArn = self.globalNetworkArn {
            try encodeContainer.encode(globalNetworkArn, forKey: .globalNetworkArn)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let globalNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkArn)
        globalNetworkArn = globalNetworkArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetworkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a global network. This is a single private network acting as a high-level container for your network objects, including an Amazon Web Services-managed Core Network.
    public struct GlobalNetwork: Swift.Equatable {
        /// The date and time that the global network was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the global network.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the global network.
        public var globalNetworkArn: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the global network.
        public var state: NetworkManagerClientTypes.GlobalNetworkState?
        /// The tags for the global network.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkArn: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.GlobalNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkArn = globalNetworkArn
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum GlobalNetworkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalNetworkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlobalNetworkState(rawValue: rawValue) ?? GlobalNetworkState.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed due to an internal error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Indicates when to retry the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.Link: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case linkArn = "LinkArn"
        case linkId = "LinkId"
        case provider = "Provider"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkArn = self.linkArn {
            try encodeContainer.encode(linkArn, forKey: .linkArn)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = self.siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkArn)
        linkArn = linkArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a link.
    public struct Link: Swift.Equatable {
        /// The bandwidth for the link.
        public var bandwidth: NetworkManagerClientTypes.Bandwidth?
        /// The date and time that the link was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the link.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the link.
        public var linkArn: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The provider of the link.
        public var provider: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the link.
        public var state: NetworkManagerClientTypes.LinkState?
        /// The tags for the link.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The type of the link.
        public var type: Swift.String?

        public init (
            bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkArn: Swift.String? = nil,
            linkId: Swift.String? = nil,
            provider: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.LinkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.bandwidth = bandwidth
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkArn = linkArn
            self.linkId = linkId
            self.provider = provider
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes.LinkAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkAssociationState = "LinkAssociationState"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkAssociationState = self.linkAssociationState {
            try encodeContainer.encode(linkAssociationState.rawValue, forKey: .linkAssociationState)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkAssociationStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociationState.self, forKey: .linkAssociationState)
        linkAssociationState = linkAssociationStateDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the association between a device and a link.
    public struct LinkAssociation: Swift.Equatable {
        /// The device ID for the link association.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the association.
        public var linkAssociationState: NetworkManagerClientTypes.LinkAssociationState?
        /// The ID of the link.
        public var linkId: Swift.String?

        public init (
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkAssociationState: NetworkManagerClientTypes.LinkAssociationState? = nil,
            linkId: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkAssociationState = linkAssociationState
            self.linkId = linkId
        }
    }

}

extension NetworkManagerClientTypes {
    public enum LinkAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinkAssociationState(rawValue: rawValue) ?? LinkAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum LinkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinkState(rawValue: rawValue) ?? LinkState.sdkUnknown(rawValue)
        }
    }
}

extension ListAttachmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let coreNetworkId = coreNetworkId {
                let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
                items.append(coreNetworkIdQueryItem)
            }
            if let attachmentType = attachmentType {
                let attachmentTypeQueryItem = ClientRuntime.URLQueryItem(name: "attachmentType".urlPercentEncoding(), value: Swift.String(attachmentType.rawValue).urlPercentEncoding())
                items.append(attachmentTypeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let edgeLocation = edgeLocation {
                let edgeLocationQueryItem = ClientRuntime.URLQueryItem(name: "edgeLocation".urlPercentEncoding(), value: Swift.String(edgeLocation).urlPercentEncoding())
                items.append(edgeLocationQueryItem)
            }
            return items
        }
    }
}

extension ListAttachmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/attachments"
    }
}

public struct ListAttachmentsInput: Swift.Equatable {
    /// The type of attachment.
    public var attachmentType: NetworkManagerClientTypes.AttachmentType?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The Region where the edge is located.
    public var edgeLocation: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The state of the attachment.
    public var state: NetworkManagerClientTypes.AttachmentState?

    public init (
        attachmentType: NetworkManagerClientTypes.AttachmentType? = nil,
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: NetworkManagerClientTypes.AttachmentState? = nil
    )
    {
        self.attachmentType = attachmentType
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListAttachmentsInputBody: Swift.Equatable {
}

extension ListAttachmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAttachmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttachmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAttachmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAttachmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachments = output.attachments
            self.nextToken = output.nextToken
        } else {
            self.attachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttachmentsOutputResponse: Swift.Equatable {
    /// Describes the list of attachments.
    public var attachments: [NetworkManagerClientTypes.Attachment]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        attachments: [NetworkManagerClientTypes.Attachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.nextToken = nextToken
    }
}

struct ListAttachmentsOutputResponseBody: Swift.Equatable {
    let attachments: [NetworkManagerClientTypes.Attachment]?
    let nextToken: Swift.String?
}

extension ListAttachmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Attachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[NetworkManagerClientTypes.Attachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [NetworkManagerClientTypes.Attachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectPeersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let connectAttachmentId = connectAttachmentId {
                let connectAttachmentIdQueryItem = ClientRuntime.URLQueryItem(name: "connectAttachmentId".urlPercentEncoding(), value: Swift.String(connectAttachmentId).urlPercentEncoding())
                items.append(connectAttachmentIdQueryItem)
            }
            if let coreNetworkId = coreNetworkId {
                let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
                items.append(coreNetworkIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConnectPeersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/connect-peers"
    }
}

public struct ListConnectPeersInput: Swift.Equatable {
    /// The ID of the attachment.
    public var connectAttachmentId: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectAttachmentId: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectAttachmentId = connectAttachmentId
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectPeersInputBody: Swift.Equatable {
}

extension ListConnectPeersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConnectPeersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectPeersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConnectPeersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectPeersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConnectPeersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeers = output.connectPeers
            self.nextToken = output.nextToken
        } else {
            self.connectPeers = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectPeersOutputResponse: Swift.Equatable {
    /// Describes the Connect peers.
    public var connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeers = connectPeers
        self.nextToken = nextToken
    }
}

struct ListConnectPeersOutputResponseBody: Swift.Equatable {
    let connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]?
    let nextToken: Swift.String?
}

extension ListConnectPeersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeers = "ConnectPeers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeersContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ConnectPeerSummary?].self, forKey: .connectPeers)
        var connectPeersDecoded0:[NetworkManagerClientTypes.ConnectPeerSummary]? = nil
        if let connectPeersContainer = connectPeersContainer {
            connectPeersDecoded0 = [NetworkManagerClientTypes.ConnectPeerSummary]()
            for structure0 in connectPeersContainer {
                if let structure0 = structure0 {
                    connectPeersDecoded0?.append(structure0)
                }
            }
        }
        connectPeers = connectPeersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreNetworkPolicyVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCoreNetworkPolicyVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions"
    }
}

public struct ListCoreNetworkPolicyVersionsInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreNetworkPolicyVersionsInputBody: Swift.Equatable {
}

extension ListCoreNetworkPolicyVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreNetworkPolicyVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreNetworkPolicyVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCoreNetworkPolicyVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreNetworkPolicyVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCoreNetworkPolicyVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicyVersions = output.coreNetworkPolicyVersions
            self.nextToken = output.nextToken
        } else {
            self.coreNetworkPolicyVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreNetworkPolicyVersionsOutputResponse: Swift.Equatable {
    /// Describes core network policy versions.
    public var coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkPolicyVersions = coreNetworkPolicyVersions
        self.nextToken = nextToken
    }
}

struct ListCoreNetworkPolicyVersionsOutputResponseBody: Swift.Equatable {
    let coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]?
    let nextToken: Swift.String?
}

extension ListCoreNetworkPolicyVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicyVersions = "CoreNetworkPolicyVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyVersionsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkPolicyVersion?].self, forKey: .coreNetworkPolicyVersions)
        var coreNetworkPolicyVersionsDecoded0:[NetworkManagerClientTypes.CoreNetworkPolicyVersion]? = nil
        if let coreNetworkPolicyVersionsContainer = coreNetworkPolicyVersionsContainer {
            coreNetworkPolicyVersionsDecoded0 = [NetworkManagerClientTypes.CoreNetworkPolicyVersion]()
            for structure0 in coreNetworkPolicyVersionsContainer {
                if let structure0 = structure0 {
                    coreNetworkPolicyVersionsDecoded0?.append(structure0)
                }
            }
        }
        coreNetworkPolicyVersions = coreNetworkPolicyVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreNetworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCoreNetworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/core-networks"
    }
}

public struct ListCoreNetworksInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreNetworksInputBody: Swift.Equatable {
}

extension ListCoreNetworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreNetworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreNetworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCoreNetworksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreNetworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCoreNetworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworks = output.coreNetworks
            self.nextToken = output.nextToken
        } else {
            self.coreNetworks = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreNetworksOutputResponse: Swift.Equatable {
    /// Describes the list of core networks.
    public var coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworks = coreNetworks
        self.nextToken = nextToken
    }
}

struct ListCoreNetworksOutputResponseBody: Swift.Equatable {
    let coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]?
    let nextToken: Swift.String?
}

extension ListCoreNetworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworks = "CoreNetworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkSummary?].self, forKey: .coreNetworks)
        var coreNetworksDecoded0:[NetworkManagerClientTypes.CoreNetworkSummary]? = nil
        if let coreNetworksContainer = coreNetworksContainer {
            coreNetworksDecoded0 = [NetworkManagerClientTypes.CoreNetworkSummary]()
            for structure0 in coreNetworksContainer {
                if let structure0 = structure0 {
                    coreNetworksDecoded0?.append(structure0)
                }
            }
        }
        coreNetworks = coreNetworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationServiceAccessStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationServiceAccessStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organizations/service-access"
    }
}

public struct ListOrganizationServiceAccessStatusInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationServiceAccessStatusInputBody: Swift.Equatable {
}

extension ListOrganizationServiceAccessStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationServiceAccessStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationServiceAccessStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOrganizationServiceAccessStatusOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationServiceAccessStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOrganizationServiceAccessStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationStatus = output.organizationStatus
        } else {
            self.nextToken = nil
            self.organizationStatus = nil
        }
    }
}

public struct ListOrganizationServiceAccessStatusOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Displays the status of an Amazon Web Services Organization.
    public var organizationStatus: NetworkManagerClientTypes.OrganizationStatus?

    public init (
        nextToken: Swift.String? = nil,
        organizationStatus: NetworkManagerClientTypes.OrganizationStatus? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationStatus = organizationStatus
    }
}

struct ListOrganizationServiceAccessStatusOutputResponseBody: Swift.Equatable {
    let organizationStatus: NetworkManagerClientTypes.OrganizationStatus?
    let nextToken: Swift.String?
}

extension ListOrganizationServiceAccessStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationStatus = "OrganizationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationStatusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.OrganizationStatus.self, forKey: .organizationStatus)
        organizationStatus = organizationStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPeeringsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let coreNetworkId = coreNetworkId {
                let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
                items.append(coreNetworkIdQueryItem)
            }
            if let peeringType = peeringType {
                let peeringTypeQueryItem = ClientRuntime.URLQueryItem(name: "peeringType".urlPercentEncoding(), value: Swift.String(peeringType.rawValue).urlPercentEncoding())
                items.append(peeringTypeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let edgeLocation = edgeLocation {
                let edgeLocationQueryItem = ClientRuntime.URLQueryItem(name: "edgeLocation".urlPercentEncoding(), value: Swift.String(edgeLocation).urlPercentEncoding())
                items.append(edgeLocationQueryItem)
            }
            return items
        }
    }
}

extension ListPeeringsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/peerings"
    }
}

public struct ListPeeringsInput: Swift.Equatable {
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// Returns a list edge locations for the
    public var edgeLocation: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Returns a list of a peering requests.
    public var peeringType: NetworkManagerClientTypes.PeeringType?
    /// Returns a list of the peering request states.
    public var state: NetworkManagerClientTypes.PeeringState?

    public init (
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        peeringType: NetworkManagerClientTypes.PeeringType? = nil,
        state: NetworkManagerClientTypes.PeeringState? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.peeringType = peeringType
        self.state = state
    }
}

struct ListPeeringsInputBody: Swift.Equatable {
}

extension ListPeeringsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPeeringsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPeeringsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPeeringsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPeeringsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPeeringsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.peerings = output.peerings
        } else {
            self.nextToken = nil
            self.peerings = nil
        }
    }
}

public struct ListPeeringsOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Lists the transit gateway peerings for the ListPeerings request.
    public var peerings: [NetworkManagerClientTypes.Peering]?

    public init (
        nextToken: Swift.String? = nil,
        peerings: [NetworkManagerClientTypes.Peering]? = nil
    )
    {
        self.nextToken = nextToken
        self.peerings = peerings
    }
}

struct ListPeeringsOutputResponseBody: Swift.Equatable {
    let peerings: [NetworkManagerClientTypes.Peering]?
    let nextToken: Swift.String?
}

extension ListPeeringsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case peerings = "Peerings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let peeringsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Peering?].self, forKey: .peerings)
        var peeringsDecoded0:[NetworkManagerClientTypes.Peering]? = nil
        if let peeringsContainer = peeringsContainer {
            peeringsDecoded0 = [NetworkManagerClientTypes.Peering]()
            for structure0 in peeringsContainer {
                if let structure0 = structure0 {
                    peeringsDecoded0?.append(structure0)
                }
            }
        }
        peerings = peeringsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags.
    public var tagList: [NetworkManagerClientTypes.Tag]?

    public init (
        tagList: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tagList: [NetworkManagerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension NetworkManagerClientTypes.Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case latitude = "Latitude"
        case longitude = "Longitude"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let latitude = self.latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = self.longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension NetworkManagerClientTypes.Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension NetworkManagerClientTypes {
    /// Describes a location.
    public struct Location: Swift.Equatable {
        /// The physical address.
        public var address: Swift.String?
        /// The latitude.
        public var latitude: Swift.String?
        /// The longitude.
        public var longitude: Swift.String?

        public init (
            address: Swift.String? = nil,
            latitude: Swift.String? = nil,
            longitude: Swift.String? = nil
        )
        {
            self.address = address
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

extension NetworkManagerClientTypes.NetworkResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case coreNetworkId = "CoreNetworkId"
        case definition = "Definition"
        case definitionTimestamp = "DefinitionTimestamp"
        case metadata = "Metadata"
        case registeredGatewayArn = "RegisteredGatewayArn"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let definitionTimestamp = self.definitionTimestamp {
            try encodeContainer.encodeTimestamp(definitionTimestamp, format: .epochSeconds, forKey: .definitionTimestamp)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, networkResourceMetadataMap0) in metadata {
                try metadataContainer.encode(networkResourceMetadataMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let registeredGatewayArn = self.registeredGatewayArn {
            try encodeContainer.encode(registeredGatewayArn, forKey: .registeredGatewayArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registeredGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredGatewayArn)
        registeredGatewayArn = registeredGatewayArnDecoded
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let definitionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .definitionTimestamp)
        definitionTimestamp = definitionTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, constrainedstring0) in metadataContainer {
                if let constrainedstring0 = constrainedstring0 {
                    metadataDecoded0?[key0] = constrainedstring0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a network resource.
    public struct NetworkResource: Swift.Equatable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public var definition: Swift.String?
        /// The time that the resource definition was retrieved.
        public var definitionTimestamp: ClientRuntime.Date?
        /// The resource metadata.
        public var metadata: [Swift.String:Swift.String]?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type. The following are the supported resource types for Direct Connect:
        ///
        /// * dxcon
        ///
        /// * dx-gateway
        ///
        /// * dx-vif
        ///
        ///
        /// The following are the supported resource types for Network Manager:
        ///
        /// * connection
        ///
        /// * device
        ///
        /// * link
        ///
        /// * site
        ///
        ///
        /// The following are the supported resource types for Amazon VPC:
        ///
        /// * customer-gateway
        ///
        /// * transit-gateway
        ///
        /// * transit-gateway-attachment
        ///
        /// * transit-gateway-connect-peer
        ///
        /// * transit-gateway-route-table
        ///
        /// * vpn-connection
        public var resourceType: Swift.String?
        /// The tags.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            definition: Swift.String? = nil,
            definitionTimestamp: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.definition = definition
            self.definitionTimestamp = definitionTimestamp
            self.metadata = metadata
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.NetworkResourceCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a resource count.
    public struct NetworkResourceCount: Swift.Equatable {
        /// The resource count.
        public var count: Swift.Int?
        /// The resource type.
        public var resourceType: Swift.String?

        public init (
            count: Swift.Int? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.count = count
            self.resourceType = resourceType
        }
    }

}

extension NetworkManagerClientTypes.NetworkResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case isMiddlebox = "IsMiddlebox"
        case nameTag = "NameTag"
        case registeredGatewayArn = "RegisteredGatewayArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if isMiddlebox != false {
            try encodeContainer.encode(isMiddlebox, forKey: .isMiddlebox)
        }
        if let nameTag = self.nameTag {
            try encodeContainer.encode(nameTag, forKey: .nameTag)
        }
        if let registeredGatewayArn = self.registeredGatewayArn {
            try encodeContainer.encode(registeredGatewayArn, forKey: .registeredGatewayArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registeredGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredGatewayArn)
        registeredGatewayArn = registeredGatewayArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let nameTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameTag)
        nameTag = nameTagDecoded
        let isMiddleboxDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMiddlebox) ?? false
        isMiddlebox = isMiddleboxDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a network resource.
    public struct NetworkResourceSummary: Swift.Equatable {
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public var definition: Swift.String?
        /// Indicates whether this is a middlebox appliance.
        public var isMiddlebox: Swift.Bool
        /// The value for the Name tag.
        public var nameTag: Swift.String?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init (
            definition: Swift.String? = nil,
            isMiddlebox: Swift.Bool = false,
            nameTag: Swift.String? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.definition = definition
            self.isMiddlebox = isMiddlebox
            self.nameTag = nameTag
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }
    }

}

extension NetworkManagerClientTypes.NetworkRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinations = "Destinations"
        case prefixListId = "PrefixListId"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCidrBlock = self.destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for networkroutedestination0 in destinations {
                try destinationsContainer.encode(networkroutedestination0)
            }
        }
        if let prefixListId = self.prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkRouteDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[NetworkManagerClientTypes.NetworkRouteDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [NetworkManagerClientTypes.NetworkRouteDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let prefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteType.self, forKey: .type)
        type = typeDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a network route.
    public struct NetworkRoute: Swift.Equatable {
        /// A unique identifier for the route, such as a CIDR block.
        public var destinationCidrBlock: Swift.String?
        /// The destinations.
        public var destinations: [NetworkManagerClientTypes.NetworkRouteDestination]?
        /// The ID of the prefix list.
        public var prefixListId: Swift.String?
        /// The route state. The possible values are active and blackhole.
        public var state: NetworkManagerClientTypes.RouteState?
        /// The route type. The possible values are propagated and static.
        public var type: NetworkManagerClientTypes.RouteType?

        public init (
            destinationCidrBlock: Swift.String? = nil,
            destinations: [NetworkManagerClientTypes.NetworkRouteDestination]? = nil,
            prefixListId: Swift.String? = nil,
            state: NetworkManagerClientTypes.RouteState? = nil,
            type: NetworkManagerClientTypes.RouteType? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.destinations = destinations
            self.prefixListId = prefixListId
            self.state = state
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes.NetworkRouteDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkAttachmentId = "CoreNetworkAttachmentId"
        case edgeLocation = "EdgeLocation"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case segmentName = "SegmentName"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkAttachmentId = self.coreNetworkAttachmentId {
            try encodeContainer.encode(coreNetworkAttachmentId, forKey: .coreNetworkAttachmentId)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let transitGatewayAttachmentId = self.transitGatewayAttachmentId {
            try encodeContainer.encode(transitGatewayAttachmentId, forKey: .transitGatewayAttachmentId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAttachmentId)
        coreNetworkAttachmentId = coreNetworkAttachmentIdDecoded
        let transitGatewayAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayAttachmentId)
        transitGatewayAttachmentId = transitGatewayAttachmentIdDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the destination of a network route.
    public struct NetworkRouteDestination: Swift.Equatable {
        /// The ID of a core network attachment.
        public var coreNetworkAttachmentId: Swift.String?
        /// The edge location for the network destination.
        public var edgeLocation: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The name of the segment.
        public var segmentName: Swift.String?
        /// The ID of the transit gateway attachment.
        public var transitGatewayAttachmentId: Swift.String?

        public init (
            coreNetworkAttachmentId: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            segmentName: Swift.String? = nil,
            transitGatewayAttachmentId: Swift.String? = nil
        )
        {
            self.coreNetworkAttachmentId = coreNetworkAttachmentId
            self.edgeLocation = edgeLocation
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.segmentName = segmentName
            self.transitGatewayAttachmentId = transitGatewayAttachmentId
        }
    }

}

extension NetworkManagerClientTypes.NetworkTelemetry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case address = "Address"
        case awsRegion = "AwsRegion"
        case coreNetworkId = "CoreNetworkId"
        case health = "Health"
        case registeredGatewayArn = "RegisteredGatewayArn"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let health = self.health {
            try encodeContainer.encode(health, forKey: .health)
        }
        if let registeredGatewayArn = self.registeredGatewayArn {
            try encodeContainer.encode(registeredGatewayArn, forKey: .registeredGatewayArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registeredGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredGatewayArn)
        registeredGatewayArn = registeredGatewayArnDecoded
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let healthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionHealth.self, forKey: .health)
        health = healthDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the telemetry information for a resource.
    public struct NetworkTelemetry: Swift.Equatable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The address.
        public var address: Swift.String?
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The connection health.
        public var health: NetworkManagerClientTypes.ConnectionHealth?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            address: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            health: NetworkManagerClientTypes.ConnectionHealth? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.address = address
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.health = health
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension NetworkManagerClientTypes.OrganizationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountStatusList = "AccountStatusList"
        case organizationAwsServiceAccessStatus = "OrganizationAwsServiceAccessStatus"
        case organizationId = "OrganizationId"
        case slrDeploymentStatus = "SLRDeploymentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountStatusList = accountStatusList {
            var accountStatusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountStatusList)
            for accountstatus0 in accountStatusList {
                try accountStatusListContainer.encode(accountstatus0)
            }
        }
        if let organizationAwsServiceAccessStatus = self.organizationAwsServiceAccessStatus {
            try encodeContainer.encode(organizationAwsServiceAccessStatus, forKey: .organizationAwsServiceAccessStatus)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let slrDeploymentStatus = self.slrDeploymentStatus {
            try encodeContainer.encode(slrDeploymentStatus, forKey: .slrDeploymentStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let organizationAwsServiceAccessStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationAwsServiceAccessStatus)
        organizationAwsServiceAccessStatus = organizationAwsServiceAccessStatusDecoded
        let slrDeploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slrDeploymentStatus)
        slrDeploymentStatus = slrDeploymentStatusDecoded
        let accountStatusListContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.AccountStatus?].self, forKey: .accountStatusList)
        var accountStatusListDecoded0:[NetworkManagerClientTypes.AccountStatus]? = nil
        if let accountStatusListContainer = accountStatusListContainer {
            accountStatusListDecoded0 = [NetworkManagerClientTypes.AccountStatus]()
            for structure0 in accountStatusListContainer {
                if let structure0 = structure0 {
                    accountStatusListDecoded0?.append(structure0)
                }
            }
        }
        accountStatusList = accountStatusListDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// The status of an Amazon Web Services Organization and the accounts within that organization.
    public struct OrganizationStatus: Swift.Equatable {
        /// The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either SUCCEEDED or IN_PROGRESS.
        public var accountStatusList: [NetworkManagerClientTypes.AccountStatus]?
        /// The status of the organization's AWS service access. This will be ENABLED or DISABLED.
        public var organizationAwsServiceAccessStatus: Swift.String?
        /// The ID of an Amazon Web Services Organization.
        public var organizationId: Swift.String?
        /// The status of the SLR deployment for the account. This will be either SUCCEEDED or IN_PROGRESS.
        public var slrDeploymentStatus: Swift.String?

        public init (
            accountStatusList: [NetworkManagerClientTypes.AccountStatus]? = nil,
            organizationAwsServiceAccessStatus: Swift.String? = nil,
            organizationId: Swift.String? = nil,
            slrDeploymentStatus: Swift.String? = nil
        )
        {
            self.accountStatusList = accountStatusList
            self.organizationAwsServiceAccessStatus = organizationAwsServiceAccessStatus
            self.organizationId = organizationId
            self.slrDeploymentStatus = slrDeploymentStatus
        }
    }

}

extension NetworkManagerClientTypes.PathComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case resource = "Resource"
        case sequence = "Sequence"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCidrBlock = self.destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let sequence = self.sequence {
            try encodeContainer.encode(sequence, forKey: .sequence)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sequence)
        sequence = sequenceDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.NetworkResourceSummary.self, forKey: .resource)
        resource = resourceDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a path component.
    public struct PathComponent: Swift.Equatable {
        /// The destination CIDR block in the route table.
        public var destinationCidrBlock: Swift.String?
        /// The resource.
        public var resource: NetworkManagerClientTypes.NetworkResourceSummary?
        /// The sequence number in the path. The destination is 0.
        public var sequence: Swift.Int?

        public init (
            destinationCidrBlock: Swift.String? = nil,
            resource: NetworkManagerClientTypes.NetworkResourceSummary? = nil,
            sequence: Swift.Int? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.resource = resource
            self.sequence = sequence
        }
    }

}

extension NetworkManagerClientTypes.Peering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkArn = "CoreNetworkArn"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case edgeLocation = "EdgeLocation"
        case ownerAccountId = "OwnerAccountId"
        case peeringId = "PeeringId"
        case peeringType = "PeeringType"
        case resourceArn = "ResourceArn"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkArn = self.coreNetworkArn {
            try encodeContainer.encode(coreNetworkArn, forKey: .coreNetworkArn)
        }
        if let coreNetworkId = self.coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let edgeLocation = self.edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let peeringId = self.peeringId {
            try encodeContainer.encode(peeringId, forKey: .peeringId)
        }
        if let peeringType = self.peeringType {
            try encodeContainer.encode(peeringType.rawValue, forKey: .peeringType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let coreNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkArn)
        coreNetworkArn = coreNetworkArnDecoded
        let peeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peeringId)
        peeringId = peeringIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let peeringTypeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.PeeringType.self, forKey: .peeringType)
        peeringType = peeringTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.PeeringState.self, forKey: .state)
        state = stateDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a peering connection.
    public struct Peering: Swift.Equatable {
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// The ID of the core network for the peering request.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the attachment peer was created.
        public var createdAt: ClientRuntime.Date?
        /// The edge location for the peer.
        public var edgeLocation: Swift.String?
        /// The ID of the account owner.
        public var ownerAccountId: Swift.String?
        /// The ID of the peering attachment.
        public var peeringId: Swift.String?
        /// The type of peering. This will be TRANSIT_GATEWAY.
        public var peeringType: NetworkManagerClientTypes.PeeringType?
        /// The resource ARN of the peer.
        public var resourceArn: Swift.String?
        /// The current state of the peering connection.
        public var state: NetworkManagerClientTypes.PeeringState?
        /// The list of key-value tags associated with the peering.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            edgeLocation: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            peeringId: Swift.String? = nil,
            peeringType: NetworkManagerClientTypes.PeeringType? = nil,
            resourceArn: Swift.String? = nil,
            state: NetworkManagerClientTypes.PeeringState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.ownerAccountId = ownerAccountId
            self.peeringId = peeringId
            self.peeringType = peeringType
            self.resourceArn = resourceArn
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum PeeringState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [PeeringState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PeeringState(rawValue: rawValue) ?? PeeringState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum PeeringType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case transitGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [PeeringType] {
            return [
                .transitGateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .transitGateway: return "TRANSIT_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PeeringType(rawValue: rawValue) ?? PeeringType.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.ProposedSegmentChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
        case segmentName = "SegmentName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentPolicyRuleNumber = self.attachmentPolicyRuleNumber {
            try encodeContainer.encode(attachmentPolicyRuleNumber, forKey: .attachmentPolicyRuleNumber)
        }
        if let segmentName = self.segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let attachmentPolicyRuleNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentPolicyRuleNumber)
        attachmentPolicyRuleNumber = attachmentPolicyRuleNumberDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a proposed segment change. In some cases, the segment change must first be evaluated and accepted.
    public struct ProposedSegmentChange: Swift.Equatable {
        /// The rule number in the policy document that applies to this change.
        public var attachmentPolicyRuleNumber: Swift.Int?
        /// The name of the segment to change.
        public var segmentName: Swift.String?
        /// The list of key-value tags that changed for the segment.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            attachmentPolicyRuleNumber: Swift.Int? = nil,
            segmentName: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.segmentName = segmentName
            self.tags = tags
        }
    }

}

extension PutCoreNetworkPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case latestVersionId = "LatestVersionId"
        case policyDocument = "PolicyDocument"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let latestVersionId = self.latestVersionId {
            try encodeContainer.encode(latestVersionId, forKey: .latestVersionId)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
    }
}

extension PutCoreNetworkPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy"
    }
}

public struct PutCoreNetworkPolicyInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// a core network policy description.
    public var description: Swift.String?
    /// The ID of a core network policy.
    public var latestVersionId: Swift.Int?
    /// The policy document.
    /// This member is required.
    public var policyDocument: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        description: Swift.String? = nil,
        latestVersionId: Swift.Int? = nil,
        policyDocument: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.description = description
        self.latestVersionId = latestVersionId
        self.policyDocument = policyDocument
    }
}

struct PutCoreNetworkPolicyInputBody: Swift.Equatable {
    let policyDocument: Swift.String?
    let description: Swift.String?
    let latestVersionId: Swift.Int?
    let clientToken: Swift.String?
}

extension PutCoreNetworkPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case latestVersionId = "LatestVersionId"
        case policyDocument = "PolicyDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let latestVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionId)
        latestVersionId = latestVersionIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension PutCoreNetworkPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCoreNetworkPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CoreNetworkPolicyException" : self = .coreNetworkPolicyException(try CoreNetworkPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutCoreNetworkPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case coreNetworkPolicyException(CoreNetworkPolicyException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCoreNetworkPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutCoreNetworkPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct PutCoreNetworkPolicyOutputResponse: Swift.Equatable {
    /// Describes the changed core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct PutCoreNetworkPolicyOutputResponseBody: Swift.Equatable {
    let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension PutCoreNetworkPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resource-policy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// The JSON resource policy document.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The ARN of the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policyDocument: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policyDocument: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension RegisterTransitGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transitGatewayArn = self.transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }
}

extension RegisterTransitGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
    }
}

public struct RegisterTransitGatewayInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct RegisterTransitGatewayInputBody: Swift.Equatable {
    let transitGatewayArn: Swift.String?
}

extension RegisterTransitGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
    }
}

extension RegisterTransitGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTransitGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterTransitGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTransitGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct RegisterTransitGatewayOutputResponse: Swift.Equatable {
    /// Information about the transit gateway registration.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct RegisterTransitGatewayOutputResponseBody: Swift.Equatable {
    let transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?
}

extension RegisterTransitGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension RejectAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/attachments/\(attachmentId.urlPercentEncoding())/reject"
    }
}

public struct RejectAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct RejectAttachmentInputBody: Swift.Equatable {
}

extension RejectAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RejectAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RejectAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RejectAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

public struct RejectAttachmentOutputResponse: Swift.Equatable {
    /// Describes the rejected attachment request.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init (
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct RejectAttachmentOutputResponseBody: Swift.Equatable {
    let attachment: NetworkManagerClientTypes.Attachment?
}

extension RejectAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

extension NetworkManagerClientTypes.Relationship: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = self.from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let to = self.to {
            try encodeContainer.encode(to, forKey: .to)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .to)
        to = toDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a resource relationship.
    public struct Relationship: Swift.Equatable {
        /// The ARN of the resource.
        public var from: Swift.String?
        /// The ARN of the resource.
        public var to: Swift.String?

        public init (
            from: Swift.String? = nil,
            to: Swift.String? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.context = output.context
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.context = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The specified resource could not be found.
    public var context: [Swift.String:Swift.String]?
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.context = context
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let context: [Swift.String:Swift.String]?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context = "Context"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, exceptioncontextvalue0) in contextContainer {
                if let exceptioncontextvalue0 = exceptioncontextvalue0 {
                    contextDecoded0?[key0] = exceptioncontextvalue0
                }
            }
        }
        context = contextDecoded0
    }
}

extension RestoreCoreNetworkPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions/\(policyVersionId)/restore"
    }
}

public struct RestoreCoreNetworkPolicyVersionInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of the policy version to restore.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct RestoreCoreNetworkPolicyVersionInputBody: Swift.Equatable {
}

extension RestoreCoreNetworkPolicyVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RestoreCoreNetworkPolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreCoreNetworkPolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestoreCoreNetworkPolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreCoreNetworkPolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RestoreCoreNetworkPolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct RestoreCoreNetworkPolicyVersionOutputResponse: Swift.Equatable {
    /// Describes the restored core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct RestoreCoreNetworkPolicyVersionOutputResponseBody: Swift.Equatable {
    let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension RestoreCoreNetworkPolicyVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

extension NetworkManagerClientTypes.RouteAnalysis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forwardPath = "ForwardPath"
        case globalNetworkId = "GlobalNetworkId"
        case includeReturnPath = "IncludeReturnPath"
        case ownerAccountId = "OwnerAccountId"
        case returnPath = "ReturnPath"
        case routeAnalysisId = "RouteAnalysisId"
        case source = "Source"
        case startTimestamp = "StartTimestamp"
        case status = "Status"
        case useMiddleboxes = "UseMiddleboxes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forwardPath = self.forwardPath {
            try encodeContainer.encode(forwardPath, forKey: .forwardPath)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if includeReturnPath != false {
            try encodeContainer.encode(includeReturnPath, forKey: .includeReturnPath)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let returnPath = self.returnPath {
            try encodeContainer.encode(returnPath, forKey: .returnPath)
        }
        if let routeAnalysisId = self.routeAnalysisId {
            try encodeContainer.encode(routeAnalysisId, forKey: .routeAnalysisId)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let startTimestamp = self.startTimestamp {
            try encodeContainer.encodeTimestamp(startTimestamp, format: .epochSeconds, forKey: .startTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if useMiddleboxes != false {
            try encodeContainer.encode(useMiddleboxes, forKey: .useMiddleboxes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let routeAnalysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeAnalysisId)
        routeAnalysisId = routeAnalysisIdDecoded
        let startTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisStatus.self, forKey: .status)
        status = statusDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptions.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptions.self, forKey: .destination)
        destination = destinationDecoded
        let includeReturnPathDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeReturnPath) ?? false
        includeReturnPath = includeReturnPathDecoded
        let useMiddleboxesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useMiddleboxes) ?? false
        useMiddleboxes = useMiddleboxesDecoded
        let forwardPathDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisPath.self, forKey: .forwardPath)
        forwardPath = forwardPathDecoded
        let returnPathDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisPath.self, forKey: .returnPath)
        returnPath = returnPathDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a route analysis.
    public struct RouteAnalysis: Swift.Equatable {
        /// The destination.
        public var destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptions?
        /// The forward path.
        public var forwardPath: NetworkManagerClientTypes.RouteAnalysisPath?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.
        public var includeReturnPath: Swift.Bool
        /// The ID of the AWS account that created the route analysis.
        public var ownerAccountId: Swift.String?
        /// The return path.
        public var returnPath: NetworkManagerClientTypes.RouteAnalysisPath?
        /// The ID of the route analysis.
        public var routeAnalysisId: Swift.String?
        /// The source.
        public var source: NetworkManagerClientTypes.RouteAnalysisEndpointOptions?
        /// The time that the analysis started.
        public var startTimestamp: ClientRuntime.Date?
        /// The status of the route analysis.
        public var status: NetworkManagerClientTypes.RouteAnalysisStatus?
        /// Indicates whether to include the location of middlebox appliances in the route analysis.
        public var useMiddleboxes: Swift.Bool

        public init (
            destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptions? = nil,
            forwardPath: NetworkManagerClientTypes.RouteAnalysisPath? = nil,
            globalNetworkId: Swift.String? = nil,
            includeReturnPath: Swift.Bool = false,
            ownerAccountId: Swift.String? = nil,
            returnPath: NetworkManagerClientTypes.RouteAnalysisPath? = nil,
            routeAnalysisId: Swift.String? = nil,
            source: NetworkManagerClientTypes.RouteAnalysisEndpointOptions? = nil,
            startTimestamp: ClientRuntime.Date? = nil,
            status: NetworkManagerClientTypes.RouteAnalysisStatus? = nil,
            useMiddleboxes: Swift.Bool = false
        )
        {
            self.destination = destination
            self.forwardPath = forwardPath
            self.globalNetworkId = globalNetworkId
            self.includeReturnPath = includeReturnPath
            self.ownerAccountId = ownerAccountId
            self.returnPath = returnPath
            self.routeAnalysisId = routeAnalysisId
            self.source = source
            self.startTimestamp = startTimestamp
            self.status = status
            self.useMiddleboxes = useMiddleboxes
        }
    }

}

extension NetworkManagerClientTypes.RouteAnalysisCompletion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reasonCode = "ReasonCode"
        case reasonContext = "ReasonContext"
        case resultCode = "ResultCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reasonCode = self.reasonCode {
            try encodeContainer.encode(reasonCode.rawValue, forKey: .reasonCode)
        }
        if let reasonContext = reasonContext {
            var reasonContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reasonContext)
            for (dictKey0, reasonContextMap0) in reasonContext {
                try reasonContextContainer.encode(reasonContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resultCode = self.resultCode {
            try encodeContainer.encode(resultCode.rawValue, forKey: .resultCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultCodeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisCompletionResultCode.self, forKey: .resultCode)
        resultCode = resultCodeDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let reasonContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .reasonContext)
        var reasonContextDecoded0: [Swift.String:Swift.String]? = nil
        if let reasonContextContainer = reasonContextContainer {
            reasonContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, reasoncontextvalue0) in reasonContextContainer {
                if let reasoncontextvalue0 = reasoncontextvalue0 {
                    reasonContextDecoded0?[key0] = reasoncontextvalue0
                }
            }
        }
        reasonContext = reasonContextDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes the status of an analysis at completion.
    public struct RouteAnalysisCompletion: Swift.Equatable {
        /// The reason code. Available only if a connection is not found.
        ///
        /// * BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND - Found a black hole route with the destination CIDR block.
        ///
        /// * CYCLIC_PATH_DETECTED - Found the same resource multiple times while traversing the path.
        ///
        /// * INACTIVE_ROUTE_FOR_DESTINATION_FOUND - Found an inactive route with the destination CIDR block.
        ///
        /// * MAX_HOPS_EXCEEDED - Analysis exceeded 64 hops without finding the destination.
        ///
        /// * ROUTE_NOT_FOUND - Cannot find a route table with the destination CIDR block.
        ///
        /// * TGW_ATTACH_ARN_NO_MATCH - Found an attachment, but not with the correct destination ARN.
        ///
        /// * TGW_ATTACH_NOT_FOUND - Cannot find an attachment.
        ///
        /// * TGW_ATTACH_NOT_IN_TGW - Found an attachment, but not to the correct transit gateway.
        ///
        /// * TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND - The state of the route table association is not associated.
        public var reasonCode: NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode?
        /// Additional information about the path. Available only if a connection is not found.
        public var reasonContext: [Swift.String:Swift.String]?
        /// The result of the analysis. If the status is NOT_CONNECTED, check the reason code.
        public var resultCode: NetworkManagerClientTypes.RouteAnalysisCompletionResultCode?

        public init (
            reasonCode: NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode? = nil,
            reasonContext: [Swift.String:Swift.String]? = nil,
            resultCode: NetworkManagerClientTypes.RouteAnalysisCompletionResultCode? = nil
        )
        {
            self.reasonCode = reasonCode
            self.reasonContext = reasonContext
            self.resultCode = resultCode
        }
    }

}

extension NetworkManagerClientTypes {
    public enum RouteAnalysisCompletionReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blackholeRouteForDestinationFound
        case cyclicPathDetected
        case inactiveRouteForDestinationFound
        case maxHopsExceeded
        case noDestinationArnProvided
        case possibleMiddlebox
        case routeNotFound
        case transitGatewayAttachment
        case transitGatewayAttachmentNotFound
        case transitGatewayAttachmentNotInTransitGateway
        case transitGatewayAttachmentStableRouteTableNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisCompletionReasonCode] {
            return [
                .blackholeRouteForDestinationFound,
                .cyclicPathDetected,
                .inactiveRouteForDestinationFound,
                .maxHopsExceeded,
                .noDestinationArnProvided,
                .possibleMiddlebox,
                .routeNotFound,
                .transitGatewayAttachment,
                .transitGatewayAttachmentNotFound,
                .transitGatewayAttachmentNotInTransitGateway,
                .transitGatewayAttachmentStableRouteTableNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blackholeRouteForDestinationFound: return "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND"
            case .cyclicPathDetected: return "CYCLIC_PATH_DETECTED"
            case .inactiveRouteForDestinationFound: return "INACTIVE_ROUTE_FOR_DESTINATION_FOUND"
            case .maxHopsExceeded: return "MAX_HOPS_EXCEEDED"
            case .noDestinationArnProvided: return "NO_DESTINATION_ARN_PROVIDED"
            case .possibleMiddlebox: return "POSSIBLE_MIDDLEBOX"
            case .routeNotFound: return "ROUTE_NOT_FOUND"
            case .transitGatewayAttachment: return "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH"
            case .transitGatewayAttachmentNotFound: return "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND"
            case .transitGatewayAttachmentNotInTransitGateway: return "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY"
            case .transitGatewayAttachmentStableRouteTableNotFound: return "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteAnalysisCompletionReasonCode(rawValue: rawValue) ?? RouteAnalysisCompletionReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum RouteAnalysisCompletionResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisCompletionResultCode] {
            return [
                .connected,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteAnalysisCompletionResultCode(rawValue: rawValue) ?? RouteAnalysisCompletionResultCode.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case transitGatewayArn = "TransitGatewayArn"
        case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let transitGatewayArn = self.transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
        if let transitGatewayAttachmentArn = self.transitGatewayAttachmentArn {
            try encodeContainer.encode(transitGatewayAttachmentArn, forKey: .transitGatewayAttachmentArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayAttachmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayAttachmentArn)
        transitGatewayAttachmentArn = transitGatewayAttachmentArnDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a source or a destination.
    public struct RouteAnalysisEndpointOptions: Swift.Equatable {
        /// The IP address.
        public var ipAddress: Swift.String?
        /// The ARN of the transit gateway.
        public var transitGatewayArn: Swift.String?
        /// The ARN of the transit gateway attachment.
        public var transitGatewayAttachmentArn: Swift.String?

        public init (
            ipAddress: Swift.String? = nil,
            transitGatewayArn: Swift.String? = nil,
            transitGatewayAttachmentArn: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }
    }

}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let transitGatewayAttachmentArn = self.transitGatewayAttachmentArn {
            try encodeContainer.encode(transitGatewayAttachmentArn, forKey: .transitGatewayAttachmentArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayAttachmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayAttachmentArn)
        transitGatewayAttachmentArn = transitGatewayAttachmentArnDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a source or a destination.
    public struct RouteAnalysisEndpointOptionsSpecification: Swift.Equatable {
        /// The IP address.
        public var ipAddress: Swift.String?
        /// The ARN of the transit gateway attachment.
        public var transitGatewayAttachmentArn: Swift.String?

        public init (
            ipAddress: Swift.String? = nil,
            transitGatewayAttachmentArn: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }
    }

}

extension NetworkManagerClientTypes.RouteAnalysisPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus = "CompletionStatus"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = self.completionStatus {
            try encodeContainer.encode(completionStatus, forKey: .completionStatus)
        }
        if let path = path {
            var pathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .path)
            for pathcomponent0 in path {
                try pathContainer.encode(pathcomponent0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let completionStatusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisCompletion.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let pathContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.PathComponent?].self, forKey: .path)
        var pathDecoded0:[NetworkManagerClientTypes.PathComponent]? = nil
        if let pathContainer = pathContainer {
            pathDecoded0 = [NetworkManagerClientTypes.PathComponent]()
            for structure0 in pathContainer {
                if let structure0 = structure0 {
                    pathDecoded0?.append(structure0)
                }
            }
        }
        path = pathDecoded0
    }
}

extension NetworkManagerClientTypes {
    /// Describes a route analysis path.
    public struct RouteAnalysisPath: Swift.Equatable {
        /// The status of the analysis at completion.
        public var completionStatus: NetworkManagerClientTypes.RouteAnalysisCompletion?
        /// The route analysis path.
        public var path: [NetworkManagerClientTypes.PathComponent]?

        public init (
            completionStatus: NetworkManagerClientTypes.RouteAnalysisCompletion? = nil,
            path: [NetworkManagerClientTypes.PathComponent]? = nil
        )
        {
            self.completionStatus = completionStatus
            self.path = path
        }
    }

}

extension NetworkManagerClientTypes {
    public enum RouteAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisStatus] {
            return [
                .completed,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteAnalysisStatus(rawValue: rawValue) ?? RouteAnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum RouteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case blackhole
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteState] {
            return [
                .active,
                .blackhole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .blackhole: return "BLACKHOLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteState(rawValue: rawValue) ?? RouteState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.RouteTableIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
        case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkSegmentEdge = self.coreNetworkSegmentEdge {
            try encodeContainer.encode(coreNetworkSegmentEdge, forKey: .coreNetworkSegmentEdge)
        }
        if let transitGatewayRouteTableArn = self.transitGatewayRouteTableArn {
            try encodeContainer.encode(transitGatewayRouteTableArn, forKey: .transitGatewayRouteTableArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRouteTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayRouteTableArn)
        transitGatewayRouteTableArn = transitGatewayRouteTableArnDecoded
        let coreNetworkSegmentEdgeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier.self, forKey: .coreNetworkSegmentEdge)
        coreNetworkSegmentEdge = coreNetworkSegmentEdgeDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a route table.
    public struct RouteTableIdentifier: Swift.Equatable {
        /// The segment edge in a core network.
        public var coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
        /// The ARN of the transit gateway route table.
        public var transitGatewayRouteTableArn: Swift.String?

        public init (
            coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier? = nil,
            transitGatewayRouteTableArn: Swift.String? = nil
        )
        {
            self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum RouteTableType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case coreNetworkSegment
        case transitGatewayRouteTable
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTableType] {
            return [
                .coreNetworkSegment,
                .transitGatewayRouteTable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .coreNetworkSegment: return "CORE_NETWORK_SEGMENT"
            case .transitGatewayRouteTable: return "TRANSIT_GATEWAY_ROUTE_TABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteTableType(rawValue: rawValue) ?? RouteTableType.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case propagated
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .propagated,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .propagated: return "PROPAGATED"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitCode = output.limitCode
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.limitCode = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service limit was exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The limit code.
    /// This member is required.
    public var limitCode: Swift.String?
    /// The error message.
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The resource type.
    public var resourceType: Swift.String?
    /// The service code.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.limitCode = limitCode
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let limitCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitCode = "LimitCode"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension NetworkManagerClientTypes.Site: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let siteArn = self.siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = self.siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let siteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.SiteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Site: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Site(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), location: \"CONTENT_REDACTED\")"}
}

extension NetworkManagerClientTypes {
    /// Describes a site.
    public struct Site: Swift.Equatable {
        /// The date and time that the site was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the site.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The location of the site.
        public var location: NetworkManagerClientTypes.Location?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the site.
        public var state: NetworkManagerClientTypes.SiteState?
        /// The tags for the site.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.SiteState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteArn = siteArn
            self.siteId = siteId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum SiteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [SiteState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SiteState(rawValue: rawValue) ?? SiteState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.SiteToSiteVpnAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case vpnConnectionArn = "VpnConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = self.attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let vpnConnectionArn = self.vpnConnectionArn {
            try encodeContainer.encode(vpnConnectionArn, forKey: .vpnConnectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let vpnConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnConnectionArn)
        vpnConnectionArn = vpnConnectionArnDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Creates a site-to-site VPN attachment.
    public struct SiteToSiteVpnAttachment: Swift.Equatable {
        /// Provides details about a site-to-site VPN attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// The ARN of the site-to-site VPN attachment.
        public var vpnConnectionArn: Swift.String?

        public init (
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            vpnConnectionArn: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.vpnConnectionArn = vpnConnectionArn
        }
    }

}

extension StartOrganizationServiceAccessUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
    }
}

extension StartOrganizationServiceAccessUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organizations/service-access"
    }
}

public struct StartOrganizationServiceAccessUpdateInput: Swift.Equatable {
    /// The action to take for the update request. This can be either ENABLE or DISABLE.
    /// This member is required.
    public var action: Swift.String?

    public init (
        action: Swift.String? = nil
    )
    {
        self.action = action
    }
}

struct StartOrganizationServiceAccessUpdateInputBody: Swift.Equatable {
    let action: Swift.String?
}

extension StartOrganizationServiceAccessUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
    }
}

extension StartOrganizationServiceAccessUpdateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartOrganizationServiceAccessUpdateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartOrganizationServiceAccessUpdateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartOrganizationServiceAccessUpdateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartOrganizationServiceAccessUpdateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationStatus = output.organizationStatus
        } else {
            self.organizationStatus = nil
        }
    }
}

public struct StartOrganizationServiceAccessUpdateOutputResponse: Swift.Equatable {
    /// The status of the service access update request for an Amazon Web Services Organization.
    public var organizationStatus: NetworkManagerClientTypes.OrganizationStatus?

    public init (
        organizationStatus: NetworkManagerClientTypes.OrganizationStatus? = nil
    )
    {
        self.organizationStatus = organizationStatus
    }
}

struct StartOrganizationServiceAccessUpdateOutputResponseBody: Swift.Equatable {
    let organizationStatus: NetworkManagerClientTypes.OrganizationStatus?
}

extension StartOrganizationServiceAccessUpdateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationStatus = "OrganizationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationStatusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.OrganizationStatus.self, forKey: .organizationStatus)
        organizationStatus = organizationStatusDecoded
    }
}

extension StartRouteAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case includeReturnPath = "IncludeReturnPath"
        case source = "Source"
        case useMiddleboxes = "UseMiddleboxes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if includeReturnPath != false {
            try encodeContainer.encode(includeReturnPath, forKey: .includeReturnPath)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if useMiddleboxes != false {
            try encodeContainer.encode(useMiddleboxes, forKey: .useMiddleboxes)
        }
    }
}

extension StartRouteAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/route-analyses"
    }
}

public struct StartRouteAnalysisInput: Swift.Equatable {
    /// The destination.
    /// This member is required.
    public var destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// Indicates whether to analyze the return path. The default is false.
    public var includeReturnPath: Swift.Bool
    /// The source from which traffic originates.
    /// This member is required.
    public var source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    /// Indicates whether to include the location of middlebox appliances in the route analysis. The default is false.
    public var useMiddleboxes: Swift.Bool

    public init (
        destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification? = nil,
        globalNetworkId: Swift.String? = nil,
        includeReturnPath: Swift.Bool = false,
        source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification? = nil,
        useMiddleboxes: Swift.Bool = false
    )
    {
        self.destination = destination
        self.globalNetworkId = globalNetworkId
        self.includeReturnPath = includeReturnPath
        self.source = source
        self.useMiddleboxes = useMiddleboxes
    }
}

struct StartRouteAnalysisInputBody: Swift.Equatable {
    let source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    let destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    let includeReturnPath: Swift.Bool
    let useMiddleboxes: Swift.Bool
}

extension StartRouteAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case includeReturnPath = "IncludeReturnPath"
        case source = "Source"
        case useMiddleboxes = "UseMiddleboxes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification.self, forKey: .destination)
        destination = destinationDecoded
        let includeReturnPathDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeReturnPath) ?? false
        includeReturnPath = includeReturnPathDecoded
        let useMiddleboxesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useMiddleboxes) ?? false
        useMiddleboxes = useMiddleboxesDecoded
    }
}

extension StartRouteAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRouteAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartRouteAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRouteAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartRouteAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routeAnalysis = output.routeAnalysis
        } else {
            self.routeAnalysis = nil
        }
    }
}

public struct StartRouteAnalysisOutputResponse: Swift.Equatable {
    /// The route analysis.
    public var routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?

    public init (
        routeAnalysis: NetworkManagerClientTypes.RouteAnalysis? = nil
    )
    {
        self.routeAnalysis = routeAnalysis
    }
}

struct StartRouteAnalysisOutputResponseBody: Swift.Equatable {
    let routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?
}

extension StartRouteAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeAnalysis = "RouteAnalysis"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeAnalysisDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysis.self, forKey: .routeAnalysis)
        routeAnalysis = routeAnalysisDecoded
    }
}

extension NetworkManagerClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a tag.
    public struct Tag: Swift.Equatable {
        /// The tag key. Constraints: Maximum length of 128 characters.
        public var key: Swift.String?
        /// The tag value. Constraints: Maximum length of 256 characters.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the specified resource.
    /// This member is required.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [NetworkManagerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Indicates when to retry the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let transitGatewayConnectPeerArn = self.transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway Connect peer association.
    public struct TransitGatewayConnectPeerAssociation: Swift.Equatable {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The state of the association.
        public var state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState?
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public var transitGatewayConnectPeerArn: Swift.String?

        public init (
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState? = nil,
            transitGatewayConnectPeerArn: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TransitGatewayConnectPeerAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayConnectPeerAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitGatewayConnectPeerAssociationState(rawValue: rawValue) ?? TransitGatewayConnectPeerAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.TransitGatewayPeering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case peering = "Peering"
        case transitGatewayArn = "TransitGatewayArn"
        case transitGatewayPeeringAttachmentId = "TransitGatewayPeeringAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let peering = self.peering {
            try encodeContainer.encode(peering, forKey: .peering)
        }
        if let transitGatewayArn = self.transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
        if let transitGatewayPeeringAttachmentId = self.transitGatewayPeeringAttachmentId {
            try encodeContainer.encode(transitGatewayPeeringAttachmentId, forKey: .transitGatewayPeeringAttachmentId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let peeringDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Peering.self, forKey: .peering)
        peering = peeringDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let transitGatewayPeeringAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayPeeringAttachmentId)
        transitGatewayPeeringAttachmentId = transitGatewayPeeringAttachmentIdDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway peering attachment.
    public struct TransitGatewayPeering: Swift.Equatable {
        /// Describes a transit gateway peer connection.
        public var peering: NetworkManagerClientTypes.Peering?
        /// The ARN of the transit gateway.
        public var transitGatewayArn: Swift.String?
        /// The ID of the transit gateway peering attachment.
        public var transitGatewayPeeringAttachmentId: Swift.String?

        public init (
            peering: NetworkManagerClientTypes.Peering? = nil,
            transitGatewayArn: Swift.String? = nil,
            transitGatewayPeeringAttachmentId: Swift.String? = nil
        )
        {
            self.peering = peering
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayPeeringAttachmentId = transitGatewayPeeringAttachmentId
        }
    }

}

extension NetworkManagerClientTypes.TransitGatewayRegistration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalNetworkId = self.globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let transitGatewayArn = self.transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistrationStateReason.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the registration of a transit gateway to a global network.
    public struct TransitGatewayRegistration: Swift.Equatable {
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the transit gateway registration.
        public var state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason?
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public var transitGatewayArn: Swift.String?

        public init (
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason? = nil,
            transitGatewayArn: Swift.String? = nil
        )
        {
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.transitGatewayArn = transitGatewayArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TransitGatewayRegistrationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayRegistrationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitGatewayRegistrationState(rawValue: rawValue) ?? TransitGatewayRegistrationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistrationStateReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistrationState.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the status of a transit gateway registration.
    public struct TransitGatewayRegistrationStateReason: Swift.Equatable {
        /// The code for the state reason.
        public var code: NetworkManagerClientTypes.TransitGatewayRegistrationState?
        /// The message for the state reason.
        public var message: Swift.String?

        public init (
            code: NetworkManagerClientTypes.TransitGatewayRegistrationState? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension NetworkManagerClientTypes.TransitGatewayRouteTableAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case peeringId = "PeeringId"
        case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = self.attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let peeringId = self.peeringId {
            try encodeContainer.encode(peeringId, forKey: .peeringId)
        }
        if let transitGatewayRouteTableArn = self.transitGatewayRouteTableArn {
            try encodeContainer.encode(transitGatewayRouteTableArn, forKey: .transitGatewayRouteTableArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let peeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peeringId)
        peeringId = peeringIdDecoded
        let transitGatewayRouteTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayRouteTableArn)
        transitGatewayRouteTableArn = transitGatewayRouteTableArnDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway route table attachment.
    public struct TransitGatewayRouteTableAttachment: Swift.Equatable {
        /// Describes a core network attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// The ID of the peering attachment.
        public var peeringId: Swift.String?
        /// The ARN of the transit gateway attachment route table.
        public var transitGatewayRouteTableArn: Swift.String?

        public init (
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            peeringId: Swift.String? = nil,
            transitGatewayRouteTableArn: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.peeringId = peeringId
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TunnelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gre
        case sdkUnknown(Swift.String)

        public static var allCases: [TunnelProtocol] {
            return [
                .gre,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gre: return "GRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TunnelProtocol(rawValue: rawValue) ?? TunnelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedLinkId = self.connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let linkId = self.linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

extension UpdateConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let connectionId = connectionId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
    }
}

public struct UpdateConnectionInput: Swift.Equatable {
    /// The ID of the link for the second device in the connection.
    public var connectedLinkId: Swift.String?
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device in the connection.
    public var linkId: Swift.String?

    public init (
        connectedLinkId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.connectedLinkId = connectedLinkId
        self.connectionId = connectionId
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct UpdateConnectionInputBody: Swift.Equatable {
    let linkId: Swift.String?
    let connectedLinkId: Swift.String?
    let description: Swift.String?
}

extension UpdateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct UpdateConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct UpdateConnectionOutputResponseBody: Swift.Equatable {
    let connection: NetworkManagerClientTypes.Connection?
}

extension UpdateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension UpdateCoreNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateCoreNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreNetworkId = coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())"
    }
}

public struct UpdateCoreNetworkInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The description of the update.
    public var description: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.description = description
    }
}

struct UpdateCoreNetworkInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateCoreNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct UpdateCoreNetworkOutputResponse: Swift.Equatable {
    /// Returns information about a core network update.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct UpdateCoreNetworkOutputResponseBody: Swift.Equatable {
    let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension UpdateCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

extension UpdateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInput(awsLocation: \(Swift.String(describing: awsLocation)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)), location: \"CONTENT_REDACTED\")"}
}

extension UpdateDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsLocation = self.awsLocation {
            try encodeContainer.encode(awsLocation, forKey: .awsLocation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = self.siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

extension UpdateDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let deviceId = deviceId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct UpdateDeviceInput: Swift.Equatable {
    /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
    public var awsLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// Describes a location.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init (
        awsLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.awsLocation = awsLocation
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.type = type
        self.vendor = vendor
    }
}

struct UpdateDeviceInputBody: Swift.Equatable {
    let awsLocation: NetworkManagerClientTypes.AWSLocation?
    let description: Swift.String?
    let type: Swift.String?
    let vendor: Swift.String?
    let model: Swift.String?
    let serialNumber: Swift.String?
    let location: NetworkManagerClientTypes.Location?
    let siteId: Swift.String?
}

extension UpdateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .awsLocation)
        awsLocation = awsLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
    }
}

extension UpdateDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct UpdateDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct UpdateDeviceOutputResponseBody: Swift.Equatable {
    let device: NetworkManagerClientTypes.Device?
}

extension UpdateDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension UpdateGlobalNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateGlobalNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())"
    }
}

public struct UpdateGlobalNetworkInput: Swift.Equatable {
    /// A description of the global network. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of your global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
    }
}

struct UpdateGlobalNetworkInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateGlobalNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct UpdateGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct UpdateGlobalNetworkOutputResponseBody: Swift.Equatable {
    let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension UpdateGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

extension UpdateLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension UpdateLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let linkId = linkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
    }
}

public struct UpdateLinkInput: Swift.Equatable {
    /// The upload and download speed in Mbps.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The provider of the link. Constraints: Maximum length of 128 characters.
    public var provider: Swift.String?
    /// The type of the link. Constraints: Maximum length of 128 characters.
    public var type: Swift.String?

    public init (
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.provider = provider
        self.type = type
    }
}

struct UpdateLinkInputBody: Swift.Equatable {
    let description: Swift.String?
    let type: Swift.String?
    let bandwidth: NetworkManagerClientTypes.Bandwidth?
    let provider: Swift.String?
}

extension UpdateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension UpdateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct UpdateLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct UpdateLinkOutputResponseBody: Swift.Equatable {
    let link: NetworkManagerClientTypes.Link?
}

extension UpdateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

extension UpdateNetworkResourceMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, networkResourceMetadataMap0) in metadata {
                try metadataContainer.encode(networkResourceMetadataMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateNetworkResourceMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resources/\(resourceArn.urlPercentEncoding())/metadata"
    }
}

public struct UpdateNetworkResourceMetadataInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The resource metadata.
    /// This member is required.
    public var metadata: [Swift.String:Swift.String]?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.metadata = metadata
        self.resourceArn = resourceArn
    }
}

struct UpdateNetworkResourceMetadataInputBody: Swift.Equatable {
    let metadata: [Swift.String:Swift.String]?
}

extension UpdateNetworkResourceMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, constrainedstring0) in metadataContainer {
                if let constrainedstring0 = constrainedstring0 {
                    metadataDecoded0?[key0] = constrainedstring0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension UpdateNetworkResourceMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkResourceMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNetworkResourceMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkResourceMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateNetworkResourceMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.resourceArn = output.resourceArn
        } else {
            self.metadata = nil
            self.resourceArn = nil
        }
    }
}

public struct UpdateNetworkResourceMetadataOutputResponse: Swift.Equatable {
    /// The updated resource metadata.
    public var metadata: [Swift.String:Swift.String]?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?

    public init (
        metadata: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.metadata = metadata
        self.resourceArn = resourceArn
    }
}

struct UpdateNetworkResourceMetadataOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let metadata: [Swift.String:Swift.String]?
}

extension UpdateNetworkResourceMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, constrainedstring0) in metadataContainer {
                if let constrainedstring0 = constrainedstring0 {
                    metadataDecoded0?[key0] = constrainedstring0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension UpdateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), siteId: \(Swift.String(describing: siteId)), location: \"CONTENT_REDACTED\")"}
}

extension UpdateSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }
}

extension UpdateSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let globalNetworkId = globalNetworkId else {
            return nil
        }
        guard let siteId = siteId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
    }
}

public struct UpdateSiteInput: Swift.Equatable {
    /// A description of your site. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location:
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The ID of your site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.siteId = siteId
    }
}

struct UpdateSiteInputBody: Swift.Equatable {
    let description: Swift.String?
    let location: NetworkManagerClientTypes.Location?
}

extension UpdateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
    }
}

extension UpdateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct UpdateSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct UpdateSiteOutputResponseBody: Swift.Equatable {
    let site: NetworkManagerClientTypes.Site?
}

extension UpdateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension UpdateVpcAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSubnetArns = "AddSubnetArns"
        case options = "Options"
        case removeSubnetArns = "RemoveSubnetArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addSubnetArns = addSubnetArns {
            var addSubnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSubnetArns)
            for subnetarn0 in addSubnetArns {
                try addSubnetArnsContainer.encode(subnetarn0)
            }
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let removeSubnetArns = removeSubnetArns {
            var removeSubnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSubnetArns)
            for subnetarn0 in removeSubnetArns {
                try removeSubnetArnsContainer.encode(subnetarn0)
            }
        }
    }
}

extension UpdateVpcAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attachmentId = attachmentId else {
            return nil
        }
        return "/vpc-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

public struct UpdateVpcAttachmentInput: Swift.Equatable {
    /// Adds a subnet ARN to the VPC attachment.
    public var addSubnetArns: [Swift.String]?
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// Additional options for updating the VPC attachment.
    public var options: NetworkManagerClientTypes.VpcOptions?
    /// Removes a subnet ARN from the attachment.
    public var removeSubnetArns: [Swift.String]?

    public init (
        addSubnetArns: [Swift.String]? = nil,
        attachmentId: Swift.String? = nil,
        options: NetworkManagerClientTypes.VpcOptions? = nil,
        removeSubnetArns: [Swift.String]? = nil
    )
    {
        self.addSubnetArns = addSubnetArns
        self.attachmentId = attachmentId
        self.options = options
        self.removeSubnetArns = removeSubnetArns
    }
}

struct UpdateVpcAttachmentInputBody: Swift.Equatable {
    let addSubnetArns: [Swift.String]?
    let removeSubnetArns: [Swift.String]?
    let options: NetworkManagerClientTypes.VpcOptions?
}

extension UpdateVpcAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSubnetArns = "AddSubnetArns"
        case options = "Options"
        case removeSubnetArns = "RemoveSubnetArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSubnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSubnetArns)
        var addSubnetArnsDecoded0:[Swift.String]? = nil
        if let addSubnetArnsContainer = addSubnetArnsContainer {
            addSubnetArnsDecoded0 = [Swift.String]()
            for string0 in addSubnetArnsContainer {
                if let string0 = string0 {
                    addSubnetArnsDecoded0?.append(string0)
                }
            }
        }
        addSubnetArns = addSubnetArnsDecoded0
        let removeSubnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSubnetArns)
        var removeSubnetArnsDecoded0:[Swift.String]? = nil
        if let removeSubnetArnsContainer = removeSubnetArnsContainer {
            removeSubnetArnsDecoded0 = [Swift.String]()
            for string0 in removeSubnetArnsContainer {
                if let string0 = string0 {
                    removeSubnetArnsDecoded0?.append(string0)
                }
            }
        }
        removeSubnetArns = removeSubnetArnsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcOptions.self, forKey: .options)
        options = optionsDecoded
    }
}

extension UpdateVpcAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVpcAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVpcAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcAttachment = output.vpcAttachment
        } else {
            self.vpcAttachment = nil
        }
    }
}

public struct UpdateVpcAttachmentOutputResponse: Swift.Equatable {
    /// Describes the updated VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init (
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

struct UpdateVpcAttachmentOutputResponseBody: Swift.Equatable {
    let vpcAttachment: NetworkManagerClientTypes.VpcAttachment?
}

extension UpdateVpcAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcAttachment = "VpcAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcAttachment.self, forKey: .vpcAttachment)
        vpcAttachment = vpcAttachmentDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable.
    public var fields: [NetworkManagerClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the error.
    public var reason: NetworkManagerClientTypes.ValidationExceptionReason?

    public init (
        fields: [NetworkManagerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: NetworkManagerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: NetworkManagerClientTypes.ValidationExceptionReason?
    let fields: [NetworkManagerClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[NetworkManagerClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [NetworkManagerClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension NetworkManagerClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a validation exception for a field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message for the field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .other: return "Other"
            case .unknownOperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.VpcAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case options = "Options"
        case subnetArns = "SubnetArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = self.attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let subnetArns = subnetArns {
            var subnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetArns)
            for subnetarn0 in subnetArns {
                try subnetArnsContainer.encode(subnetarn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let subnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetArns)
        var subnetArnsDecoded0:[Swift.String]? = nil
        if let subnetArnsContainer = subnetArnsContainer {
            subnetArnsDecoded0 = [Swift.String]()
            for string0 in subnetArnsContainer {
                if let string0 = string0 {
                    subnetArnsDecoded0?.append(string0)
                }
            }
        }
        subnetArns = subnetArnsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcOptions.self, forKey: .options)
        options = optionsDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes a VPC attachment.
    public struct VpcAttachment: Swift.Equatable {
        /// Provides details about the VPC attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// Provides details about the VPC attachment.
        public var options: NetworkManagerClientTypes.VpcOptions?
        /// The subnet ARNs.
        public var subnetArns: [Swift.String]?

        public init (
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            options: NetworkManagerClientTypes.VpcOptions? = nil,
            subnetArns: [Swift.String]? = nil
        )
        {
            self.attachment = attachment
            self.options = options
            self.subnetArns = subnetArns
        }
    }

}

extension NetworkManagerClientTypes.VpcOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applianceModeSupport = "ApplianceModeSupport"
        case ipv6Support = "Ipv6Support"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applianceModeSupport != false {
            try encodeContainer.encode(applianceModeSupport, forKey: .applianceModeSupport)
        }
        if ipv6Support != false {
            try encodeContainer.encode(ipv6Support, forKey: .ipv6Support)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6SupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ipv6Support) ?? false
        ipv6Support = ipv6SupportDecoded
        let applianceModeSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applianceModeSupport) ?? false
        applianceModeSupport = applianceModeSupportDecoded
    }
}

extension NetworkManagerClientTypes {
    /// Describes the VPC options.
    public struct VpcOptions: Swift.Equatable {
        /// Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is false.
        public var applianceModeSupport: Swift.Bool
        /// Indicates whether IPv6 is supported.
        public var ipv6Support: Swift.Bool

        public init (
            applianceModeSupport: Swift.Bool = false,
            ipv6Support: Swift.Bool = false
        )
        {
            self.applianceModeSupport = applianceModeSupport
            self.ipv6Support = ipv6Support
        }
    }

}
