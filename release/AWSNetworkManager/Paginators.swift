// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeGlobalNetworksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeGlobalNetworksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeGlobalNetworksOutputResponse`
extension NetworkManagerClient {
    public func describeGlobalNetworksPaginated(input: DescribeGlobalNetworksInput) -> ClientRuntime.PaginatorSequence<DescribeGlobalNetworksInput, DescribeGlobalNetworksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeGlobalNetworksInput, DescribeGlobalNetworksOutputResponse>(input: input, inputKey: \DescribeGlobalNetworksInput.nextToken, outputKey: \DescribeGlobalNetworksOutputResponse.nextToken, paginationFunction: self.describeGlobalNetworks(input:))
    }
}

extension DescribeGlobalNetworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGlobalNetworksInput {
        return DescribeGlobalNetworksInput(
            globalNetworkIds: self.globalNetworkIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeGlobalNetworksPaginated`
/// to access the nested member `[NetworkManagerClientTypes.GlobalNetwork]`
/// - Returns: `[NetworkManagerClientTypes.GlobalNetwork]`
extension PaginatorSequence where Input == DescribeGlobalNetworksInput, Output == DescribeGlobalNetworksOutputResponse {
    public func globalNetworks() async throws -> [NetworkManagerClientTypes.GlobalNetwork] {
        return try await self.asyncCompactMap { item in item.globalNetworks }
    }
}

/// Paginate over `[GetConnectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetConnectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetConnectionsOutputResponse`
extension NetworkManagerClient {
    public func getConnectionsPaginated(input: GetConnectionsInput) -> ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutputResponse>(input: input, inputKey: \GetConnectionsInput.nextToken, outputKey: \GetConnectionsOutputResponse.nextToken, paginationFunction: self.getConnections(input:))
    }
}

extension GetConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectionsInput {
        return GetConnectionsInput(
            connectionIds: self.connectionIds,
            deviceId: self.deviceId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getConnectionsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.Connection]`
/// - Returns: `[NetworkManagerClientTypes.Connection]`
extension PaginatorSequence where Input == GetConnectionsInput, Output == GetConnectionsOutputResponse {
    public func connections() async throws -> [NetworkManagerClientTypes.Connection] {
        return try await self.asyncCompactMap { item in item.connections }
    }
}

/// Paginate over `[GetConnectPeerAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetConnectPeerAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetConnectPeerAssociationsOutputResponse`
extension NetworkManagerClient {
    public func getConnectPeerAssociationsPaginated(input: GetConnectPeerAssociationsInput) -> ClientRuntime.PaginatorSequence<GetConnectPeerAssociationsInput, GetConnectPeerAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetConnectPeerAssociationsInput, GetConnectPeerAssociationsOutputResponse>(input: input, inputKey: \GetConnectPeerAssociationsInput.nextToken, outputKey: \GetConnectPeerAssociationsOutputResponse.nextToken, paginationFunction: self.getConnectPeerAssociations(input:))
    }
}

extension GetConnectPeerAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectPeerAssociationsInput {
        return GetConnectPeerAssociationsInput(
            connectPeerIds: self.connectPeerIds,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getConnectPeerAssociationsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.ConnectPeerAssociation]`
/// - Returns: `[NetworkManagerClientTypes.ConnectPeerAssociation]`
extension PaginatorSequence where Input == GetConnectPeerAssociationsInput, Output == GetConnectPeerAssociationsOutputResponse {
    public func connectPeerAssociations() async throws -> [NetworkManagerClientTypes.ConnectPeerAssociation] {
        return try await self.asyncCompactMap { item in item.connectPeerAssociations }
    }
}

/// Paginate over `[GetCoreNetworkChangeEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCoreNetworkChangeEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCoreNetworkChangeEventsOutputResponse`
extension NetworkManagerClient {
    public func getCoreNetworkChangeEventsPaginated(input: GetCoreNetworkChangeEventsInput) -> ClientRuntime.PaginatorSequence<GetCoreNetworkChangeEventsInput, GetCoreNetworkChangeEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCoreNetworkChangeEventsInput, GetCoreNetworkChangeEventsOutputResponse>(input: input, inputKey: \GetCoreNetworkChangeEventsInput.nextToken, outputKey: \GetCoreNetworkChangeEventsOutputResponse.nextToken, paginationFunction: self.getCoreNetworkChangeEvents(input:))
    }
}

extension GetCoreNetworkChangeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCoreNetworkChangeEventsInput {
        return GetCoreNetworkChangeEventsInput(
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            policyVersionId: self.policyVersionId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getCoreNetworkChangeEventsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.CoreNetworkChangeEvent]`
/// - Returns: `[NetworkManagerClientTypes.CoreNetworkChangeEvent]`
extension PaginatorSequence where Input == GetCoreNetworkChangeEventsInput, Output == GetCoreNetworkChangeEventsOutputResponse {
    public func coreNetworkChangeEvents() async throws -> [NetworkManagerClientTypes.CoreNetworkChangeEvent] {
        return try await self.asyncCompactMap { item in item.coreNetworkChangeEvents }
    }
}

/// Paginate over `[GetCoreNetworkChangeSetOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCoreNetworkChangeSetInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCoreNetworkChangeSetOutputResponse`
extension NetworkManagerClient {
    public func getCoreNetworkChangeSetPaginated(input: GetCoreNetworkChangeSetInput) -> ClientRuntime.PaginatorSequence<GetCoreNetworkChangeSetInput, GetCoreNetworkChangeSetOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCoreNetworkChangeSetInput, GetCoreNetworkChangeSetOutputResponse>(input: input, inputKey: \GetCoreNetworkChangeSetInput.nextToken, outputKey: \GetCoreNetworkChangeSetOutputResponse.nextToken, paginationFunction: self.getCoreNetworkChangeSet(input:))
    }
}

extension GetCoreNetworkChangeSetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCoreNetworkChangeSetInput {
        return GetCoreNetworkChangeSetInput(
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            policyVersionId: self.policyVersionId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getCoreNetworkChangeSetPaginated`
/// to access the nested member `[NetworkManagerClientTypes.CoreNetworkChange]`
/// - Returns: `[NetworkManagerClientTypes.CoreNetworkChange]`
extension PaginatorSequence where Input == GetCoreNetworkChangeSetInput, Output == GetCoreNetworkChangeSetOutputResponse {
    public func coreNetworkChanges() async throws -> [NetworkManagerClientTypes.CoreNetworkChange] {
        return try await self.asyncCompactMap { item in item.coreNetworkChanges }
    }
}

/// Paginate over `[GetCustomerGatewayAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCustomerGatewayAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCustomerGatewayAssociationsOutputResponse`
extension NetworkManagerClient {
    public func getCustomerGatewayAssociationsPaginated(input: GetCustomerGatewayAssociationsInput) -> ClientRuntime.PaginatorSequence<GetCustomerGatewayAssociationsInput, GetCustomerGatewayAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCustomerGatewayAssociationsInput, GetCustomerGatewayAssociationsOutputResponse>(input: input, inputKey: \GetCustomerGatewayAssociationsInput.nextToken, outputKey: \GetCustomerGatewayAssociationsOutputResponse.nextToken, paginationFunction: self.getCustomerGatewayAssociations(input:))
    }
}

extension GetCustomerGatewayAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCustomerGatewayAssociationsInput {
        return GetCustomerGatewayAssociationsInput(
            customerGatewayArns: self.customerGatewayArns,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getCustomerGatewayAssociationsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.CustomerGatewayAssociation]`
/// - Returns: `[NetworkManagerClientTypes.CustomerGatewayAssociation]`
extension PaginatorSequence where Input == GetCustomerGatewayAssociationsInput, Output == GetCustomerGatewayAssociationsOutputResponse {
    public func customerGatewayAssociations() async throws -> [NetworkManagerClientTypes.CustomerGatewayAssociation] {
        return try await self.asyncCompactMap { item in item.customerGatewayAssociations }
    }
}

/// Paginate over `[GetDevicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetDevicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetDevicesOutputResponse`
extension NetworkManagerClient {
    public func getDevicesPaginated(input: GetDevicesInput) -> ClientRuntime.PaginatorSequence<GetDevicesInput, GetDevicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDevicesInput, GetDevicesOutputResponse>(input: input, inputKey: \GetDevicesInput.nextToken, outputKey: \GetDevicesOutputResponse.nextToken, paginationFunction: self.getDevices(input:))
    }
}

extension GetDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDevicesInput {
        return GetDevicesInput(
            deviceIds: self.deviceIds,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            siteId: self.siteId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getDevicesPaginated`
/// to access the nested member `[NetworkManagerClientTypes.Device]`
/// - Returns: `[NetworkManagerClientTypes.Device]`
extension PaginatorSequence where Input == GetDevicesInput, Output == GetDevicesOutputResponse {
    public func devices() async throws -> [NetworkManagerClientTypes.Device] {
        return try await self.asyncCompactMap { item in item.devices }
    }
}

/// Paginate over `[GetLinkAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetLinkAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetLinkAssociationsOutputResponse`
extension NetworkManagerClient {
    public func getLinkAssociationsPaginated(input: GetLinkAssociationsInput) -> ClientRuntime.PaginatorSequence<GetLinkAssociationsInput, GetLinkAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetLinkAssociationsInput, GetLinkAssociationsOutputResponse>(input: input, inputKey: \GetLinkAssociationsInput.nextToken, outputKey: \GetLinkAssociationsOutputResponse.nextToken, paginationFunction: self.getLinkAssociations(input:))
    }
}

extension GetLinkAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLinkAssociationsInput {
        return GetLinkAssociationsInput(
            deviceId: self.deviceId,
            globalNetworkId: self.globalNetworkId,
            linkId: self.linkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getLinkAssociationsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.LinkAssociation]`
/// - Returns: `[NetworkManagerClientTypes.LinkAssociation]`
extension PaginatorSequence where Input == GetLinkAssociationsInput, Output == GetLinkAssociationsOutputResponse {
    public func linkAssociations() async throws -> [NetworkManagerClientTypes.LinkAssociation] {
        return try await self.asyncCompactMap { item in item.linkAssociations }
    }
}

/// Paginate over `[GetLinksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetLinksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetLinksOutputResponse`
extension NetworkManagerClient {
    public func getLinksPaginated(input: GetLinksInput) -> ClientRuntime.PaginatorSequence<GetLinksInput, GetLinksOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetLinksInput, GetLinksOutputResponse>(input: input, inputKey: \GetLinksInput.nextToken, outputKey: \GetLinksOutputResponse.nextToken, paginationFunction: self.getLinks(input:))
    }
}

extension GetLinksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLinksInput {
        return GetLinksInput(
            globalNetworkId: self.globalNetworkId,
            linkIds: self.linkIds,
            maxResults: self.maxResults,
            nextToken: token,
            provider: self.provider,
            siteId: self.siteId,
            type: self.type
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getLinksPaginated`
/// to access the nested member `[NetworkManagerClientTypes.Link]`
/// - Returns: `[NetworkManagerClientTypes.Link]`
extension PaginatorSequence where Input == GetLinksInput, Output == GetLinksOutputResponse {
    public func links() async throws -> [NetworkManagerClientTypes.Link] {
        return try await self.asyncCompactMap { item in item.links }
    }
}

/// Paginate over `[GetNetworkResourceCountsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetNetworkResourceCountsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetNetworkResourceCountsOutputResponse`
extension NetworkManagerClient {
    public func getNetworkResourceCountsPaginated(input: GetNetworkResourceCountsInput) -> ClientRuntime.PaginatorSequence<GetNetworkResourceCountsInput, GetNetworkResourceCountsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetNetworkResourceCountsInput, GetNetworkResourceCountsOutputResponse>(input: input, inputKey: \GetNetworkResourceCountsInput.nextToken, outputKey: \GetNetworkResourceCountsOutputResponse.nextToken, paginationFunction: self.getNetworkResourceCounts(input:))
    }
}

extension GetNetworkResourceCountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkResourceCountsInput {
        return GetNetworkResourceCountsInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getNetworkResourceCountsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.NetworkResourceCount]`
/// - Returns: `[NetworkManagerClientTypes.NetworkResourceCount]`
extension PaginatorSequence where Input == GetNetworkResourceCountsInput, Output == GetNetworkResourceCountsOutputResponse {
    public func networkResourceCounts() async throws -> [NetworkManagerClientTypes.NetworkResourceCount] {
        return try await self.asyncCompactMap { item in item.networkResourceCounts }
    }
}

/// Paginate over `[GetNetworkResourceRelationshipsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetNetworkResourceRelationshipsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetNetworkResourceRelationshipsOutputResponse`
extension NetworkManagerClient {
    public func getNetworkResourceRelationshipsPaginated(input: GetNetworkResourceRelationshipsInput) -> ClientRuntime.PaginatorSequence<GetNetworkResourceRelationshipsInput, GetNetworkResourceRelationshipsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetNetworkResourceRelationshipsInput, GetNetworkResourceRelationshipsOutputResponse>(input: input, inputKey: \GetNetworkResourceRelationshipsInput.nextToken, outputKey: \GetNetworkResourceRelationshipsOutputResponse.nextToken, paginationFunction: self.getNetworkResourceRelationships(input:))
    }
}

extension GetNetworkResourceRelationshipsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkResourceRelationshipsInput {
        return GetNetworkResourceRelationshipsInput(
            accountId: self.accountId,
            awsRegion: self.awsRegion,
            coreNetworkId: self.coreNetworkId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            registeredGatewayArn: self.registeredGatewayArn,
            resourceArn: self.resourceArn,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getNetworkResourceRelationshipsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.Relationship]`
/// - Returns: `[NetworkManagerClientTypes.Relationship]`
extension PaginatorSequence where Input == GetNetworkResourceRelationshipsInput, Output == GetNetworkResourceRelationshipsOutputResponse {
    public func relationships() async throws -> [NetworkManagerClientTypes.Relationship] {
        return try await self.asyncCompactMap { item in item.relationships }
    }
}

/// Paginate over `[GetNetworkResourcesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetNetworkResourcesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetNetworkResourcesOutputResponse`
extension NetworkManagerClient {
    public func getNetworkResourcesPaginated(input: GetNetworkResourcesInput) -> ClientRuntime.PaginatorSequence<GetNetworkResourcesInput, GetNetworkResourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetNetworkResourcesInput, GetNetworkResourcesOutputResponse>(input: input, inputKey: \GetNetworkResourcesInput.nextToken, outputKey: \GetNetworkResourcesOutputResponse.nextToken, paginationFunction: self.getNetworkResources(input:))
    }
}

extension GetNetworkResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkResourcesInput {
        return GetNetworkResourcesInput(
            accountId: self.accountId,
            awsRegion: self.awsRegion,
            coreNetworkId: self.coreNetworkId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            registeredGatewayArn: self.registeredGatewayArn,
            resourceArn: self.resourceArn,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getNetworkResourcesPaginated`
/// to access the nested member `[NetworkManagerClientTypes.NetworkResource]`
/// - Returns: `[NetworkManagerClientTypes.NetworkResource]`
extension PaginatorSequence where Input == GetNetworkResourcesInput, Output == GetNetworkResourcesOutputResponse {
    public func networkResources() async throws -> [NetworkManagerClientTypes.NetworkResource] {
        return try await self.asyncCompactMap { item in item.networkResources }
    }
}

/// Paginate over `[GetNetworkTelemetryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetNetworkTelemetryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetNetworkTelemetryOutputResponse`
extension NetworkManagerClient {
    public func getNetworkTelemetryPaginated(input: GetNetworkTelemetryInput) -> ClientRuntime.PaginatorSequence<GetNetworkTelemetryInput, GetNetworkTelemetryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetNetworkTelemetryInput, GetNetworkTelemetryOutputResponse>(input: input, inputKey: \GetNetworkTelemetryInput.nextToken, outputKey: \GetNetworkTelemetryOutputResponse.nextToken, paginationFunction: self.getNetworkTelemetry(input:))
    }
}

extension GetNetworkTelemetryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkTelemetryInput {
        return GetNetworkTelemetryInput(
            accountId: self.accountId,
            awsRegion: self.awsRegion,
            coreNetworkId: self.coreNetworkId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            registeredGatewayArn: self.registeredGatewayArn,
            resourceArn: self.resourceArn,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getNetworkTelemetryPaginated`
/// to access the nested member `[NetworkManagerClientTypes.NetworkTelemetry]`
/// - Returns: `[NetworkManagerClientTypes.NetworkTelemetry]`
extension PaginatorSequence where Input == GetNetworkTelemetryInput, Output == GetNetworkTelemetryOutputResponse {
    public func networkTelemetry() async throws -> [NetworkManagerClientTypes.NetworkTelemetry] {
        return try await self.asyncCompactMap { item in item.networkTelemetry }
    }
}

/// Paginate over `[GetSitesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetSitesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetSitesOutputResponse`
extension NetworkManagerClient {
    public func getSitesPaginated(input: GetSitesInput) -> ClientRuntime.PaginatorSequence<GetSitesInput, GetSitesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetSitesInput, GetSitesOutputResponse>(input: input, inputKey: \GetSitesInput.nextToken, outputKey: \GetSitesOutputResponse.nextToken, paginationFunction: self.getSites(input:))
    }
}

extension GetSitesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSitesInput {
        return GetSitesInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            siteIds: self.siteIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getSitesPaginated`
/// to access the nested member `[NetworkManagerClientTypes.Site]`
/// - Returns: `[NetworkManagerClientTypes.Site]`
extension PaginatorSequence where Input == GetSitesInput, Output == GetSitesOutputResponse {
    public func sites() async throws -> [NetworkManagerClientTypes.Site] {
        return try await self.asyncCompactMap { item in item.sites }
    }
}

/// Paginate over `[GetTransitGatewayConnectPeerAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayConnectPeerAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayConnectPeerAssociationsOutputResponse`
extension NetworkManagerClient {
    public func getTransitGatewayConnectPeerAssociationsPaginated(input: GetTransitGatewayConnectPeerAssociationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayConnectPeerAssociationsInput, GetTransitGatewayConnectPeerAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayConnectPeerAssociationsInput, GetTransitGatewayConnectPeerAssociationsOutputResponse>(input: input, inputKey: \GetTransitGatewayConnectPeerAssociationsInput.nextToken, outputKey: \GetTransitGatewayConnectPeerAssociationsOutputResponse.nextToken, paginationFunction: self.getTransitGatewayConnectPeerAssociations(input:))
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayConnectPeerAssociationsInput {
        return GetTransitGatewayConnectPeerAssociationsInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayConnectPeerArns: self.transitGatewayConnectPeerArns
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayConnectPeerAssociationsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]`
/// - Returns: `[NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]`
extension PaginatorSequence where Input == GetTransitGatewayConnectPeerAssociationsInput, Output == GetTransitGatewayConnectPeerAssociationsOutputResponse {
    public func transitGatewayConnectPeerAssociations() async throws -> [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation] {
        return try await self.asyncCompactMap { item in item.transitGatewayConnectPeerAssociations }
    }
}

/// Paginate over `[GetTransitGatewayRegistrationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayRegistrationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayRegistrationsOutputResponse`
extension NetworkManagerClient {
    public func getTransitGatewayRegistrationsPaginated(input: GetTransitGatewayRegistrationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayRegistrationsInput, GetTransitGatewayRegistrationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayRegistrationsInput, GetTransitGatewayRegistrationsOutputResponse>(input: input, inputKey: \GetTransitGatewayRegistrationsInput.nextToken, outputKey: \GetTransitGatewayRegistrationsOutputResponse.nextToken, paginationFunction: self.getTransitGatewayRegistrations(input:))
    }
}

extension GetTransitGatewayRegistrationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayRegistrationsInput {
        return GetTransitGatewayRegistrationsInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayArns: self.transitGatewayArns
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayRegistrationsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.TransitGatewayRegistration]`
/// - Returns: `[NetworkManagerClientTypes.TransitGatewayRegistration]`
extension PaginatorSequence where Input == GetTransitGatewayRegistrationsInput, Output == GetTransitGatewayRegistrationsOutputResponse {
    public func transitGatewayRegistrations() async throws -> [NetworkManagerClientTypes.TransitGatewayRegistration] {
        return try await self.asyncCompactMap { item in item.transitGatewayRegistrations }
    }
}

/// Paginate over `[ListAttachmentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAttachmentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAttachmentsOutputResponse`
extension NetworkManagerClient {
    public func listAttachmentsPaginated(input: ListAttachmentsInput) -> ClientRuntime.PaginatorSequence<ListAttachmentsInput, ListAttachmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAttachmentsInput, ListAttachmentsOutputResponse>(input: input, inputKey: \ListAttachmentsInput.nextToken, outputKey: \ListAttachmentsOutputResponse.nextToken, paginationFunction: self.listAttachments(input:))
    }
}

extension ListAttachmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachmentsInput {
        return ListAttachmentsInput(
            attachmentType: self.attachmentType,
            coreNetworkId: self.coreNetworkId,
            edgeLocation: self.edgeLocation,
            maxResults: self.maxResults,
            nextToken: token,
            state: self.state
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAttachmentsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.Attachment]`
/// - Returns: `[NetworkManagerClientTypes.Attachment]`
extension PaginatorSequence where Input == ListAttachmentsInput, Output == ListAttachmentsOutputResponse {
    public func attachments() async throws -> [NetworkManagerClientTypes.Attachment] {
        return try await self.asyncCompactMap { item in item.attachments }
    }
}

/// Paginate over `[ListConnectPeersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListConnectPeersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListConnectPeersOutputResponse`
extension NetworkManagerClient {
    public func listConnectPeersPaginated(input: ListConnectPeersInput) -> ClientRuntime.PaginatorSequence<ListConnectPeersInput, ListConnectPeersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListConnectPeersInput, ListConnectPeersOutputResponse>(input: input, inputKey: \ListConnectPeersInput.nextToken, outputKey: \ListConnectPeersOutputResponse.nextToken, paginationFunction: self.listConnectPeers(input:))
    }
}

extension ListConnectPeersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConnectPeersInput {
        return ListConnectPeersInput(
            connectAttachmentId: self.connectAttachmentId,
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listConnectPeersPaginated`
/// to access the nested member `[NetworkManagerClientTypes.ConnectPeerSummary]`
/// - Returns: `[NetworkManagerClientTypes.ConnectPeerSummary]`
extension PaginatorSequence where Input == ListConnectPeersInput, Output == ListConnectPeersOutputResponse {
    public func connectPeers() async throws -> [NetworkManagerClientTypes.ConnectPeerSummary] {
        return try await self.asyncCompactMap { item in item.connectPeers }
    }
}

/// Paginate over `[ListCoreNetworkPolicyVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCoreNetworkPolicyVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCoreNetworkPolicyVersionsOutputResponse`
extension NetworkManagerClient {
    public func listCoreNetworkPolicyVersionsPaginated(input: ListCoreNetworkPolicyVersionsInput) -> ClientRuntime.PaginatorSequence<ListCoreNetworkPolicyVersionsInput, ListCoreNetworkPolicyVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCoreNetworkPolicyVersionsInput, ListCoreNetworkPolicyVersionsOutputResponse>(input: input, inputKey: \ListCoreNetworkPolicyVersionsInput.nextToken, outputKey: \ListCoreNetworkPolicyVersionsOutputResponse.nextToken, paginationFunction: self.listCoreNetworkPolicyVersions(input:))
    }
}

extension ListCoreNetworkPolicyVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCoreNetworkPolicyVersionsInput {
        return ListCoreNetworkPolicyVersionsInput(
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCoreNetworkPolicyVersionsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.CoreNetworkPolicyVersion]`
/// - Returns: `[NetworkManagerClientTypes.CoreNetworkPolicyVersion]`
extension PaginatorSequence where Input == ListCoreNetworkPolicyVersionsInput, Output == ListCoreNetworkPolicyVersionsOutputResponse {
    public func coreNetworkPolicyVersions() async throws -> [NetworkManagerClientTypes.CoreNetworkPolicyVersion] {
        return try await self.asyncCompactMap { item in item.coreNetworkPolicyVersions }
    }
}

/// Paginate over `[ListCoreNetworksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCoreNetworksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCoreNetworksOutputResponse`
extension NetworkManagerClient {
    public func listCoreNetworksPaginated(input: ListCoreNetworksInput) -> ClientRuntime.PaginatorSequence<ListCoreNetworksInput, ListCoreNetworksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCoreNetworksInput, ListCoreNetworksOutputResponse>(input: input, inputKey: \ListCoreNetworksInput.nextToken, outputKey: \ListCoreNetworksOutputResponse.nextToken, paginationFunction: self.listCoreNetworks(input:))
    }
}

extension ListCoreNetworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCoreNetworksInput {
        return ListCoreNetworksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCoreNetworksPaginated`
/// to access the nested member `[NetworkManagerClientTypes.CoreNetworkSummary]`
/// - Returns: `[NetworkManagerClientTypes.CoreNetworkSummary]`
extension PaginatorSequence where Input == ListCoreNetworksInput, Output == ListCoreNetworksOutputResponse {
    public func coreNetworks() async throws -> [NetworkManagerClientTypes.CoreNetworkSummary] {
        return try await self.asyncCompactMap { item in item.coreNetworks }
    }
}

/// Paginate over `[ListPeeringsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPeeringsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPeeringsOutputResponse`
extension NetworkManagerClient {
    public func listPeeringsPaginated(input: ListPeeringsInput) -> ClientRuntime.PaginatorSequence<ListPeeringsInput, ListPeeringsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPeeringsInput, ListPeeringsOutputResponse>(input: input, inputKey: \ListPeeringsInput.nextToken, outputKey: \ListPeeringsOutputResponse.nextToken, paginationFunction: self.listPeerings(input:))
    }
}

extension ListPeeringsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPeeringsInput {
        return ListPeeringsInput(
            coreNetworkId: self.coreNetworkId,
            edgeLocation: self.edgeLocation,
            maxResults: self.maxResults,
            nextToken: token,
            peeringType: self.peeringType,
            state: self.state
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPeeringsPaginated`
/// to access the nested member `[NetworkManagerClientTypes.Peering]`
/// - Returns: `[NetworkManagerClientTypes.Peering]`
extension PaginatorSequence where Input == ListPeeringsInput, Output == ListPeeringsOutputResponse {
    public func peerings() async throws -> [NetworkManagerClientTypes.Peering] {
        return try await self.asyncCompactMap { item in item.peerings }
    }
}
