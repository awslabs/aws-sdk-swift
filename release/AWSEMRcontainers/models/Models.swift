// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CancelJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns/\(id.urlPercentEncoding())"
    }
}

public struct CancelJobRunInput: Swift.Equatable {
    /// The ID of the job run to cancel.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the virtual cluster for which the job run will be canceled.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunInputBody: Swift.Equatable {
}

extension CancelJobRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CancelJobRunOutputResponse: Swift.Equatable {
    /// The output contains the ID of the cancelled job run.
    public var id: Swift.String?
    /// The output contains the virtual cluster ID for which the job run is cancelled.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let virtualClusterId: Swift.String?
}

extension CancelJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension EmrContainersClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateData = self.certificateData {
            try encodeContainer.encode(certificateData, forKey: .certificateData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateData)
        certificateData = certificateDataDecoded
    }
}

extension EmrContainersClientTypes {
    /// The entity representing certificate data generated for managed endpoint.
    public struct Certificate: Swift.Equatable {
        /// The ARN of the certificate generated for managed endpoint.
        public var certificateArn: Swift.String?
        /// The base64 encoded PEM certificate data generated for managed endpoint.
        public var certificateData: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            certificateData: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateData = certificateData
        }
    }

}

extension EmrContainersClientTypes.CloudWatchMonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
        case logStreamNamePrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logStreamNamePrefix = self.logStreamNamePrefix {
            try encodeContainer.encode(logStreamNamePrefix, forKey: .logStreamNamePrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let logStreamNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamNamePrefix)
        logStreamNamePrefix = logStreamNamePrefixDecoded
    }
}

extension EmrContainersClientTypes {
    /// A configuration for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs.
    public struct CloudWatchMonitoringConfiguration: Swift.Equatable {
        /// The name of the log group for log publishing.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The specified name prefix for log streams.
        public var logStreamNamePrefix: Swift.String?

        public init (
            logGroupName: Swift.String? = nil,
            logStreamNamePrefix: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logStreamNamePrefix = logStreamNamePrefix
        }
    }

}

extension EmrContainersClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classification
        case configurations
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = self.classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for configurationlist0 in configurations {
                try configurationsContainer.encode(configurationlist0)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, sensitivepropertiesmap0) in properties {
                try propertiesContainer.encode(sensitivepropertiesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string10240) in propertiesContainer {
                if let string10240 = string10240 {
                    propertiesDecoded0?[key0] = string10240
                }
            }
        }
        properties = propertiesDecoded0
        let configurationsContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[EmrContainersClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [EmrContainersClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension EmrContainersClientTypes.Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configuration(classification: \(Swift.String(describing: classification)), configurations: \(Swift.String(describing: configurations)), properties: \"CONTENT_REDACTED\")"}
}

extension EmrContainersClientTypes {
    /// A configuration specification to be used when provisioning virtual clusters, which can include configurations for applications and software bundled with Amazon EMR on EKS. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.
    public struct Configuration: Swift.Equatable {
        /// The classification within a configuration.
        /// This member is required.
        public var classification: Swift.String?
        /// A list of additional configurations to apply within a configuration object.
        public var configurations: [EmrContainersClientTypes.Configuration]?
        /// A set of properties specified within a configuration classification.
        public var properties: [Swift.String:Swift.String]?

        public init (
            classification: Swift.String? = nil,
            configurations: [EmrContainersClientTypes.Configuration]? = nil,
            properties: [Swift.String:Swift.String]? = nil
        )
        {
            self.classification = classification
            self.configurations = configurations
            self.properties = properties
        }
    }

}

extension EmrContainersClientTypes.ConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration
        case monitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            var applicationConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationConfiguration)
            for configurationlist0 in applicationConfiguration {
                try applicationConfigurationContainer.encode(configurationlist0)
            }
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.Configuration?].self, forKey: .applicationConfiguration)
        var applicationConfigurationDecoded0:[EmrContainersClientTypes.Configuration]? = nil
        if let applicationConfigurationContainer = applicationConfigurationContainer {
            applicationConfigurationDecoded0 = [EmrContainersClientTypes.Configuration]()
            for structure0 in applicationConfigurationContainer {
                if let structure0 = structure0 {
                    applicationConfigurationDecoded0?.append(structure0)
                }
            }
        }
        applicationConfiguration = applicationConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension EmrContainersClientTypes {
    /// A configuration specification to be used to override existing configurations.
    public struct ConfigurationOverrides: Swift.Equatable {
        /// The configurations for the application running by the job run.
        public var applicationConfiguration: [EmrContainersClientTypes.Configuration]?
        /// The configurations for monitoring.
        public var monitoringConfiguration: EmrContainersClientTypes.MonitoringConfiguration?

        public init (
            applicationConfiguration: [EmrContainersClientTypes.Configuration]? = nil,
            monitoringConfiguration: EmrContainersClientTypes.MonitoringConfiguration? = nil
        )
        {
            self.applicationConfiguration = applicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension EmrContainersClientTypes.ContainerInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksinfo = "eksInfo"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .eksinfo(eksinfo):
                try container.encode(eksinfo, forKey: .eksinfo)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let eksinfoDecoded = try values.decodeIfPresent(EmrContainersClientTypes.EksInfo.self, forKey: .eksinfo)
        if let eksinfo = eksinfoDecoded {
            self = .eksinfo(eksinfo)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EmrContainersClientTypes {
    /// The information about the container used for a job run or a managed endpoint.
    public enum ContainerInfo: Swift.Equatable {
        /// The information about the EKS cluster.
        case eksinfo(EmrContainersClientTypes.EksInfo)
        case sdkUnknown(Swift.String)
    }

}

extension EmrContainersClientTypes.ContainerProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case info
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let info = self.info {
            try encodeContainer.encode(info, forKey: .info)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerProviderType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let infoDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerInfo.self, forKey: .info)
        info = infoDecoded
    }
}

extension EmrContainersClientTypes {
    /// The information about the container provider.
    public struct ContainerProvider: Swift.Equatable {
        /// The ID of the container cluster.
        /// This member is required.
        public var id: Swift.String?
        /// The information about the container cluster.
        public var info: EmrContainersClientTypes.ContainerInfo?
        /// The type of the container provider. EKS is the only supported type as of now.
        /// This member is required.
        public var type: EmrContainersClientTypes.ContainerProviderType?

        public init (
            id: Swift.String? = nil,
            info: EmrContainersClientTypes.ContainerInfo? = nil,
            type: EmrContainersClientTypes.ContainerProviderType? = nil
        )
        {
            self.id = id
            self.info = info
            self.type = type
        }
    }

}

extension EmrContainersClientTypes {
    public enum ContainerProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eks
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerProviderType] {
            return [
                .eks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eks: return "EKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerProviderType(rawValue: rawValue) ?? ContainerProviderType.sdkUnknown(rawValue)
        }
    }
}

extension CreateManagedEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateManagedEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints"
    }
}

public struct CreateManagedEndpointInput: Swift.Equatable {
    /// The certificate ARN provided by users for the managed endpoint. This field is under deprecation and will be removed in future releases.
    @available(*, deprecated, message: "Customer provided certificate-arn is deprecated and would be removed in future.")
    public var certificateArn: Swift.String?
    /// The client idempotency token for this create call.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration settings that will be used to override existing configurations.
    public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    /// The ARN of the execution role.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The name of the managed endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon EMR release version.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The tags of the managed endpoint.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the managed endpoint.
    /// This member is required.
    public var type: Swift.String?
    /// The ID of the virtual cluster for which a managed endpoint is created.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.name = name
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.type = type
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: Swift.String?
    let releaseLabel: Swift.String?
    let executionRoleArn: Swift.String?
    let certificateArn: Swift.String?
    let configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateManagedEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateManagedEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateManagedEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateManagedEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateManagedEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CreateManagedEndpointOutputResponse: Swift.Equatable {
    /// The output contains the ARN of the managed endpoint.
    public var arn: Swift.String?
    /// The output contains the ID of the managed endpoint.
    public var id: Swift.String?
    /// The output contains the name of the managed endpoint.
    public var name: Swift.String?
    /// The output contains the ID of the virtual cluster.
    public var virtualClusterId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let virtualClusterId: Swift.String?
}

extension CreateManagedEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension CreateVirtualClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerProvider = self.containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateVirtualClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/virtualclusters"
    }
}

public struct CreateVirtualClusterInput: Swift.Equatable {
    /// The client token of the virtual cluster.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The container provider of the virtual cluster.
    /// This member is required.
    public var containerProvider: EmrContainersClientTypes.ContainerProvider?
    /// The specified name of the virtual cluster.
    /// This member is required.
    public var name: Swift.String?
    /// The tags assigned to the virtual cluster.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        containerProvider: EmrContainersClientTypes.ContainerProvider? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerProvider = containerProvider
        self.name = name
        self.tags = tags
    }
}

struct CreateVirtualClusterInputBody: Swift.Equatable {
    let name: Swift.String?
    let containerProvider: EmrContainersClientTypes.ContainerProvider?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVirtualClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVirtualClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualClusterOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateVirtualClusterOutputResponse: Swift.Equatable {
    /// This output contains the ARN of virtual cluster.
    public var arn: Swift.String?
    /// This output contains the virtual cluster ID.
    public var id: Swift.String?
    /// This output contains the name of the virtual cluster.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

struct CreateVirtualClusterOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateVirtualClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteManagedEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints/\(id.urlPercentEncoding())"
    }
}

public struct DeleteManagedEndpointInput: Swift.Equatable {
    /// The ID of the managed endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the endpoint's virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointInputBody: Swift.Equatable {
}

extension DeleteManagedEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteManagedEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteManagedEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteManagedEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteManagedEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct DeleteManagedEndpointOutputResponse: Swift.Equatable {
    /// The output displays the ID of the managed endpoint.
    public var id: Swift.String?
    /// The output displays the ID of the endpoint's virtual cluster.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let virtualClusterId: Swift.String?
}

extension DeleteManagedEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension DeleteVirtualClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(id.urlPercentEncoding())"
    }
}

public struct DeleteVirtualClusterInput: Swift.Equatable {
    /// The ID of the virtual cluster that will be deleted.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterInputBody: Swift.Equatable {
}

extension DeleteVirtualClusterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVirtualClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualClusterOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteVirtualClusterOutputResponse: Swift.Equatable {
    /// This output contains the ID of the virtual cluster that will be deleted.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteVirtualClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns/\(id.urlPercentEncoding())"
    }
}

public struct DescribeJobRunInput: Swift.Equatable {
    /// The ID of the job run request.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the virtual cluster for which the job run is submitted.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeJobRunInputBody: Swift.Equatable {
}

extension DescribeJobRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobRun = output.jobRun
        } else {
            self.jobRun = nil
        }
    }
}

public struct DescribeJobRunOutputResponse: Swift.Equatable {
    /// The output displays information about a job run.
    public var jobRun: EmrContainersClientTypes.JobRun?

    public init (
        jobRun: EmrContainersClientTypes.JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

struct DescribeJobRunOutputResponseBody: Swift.Equatable {
    let jobRun: EmrContainersClientTypes.JobRun?
}

extension DescribeJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRun
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobRun.self, forKey: .jobRun)
        jobRun = jobRunDecoded
    }
}

extension DescribeManagedEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints/\(id.urlPercentEncoding())"
    }
}

public struct DescribeManagedEndpointInput: Swift.Equatable {
    /// This output displays ID of the managed endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the endpoint's virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeManagedEndpointInputBody: Swift.Equatable {
}

extension DescribeManagedEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeManagedEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeManagedEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeManagedEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeManagedEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct DescribeManagedEndpointOutputResponse: Swift.Equatable {
    /// This output displays information about a managed endpoint.
    public var endpoint: EmrContainersClientTypes.Endpoint?

    public init (
        endpoint: EmrContainersClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DescribeManagedEndpointOutputResponseBody: Swift.Equatable {
    let endpoint: EmrContainersClientTypes.Endpoint?
}

extension DescribeManagedEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension DescribeVirtualClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(id.urlPercentEncoding())"
    }
}

public struct DescribeVirtualClusterInput: Swift.Equatable {
    /// The ID of the virtual cluster that will be described.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeVirtualClusterInputBody: Swift.Equatable {
}

extension DescribeVirtualClusterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualClusterOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualCluster = output.virtualCluster
        } else {
            self.virtualCluster = nil
        }
    }
}

public struct DescribeVirtualClusterOutputResponse: Swift.Equatable {
    /// This output displays information about the specified virtual cluster.
    public var virtualCluster: EmrContainersClientTypes.VirtualCluster?

    public init (
        virtualCluster: EmrContainersClientTypes.VirtualCluster? = nil
    )
    {
        self.virtualCluster = virtualCluster
    }
}

struct DescribeVirtualClusterOutputResponseBody: Swift.Equatable {
    let virtualCluster: EmrContainersClientTypes.VirtualCluster?
}

extension DescribeVirtualClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualCluster
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClusterDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.VirtualCluster.self, forKey: .virtualCluster)
        virtualCluster = virtualClusterDecoded
    }
}

extension EmrContainersClientTypes.EksInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension EmrContainersClientTypes {
    /// The information about the EKS cluster.
    public struct EksInfo: Swift.Equatable {
        /// The namespaces of the EKS cluster.
        public var namespace: Swift.String?

        public init (
            namespace: Swift.String? = nil
        )
        {
            self.namespace = namespace
        }
    }

}

extension EmrContainersClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case certificateArn
        case certificateAuthority
        case configurationOverrides
        case createdAt
        case executionRoleArn
        case failureReason
        case id
        case name
        case releaseLabel
        case securityGroup
        case serverUrl
        case state
        case stateDetails
        case subnetIds
        case tags
        case type
        case virtualClusterId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateAuthority = self.certificateAuthority {
            try encodeContainer.encode(certificateAuthority, forKey: .certificateAuthority)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let securityGroup = self.securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let serverUrl = self.serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let virtualClusterId = self.virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.EndpointState.self, forKey: .state)
        state = stateDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateAuthorityDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.Certificate.self, forKey: .certificateAuthority)
        certificateAuthority = certificateAuthorityDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EmrContainersClientTypes {
    /// This entity represents the endpoint that is managed by Amazon EMR on EKS.
    public struct Endpoint: Swift.Equatable {
        /// The ARN of the endpoint.
        public var arn: Swift.String?
        /// The certificate ARN of the endpoint. This field is under deprecation and will be removed in future.
        @available(*, deprecated, message: "Customer provided certificate-arn is deprecated and would be removed in future.")
        public var certificateArn: Swift.String?
        /// The certificate generated by emr control plane on customer behalf to secure the managed endpoint.
        public var certificateAuthority: EmrContainersClientTypes.Certificate?
        /// The configuration settings that are used to override existing configurations for endpoints.
        public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
        /// The date and time when the endpoint was created.
        public var createdAt: ClientRuntime.Date?
        /// The execution role ARN of the endpoint.
        public var executionRoleArn: Swift.String?
        /// The reasons why the endpoint has failed.
        public var failureReason: EmrContainersClientTypes.FailureReason?
        /// The ID of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The EMR release version to be used for the endpoint.
        public var releaseLabel: Swift.String?
        /// The security group configuration of the endpoint.
        public var securityGroup: Swift.String?
        /// The server URL of the endpoint.
        public var serverUrl: Swift.String?
        /// The state of the endpoint.
        public var state: EmrContainersClientTypes.EndpointState?
        /// Additional details of the endpoint state.
        public var stateDetails: Swift.String?
        /// The subnet IDs of the endpoint.
        public var subnetIds: [Swift.String]?
        /// The tags of the endpoint.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the endpoint.
        public var type: Swift.String?
        /// The ID of the endpoint's virtual cluster.
        public var virtualClusterId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateAuthority: EmrContainersClientTypes.Certificate? = nil,
            configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            executionRoleArn: Swift.String? = nil,
            failureReason: EmrContainersClientTypes.FailureReason? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            securityGroup: Swift.String? = nil,
            serverUrl: Swift.String? = nil,
            state: EmrContainersClientTypes.EndpointState? = nil,
            stateDetails: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil,
            virtualClusterId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.certificateArn = certificateArn
            self.certificateAuthority = certificateAuthority
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.id = id
            self.name = name
            self.releaseLabel = releaseLabel
            self.securityGroup = securityGroup
            self.serverUrl = serverUrl
            self.state = state
            self.stateDetails = stateDetails
            self.subnetIds = subnetIds
            self.tags = tags
            self.type = type
            self.virtualClusterId = virtualClusterId
        }
    }

}

extension EmrContainersClientTypes {
    public enum EndpointState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case terminated
        case terminatedWithErrors
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointState] {
            return [
                .active,
                .creating,
                .terminated,
                .terminatedWithErrors,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .terminated: return "TERMINATED"
            case .terminatedWithErrors: return "TERMINATED_WITH_ERRORS"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointState(rawValue: rawValue) ?? EndpointState.sdkUnknown(rawValue)
        }
    }
}

extension EmrContainersClientTypes {
    public enum FailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clusterUnavailable
        case internalError
        case userError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureReason] {
            return [
                .clusterUnavailable,
                .internalError,
                .userError,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clusterUnavailable: return "CLUSTER_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case .userError: return "USER_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureReason(rawValue: rawValue) ?? FailureReason.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This is an internal server exception.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrContainersClientTypes.JobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sparkSqlJobDriver
        case sparkSubmitJobDriver
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sparkSqlJobDriver = self.sparkSqlJobDriver {
            try encodeContainer.encode(sparkSqlJobDriver, forKey: .sparkSqlJobDriver)
        }
        if let sparkSubmitJobDriver = self.sparkSubmitJobDriver {
            try encodeContainer.encode(sparkSubmitJobDriver, forKey: .sparkSubmitJobDriver)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sparkSubmitJobDriverDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.SparkSubmitJobDriver.self, forKey: .sparkSubmitJobDriver)
        sparkSubmitJobDriver = sparkSubmitJobDriverDecoded
        let sparkSqlJobDriverDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.SparkSqlJobDriver.self, forKey: .sparkSqlJobDriver)
        sparkSqlJobDriver = sparkSqlJobDriverDecoded
    }
}

extension EmrContainersClientTypes {
    /// Specify the driver that the job runs on.
    public struct JobDriver: Swift.Equatable {
        /// The job driver for job type.
        public var sparkSqlJobDriver: EmrContainersClientTypes.SparkSqlJobDriver?
        /// The job driver parameters specified for spark submit.
        public var sparkSubmitJobDriver: EmrContainersClientTypes.SparkSubmitJobDriver?

        public init (
            sparkSqlJobDriver: EmrContainersClientTypes.SparkSqlJobDriver? = nil,
            sparkSubmitJobDriver: EmrContainersClientTypes.SparkSubmitJobDriver? = nil
        )
        {
            self.sparkSqlJobDriver = sparkSqlJobDriver
            self.sparkSubmitJobDriver = sparkSubmitJobDriver
        }
    }

}

extension EmrContainersClientTypes.JobRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientToken
        case configurationOverrides
        case createdAt
        case createdBy
        case executionRoleArn
        case failureReason
        case finishedAt
        case id
        case jobDriver
        case name
        case releaseLabel
        case state
        case stateDetails
        case tags
        case virtualClusterId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let finishedAt = self.finishedAt {
            try encodeContainer.encode(finishedAt.timeIntervalSince1970, forKey: .finishedAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let virtualClusterId = self.virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let finishedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .finishedAt)
        finishedAt = finishedAtDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EmrContainersClientTypes {
    /// This entity describes a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    public struct JobRun: Swift.Equatable {
        /// The ARN of job run.
        public var arn: Swift.String?
        /// The client token used to start a job run.
        public var clientToken: Swift.String?
        /// The configuration settings that are used to override default configuration.
        public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
        /// The date and time when the job run was created.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job run.
        public var createdBy: Swift.String?
        /// The execution role ARN of the job run.
        public var executionRoleArn: Swift.String?
        /// The reasons why the job run has failed.
        public var failureReason: EmrContainersClientTypes.FailureReason?
        /// The date and time when the job run has finished.
        public var finishedAt: ClientRuntime.Date?
        /// The ID of the job run.
        public var id: Swift.String?
        /// Parameters of job driver for the job run.
        public var jobDriver: EmrContainersClientTypes.JobDriver?
        /// The name of the job run.
        public var name: Swift.String?
        /// The release version of Amazon EMR.
        public var releaseLabel: Swift.String?
        /// The state of the job run.
        public var state: EmrContainersClientTypes.JobRunState?
        /// Additional details of the job run state.
        public var stateDetails: Swift.String?
        /// The assigned tags of the job run.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the job run's virtual cluster.
        public var virtualClusterId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            failureReason: EmrContainersClientTypes.FailureReason? = nil,
            finishedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            jobDriver: EmrContainersClientTypes.JobDriver? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            state: EmrContainersClientTypes.JobRunState? = nil,
            stateDetails: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            virtualClusterId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.clientToken = clientToken
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.finishedAt = finishedAt
            self.id = id
            self.jobDriver = jobDriver
            self.name = name
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.tags = tags
            self.virtualClusterId = virtualClusterId
        }
    }

}

extension EmrContainersClientTypes {
    public enum JobRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelPending
        case completed
        case failed
        case pending
        case running
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobRunState] {
            return [
                .cancelled,
                .cancelPending,
                .completed,
                .failed,
                .pending,
                .running,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelPending: return "CANCEL_PENDING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
        }
    }
}

extension ListJobRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let name = name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let createdBefore = createdBefore {
            let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdBeforeQueryItem)
        }
        if let createdAfter = createdAfter {
            let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdAfterQueryItem)
        }
        if let states = states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListJobRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns"
    }
}

public struct ListJobRunsInput: Swift.Equatable {
    /// The date and time after which the job runs were submitted.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the job runs were submitted.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of job runs that can be listed.
    public var maxResults: Swift.Int?
    /// The name of the job run.
    public var name: Swift.String?
    /// The token for the next set of job runs to return.
    public var nextToken: Swift.String?
    /// The states of the job run.
    public var states: [EmrContainersClientTypes.JobRunState]?
    /// The ID of the virtual cluster for which to list the job run.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        states: [EmrContainersClientTypes.JobRunState]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.states = states
        self.virtualClusterId = virtualClusterId
    }
}

struct ListJobRunsInputBody: Swift.Equatable {
}

extension ListJobRunsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobRunsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutputResponse: Swift.Equatable {
    /// This output lists information about the specified job runs.
    public var jobRuns: [EmrContainersClientTypes.JobRun]?
    /// This output displays the token for the next set of job runs.
    public var nextToken: Swift.String?

    public init (
        jobRuns: [EmrContainersClientTypes.JobRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputResponseBody: Swift.Equatable {
    let jobRuns: [EmrContainersClientTypes.JobRun]?
    let nextToken: Swift.String?
}

extension ListJobRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRuns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[EmrContainersClientTypes.JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [EmrContainersClientTypes.JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let types = types {
            types.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "types".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let createdBefore = createdBefore {
            let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdBeforeQueryItem)
        }
        if let createdAfter = createdAfter {
            let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdAfterQueryItem)
        }
        if let states = states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListManagedEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints"
    }
}

public struct ListManagedEndpointsInput: Swift.Equatable {
    /// The date and time after which the endpoints are created.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the endpoints are created.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of managed endpoints that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of managed endpoints to return.
    public var nextToken: Swift.String?
    /// The states of the managed endpoints.
    public var states: [EmrContainersClientTypes.EndpointState]?
    /// The types of the managed endpoints.
    public var types: [Swift.String]?
    /// The ID of the virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EmrContainersClientTypes.EndpointState]? = nil,
        types: [Swift.String]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.types = types
        self.virtualClusterId = virtualClusterId
    }
}

struct ListManagedEndpointsInputBody: Swift.Equatable {
}

extension ListManagedEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListManagedEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListManagedEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListManagedEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedEndpointsOutputResponse: Swift.Equatable {
    /// The managed endpoints to be listed.
    public var endpoints: [EmrContainersClientTypes.Endpoint]?
    /// The token for the next set of endpoints to return.
    public var nextToken: Swift.String?

    public init (
        endpoints: [EmrContainersClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListManagedEndpointsOutputResponseBody: Swift.Equatable {
    let endpoints: [EmrContainersClientTypes.Endpoint]?
    let nextToken: Swift.String?
}

extension ListManagedEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[EmrContainersClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [EmrContainersClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of tagged resources.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags assigned to resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVirtualClustersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let containerProviderId = containerProviderId {
            let containerProviderIdQueryItem = ClientRuntime.URLQueryItem(name: "containerProviderId".urlPercentEncoding(), value: Swift.String(containerProviderId).urlPercentEncoding())
            items.append(containerProviderIdQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let containerProviderType = containerProviderType {
            let containerProviderTypeQueryItem = ClientRuntime.URLQueryItem(name: "containerProviderType".urlPercentEncoding(), value: Swift.String(containerProviderType.rawValue).urlPercentEncoding())
            items.append(containerProviderTypeQueryItem)
        }
        if let createdBefore = createdBefore {
            let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdBeforeQueryItem)
        }
        if let createdAfter = createdAfter {
            let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdAfterQueryItem)
        }
        if let states = states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListVirtualClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/virtualclusters"
    }
}

public struct ListVirtualClustersInput: Swift.Equatable {
    /// The container provider ID of the virtual cluster.
    public var containerProviderId: Swift.String?
    /// The container provider type of the virtual cluster. EKS is the only supported type as of now.
    public var containerProviderType: EmrContainersClientTypes.ContainerProviderType?
    /// The date and time after which the virtual clusters are created.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the virtual clusters are created.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of virtual clusters that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of virtual clusters to return.
    public var nextToken: Swift.String?
    /// The states of the requested virtual clusters.
    public var states: [EmrContainersClientTypes.VirtualClusterState]?

    public init (
        containerProviderId: Swift.String? = nil,
        containerProviderType: EmrContainersClientTypes.ContainerProviderType? = nil,
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EmrContainersClientTypes.VirtualClusterState]? = nil
    )
    {
        self.containerProviderId = containerProviderId
        self.containerProviderType = containerProviderType
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListVirtualClustersInputBody: Swift.Equatable {
}

extension ListVirtualClustersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVirtualClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualClustersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVirtualClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualClusters = output.virtualClusters
        } else {
            self.nextToken = nil
            self.virtualClusters = nil
        }
    }
}

public struct ListVirtualClustersOutputResponse: Swift.Equatable {
    /// This output displays the token for the next set of virtual clusters.
    public var nextToken: Swift.String?
    /// This output lists the specified virtual clusters.
    public var virtualClusters: [EmrContainersClientTypes.VirtualCluster]?

    public init (
        nextToken: Swift.String? = nil,
        virtualClusters: [EmrContainersClientTypes.VirtualCluster]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualClusters = virtualClusters
    }
}

struct ListVirtualClustersOutputResponseBody: Swift.Equatable {
    let virtualClusters: [EmrContainersClientTypes.VirtualCluster]?
    let nextToken: Swift.String?
}

extension ListVirtualClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualClusters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClustersContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.VirtualCluster?].self, forKey: .virtualClusters)
        var virtualClustersDecoded0:[EmrContainersClientTypes.VirtualCluster]? = nil
        if let virtualClustersContainer = virtualClustersContainer {
            virtualClustersDecoded0 = [EmrContainersClientTypes.VirtualCluster]()
            for structure0 in virtualClustersContainer {
                if let structure0 = structure0 {
                    virtualClustersDecoded0?.append(structure0)
                }
            }
        }
        virtualClusters = virtualClustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EmrContainersClientTypes.MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMonitoringConfiguration
        case persistentAppUI
        case s3MonitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMonitoringConfiguration = self.cloudWatchMonitoringConfiguration {
            try encodeContainer.encode(cloudWatchMonitoringConfiguration, forKey: .cloudWatchMonitoringConfiguration)
        }
        if let persistentAppUI = self.persistentAppUI {
            try encodeContainer.encode(persistentAppUI.rawValue, forKey: .persistentAppUI)
        }
        if let s3MonitoringConfiguration = self.s3MonitoringConfiguration {
            try encodeContainer.encode(s3MonitoringConfiguration, forKey: .s3MonitoringConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let persistentAppUIDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.PersistentAppUI.self, forKey: .persistentAppUI)
        persistentAppUI = persistentAppUIDecoded
        let cloudWatchMonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.CloudWatchMonitoringConfiguration.self, forKey: .cloudWatchMonitoringConfiguration)
        cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfigurationDecoded
        let s3MonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.S3MonitoringConfiguration.self, forKey: .s3MonitoringConfiguration)
        s3MonitoringConfiguration = s3MonitoringConfigurationDecoded
    }
}

extension EmrContainersClientTypes {
    /// Configuration setting for monitoring.
    public struct MonitoringConfiguration: Swift.Equatable {
        /// Monitoring configurations for CloudWatch.
        public var cloudWatchMonitoringConfiguration: EmrContainersClientTypes.CloudWatchMonitoringConfiguration?
        /// Monitoring configurations for the persistent application UI.
        public var persistentAppUI: EmrContainersClientTypes.PersistentAppUI?
        /// Amazon S3 configuration for monitoring log publishing.
        public var s3MonitoringConfiguration: EmrContainersClientTypes.S3MonitoringConfiguration?

        public init (
            cloudWatchMonitoringConfiguration: EmrContainersClientTypes.CloudWatchMonitoringConfiguration? = nil,
            persistentAppUI: EmrContainersClientTypes.PersistentAppUI? = nil,
            s3MonitoringConfiguration: EmrContainersClientTypes.S3MonitoringConfiguration? = nil
        )
        {
            self.cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfiguration
            self.persistentAppUI = persistentAppUI
            self.s3MonitoringConfiguration = s3MonitoringConfiguration
        }
    }

}

extension EmrContainersClientTypes {
    public enum PersistentAppUI: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PersistentAppUI] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PersistentAppUI(rawValue: rawValue) ?? PersistentAppUI.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrContainersClientTypes.S3MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logUri = self.logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUri)
        logUri = logUriDecoded
    }
}

extension EmrContainersClientTypes {
    /// Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.
    public struct S3MonitoringConfiguration: Swift.Equatable {
        /// Amazon S3 destination URI for log publishing.
        /// This member is required.
        public var logUri: Swift.String?

        public init (
            logUri: Swift.String? = nil
        )
        {
            self.logUri = logUri
        }
    }

}

extension EmrContainersClientTypes.SparkSqlJobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryPoint
        case sparkSqlParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let sparkSqlParameters = self.sparkSqlParameters {
            try encodeContainer.encode(sparkSqlParameters, forKey: .sparkSqlParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let sparkSqlParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sparkSqlParameters)
        sparkSqlParameters = sparkSqlParametersDecoded
    }
}

extension EmrContainersClientTypes.SparkSqlJobDriver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SparkSqlJobDriver(entryPoint: \"CONTENT_REDACTED\", sparkSqlParameters: \"CONTENT_REDACTED\")"}
}

extension EmrContainersClientTypes {
    /// The job driver for job type.
    public struct SparkSqlJobDriver: Swift.Equatable {
        /// The SQL file to be executed.
        public var entryPoint: Swift.String?
        /// The Spark parameters to be included in the Spark SQL command.
        public var sparkSqlParameters: Swift.String?

        public init (
            entryPoint: Swift.String? = nil,
            sparkSqlParameters: Swift.String? = nil
        )
        {
            self.entryPoint = entryPoint
            self.sparkSqlParameters = sparkSqlParameters
        }
    }

}

extension EmrContainersClientTypes.SparkSubmitJobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryPoint
        case entryPointArguments
        case sparkSubmitParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let entryPointArguments = entryPointArguments {
            var entryPointArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPointArguments)
            for entrypointarguments0 in entryPointArguments {
                try entryPointArgumentsContainer.encode(entrypointarguments0)
            }
        }
        if let sparkSubmitParameters = self.sparkSubmitParameters {
            try encodeContainer.encode(sparkSubmitParameters, forKey: .sparkSubmitParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let entryPointArgumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPointArguments)
        var entryPointArgumentsDecoded0:[Swift.String]? = nil
        if let entryPointArgumentsContainer = entryPointArgumentsContainer {
            entryPointArgumentsDecoded0 = [Swift.String]()
            for string0 in entryPointArgumentsContainer {
                if let string0 = string0 {
                    entryPointArgumentsDecoded0?.append(string0)
                }
            }
        }
        entryPointArguments = entryPointArgumentsDecoded0
        let sparkSubmitParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sparkSubmitParameters)
        sparkSubmitParameters = sparkSubmitParametersDecoded
    }
}

extension EmrContainersClientTypes.SparkSubmitJobDriver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SparkSubmitJobDriver(entryPointArguments: \(Swift.String(describing: entryPointArguments)), entryPoint: \"CONTENT_REDACTED\", sparkSubmitParameters: \"CONTENT_REDACTED\")"}
}

extension EmrContainersClientTypes {
    /// The information about job driver for Spark submit.
    public struct SparkSubmitJobDriver: Swift.Equatable {
        /// The entry point of job application.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The arguments for job application.
        public var entryPointArguments: [Swift.String]?
        /// The Spark submit parameters that are used for job runs.
        public var sparkSubmitParameters: Swift.String?

        public init (
            entryPoint: Swift.String? = nil,
            entryPointArguments: [Swift.String]? = nil,
            sparkSubmitParameters: Swift.String? = nil
        )
        {
            self.entryPoint = entryPoint
            self.entryPointArguments = entryPointArguments
            self.sparkSubmitParameters = sparkSubmitParameters
        }
    }

}

extension StartJobRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case name
        case releaseLabel
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns"
    }
}

public struct StartJobRunInput: Swift.Equatable {
    /// The client idempotency token of the job run request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration overrides for the job run.
    public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    /// The execution role ARN for the job run.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The job driver for the job run.
    /// This member is required.
    public var jobDriver: EmrContainersClientTypes.JobDriver?
    /// The name of the job run.
    public var name: Swift.String?
    /// The Amazon EMR release version to use for the job run.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The tags assigned to job runs.
    public var tags: [Swift.String:Swift.String]?
    /// The virtual cluster ID for which the job run request is submitted.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        jobDriver: EmrContainersClientTypes.JobDriver? = nil,
        name: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.jobDriver = jobDriver
        self.name = name
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let executionRoleArn: Swift.String?
    let releaseLabel: Swift.String?
    let jobDriver: EmrContainersClientTypes.JobDriver?
    let configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    let tags: [Swift.String:Swift.String]?
}

extension StartJobRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case name
        case releaseLabel
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct StartJobRunOutputResponse: Swift.Equatable {
    /// This output lists the ARN of job run.
    public var arn: Swift.String?
    /// This output displays the started job run ID.
    public var id: Swift.String?
    /// This output displays the name of the started job run.
    public var name: Swift.String?
    /// This output displays the virtual cluster ID for which the job run was submitted.
    public var virtualClusterId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let virtualClusterId: Swift.String?
}

extension StartJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags assigned to resources.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are invalid parameters in the client request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrContainersClientTypes.VirtualCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerProvider
        case createdAt
        case id
        case name
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerProvider = self.containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.VirtualClusterState.self, forKey: .state)
        state = stateDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EmrContainersClientTypes {
    /// This entity describes a virtual cluster. A virtual cluster is a Kubernetes namespace that Amazon EMR is registered with. Amazon EMR uses virtual clusters to run jobs and host endpoints. Multiple virtual clusters can be backed by the same physical cluster. However, each virtual cluster maps to one namespace on an EKS cluster. Virtual clusters do not create any active resources that contribute to your bill or that require lifecycle management outside the service.
    public struct VirtualCluster: Swift.Equatable {
        /// The ARN of the virtual cluster.
        public var arn: Swift.String?
        /// The container provider of the virtual cluster.
        public var containerProvider: EmrContainersClientTypes.ContainerProvider?
        /// The date and time when the virtual cluster is created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the virtual cluster.
        public var id: Swift.String?
        /// The name of the virtual cluster.
        public var name: Swift.String?
        /// The state of the virtual cluster.
        public var state: EmrContainersClientTypes.VirtualClusterState?
        /// The assigned tags of the virtual cluster.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            containerProvider: EmrContainersClientTypes.ContainerProvider? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: EmrContainersClientTypes.VirtualClusterState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerProvider = containerProvider
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension EmrContainersClientTypes {
    public enum VirtualClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arrested
        case running
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualClusterState] {
            return [
                .arrested,
                .running,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arrested: return "ARRESTED"
            case .running: return "RUNNING"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualClusterState(rawValue: rawValue) ?? VirtualClusterState.sdkUnknown(rawValue)
        }
    }
}
