// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountSuspendedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountSuspendedException(message: \(Swift.String(describing: message)))"}
}

extension AccountSuspendedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccountSuspendedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The message can't be sent because the account's ability to send email has been
///             permanently restricted.
public struct AccountSuspendedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountSuspendedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccountSuspendedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in your request already exists.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input you provided is invalid.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointEmailClientTypes {
    /// The action that you want Amazon Pinpoint to take if it can't read the required MX record for a
    ///             custom MAIL FROM domain. When you set this value to UseDefaultValue, Amazon Pinpoint
    ///             uses amazonses.com as the MAIL FROM domain. When you set this value
    ///             to RejectMessage, Amazon Pinpoint returns a MailFromDomainNotVerified
    ///             error, and doesn't attempt to deliver the email.
    ///         These behaviors are taken when the custom MAIL FROM domain configuration is in the
    ///                 Pending, Failed, and TemporaryFailure
    ///             states.
    public enum BehaviorOnMxFailure: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rejectMessage
        case useDefaultValue
        case sdkUnknown(Swift.String)

        public static var allCases: [BehaviorOnMxFailure] {
            return [
                .rejectMessage,
                .useDefaultValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rejectMessage: return "REJECT_MESSAGE"
            case .useDefaultValue: return "USE_DEFAULT_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BehaviorOnMxFailure(rawValue: rawValue) ?? BehaviorOnMxFailure.sdkUnknown(rawValue)
        }
    }
}

extension PinpointEmailClientTypes.BlacklistEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case listingTime = "ListingTime"
        case rblName = "RblName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let listingTime = listingTime {
            try encodeContainer.encode(listingTime.timeIntervalSince1970, forKey: .listingTime)
        }
        if let rblName = rblName {
            try encodeContainer.encode(rblName, forKey: .rblName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rblNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rblName)
        rblName = rblNameDecoded
        let listingTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .listingTime)
        listingTime = listingTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PinpointEmailClientTypes.BlacklistEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BlacklistEntry(description: \(Swift.String(describing: description)), listingTime: \(Swift.String(describing: listingTime)), rblName: \(Swift.String(describing: rblName)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about a blacklisting event that impacts one of the
    ///             dedicated IP addresses that is associated with your account.
    public struct BlacklistEntry: Swift.Equatable {
        /// Additional information about the blacklisting event, as provided by the blacklist
        ///             maintainer.
        public let description: Swift.String?
        /// The time when the blacklisting event occurred, shown in Unix time format.
        public let listingTime: ClientRuntime.Date?
        /// The name of the blacklist that the IP address appears on.
        public let rblName: Swift.String?

        public init (
            description: Swift.String? = nil,
            listingTime: ClientRuntime.Date? = nil,
            rblName: Swift.String? = nil
        )
        {
            self.description = description
            self.listingTime = listingTime
            self.rblName = rblName
        }
    }

}

extension PinpointEmailClientTypes.Body: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case html = "Html"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let html = html {
            try encodeContainer.encode(html, forKey: .html)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.Content.self, forKey: .text)
        text = textDecoded
        let htmlDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.Content.self, forKey: .html)
        html = htmlDecoded
    }
}

extension PinpointEmailClientTypes.Body: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Body(html: \(Swift.String(describing: html)), text: \(Swift.String(describing: text)))"}
}

extension PinpointEmailClientTypes {
    /// Represents the body of the email message.
    public struct Body: Swift.Equatable {
        /// An object that represents the version of the message that is displayed in email
        ///             clients that support HTML. HTML messages can include formatted text, hyperlinks, images,
        ///             and more.
        public let html: PinpointEmailClientTypes.Content?
        /// An object that represents the version of the message that is displayed in email
        ///             clients that don't support HTML, or clients where the recipient has disabled HTML
        ///             rendering.
        public let text: PinpointEmailClientTypes.Content?

        public init (
            html: PinpointEmailClientTypes.Content? = nil,
            text: PinpointEmailClientTypes.Content? = nil
        )
        {
            self.html = html
            self.text = text
        }
    }

}

extension PinpointEmailClientTypes.CloudWatchDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionConfigurations = "DimensionConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionConfigurations = dimensionConfigurations {
            var dimensionConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionConfigurations)
            for cloudwatchdimensionconfigurations0 in dimensionConfigurations {
                try dimensionConfigurationsContainer.encode(cloudwatchdimensionconfigurations0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionConfigurationsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.CloudWatchDimensionConfiguration?].self, forKey: .dimensionConfigurations)
        var dimensionConfigurationsDecoded0:[PinpointEmailClientTypes.CloudWatchDimensionConfiguration]? = nil
        if let dimensionConfigurationsContainer = dimensionConfigurationsContainer {
            dimensionConfigurationsDecoded0 = [PinpointEmailClientTypes.CloudWatchDimensionConfiguration]()
            for structure0 in dimensionConfigurationsContainer {
                if let structure0 = structure0 {
                    dimensionConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        dimensionConfigurations = dimensionConfigurationsDecoded0
    }
}

extension PinpointEmailClientTypes.CloudWatchDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchDestination(dimensionConfigurations: \(Swift.String(describing: dimensionConfigurations)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
    ///             monitor and gain insights on your email sending metrics.
    public struct CloudWatchDestination: Swift.Equatable {
        /// An array of objects that define the dimensions to use when you send email events to
        ///             Amazon CloudWatch.
        /// This member is required.
        public let dimensionConfigurations: [PinpointEmailClientTypes.CloudWatchDimensionConfiguration]?

        public init (
            dimensionConfigurations: [PinpointEmailClientTypes.CloudWatchDimensionConfiguration]? = nil
        )
        {
            self.dimensionConfigurations = dimensionConfigurations
        }
    }

}

extension PinpointEmailClientTypes.CloudWatchDimensionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultDimensionValue = "DefaultDimensionValue"
        case dimensionName = "DimensionName"
        case dimensionValueSource = "DimensionValueSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultDimensionValue = defaultDimensionValue {
            try encodeContainer.encode(defaultDimensionValue, forKey: .defaultDimensionValue)
        }
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValueSource = dimensionValueSource {
            try encodeContainer.encode(dimensionValueSource.rawValue, forKey: .dimensionValueSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueSourceDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DimensionValueSource.self, forKey: .dimensionValueSource)
        dimensionValueSource = dimensionValueSourceDecoded
        let defaultDimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultDimensionValue)
        defaultDimensionValue = defaultDimensionValueDecoded
    }
}

extension PinpointEmailClientTypes.CloudWatchDimensionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchDimensionConfiguration(defaultDimensionValue: \(Swift.String(describing: defaultDimensionValue)), dimensionName: \(Swift.String(describing: dimensionName)), dimensionValueSource: \(Swift.String(describing: dimensionValueSource)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines the dimension configuration to use when you send Amazon Pinpoint email
    ///             events to Amazon CloudWatch.
    public struct CloudWatchDimensionConfiguration: Swift.Equatable {
        /// The default value of the dimension that is published to Amazon CloudWatch if you don't provide the
        ///             value of the dimension when you send an email. This value has to meet the following
        ///             criteria:
        ///
        ///
        ///                 It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
        ///                     or dashes (-).
        ///
        ///
        ///                 It can contain no more than 256 characters.
        ///
        ///
        /// This member is required.
        public let defaultDimensionValue: Swift.String?
        /// The name of an Amazon CloudWatch dimension associated with an email sending metric. The name has to
        ///             meet the following criteria:
        ///
        ///
        ///                 It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
        ///                     or dashes (-).
        ///
        ///
        ///                 It can contain no more than 256 characters.
        ///
        ///
        /// This member is required.
        public let dimensionName: Swift.String?
        /// The location where Amazon Pinpoint finds the value of a dimension to publish to Amazon CloudWatch. If you
        ///             want Amazon Pinpoint to use the message tags that you specify using an X-SES-MESSAGE-TAGS header
        ///             or a parameter to the SendEmail/SendRawEmail API, choose messageTag. If you
        ///             want Amazon Pinpoint to use your own email headers, choose emailHeader. If you want
        ///             Amazon Pinpoint to use link tags, choose linkTags.
        /// This member is required.
        public let dimensionValueSource: PinpointEmailClientTypes.DimensionValueSource?

        public init (
            defaultDimensionValue: Swift.String? = nil,
            dimensionName: Swift.String? = nil,
            dimensionValueSource: PinpointEmailClientTypes.DimensionValueSource? = nil
        )
        {
            self.defaultDimensionValue = defaultDimensionValue
            self.dimensionName = dimensionName
            self.dimensionValueSource = dimensionValueSource
        }
    }

}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is being modified by another operation or thread.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointEmailClientTypes.Content: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case charset = "Charset"
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension PinpointEmailClientTypes.Content: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Content(charset: \(Swift.String(describing: charset)), data: \(Swift.String(describing: data)))"}
}

extension PinpointEmailClientTypes {
    /// An object that represents the content of the email, and optionally a character set
    ///             specification.
    public struct Content: Swift.Equatable {
        /// The character set for the content. Because of the constraints of the SMTP protocol,
        ///             Amazon Pinpoint uses 7-bit ASCII by default. If the text includes characters outside of the ASCII
        ///             range, you have to specify a character set. For example, you could specify
        ///                 UTF-8, ISO-8859-1, or Shift_JIS.
        public let charset: Swift.String?
        /// The content of the message itself.
        /// This member is required.
        public let data: Swift.String?

        public init (
            charset: Swift.String? = nil,
            data: Swift.String? = nil
        )
        {
            self.charset = charset
            self.data = data
        }
    }

}

public struct CreateConfigurationSetEventDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationSetEventDestinationOutputError>
}

extension CreateConfigurationSetEventDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationSetEventDestinationInput(configurationSetName: \(Swift.String(describing: configurationSetName)), eventDestination: \(Swift.String(describing: eventDestination)), eventDestinationName: \(Swift.String(describing: eventDestinationName)))"}
}

extension CreateConfigurationSetEventDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
        if let eventDestinationName = eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

public struct CreateConfigurationSetEventDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationSetEventDestinationOutputError>
}

public struct CreateConfigurationSetEventDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationSetEventDestinationOutputError>
}

/// A request to add an event destination to a configuration set.
public struct CreateConfigurationSetEventDestinationInput: Swift.Equatable {
    /// The name of the configuration set that you want to add an event destination to.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// An object that defines the event destination.
    /// This member is required.
    public let eventDestination: PinpointEmailClientTypes.EventDestinationDefinition?
    /// A name that identifies the event destination within the configuration set.
    /// This member is required.
    public let eventDestinationName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointEmailClientTypes.EventDestinationDefinition? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct CreateConfigurationSetEventDestinationInputBody: Swift.Equatable {
    public let eventDestinationName: Swift.String?
    public let eventDestination: PinpointEmailClientTypes.EventDestinationDefinition?
}

extension CreateConfigurationSetEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension CreateConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetEventDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetEventDestinationOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetEventDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationSetEventDestinationOutputResponse()"}
}

extension CreateConfigurationSetEventDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct CreateConfigurationSetEventDestinationOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateConfigurationSetEventDestinationOutputResponseBody: Swift.Equatable {
}

extension CreateConfigurationSetEventDestinationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateConfigurationSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationSetOutputError>
}

extension CreateConfigurationSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationSetInput(configurationSetName: \(Swift.String(describing: configurationSetName)), deliveryOptions: \(Swift.String(describing: deliveryOptions)), reputationOptions: \(Swift.String(describing: reputationOptions)), sendingOptions: \(Swift.String(describing: sendingOptions)), tags: \(Swift.String(describing: tags)), trackingOptions: \(Swift.String(describing: trackingOptions)))"}
}

extension CreateConfigurationSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let deliveryOptions = deliveryOptions {
            try encodeContainer.encode(deliveryOptions, forKey: .deliveryOptions)
        }
        if let reputationOptions = reputationOptions {
            try encodeContainer.encode(reputationOptions, forKey: .reputationOptions)
        }
        if let sendingOptions = sendingOptions {
            try encodeContainer.encode(sendingOptions, forKey: .sendingOptions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trackingOptions = trackingOptions {
            try encodeContainer.encode(trackingOptions, forKey: .trackingOptions)
        }
    }
}

public struct CreateConfigurationSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationSetOutputError>
}

public struct CreateConfigurationSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationSetOutputError>
}

/// A request to create a configuration set.
public struct CreateConfigurationSetInput: Swift.Equatable {
    /// The name of the configuration set.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// An object that defines the dedicated IP pool that is used to send emails that you send
    ///             using the configuration set.
    public let deliveryOptions: PinpointEmailClientTypes.DeliveryOptions?
    /// An object that defines whether or not Amazon Pinpoint collects reputation metrics for the emails
    ///             that you send that use the configuration set.
    public let reputationOptions: PinpointEmailClientTypes.ReputationOptions?
    /// An object that defines whether or not Amazon Pinpoint can send email that you send using the
    ///             configuration set.
    public let sendingOptions: PinpointEmailClientTypes.SendingOptions?
    /// An array of objects that define the tags (keys and values) that you want to associate
    ///             with the configuration set.
    public let tags: [PinpointEmailClientTypes.Tag]?
    /// An object that defines the open and click tracking options for emails that you send
    ///             using the configuration set.
    public let trackingOptions: PinpointEmailClientTypes.TrackingOptions?

    public init (
        configurationSetName: Swift.String? = nil,
        deliveryOptions: PinpointEmailClientTypes.DeliveryOptions? = nil,
        reputationOptions: PinpointEmailClientTypes.ReputationOptions? = nil,
        sendingOptions: PinpointEmailClientTypes.SendingOptions? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil,
        trackingOptions: PinpointEmailClientTypes.TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.deliveryOptions = deliveryOptions
        self.reputationOptions = reputationOptions
        self.sendingOptions = sendingOptions
        self.tags = tags
        self.trackingOptions = trackingOptions
    }
}

struct CreateConfigurationSetInputBody: Swift.Equatable {
    public let configurationSetName: Swift.String?
    public let trackingOptions: PinpointEmailClientTypes.TrackingOptions?
    public let deliveryOptions: PinpointEmailClientTypes.DeliveryOptions?
    public let reputationOptions: PinpointEmailClientTypes.ReputationOptions?
    public let sendingOptions: PinpointEmailClientTypes.SendingOptions?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension CreateConfigurationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let trackingOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.TrackingOptions.self, forKey: .trackingOptions)
        trackingOptions = trackingOptionsDecoded
        let deliveryOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DeliveryOptions.self, forKey: .deliveryOptions)
        deliveryOptions = deliveryOptionsDecoded
        let reputationOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.ReputationOptions.self, forKey: .reputationOptions)
        reputationOptions = reputationOptionsDecoded
        let sendingOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.SendingOptions.self, forKey: .sendingOptions)
        sendingOptions = sendingOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationSetOutputResponse()"}
}

extension CreateConfigurationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct CreateConfigurationSetOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateConfigurationSetOutputResponseBody: Swift.Equatable {
}

extension CreateConfigurationSetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateDedicatedIpPoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDedicatedIpPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDedicatedIpPoolOutputError>
}

extension CreateDedicatedIpPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDedicatedIpPoolInput(poolName: \(Swift.String(describing: poolName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDedicatedIpPoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolName = "PoolName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDedicatedIpPoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDedicatedIpPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDedicatedIpPoolOutputError>
}

public struct CreateDedicatedIpPoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDedicatedIpPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDedicatedIpPoolOutputError>
}

/// A request to create a new dedicated IP pool.
public struct CreateDedicatedIpPoolInput: Swift.Equatable {
    /// The name of the dedicated IP pool.
    /// This member is required.
    public let poolName: Swift.String?
    /// An object that defines the tags (keys and values) that you want to associate with the
    ///             pool.
    public let tags: [PinpointEmailClientTypes.Tag]?

    public init (
        poolName: Swift.String? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil
    )
    {
        self.poolName = poolName
        self.tags = tags
    }
}

struct CreateDedicatedIpPoolInputBody: Swift.Equatable {
    public let poolName: Swift.String?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension CreateDedicatedIpPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolName = "PoolName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDedicatedIpPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDedicatedIpPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDedicatedIpPoolOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDedicatedIpPoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDedicatedIpPoolOutputResponse()"}
}

extension CreateDedicatedIpPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct CreateDedicatedIpPoolOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateDedicatedIpPoolOutputResponseBody: Swift.Equatable {
}

extension CreateDedicatedIpPoolOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateDeliverabilityTestReportInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeliverabilityTestReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeliverabilityTestReportOutputError>
}

extension CreateDeliverabilityTestReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeliverabilityTestReportInput(content: \(Swift.String(describing: content)), fromEmailAddress: \(Swift.String(describing: fromEmailAddress)), reportName: \(Swift.String(describing: reportName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDeliverabilityTestReportInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case fromEmailAddress = "FromEmailAddress"
        case reportName = "ReportName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDeliverabilityTestReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeliverabilityTestReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeliverabilityTestReportOutputError>
}

public struct CreateDeliverabilityTestReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeliverabilityTestReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeliverabilityTestReportOutputError>
}

/// A request to perform a predictive inbox placement test. Predictive inbox placement tests can help you predict how your messages will
///             be handled by various email providers around the world. When you perform a predictive inbox placement test, you
///             provide a sample message that contains the content that you plan to send to your
///             customers. Amazon Pinpoint then sends that message to special email addresses spread across
///             several major email providers. After about 24 hours, the test is complete, and you can
///             use the GetDeliverabilityTestReport operation to view the results of the
///             test.
public struct CreateDeliverabilityTestReportInput: Swift.Equatable {
    /// The HTML body of the message that you sent when you performed the predictive inbox placement test.
    /// This member is required.
    public let content: PinpointEmailClientTypes.EmailContent?
    /// The email address that the predictive inbox placement test email was sent from.
    /// This member is required.
    public let fromEmailAddress: Swift.String?
    /// A unique name that helps you to identify the predictive inbox placement test when you retrieve the
    ///             results.
    public let reportName: Swift.String?
    /// An array of objects that define the tags (keys and values) that you want to associate
    ///             with the predictive inbox placement test.
    public let tags: [PinpointEmailClientTypes.Tag]?

    public init (
        content: PinpointEmailClientTypes.EmailContent? = nil,
        fromEmailAddress: Swift.String? = nil,
        reportName: Swift.String? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil
    )
    {
        self.content = content
        self.fromEmailAddress = fromEmailAddress
        self.reportName = reportName
        self.tags = tags
    }
}

struct CreateDeliverabilityTestReportInputBody: Swift.Equatable {
    public let reportName: Swift.String?
    public let fromEmailAddress: Swift.String?
    public let content: PinpointEmailClientTypes.EmailContent?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension CreateDeliverabilityTestReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case fromEmailAddress = "FromEmailAddress"
        case reportName = "ReportName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let contentDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.EmailContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeliverabilityTestReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeliverabilityTestReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountSuspendedException" : self = .accountSuspendedException(try AccountSuspendedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeliverabilityTestReportOutputError: Swift.Error, Swift.Equatable {
    case accountSuspendedException(AccountSuspendedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeliverabilityTestReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeliverabilityTestReportOutputResponse(deliverabilityTestStatus: \(Swift.String(describing: deliverabilityTestStatus)), reportId: \(Swift.String(describing: reportId)))"}
}

extension CreateDeliverabilityTestReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeliverabilityTestReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deliverabilityTestStatus = output.deliverabilityTestStatus
            self.reportId = output.reportId
        } else {
            self.deliverabilityTestStatus = nil
            self.reportId = nil
        }
    }
}

/// Information about the predictive inbox placement test that you created.
public struct CreateDeliverabilityTestReportOutputResponse: Swift.Equatable {
    /// The status of the predictive inbox placement test. If the status is IN_PROGRESS, then the predictive inbox placement test
    ///             is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
    ///             test. If the status is COMPLETE, then the test is finished, and you can use
    ///             the GetDeliverabilityTestReport to view the results of the test.
    /// This member is required.
    public let deliverabilityTestStatus: PinpointEmailClientTypes.DeliverabilityTestStatus?
    /// A unique string that identifies the predictive inbox placement test.
    /// This member is required.
    public let reportId: Swift.String?

    public init (
        deliverabilityTestStatus: PinpointEmailClientTypes.DeliverabilityTestStatus? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.deliverabilityTestStatus = deliverabilityTestStatus
        self.reportId = reportId
    }
}

struct CreateDeliverabilityTestReportOutputResponseBody: Swift.Equatable {
    public let reportId: Swift.String?
    public let deliverabilityTestStatus: PinpointEmailClientTypes.DeliverabilityTestStatus?
}

extension CreateDeliverabilityTestReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliverabilityTestStatus = "DeliverabilityTestStatus"
        case reportId = "ReportId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let deliverabilityTestStatusDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DeliverabilityTestStatus.self, forKey: .deliverabilityTestStatus)
        deliverabilityTestStatus = deliverabilityTestStatusDecoded
    }
}

public struct CreateEmailIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEmailIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEmailIdentityOutputError>
}

extension CreateEmailIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEmailIdentityInput(emailIdentity: \(Swift.String(describing: emailIdentity)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEmailIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailIdentity = "EmailIdentity"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailIdentity = emailIdentity {
            try encodeContainer.encode(emailIdentity, forKey: .emailIdentity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEmailIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEmailIdentityOutputError>
}

public struct CreateEmailIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEmailIdentityOutputError>
}

/// A request to begin the verification process for an email identity (an email address or
///             domain).
public struct CreateEmailIdentityInput: Swift.Equatable {
    /// The email address or domain that you want to verify.
    /// This member is required.
    public let emailIdentity: Swift.String?
    /// An array of objects that define the tags (keys and values) that you want to associate
    ///             with the email identity.
    public let tags: [PinpointEmailClientTypes.Tag]?

    public init (
        emailIdentity: Swift.String? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil
    )
    {
        self.emailIdentity = emailIdentity
        self.tags = tags
    }
}

struct CreateEmailIdentityInputBody: Swift.Equatable {
    public let emailIdentity: Swift.String?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension CreateEmailIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailIdentity = "EmailIdentity"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailIdentity)
        emailIdentity = emailIdentityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEmailIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEmailIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEmailIdentityOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEmailIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEmailIdentityOutputResponse(dkimAttributes: \(Swift.String(describing: dkimAttributes)), identityType: \(Swift.String(describing: identityType)), verifiedForSendingStatus: \(Swift.String(describing: verifiedForSendingStatus)))"}
}

extension CreateEmailIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEmailIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dkimAttributes = output.dkimAttributes
            self.identityType = output.identityType
            self.verifiedForSendingStatus = output.verifiedForSendingStatus
        } else {
            self.dkimAttributes = nil
            self.identityType = nil
            self.verifiedForSendingStatus = false
        }
    }
}

/// If the email identity is a domain, this object contains tokens that you can use to
///             create a set of CNAME records. To sucessfully verify your domain, you have to add these
///             records to the DNS configuration for your domain.
///         If the email identity is an email address, this object is empty.
public struct CreateEmailIdentityOutputResponse: Swift.Equatable {
    /// An object that contains information about the DKIM attributes for the identity. This
    ///             object includes the tokens that you use to create the CNAME records that are required to
    ///             complete the DKIM verification process.
    public let dkimAttributes: PinpointEmailClientTypes.DkimAttributes?
    /// The email identity type.
    public let identityType: PinpointEmailClientTypes.IdentityType?
    /// Specifies whether or not the identity is verified. In Amazon Pinpoint, you can only send email
    ///             from verified email addresses or domains. For more information about verifying
    ///             identities, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide.
    public let verifiedForSendingStatus: Swift.Bool

    public init (
        dkimAttributes: PinpointEmailClientTypes.DkimAttributes? = nil,
        identityType: PinpointEmailClientTypes.IdentityType? = nil,
        verifiedForSendingStatus: Swift.Bool = false
    )
    {
        self.dkimAttributes = dkimAttributes
        self.identityType = identityType
        self.verifiedForSendingStatus = verifiedForSendingStatus
    }
}

struct CreateEmailIdentityOutputResponseBody: Swift.Equatable {
    public let identityType: PinpointEmailClientTypes.IdentityType?
    public let verifiedForSendingStatus: Swift.Bool
    public let dkimAttributes: PinpointEmailClientTypes.DkimAttributes?
}

extension CreateEmailIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dkimAttributes = "DkimAttributes"
        case identityType = "IdentityType"
        case verifiedForSendingStatus = "VerifiedForSendingStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let verifiedForSendingStatusDecoded = try containerValues.decode(Swift.Bool.self, forKey: .verifiedForSendingStatus)
        verifiedForSendingStatus = verifiedForSendingStatusDecoded
        let dkimAttributesDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DkimAttributes.self, forKey: .dkimAttributes)
        dkimAttributes = dkimAttributesDecoded
    }
}

extension PinpointEmailClientTypes.DailyVolume: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainIspPlacements = "DomainIspPlacements"
        case startDate = "StartDate"
        case volumeStatistics = "VolumeStatistics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainIspPlacements = domainIspPlacements {
            var domainIspPlacementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainIspPlacements)
            for domainispplacements0 in domainIspPlacements {
                try domainIspPlacementsContainer.encode(domainispplacements0)
            }
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let volumeStatistics = volumeStatistics {
            try encodeContainer.encode(volumeStatistics, forKey: .volumeStatistics)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let volumeStatisticsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.VolumeStatistics.self, forKey: .volumeStatistics)
        volumeStatistics = volumeStatisticsDecoded
        let domainIspPlacementsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DomainIspPlacement?].self, forKey: .domainIspPlacements)
        var domainIspPlacementsDecoded0:[PinpointEmailClientTypes.DomainIspPlacement]? = nil
        if let domainIspPlacementsContainer = domainIspPlacementsContainer {
            domainIspPlacementsDecoded0 = [PinpointEmailClientTypes.DomainIspPlacement]()
            for structure0 in domainIspPlacementsContainer {
                if let structure0 = structure0 {
                    domainIspPlacementsDecoded0?.append(structure0)
                }
            }
        }
        domainIspPlacements = domainIspPlacementsDecoded0
    }
}

extension PinpointEmailClientTypes.DailyVolume: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DailyVolume(domainIspPlacements: \(Swift.String(describing: domainIspPlacements)), startDate: \(Swift.String(describing: startDate)), volumeStatistics: \(Swift.String(describing: volumeStatistics)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about the volume of email sent on each day of the
    ///             analysis period.
    public struct DailyVolume: Swift.Equatable {
        /// An object that contains inbox placement metrics for a specified day in the analysis
        ///             period, broken out by the recipient's email provider.
        public let domainIspPlacements: [PinpointEmailClientTypes.DomainIspPlacement]?
        /// The date that the DailyVolume metrics apply to, in Unix time.
        public let startDate: ClientRuntime.Date?
        /// An object that contains inbox placement metrics for a specific day in the analysis
        ///             period.
        public let volumeStatistics: PinpointEmailClientTypes.VolumeStatistics?

        public init (
            domainIspPlacements: [PinpointEmailClientTypes.DomainIspPlacement]? = nil,
            startDate: ClientRuntime.Date? = nil,
            volumeStatistics: PinpointEmailClientTypes.VolumeStatistics? = nil
        )
        {
            self.domainIspPlacements = domainIspPlacements
            self.startDate = startDate
            self.volumeStatistics = volumeStatistics
        }
    }

}

extension PinpointEmailClientTypes.DedicatedIp: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ip = "Ip"
        case poolName = "PoolName"
        case warmupPercentage = "WarmupPercentage"
        case warmupStatus = "WarmupStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let warmupPercentage = warmupPercentage {
            try encodeContainer.encode(warmupPercentage, forKey: .warmupPercentage)
        }
        if let warmupStatus = warmupStatus {
            try encodeContainer.encode(warmupStatus.rawValue, forKey: .warmupStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let warmupStatusDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.WarmupStatus.self, forKey: .warmupStatus)
        warmupStatus = warmupStatusDecoded
        let warmupPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .warmupPercentage)
        warmupPercentage = warmupPercentageDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
    }
}

extension PinpointEmailClientTypes.DedicatedIp: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DedicatedIp(ip: \(Swift.String(describing: ip)), poolName: \(Swift.String(describing: poolName)), warmupPercentage: \(Swift.String(describing: warmupPercentage)), warmupStatus: \(Swift.String(describing: warmupStatus)))"}
}

extension PinpointEmailClientTypes {
    /// Contains information about a dedicated IP address that is associated with your Amazon Pinpoint
    ///             account.
    ///
    public struct DedicatedIp: Swift.Equatable {
        /// An IP address that is reserved for use by your Amazon Pinpoint account.
        /// This member is required.
        public let ip: Swift.String?
        /// The name of the dedicated IP pool that the IP address is associated with.
        public let poolName: Swift.String?
        /// Indicates how complete the dedicated IP warm-up process is. When this value equals 1,
        ///             the address has completed the warm-up process and is ready for use.
        /// This member is required.
        public let warmupPercentage: Swift.Int?
        /// The warm-up status of a dedicated IP address. The status can have one of the following
        ///             values:
        ///
        ///
        ///
        ///                   IN_PROGRESS  The IP address isn't ready to use because the
        ///                     dedicated IP warm-up process is ongoing.
        ///
        ///
        ///
        ///                   DONE  The dedicated IP warm-up process is complete, and
        ///                     the IP address is ready to use.
        ///
        ///
        /// This member is required.
        public let warmupStatus: PinpointEmailClientTypes.WarmupStatus?

        public init (
            ip: Swift.String? = nil,
            poolName: Swift.String? = nil,
            warmupPercentage: Swift.Int? = nil,
            warmupStatus: PinpointEmailClientTypes.WarmupStatus? = nil
        )
        {
            self.ip = ip
            self.poolName = poolName
            self.warmupPercentage = warmupPercentage
            self.warmupStatus = warmupStatus
        }
    }

}

extension DeleteConfigurationSetEventDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationSetEventDestinationInput(configurationSetName: \(Swift.String(describing: configurationSetName)), eventDestinationName: \(Swift.String(describing: eventDestinationName)))"}
}

extension DeleteConfigurationSetEventDestinationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConfigurationSetEventDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

public struct DeleteConfigurationSetEventDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

/// A request to delete an event destination from a configuration set.
public struct DeleteConfigurationSetEventDestinationInput: Swift.Equatable {
    /// The name of the configuration set that contains the event destination that you want to
    ///             delete.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// The name of the event destination that you want to delete.
    /// This member is required.
    public let eventDestinationName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteConfigurationSetEventDestinationInputBody: Swift.Equatable {
}

extension DeleteConfigurationSetEventDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetEventDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetEventDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetEventDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationSetEventDestinationOutputResponse()"}
}

extension DeleteConfigurationSetEventDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct DeleteConfigurationSetEventDestinationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteConfigurationSetEventDestinationOutputResponseBody: Swift.Equatable {
}

extension DeleteConfigurationSetEventDestinationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationSetInput(configurationSetName: \(Swift.String(describing: configurationSetName)))"}
}

extension DeleteConfigurationSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConfigurationSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationSetOutputError>
}

public struct DeleteConfigurationSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationSetOutputError>
}

/// A request to delete a configuration set.
public struct DeleteConfigurationSetInput: Swift.Equatable {
    /// The name of the configuration set that you want to delete.
    /// This member is required.
    public let configurationSetName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Swift.Equatable {
}

extension DeleteConfigurationSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationSetOutputResponse()"}
}

extension DeleteConfigurationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct DeleteConfigurationSetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteConfigurationSetOutputResponseBody: Swift.Equatable {
}

extension DeleteConfigurationSetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDedicatedIpPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDedicatedIpPoolInput(poolName: \(Swift.String(describing: poolName)))"}
}

extension DeleteDedicatedIpPoolInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDedicatedIpPoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDedicatedIpPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDedicatedIpPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDedicatedIpPoolOutputError>
}

public struct DeleteDedicatedIpPoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDedicatedIpPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDedicatedIpPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDedicatedIpPoolOutputError>
}

/// A request to delete a dedicated IP pool.
public struct DeleteDedicatedIpPoolInput: Swift.Equatable {
    /// The name of the dedicated IP pool that you want to delete.
    /// This member is required.
    public let poolName: Swift.String?

    public init (
        poolName: Swift.String? = nil
    )
    {
        self.poolName = poolName
    }
}

struct DeleteDedicatedIpPoolInputBody: Swift.Equatable {
}

extension DeleteDedicatedIpPoolInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDedicatedIpPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDedicatedIpPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDedicatedIpPoolOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDedicatedIpPoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDedicatedIpPoolOutputResponse()"}
}

extension DeleteDedicatedIpPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct DeleteDedicatedIpPoolOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDedicatedIpPoolOutputResponseBody: Swift.Equatable {
}

extension DeleteDedicatedIpPoolOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEmailIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEmailIdentityInput(emailIdentity: \(Swift.String(describing: emailIdentity)))"}
}

extension DeleteEmailIdentityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteEmailIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEmailIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEmailIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEmailIdentityOutputError>
}

public struct DeleteEmailIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEmailIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEmailIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEmailIdentityOutputError>
}

/// A request to delete an existing email identity. When you delete an identity, you lose
///             the ability to use Amazon Pinpoint to send email from that identity. You can restore your ability
///             to send email by completing the verification process for the identity again.
public struct DeleteEmailIdentityInput: Swift.Equatable {
    /// The identity (that is, the email address or domain) that you want to delete from your
    ///             Amazon Pinpoint account.
    /// This member is required.
    public let emailIdentity: Swift.String?

    public init (
        emailIdentity: Swift.String? = nil
    )
    {
        self.emailIdentity = emailIdentity
    }
}

struct DeleteEmailIdentityInputBody: Swift.Equatable {
}

extension DeleteEmailIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEmailIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEmailIdentityOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEmailIdentityOutputResponse()"}
}

extension DeleteEmailIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct DeleteEmailIdentityOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEmailIdentityOutputResponseBody: Swift.Equatable {
}

extension DeleteEmailIdentityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PinpointEmailClientTypes {
    /// The current status of your Deliverability dashboard subscription. If this value is
    ///                 PENDING_EXPIRATION, your subscription is scheduled to expire at the end
    ///             of the current calendar month.
    public enum DeliverabilityDashboardAccountStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case disabled
        case pendingExpiration
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliverabilityDashboardAccountStatus] {
            return [
                .active,
                .disabled,
                .pendingExpiration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case .pendingExpiration: return "PENDING_EXPIRATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliverabilityDashboardAccountStatus(rawValue: rawValue) ?? DeliverabilityDashboardAccountStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointEmailClientTypes.DeliverabilityTestReport: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case deliverabilityTestStatus = "DeliverabilityTestStatus"
        case fromEmailAddress = "FromEmailAddress"
        case reportId = "ReportId"
        case reportName = "ReportName"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let deliverabilityTestStatus = deliverabilityTestStatus {
            try encodeContainer.encode(deliverabilityTestStatus.rawValue, forKey: .deliverabilityTestStatus)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let deliverabilityTestStatusDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DeliverabilityTestStatus.self, forKey: .deliverabilityTestStatus)
        deliverabilityTestStatus = deliverabilityTestStatusDecoded
    }
}

extension PinpointEmailClientTypes.DeliverabilityTestReport: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeliverabilityTestReport(createDate: \(Swift.String(describing: createDate)), deliverabilityTestStatus: \(Swift.String(describing: deliverabilityTestStatus)), fromEmailAddress: \(Swift.String(describing: fromEmailAddress)), reportId: \(Swift.String(describing: reportId)), reportName: \(Swift.String(describing: reportName)), subject: \(Swift.String(describing: subject)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains metadata related to a predictive inbox placement test.
    public struct DeliverabilityTestReport: Swift.Equatable {
        /// The date and time when the predictive inbox placement test was created, in Unix time format.
        public let createDate: ClientRuntime.Date?
        /// The status of the predictive inbox placement test. If the status is IN_PROGRESS, then the predictive inbox placement test
        ///             is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
        ///             test. If the status is COMPLETE, then the test is finished, and you can use
        ///             the GetDeliverabilityTestReport to view the results of the test.
        public let deliverabilityTestStatus: PinpointEmailClientTypes.DeliverabilityTestStatus?
        /// The sender address that you specified for the predictive inbox placement test.
        public let fromEmailAddress: Swift.String?
        /// A unique string that identifies the predictive inbox placement test.
        public let reportId: Swift.String?
        /// A name that helps you identify a predictive inbox placement test report.
        public let reportName: Swift.String?
        /// The subject line for an email that you submitted in a predictive inbox placement test.
        public let subject: Swift.String?

        public init (
            createDate: ClientRuntime.Date? = nil,
            deliverabilityTestStatus: PinpointEmailClientTypes.DeliverabilityTestStatus? = nil,
            fromEmailAddress: Swift.String? = nil,
            reportId: Swift.String? = nil,
            reportName: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.deliverabilityTestStatus = deliverabilityTestStatus
            self.fromEmailAddress = fromEmailAddress
            self.reportId = reportId
            self.reportName = reportName
            self.subject = subject
        }
    }

}

extension PinpointEmailClientTypes {
    /// The status of a predictive inbox placement test. If the status is IN_PROGRESS, then the predictive inbox placement test is
    ///             currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the test.
    ///             If the status is COMPLETE, then the test is finished, and you can use the
    ///                 GetDeliverabilityTestReport operation to view the results of the
    ///             test.
    public enum DeliverabilityTestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliverabilityTestStatus] {
            return [
                .completed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliverabilityTestStatus(rawValue: rawValue) ?? DeliverabilityTestStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointEmailClientTypes.DeliveryOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sendingPoolName = sendingPoolName {
            try encodeContainer.encode(sendingPoolName, forKey: .sendingPoolName)
        }
        if let tlsPolicy = tlsPolicy {
            try encodeContainer.encode(tlsPolicy.rawValue, forKey: .tlsPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
        let sendingPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sendingPoolName)
        sendingPoolName = sendingPoolNameDecoded
    }
}

extension PinpointEmailClientTypes.DeliveryOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeliveryOptions(sendingPoolName: \(Swift.String(describing: sendingPoolName)), tlsPolicy: \(Swift.String(describing: tlsPolicy)))"}
}

extension PinpointEmailClientTypes {
    /// Used to associate a configuration set with a dedicated IP pool.
    public struct DeliveryOptions: Swift.Equatable {
        /// The name of the dedicated IP pool that you want to associate with the configuration
        ///             set.
        public let sendingPoolName: Swift.String?
        /// Specifies whether messages that use the configuration set are required to use
        ///             Transport Layer Security (TLS). If the value is Require, messages are only
        ///             delivered if a TLS connection can be established. If the value is Optional,
        ///             messages can be delivered in plain text if a TLS connection can't be established.
        public let tlsPolicy: PinpointEmailClientTypes.TlsPolicy?

        public init (
            sendingPoolName: Swift.String? = nil,
            tlsPolicy: PinpointEmailClientTypes.TlsPolicy? = nil
        )
        {
            self.sendingPoolName = sendingPoolName
            self.tlsPolicy = tlsPolicy
        }
    }

}

extension PinpointEmailClientTypes.Destination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bccAddresses = "BccAddresses"
        case ccAddresses = "CcAddresses"
        case toAddresses = "ToAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bccAddresses = bccAddresses {
            var bccAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bccAddresses)
            for emailaddresslist0 in bccAddresses {
                try bccAddressesContainer.encode(emailaddresslist0)
            }
        }
        if let ccAddresses = ccAddresses {
            var ccAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccAddresses)
            for emailaddresslist0 in ccAddresses {
                try ccAddressesContainer.encode(emailaddresslist0)
            }
        }
        if let toAddresses = toAddresses {
            var toAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .toAddresses)
            for emailaddresslist0 in toAddresses {
                try toAddressesContainer.encode(emailaddresslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let toAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .toAddresses)
        var toAddressesDecoded0:[Swift.String]? = nil
        if let toAddressesContainer = toAddressesContainer {
            toAddressesDecoded0 = [Swift.String]()
            for string0 in toAddressesContainer {
                if let string0 = string0 {
                    toAddressesDecoded0?.append(string0)
                }
            }
        }
        toAddresses = toAddressesDecoded0
        let ccAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ccAddresses)
        var ccAddressesDecoded0:[Swift.String]? = nil
        if let ccAddressesContainer = ccAddressesContainer {
            ccAddressesDecoded0 = [Swift.String]()
            for string0 in ccAddressesContainer {
                if let string0 = string0 {
                    ccAddressesDecoded0?.append(string0)
                }
            }
        }
        ccAddresses = ccAddressesDecoded0
        let bccAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bccAddresses)
        var bccAddressesDecoded0:[Swift.String]? = nil
        if let bccAddressesContainer = bccAddressesContainer {
            bccAddressesDecoded0 = [Swift.String]()
            for string0 in bccAddressesContainer {
                if let string0 = string0 {
                    bccAddressesDecoded0?.append(string0)
                }
            }
        }
        bccAddresses = bccAddressesDecoded0
    }
}

extension PinpointEmailClientTypes.Destination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Destination(bccAddresses: \(Swift.String(describing: bccAddresses)), ccAddresses: \(Swift.String(describing: ccAddresses)), toAddresses: \(Swift.String(describing: toAddresses)))"}
}

extension PinpointEmailClientTypes {
    /// An object that describes the recipients for an email.
    public struct Destination: Swift.Equatable {
        /// An array that contains the email addresses of the "BCC" (blind carbon copy) recipients
        ///             for the email.
        public let bccAddresses: [Swift.String]?
        /// An array that contains the email addresses of the "CC" (carbon copy) recipients for
        ///             the email.
        public let ccAddresses: [Swift.String]?
        /// An array that contains the email addresses of the "To" recipients for the
        ///             email.
        public let toAddresses: [Swift.String]?

        public init (
            bccAddresses: [Swift.String]? = nil,
            ccAddresses: [Swift.String]? = nil,
            toAddresses: [Swift.String]? = nil
        )
        {
            self.bccAddresses = bccAddresses
            self.ccAddresses = ccAddresses
            self.toAddresses = toAddresses
        }
    }

}

extension PinpointEmailClientTypes {
    /// The location where Amazon Pinpoint finds the value of a dimension to publish to Amazon CloudWatch. If you
    ///             want Amazon Pinpoint to use the message tags that you specify using an X-SES-MESSAGE-TAGS header
    ///             or a parameter to the SendEmail/SendRawEmail API, choose messageTag. If you
    ///             want Amazon Pinpoint to use your own email headers, choose emailHeader. If you want
    ///             Amazon Pinpoint to use link tags, choose linkTags.
    public enum DimensionValueSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case emailHeader
        case linkTag
        case messageTag
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionValueSource] {
            return [
                .emailHeader,
                .linkTag,
                .messageTag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .emailHeader: return "EMAIL_HEADER"
            case .linkTag: return "LINK_TAG"
            case .messageTag: return "MESSAGE_TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionValueSource(rawValue: rawValue) ?? DimensionValueSource.sdkUnknown(rawValue)
        }
    }
}

extension PinpointEmailClientTypes.DkimAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingEnabled = "SigningEnabled"
        case status = "Status"
        case tokens = "Tokens"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if signingEnabled != false {
            try encodeContainer.encode(signingEnabled, forKey: .signingEnabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tokens = tokens {
            var tokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokens)
            for dnstokenlist0 in tokens {
                try tokensContainer.encode(dnstokenlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .signingEnabled)
        signingEnabled = signingEnabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DkimStatus.self, forKey: .status)
        status = statusDecoded
        let tokensContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokens)
        var tokensDecoded0:[Swift.String]? = nil
        if let tokensContainer = tokensContainer {
            tokensDecoded0 = [Swift.String]()
            for string0 in tokensContainer {
                if let string0 = string0 {
                    tokensDecoded0?.append(string0)
                }
            }
        }
        tokens = tokensDecoded0
    }
}

extension PinpointEmailClientTypes.DkimAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DkimAttributes(signingEnabled: \(Swift.String(describing: signingEnabled)), status: \(Swift.String(describing: status)), tokens: \(Swift.String(describing: tokens)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about the DKIM configuration for an email
    ///             identity.
    public struct DkimAttributes: Swift.Equatable {
        /// If the value is true, then the messages that Amazon Pinpoint sends from the
        ///             identity are DKIM-signed. If the value is false, then the messages that
        ///             Amazon Pinpoint sends from the identity aren't DKIM-signed.
        public let signingEnabled: Swift.Bool
        /// Describes whether or not Amazon Pinpoint has successfully located the DKIM records in the DNS
        ///             records for the domain. The status can be one of the following:
        ///
        ///
        ///
        ///                   PENDING  Amazon Pinpoint hasn't yet located the DKIM records in the
        ///                     DNS configuration for the domain, but will continue to attempt to locate
        ///                     them.
        ///
        ///
        ///
        ///                   SUCCESS  Amazon Pinpoint located the DKIM records in the DNS
        ///                     configuration for the domain and determined that they're correct. Amazon Pinpoint can now
        ///                     send DKIM-signed email from the identity.
        ///
        ///
        ///
        ///                   FAILED  Amazon Pinpoint was unable to locate the DKIM records in the
        ///                     DNS settings for the domain, and won't continue to search for them.
        ///
        ///
        ///
        ///                   TEMPORARY_FAILURE  A temporary issue occurred, which
        ///                     prevented Amazon Pinpoint from determining the DKIM status for the domain.
        ///
        ///
        ///
        ///                   NOT_STARTED  Amazon Pinpoint hasn't yet started searching for the
        ///                     DKIM records in the DKIM records for the domain.
        ///
        ///
        public let status: PinpointEmailClientTypes.DkimStatus?
        /// A set of unique strings that you use to create a set of CNAME records that you add to
        ///             the DNS configuration for your domain. When Amazon Pinpoint detects these records in the DNS
        ///             configuration for your domain, the DKIM authentication process is complete. Amazon Pinpoint
        ///             usually detects these records within about 72 hours of adding them to the DNS
        ///             configuration for your domain.
        public let tokens: [Swift.String]?

        public init (
            signingEnabled: Swift.Bool = false,
            status: PinpointEmailClientTypes.DkimStatus? = nil,
            tokens: [Swift.String]? = nil
        )
        {
            self.signingEnabled = signingEnabled
            self.status = status
            self.tokens = tokens
        }
    }

}

extension PinpointEmailClientTypes {
    /// The DKIM authentication status of the identity. The status can be one of the
    ///             following:
    ///
    ///
    ///
    ///                   PENDING  The DKIM verification process was initiated, and
    ///                     Amazon Pinpoint is still waiting for the required CNAME records to appear in the DNS
    ///                     configuration for the domain.
    ///
    ///
    ///
    ///                   SUCCESS  The DKIM authentication process completed
    ///                     successfully.
    ///
    ///
    ///
    ///                   FAILED  The DKIM authentication process failed. This can
    ///                     happen when Amazon Pinpoint fails to find the required CNAME records in the DNS
    ///                     configuration of the domain.
    ///
    ///
    ///
    ///                   TEMPORARY_FAILURE  A temporary issue is preventing Amazon Pinpoint
    ///                     from determining the DKIM authentication status of the domain.
    ///
    ///
    ///
    ///                   NOT_STARTED  The DKIM verification process hasn't been
    ///                     initiated for the domain.
    ///
    ///
    public enum DkimStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case notStarted
        case pending
        case success
        case temporaryFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [DkimStatus] {
            return [
                .failed,
                .notStarted,
                .pending,
                .success,
                .temporaryFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .notStarted: return "NOT_STARTED"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case .temporaryFailure: return "TEMPORARY_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DkimStatus(rawValue: rawValue) ?? DkimStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointEmailClientTypes.DomainDeliverabilityCampaign: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignId = "CampaignId"
        case deleteRate = "DeleteRate"
        case esps = "Esps"
        case firstSeenDateTime = "FirstSeenDateTime"
        case fromAddress = "FromAddress"
        case imageUrl = "ImageUrl"
        case inboxCount = "InboxCount"
        case lastSeenDateTime = "LastSeenDateTime"
        case projectedVolume = "ProjectedVolume"
        case readDeleteRate = "ReadDeleteRate"
        case readRate = "ReadRate"
        case sendingIps = "SendingIps"
        case spamCount = "SpamCount"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignId = campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let deleteRate = deleteRate {
            try encodeContainer.encode(deleteRate, forKey: .deleteRate)
        }
        if let esps = esps {
            var espsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .esps)
            for esps0 in esps {
                try espsContainer.encode(esps0)
            }
        }
        if let firstSeenDateTime = firstSeenDateTime {
            try encodeContainer.encode(firstSeenDateTime.timeIntervalSince1970, forKey: .firstSeenDateTime)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let inboxCount = inboxCount {
            try encodeContainer.encode(inboxCount, forKey: .inboxCount)
        }
        if let lastSeenDateTime = lastSeenDateTime {
            try encodeContainer.encode(lastSeenDateTime.timeIntervalSince1970, forKey: .lastSeenDateTime)
        }
        if let projectedVolume = projectedVolume {
            try encodeContainer.encode(projectedVolume, forKey: .projectedVolume)
        }
        if let readDeleteRate = readDeleteRate {
            try encodeContainer.encode(readDeleteRate, forKey: .readDeleteRate)
        }
        if let readRate = readRate {
            try encodeContainer.encode(readRate, forKey: .readRate)
        }
        if let sendingIps = sendingIps {
            var sendingIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sendingIps)
            for iplist0 in sendingIps {
                try sendingIpsContainer.encode(iplist0)
            }
        }
        if let spamCount = spamCount {
            try encodeContainer.encode(spamCount, forKey: .spamCount)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let sendingIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sendingIps)
        var sendingIpsDecoded0:[Swift.String]? = nil
        if let sendingIpsContainer = sendingIpsContainer {
            sendingIpsDecoded0 = [Swift.String]()
            for string0 in sendingIpsContainer {
                if let string0 = string0 {
                    sendingIpsDecoded0?.append(string0)
                }
            }
        }
        sendingIps = sendingIpsDecoded0
        let firstSeenDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .firstSeenDateTime)
        firstSeenDateTime = firstSeenDateTimeDecoded
        let lastSeenDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSeenDateTime)
        lastSeenDateTime = lastSeenDateTimeDecoded
        let inboxCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inboxCount)
        inboxCount = inboxCountDecoded
        let spamCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spamCount)
        spamCount = spamCountDecoded
        let readRateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .readRate)
        readRate = readRateDecoded
        let deleteRateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .deleteRate)
        deleteRate = deleteRateDecoded
        let readDeleteRateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .readDeleteRate)
        readDeleteRate = readDeleteRateDecoded
        let projectedVolumeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .projectedVolume)
        projectedVolume = projectedVolumeDecoded
        let espsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .esps)
        var espsDecoded0:[Swift.String]? = nil
        if let espsContainer = espsContainer {
            espsDecoded0 = [Swift.String]()
            for string0 in espsContainer {
                if let string0 = string0 {
                    espsDecoded0?.append(string0)
                }
            }
        }
        esps = espsDecoded0
    }
}

extension PinpointEmailClientTypes.DomainDeliverabilityCampaign: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainDeliverabilityCampaign(campaignId: \(Swift.String(describing: campaignId)), deleteRate: \(Swift.String(describing: deleteRate)), esps: \(Swift.String(describing: esps)), firstSeenDateTime: \(Swift.String(describing: firstSeenDateTime)), fromAddress: \(Swift.String(describing: fromAddress)), imageUrl: \(Swift.String(describing: imageUrl)), inboxCount: \(Swift.String(describing: inboxCount)), lastSeenDateTime: \(Swift.String(describing: lastSeenDateTime)), projectedVolume: \(Swift.String(describing: projectedVolume)), readDeleteRate: \(Swift.String(describing: readDeleteRate)), readRate: \(Swift.String(describing: readRate)), sendingIps: \(Swift.String(describing: sendingIps)), spamCount: \(Swift.String(describing: spamCount)), subject: \(Swift.String(describing: subject)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains the deliverability data for a specific campaign. This data is
    ///             available for a campaign only if the campaign sent email by using a domain that the
    ///             Deliverability dashboard is enabled for (PutDeliverabilityDashboardOption
    ///             operation).
    public struct DomainDeliverabilityCampaign: Swift.Equatable {
        /// The unique identifier for the campaign. Amazon Pinpoint automatically generates and assigns this
        ///             identifier to a campaign. This value is not the same as the campaign identifier that
        ///             Amazon Pinpoint assigns to campaigns that you create and manage by using the Amazon Pinpoint API or the
        ///             Amazon Pinpoint console.
        public let campaignId: Swift.String?
        /// The percentage of email messages that were deleted by recipients, without being opened
        ///             first. Due to technical limitations, this value only includes recipients who opened the
        ///             message by using an email client that supports images.
        public let deleteRate: Swift.Double?
        /// The major email providers who handled the email message.
        public let esps: [Swift.String]?
        /// The first time, in Unix time format, when the email message was delivered to any
        ///             recipient's inbox. This value can help you determine how long it took for a campaign to
        ///             deliver an email message.
        public let firstSeenDateTime: ClientRuntime.Date?
        /// The verified email address that the email message was sent from.
        public let fromAddress: Swift.String?
        /// The URL of an image that contains a snapshot of the email message that was
        ///             sent.
        public let imageUrl: Swift.String?
        /// The number of email messages that were delivered to recipients inboxes.
        public let inboxCount: Swift.Int?
        /// The last time, in Unix time format, when the email message was delivered to any
        ///             recipient's inbox. This value can help you determine how long it took for a campaign to
        ///             deliver an email message.
        public let lastSeenDateTime: ClientRuntime.Date?
        /// The projected number of recipients that the email message was sent to.
        public let projectedVolume: Swift.Int?
        /// The percentage of email messages that were opened and then deleted by recipients. Due
        ///             to technical limitations, this value only includes recipients who opened the message by
        ///             using an email client that supports images.
        public let readDeleteRate: Swift.Double?
        /// The percentage of email messages that were opened by recipients. Due to technical
        ///             limitations, this value only includes recipients who opened the message by using an
        ///             email client that supports images.
        public let readRate: Swift.Double?
        /// The IP addresses that were used to send the email message.
        public let sendingIps: [Swift.String]?
        /// The number of email messages that were delivered to recipients' spam or junk mail
        ///             folders.
        public let spamCount: Swift.Int?
        /// The subject line, or title, of the email message.
        public let subject: Swift.String?

        public init (
            campaignId: Swift.String? = nil,
            deleteRate: Swift.Double? = nil,
            esps: [Swift.String]? = nil,
            firstSeenDateTime: ClientRuntime.Date? = nil,
            fromAddress: Swift.String? = nil,
            imageUrl: Swift.String? = nil,
            inboxCount: Swift.Int? = nil,
            lastSeenDateTime: ClientRuntime.Date? = nil,
            projectedVolume: Swift.Int? = nil,
            readDeleteRate: Swift.Double? = nil,
            readRate: Swift.Double? = nil,
            sendingIps: [Swift.String]? = nil,
            spamCount: Swift.Int? = nil,
            subject: Swift.String? = nil
        )
        {
            self.campaignId = campaignId
            self.deleteRate = deleteRate
            self.esps = esps
            self.firstSeenDateTime = firstSeenDateTime
            self.fromAddress = fromAddress
            self.imageUrl = imageUrl
            self.inboxCount = inboxCount
            self.lastSeenDateTime = lastSeenDateTime
            self.projectedVolume = projectedVolume
            self.readDeleteRate = readDeleteRate
            self.readRate = readRate
            self.sendingIps = sendingIps
            self.spamCount = spamCount
            self.subject = subject
        }
    }

}

extension PinpointEmailClientTypes.DomainDeliverabilityTrackingOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case inboxPlacementTrackingOption = "InboxPlacementTrackingOption"
        case subscriptionStartDate = "SubscriptionStartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let inboxPlacementTrackingOption = inboxPlacementTrackingOption {
            try encodeContainer.encode(inboxPlacementTrackingOption, forKey: .inboxPlacementTrackingOption)
        }
        if let subscriptionStartDate = subscriptionStartDate {
            try encodeContainer.encode(subscriptionStartDate.timeIntervalSince1970, forKey: .subscriptionStartDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let inboxPlacementTrackingOptionDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.InboxPlacementTrackingOption.self, forKey: .inboxPlacementTrackingOption)
        inboxPlacementTrackingOption = inboxPlacementTrackingOptionDecoded
    }
}

extension PinpointEmailClientTypes.DomainDeliverabilityTrackingOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainDeliverabilityTrackingOption(domain: \(Swift.String(describing: domain)), inboxPlacementTrackingOption: \(Swift.String(describing: inboxPlacementTrackingOption)), subscriptionStartDate: \(Swift.String(describing: subscriptionStartDate)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about the Deliverability dashboard subscription for a
    ///             verified domain that you use to send email and currently has an active Deliverability dashboard
    ///             subscription. If a Deliverability dashboard subscription is active for a domain, you gain access
    ///             to reputation, inbox placement, and other metrics for the domain.
    public struct DomainDeliverabilityTrackingOption: Swift.Equatable {
        /// A verified domain thats associated with your AWS account and currently has an
        ///             active Deliverability dashboard subscription.
        public let domain: Swift.String?
        /// An object that contains information about the inbox placement data settings for the
        ///             domain.
        public let inboxPlacementTrackingOption: PinpointEmailClientTypes.InboxPlacementTrackingOption?
        /// The date, in Unix time format, when you enabled the Deliverability dashboard for the
        ///             domain.
        public let subscriptionStartDate: ClientRuntime.Date?

        public init (
            domain: Swift.String? = nil,
            inboxPlacementTrackingOption: PinpointEmailClientTypes.InboxPlacementTrackingOption? = nil,
            subscriptionStartDate: ClientRuntime.Date? = nil
        )
        {
            self.domain = domain
            self.inboxPlacementTrackingOption = inboxPlacementTrackingOption
            self.subscriptionStartDate = subscriptionStartDate
        }
    }

}

extension PinpointEmailClientTypes.DomainIspPlacement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboxPercentage = "InboxPercentage"
        case inboxRawCount = "InboxRawCount"
        case ispName = "IspName"
        case spamPercentage = "SpamPercentage"
        case spamRawCount = "SpamRawCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboxPercentage = inboxPercentage {
            try encodeContainer.encode(inboxPercentage, forKey: .inboxPercentage)
        }
        if let inboxRawCount = inboxRawCount {
            try encodeContainer.encode(inboxRawCount, forKey: .inboxRawCount)
        }
        if let ispName = ispName {
            try encodeContainer.encode(ispName, forKey: .ispName)
        }
        if let spamPercentage = spamPercentage {
            try encodeContainer.encode(spamPercentage, forKey: .spamPercentage)
        }
        if let spamRawCount = spamRawCount {
            try encodeContainer.encode(spamRawCount, forKey: .spamRawCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ispNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ispName)
        ispName = ispNameDecoded
        let inboxRawCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inboxRawCount)
        inboxRawCount = inboxRawCountDecoded
        let spamRawCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spamRawCount)
        spamRawCount = spamRawCountDecoded
        let inboxPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .inboxPercentage)
        inboxPercentage = inboxPercentageDecoded
        let spamPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .spamPercentage)
        spamPercentage = spamPercentageDecoded
    }
}

extension PinpointEmailClientTypes.DomainIspPlacement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainIspPlacement(inboxPercentage: \(Swift.String(describing: inboxPercentage)), inboxRawCount: \(Swift.String(describing: inboxRawCount)), ispName: \(Swift.String(describing: ispName)), spamPercentage: \(Swift.String(describing: spamPercentage)), spamRawCount: \(Swift.String(describing: spamRawCount)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains inbox placement data for email sent from one of your email
    ///             domains to a specific email provider.
    public struct DomainIspPlacement: Swift.Equatable {
        /// The percentage of messages that were sent from the selected domain to the specified
        ///             email provider that arrived in recipients' inboxes.
        public let inboxPercentage: Swift.Double?
        /// The total number of messages that were sent from the selected domain to the specified
        ///             email provider that arrived in recipients' inboxes.
        public let inboxRawCount: Swift.Int?
        /// The name of the email provider that the inbox placement data applies to.
        public let ispName: Swift.String?
        /// The percentage of messages that were sent from the selected domain to the specified
        ///             email provider that arrived in recipients' spam or junk mail folders.
        public let spamPercentage: Swift.Double?
        /// The total number of messages that were sent from the selected domain to the specified
        ///             email provider that arrived in recipients' spam or junk mail folders.
        public let spamRawCount: Swift.Int?

        public init (
            inboxPercentage: Swift.Double? = nil,
            inboxRawCount: Swift.Int? = nil,
            ispName: Swift.String? = nil,
            spamPercentage: Swift.Double? = nil,
            spamRawCount: Swift.Int? = nil
        )
        {
            self.inboxPercentage = inboxPercentage
            self.inboxRawCount = inboxRawCount
            self.ispName = ispName
            self.spamPercentage = spamPercentage
            self.spamRawCount = spamRawCount
        }
    }

}

extension PinpointEmailClientTypes.EmailContent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case raw = "Raw"
        case simple = "Simple"
        case template = "Template"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let raw = raw {
            try encodeContainer.encode(raw, forKey: .raw)
        }
        if let simple = simple {
            try encodeContainer.encode(simple, forKey: .simple)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.Message.self, forKey: .simple)
        simple = simpleDecoded
        let rawDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.RawMessage.self, forKey: .raw)
        raw = rawDecoded
        let templateDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.Template.self, forKey: .template)
        template = templateDecoded
    }
}

extension PinpointEmailClientTypes.EmailContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailContent(raw: \(Swift.String(describing: raw)), simple: \(Swift.String(describing: simple)), template: \(Swift.String(describing: template)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines the entire content of the email, including the message headers
    ///             and the body content. You can create a simple email message, in which you specify the
    ///             subject and the text and HTML versions of the message body. You can also create raw
    ///             messages, in which you specify a complete MIME-formatted message. Raw messages can
    ///             include attachments and custom headers.
    public struct EmailContent: Swift.Equatable {
        /// The raw email message. The message has to meet the following criteria:
        ///
        ///
        ///                 The message has to contain a header and a body, separated by one blank
        ///                     line.
        ///
        ///
        ///                 All of the required header fields must be present in the message.
        ///
        ///
        ///                 Each part of a multipart MIME message must be formatted properly.
        ///
        ///
        ///                 If you include attachments, they must be in a file format that Amazon Pinpoint supports.
        ///
        ///
        ///
        ///                 The entire message must be Base64 encoded.
        ///
        ///
        ///                 If any of the MIME parts in your message contain content that is outside of
        ///                     the 7-bit ASCII character range, you should encode that content to ensure that
        ///                     recipients' email clients render the message properly.
        ///
        ///
        ///                 The length of any single line of text in the message can't exceed 1,000
        ///                     characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321.
        ///
        ///
        public let raw: PinpointEmailClientTypes.RawMessage?
        /// The simple email message. The message consists of a subject and a message body.
        public let simple: PinpointEmailClientTypes.Message?
        /// The template to use for the email message.
        public let template: PinpointEmailClientTypes.Template?

        public init (
            raw: PinpointEmailClientTypes.RawMessage? = nil,
            simple: PinpointEmailClientTypes.Message? = nil,
            template: PinpointEmailClientTypes.Template? = nil
        )
        {
            self.raw = raw
            self.simple = simple
            self.template = template
        }
    }

}

extension PinpointEmailClientTypes.EventDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchDestination = "CloudWatchDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case name = "Name"
        case pinpointDestination = "PinpointDestination"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchDestination = cloudWatchDestination {
            try encodeContainer.encode(cloudWatchDestination, forKey: .cloudWatchDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pinpointDestination = pinpointDestination {
            try encodeContainer.encode(pinpointDestination, forKey: .pinpointDestination)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointEmailClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointEmailClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let cloudWatchDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.CloudWatchDestination.self, forKey: .cloudWatchDestination)
        cloudWatchDestination = cloudWatchDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let pinpointDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.PinpointDestination.self, forKey: .pinpointDestination)
        pinpointDestination = pinpointDestinationDecoded
    }
}

extension PinpointEmailClientTypes.EventDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventDestination(cloudWatchDestination: \(Swift.String(describing: cloudWatchDestination)), enabled: \(Swift.String(describing: enabled)), kinesisFirehoseDestination: \(Swift.String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(Swift.String(describing: matchingEventTypes)), name: \(Swift.String(describing: name)), pinpointDestination: \(Swift.String(describing: pinpointDestination)), snsDestination: \(Swift.String(describing: snsDestination)))"}
}

extension PinpointEmailClientTypes {
    /// In Amazon Pinpoint, events include message sends, deliveries, opens,
    ///             clicks, bounces, and complaints. Event destinations are places that
    ///             you can send information about these events to. For example, you can send event data to
    ///             Amazon SNS to receive notifications when you receive bounces or complaints, or you can use
    ///             Amazon Kinesis Data Firehose to stream data to Amazon S3 for long-term storage.
    public struct EventDestination: Swift.Equatable {
        /// An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
        ///             monitor and gain insights on your email sending metrics.
        public let cloudWatchDestination: PinpointEmailClientTypes.CloudWatchDestination?
        /// If true, the event destination is enabled. When the event destination is
        ///             enabled, the specified event types are sent to the destinations in this
        ///                 EventDestinationDefinition.
        ///         If false, the event destination is disabled. When the event destination
        ///             is disabled, events aren't sent to the specified destinations.
        public let enabled: Swift.Bool
        /// An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
        ///             stream data to other services, such as Amazon S3 and Amazon Redshift.
        public let kinesisFirehoseDestination: PinpointEmailClientTypes.KinesisFirehoseDestination?
        /// The types of events that Amazon Pinpoint sends to the specified event destinations.
        /// This member is required.
        public let matchingEventTypes: [PinpointEmailClientTypes.EventType]?
        /// A name that identifies the event destination.
        /// This member is required.
        public let name: Swift.String?
        /// An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
        ///             to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
        ///             for your campaigns.
        public let pinpointDestination: PinpointEmailClientTypes.PinpointDestination?
        /// An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
        ///             send notification when certain email events occur.
        public let snsDestination: PinpointEmailClientTypes.SnsDestination?

        public init (
            cloudWatchDestination: PinpointEmailClientTypes.CloudWatchDestination? = nil,
            enabled: Swift.Bool = false,
            kinesisFirehoseDestination: PinpointEmailClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointEmailClientTypes.EventType]? = nil,
            name: Swift.String? = nil,
            pinpointDestination: PinpointEmailClientTypes.PinpointDestination? = nil,
            snsDestination: PinpointEmailClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchDestination = cloudWatchDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.name = name
            self.pinpointDestination = pinpointDestination
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointEmailClientTypes.EventDestinationDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchDestination = "CloudWatchDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case pinpointDestination = "PinpointDestination"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchDestination = cloudWatchDestination {
            try encodeContainer.encode(cloudWatchDestination, forKey: .cloudWatchDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let pinpointDestination = pinpointDestination {
            try encodeContainer.encode(pinpointDestination, forKey: .pinpointDestination)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointEmailClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointEmailClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let cloudWatchDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.CloudWatchDestination.self, forKey: .cloudWatchDestination)
        cloudWatchDestination = cloudWatchDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let pinpointDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.PinpointDestination.self, forKey: .pinpointDestination)
        pinpointDestination = pinpointDestinationDecoded
    }
}

extension PinpointEmailClientTypes.EventDestinationDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventDestinationDefinition(cloudWatchDestination: \(Swift.String(describing: cloudWatchDestination)), enabled: \(Swift.String(describing: enabled)), kinesisFirehoseDestination: \(Swift.String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(Swift.String(describing: matchingEventTypes)), pinpointDestination: \(Swift.String(describing: pinpointDestination)), snsDestination: \(Swift.String(describing: snsDestination)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines the event destination. Specifically, it defines which services
    ///             receive events from emails sent using the configuration set that the event destination
    ///             is associated with. Also defines the types of events that are sent to the event
    ///             destination.
    public struct EventDestinationDefinition: Swift.Equatable {
        /// An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
        ///             monitor and gain insights on your email sending metrics.
        public let cloudWatchDestination: PinpointEmailClientTypes.CloudWatchDestination?
        /// If true, the event destination is enabled. When the event destination is
        ///             enabled, the specified event types are sent to the destinations in this
        ///                 EventDestinationDefinition.
        ///         If false, the event destination is disabled. When the event destination
        ///             is disabled, events aren't sent to the specified destinations.
        public let enabled: Swift.Bool
        /// An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
        ///             stream data to other services, such as Amazon S3 and Amazon Redshift.
        public let kinesisFirehoseDestination: PinpointEmailClientTypes.KinesisFirehoseDestination?
        /// An array that specifies which events Amazon Pinpoint should send to the destinations in this
        ///                 EventDestinationDefinition.
        public let matchingEventTypes: [PinpointEmailClientTypes.EventType]?
        /// An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
        ///             to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
        ///             for your campaigns.
        public let pinpointDestination: PinpointEmailClientTypes.PinpointDestination?
        /// An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
        ///             send notification when certain email events occur.
        public let snsDestination: PinpointEmailClientTypes.SnsDestination?

        public init (
            cloudWatchDestination: PinpointEmailClientTypes.CloudWatchDestination? = nil,
            enabled: Swift.Bool = false,
            kinesisFirehoseDestination: PinpointEmailClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointEmailClientTypes.EventType]? = nil,
            pinpointDestination: PinpointEmailClientTypes.PinpointDestination? = nil,
            snsDestination: PinpointEmailClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchDestination = cloudWatchDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.pinpointDestination = pinpointDestination
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointEmailClientTypes {
    /// An email sending event type. For example, email sends, opens, and bounces are all
    ///             email events.
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bounce
        case click
        case complaint
        case delivery
        case `open`
        case reject
        case renderingFailure
        case send
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .bounce,
                .click,
                .complaint,
                .delivery,
                .open,
                .reject,
                .renderingFailure,
                .send,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bounce: return "BOUNCE"
            case .click: return "CLICK"
            case .complaint: return "COMPLAINT"
            case .delivery: return "DELIVERY"
            case .open: return "OPEN"
            case .reject: return "REJECT"
            case .renderingFailure: return "RENDERING_FAILURE"
            case .send: return "SEND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountInput()"}
}

extension GetAccountInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountOutputError>
}

public struct GetAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountOutputError>
}

/// A request to obtain information about the email-sending capabilities of your Amazon Pinpoint
///             account.
public struct GetAccountInput: Swift.Equatable {

    public init() {}
}

struct GetAccountInputBody: Swift.Equatable {
}

extension GetAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountOutputResponse(dedicatedIpAutoWarmupEnabled: \(Swift.String(describing: dedicatedIpAutoWarmupEnabled)), enforcementStatus: \(Swift.String(describing: enforcementStatus)), productionAccessEnabled: \(Swift.String(describing: productionAccessEnabled)), sendQuota: \(Swift.String(describing: sendQuota)), sendingEnabled: \(Swift.String(describing: sendingEnabled)))"}
}

extension GetAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dedicatedIpAutoWarmupEnabled = output.dedicatedIpAutoWarmupEnabled
            self.enforcementStatus = output.enforcementStatus
            self.productionAccessEnabled = output.productionAccessEnabled
            self.sendQuota = output.sendQuota
            self.sendingEnabled = output.sendingEnabled
        } else {
            self.dedicatedIpAutoWarmupEnabled = false
            self.enforcementStatus = nil
            self.productionAccessEnabled = false
            self.sendQuota = nil
            self.sendingEnabled = false
        }
    }
}

/// A list of details about the email-sending capabilities of your Amazon Pinpoint account in the
///             current AWS Region.
public struct GetAccountOutputResponse: Swift.Equatable {
    /// Indicates whether or not the automatic warm-up feature is enabled for dedicated IP
    ///             addresses that are associated with your account.
    public let dedicatedIpAutoWarmupEnabled: Swift.Bool
    /// The reputation status of your Amazon Pinpoint account. The status can be one of the
    ///             following:
    ///
    ///
    ///
    ///                   HEALTHY  There are no reputation-related issues that
    ///                     currently impact your account.
    ///
    ///
    ///
    ///                   PROBATION  We've identified some issues with your Amazon Pinpoint
    ///                     account. We're placing your account under review while you work on correcting
    ///                     these issues.
    ///
    ///
    ///
    ///                   SHUTDOWN  Your account's ability to send email is
    ///                     currently paused because of an issue with the email sent from your account. When
    ///                     you correct the issue, you can contact us and request that your account's
    ///                     ability to send email is resumed.
    ///
    ///
    public let enforcementStatus: Swift.String?
    /// Indicates whether or not your account has production access in the current AWS
    ///             Region.
    ///         If the value is false, then your account is in the
    ///                 sandbox. When your account is in the sandbox, you can only send
    ///             email to verified identities. Additionally, the maximum number of emails you can send in
    ///             a 24-hour period (your sending quota) is 200, and the maximum number of emails you can
    ///             send per second (your maximum sending rate) is 1.
    ///         If the value is true, then your account has production access. When your
    ///             account has production access, you can send email to any address. The sending quota and
    ///             maximum sending rate for your account vary based on your specific use case.
    public let productionAccessEnabled: Swift.Bool
    /// An object that contains information about the per-day and per-second sending limits
    ///             for your Amazon Pinpoint account in the current AWS Region.
    public let sendQuota: PinpointEmailClientTypes.SendQuota?
    /// Indicates whether or not email sending is enabled for your Amazon Pinpoint account in the
    ///             current AWS Region.
    public let sendingEnabled: Swift.Bool

    public init (
        dedicatedIpAutoWarmupEnabled: Swift.Bool = false,
        enforcementStatus: Swift.String? = nil,
        productionAccessEnabled: Swift.Bool = false,
        sendQuota: PinpointEmailClientTypes.SendQuota? = nil,
        sendingEnabled: Swift.Bool = false
    )
    {
        self.dedicatedIpAutoWarmupEnabled = dedicatedIpAutoWarmupEnabled
        self.enforcementStatus = enforcementStatus
        self.productionAccessEnabled = productionAccessEnabled
        self.sendQuota = sendQuota
        self.sendingEnabled = sendingEnabled
    }
}

struct GetAccountOutputResponseBody: Swift.Equatable {
    public let sendQuota: PinpointEmailClientTypes.SendQuota?
    public let sendingEnabled: Swift.Bool
    public let dedicatedIpAutoWarmupEnabled: Swift.Bool
    public let enforcementStatus: Swift.String?
    public let productionAccessEnabled: Swift.Bool
}

extension GetAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedIpAutoWarmupEnabled = "DedicatedIpAutoWarmupEnabled"
        case enforcementStatus = "EnforcementStatus"
        case productionAccessEnabled = "ProductionAccessEnabled"
        case sendQuota = "SendQuota"
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendQuotaDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.SendQuota.self, forKey: .sendQuota)
        sendQuota = sendQuotaDecoded
        let sendingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
        let dedicatedIpAutoWarmupEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dedicatedIpAutoWarmupEnabled)
        dedicatedIpAutoWarmupEnabled = dedicatedIpAutoWarmupEnabledDecoded
        let enforcementStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enforcementStatus)
        enforcementStatus = enforcementStatusDecoded
        let productionAccessEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .productionAccessEnabled)
        productionAccessEnabled = productionAccessEnabledDecoded
    }
}

extension GetBlacklistReportsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBlacklistReportsInput(blacklistItemNames: \(Swift.String(describing: blacklistItemNames)))"}
}

extension GetBlacklistReportsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBlacklistReportsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBlacklistReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBlacklistReportsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBlacklistReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBlacklistReportsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBlacklistReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBlacklistReportsOutputError>
}

public struct GetBlacklistReportsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBlacklistReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBlacklistReportsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBlacklistReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let blacklistItemNames = input.operationInput.blacklistItemNames {
            blacklistItemNames.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "BlacklistItemNames".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBlacklistReportsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBlacklistReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBlacklistReportsOutputError>
}

/// A request to retrieve a list of the blacklists that your dedicated IP addresses appear
///             on.
public struct GetBlacklistReportsInput: Swift.Equatable {
    /// A list of IP addresses that you want to retrieve blacklist information about. You can
    ///             only specify the dedicated IP addresses that you use to send email using Amazon Pinpoint or
    ///             Amazon SES.
    /// This member is required.
    public let blacklistItemNames: [Swift.String]?

    public init (
        blacklistItemNames: [Swift.String]? = nil
    )
    {
        self.blacklistItemNames = blacklistItemNames
    }
}

struct GetBlacklistReportsInputBody: Swift.Equatable {
}

extension GetBlacklistReportsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBlacklistReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBlacklistReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBlacklistReportsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBlacklistReportsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBlacklistReportsOutputResponse(blacklistReport: \(Swift.String(describing: blacklistReport)))"}
}

extension GetBlacklistReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBlacklistReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blacklistReport = output.blacklistReport
        } else {
            self.blacklistReport = nil
        }
    }
}

/// An object that contains information about blacklist events.
public struct GetBlacklistReportsOutputResponse: Swift.Equatable {
    /// An object that contains information about a blacklist that one of your dedicated IP
    ///             addresses appears on.
    /// This member is required.
    public let blacklistReport: [Swift.String:[PinpointEmailClientTypes.BlacklistEntry]]?

    public init (
        blacklistReport: [Swift.String:[PinpointEmailClientTypes.BlacklistEntry]]? = nil
    )
    {
        self.blacklistReport = blacklistReport
    }
}

struct GetBlacklistReportsOutputResponseBody: Swift.Equatable {
    public let blacklistReport: [Swift.String:[PinpointEmailClientTypes.BlacklistEntry]]?
}

extension GetBlacklistReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blacklistReport = "BlacklistReport"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blacklistReportContainer = try containerValues.decodeIfPresent([Swift.String: [PinpointEmailClientTypes.BlacklistEntry?]?].self, forKey: .blacklistReport)
        var blacklistReportDecoded0: [Swift.String:[PinpointEmailClientTypes.BlacklistEntry]]? = nil
        if let blacklistReportContainer = blacklistReportContainer {
            blacklistReportDecoded0 = [Swift.String:[PinpointEmailClientTypes.BlacklistEntry]]()
            for (key0, blacklistentries0) in blacklistReportContainer {
                var blacklistentries0Decoded0: [PinpointEmailClientTypes.BlacklistEntry]? = nil
                if let blacklistentries0 = blacklistentries0 {
                    blacklistentries0Decoded0 = [PinpointEmailClientTypes.BlacklistEntry]()
                    for structure1 in blacklistentries0 {
                        if let structure1 = structure1 {
                            blacklistentries0Decoded0?.append(structure1)
                        }
                    }
                }
                blacklistReportDecoded0?[key0] = blacklistentries0Decoded0
            }
        }
        blacklistReport = blacklistReportDecoded0
    }
}

extension GetConfigurationSetEventDestinationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationSetEventDestinationsInput(configurationSetName: \(Swift.String(describing: configurationSetName)))"}
}

extension GetConfigurationSetEventDestinationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConfigurationSetEventDestinationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationSetEventDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationSetEventDestinationsOutputError>
}

public struct GetConfigurationSetEventDestinationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationSetEventDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationSetEventDestinationsOutputError>
}

/// A request to obtain information about the event destinations for a configuration
///             set.
public struct GetConfigurationSetEventDestinationsInput: Swift.Equatable {
    /// The name of the configuration set that contains the event destination.
    /// This member is required.
    public let configurationSetName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetEventDestinationsInputBody: Swift.Equatable {
}

extension GetConfigurationSetEventDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationSetEventDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetEventDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetEventDestinationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetEventDestinationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationSetEventDestinationsOutputResponse(eventDestinations: \(Swift.String(describing: eventDestinations)))"}
}

extension GetConfigurationSetEventDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigurationSetEventDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventDestinations = output.eventDestinations
        } else {
            self.eventDestinations = nil
        }
    }
}

/// Information about an event destination for a configuration set.
public struct GetConfigurationSetEventDestinationsOutputResponse: Swift.Equatable {
    /// An array that includes all of the events destinations that have been configured for
    ///             the configuration set.
    public let eventDestinations: [PinpointEmailClientTypes.EventDestination]?

    public init (
        eventDestinations: [PinpointEmailClientTypes.EventDestination]? = nil
    )
    {
        self.eventDestinations = eventDestinations
    }
}

struct GetConfigurationSetEventDestinationsOutputResponseBody: Swift.Equatable {
    public let eventDestinations: [PinpointEmailClientTypes.EventDestination]?
}

extension GetConfigurationSetEventDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestinations = "EventDestinations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[PinpointEmailClientTypes.EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [PinpointEmailClientTypes.EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
    }
}

extension GetConfigurationSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationSetInput(configurationSetName: \(Swift.String(describing: configurationSetName)))"}
}

extension GetConfigurationSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConfigurationSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationSetOutputError>
}

public struct GetConfigurationSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationSetOutputError>
}

/// A request to obtain information about a configuration set.
public struct GetConfigurationSetInput: Swift.Equatable {
    /// The name of the configuration set that you want to obtain more information
    ///             about.
    /// This member is required.
    public let configurationSetName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetInputBody: Swift.Equatable {
}

extension GetConfigurationSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationSetOutputResponse(configurationSetName: \(Swift.String(describing: configurationSetName)), deliveryOptions: \(Swift.String(describing: deliveryOptions)), reputationOptions: \(Swift.String(describing: reputationOptions)), sendingOptions: \(Swift.String(describing: sendingOptions)), tags: \(Swift.String(describing: tags)), trackingOptions: \(Swift.String(describing: trackingOptions)))"}
}

extension GetConfigurationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigurationSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetName = output.configurationSetName
            self.deliveryOptions = output.deliveryOptions
            self.reputationOptions = output.reputationOptions
            self.sendingOptions = output.sendingOptions
            self.tags = output.tags
            self.trackingOptions = output.trackingOptions
        } else {
            self.configurationSetName = nil
            self.deliveryOptions = nil
            self.reputationOptions = nil
            self.sendingOptions = nil
            self.tags = nil
            self.trackingOptions = nil
        }
    }
}

/// Information about a configuration set.
public struct GetConfigurationSetOutputResponse: Swift.Equatable {
    /// The name of the configuration set.
    public let configurationSetName: Swift.String?
    /// An object that defines the dedicated IP pool that is used to send emails that you send
    ///             using the configuration set.
    public let deliveryOptions: PinpointEmailClientTypes.DeliveryOptions?
    /// An object that defines whether or not Amazon Pinpoint collects reputation metrics for the emails
    ///             that you send that use the configuration set.
    public let reputationOptions: PinpointEmailClientTypes.ReputationOptions?
    /// An object that defines whether or not Amazon Pinpoint can send email that you send using the
    ///             configuration set.
    public let sendingOptions: PinpointEmailClientTypes.SendingOptions?
    /// An array of objects that define the tags (keys and values) that are associated with
    ///             the configuration set.
    public let tags: [PinpointEmailClientTypes.Tag]?
    /// An object that defines the open and click tracking options for emails that you send
    ///             using the configuration set.
    public let trackingOptions: PinpointEmailClientTypes.TrackingOptions?

    public init (
        configurationSetName: Swift.String? = nil,
        deliveryOptions: PinpointEmailClientTypes.DeliveryOptions? = nil,
        reputationOptions: PinpointEmailClientTypes.ReputationOptions? = nil,
        sendingOptions: PinpointEmailClientTypes.SendingOptions? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil,
        trackingOptions: PinpointEmailClientTypes.TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.deliveryOptions = deliveryOptions
        self.reputationOptions = reputationOptions
        self.sendingOptions = sendingOptions
        self.tags = tags
        self.trackingOptions = trackingOptions
    }
}

struct GetConfigurationSetOutputResponseBody: Swift.Equatable {
    public let configurationSetName: Swift.String?
    public let trackingOptions: PinpointEmailClientTypes.TrackingOptions?
    public let deliveryOptions: PinpointEmailClientTypes.DeliveryOptions?
    public let reputationOptions: PinpointEmailClientTypes.ReputationOptions?
    public let sendingOptions: PinpointEmailClientTypes.SendingOptions?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension GetConfigurationSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let trackingOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.TrackingOptions.self, forKey: .trackingOptions)
        trackingOptions = trackingOptionsDecoded
        let deliveryOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DeliveryOptions.self, forKey: .deliveryOptions)
        deliveryOptions = deliveryOptionsDecoded
        let reputationOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.ReputationOptions.self, forKey: .reputationOptions)
        reputationOptions = reputationOptionsDecoded
        let sendingOptionsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.SendingOptions.self, forKey: .sendingOptions)
        sendingOptions = sendingOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDedicatedIpInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDedicatedIpInput(ip: \(Swift.String(describing: ip)))"}
}

extension GetDedicatedIpInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDedicatedIpInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDedicatedIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDedicatedIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDedicatedIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDedicatedIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDedicatedIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDedicatedIpOutputError>
}

public struct GetDedicatedIpInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDedicatedIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDedicatedIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDedicatedIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDedicatedIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDedicatedIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDedicatedIpOutputError>
}

/// A request to obtain more information about a dedicated IP address.
public struct GetDedicatedIpInput: Swift.Equatable {
    /// The IP address that you want to obtain more information about. The value you specify
    ///             has to be a dedicated IP address that's assocaited with your Amazon Pinpoint account.
    /// This member is required.
    public let ip: Swift.String?

    public init (
        ip: Swift.String? = nil
    )
    {
        self.ip = ip
    }
}

struct GetDedicatedIpInputBody: Swift.Equatable {
}

extension GetDedicatedIpInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDedicatedIpOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDedicatedIpOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDedicatedIpOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDedicatedIpOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDedicatedIpOutputResponse(dedicatedIp: \(Swift.String(describing: dedicatedIp)))"}
}

extension GetDedicatedIpOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDedicatedIpOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dedicatedIp = output.dedicatedIp
        } else {
            self.dedicatedIp = nil
        }
    }
}

/// Information about a dedicated IP address.
public struct GetDedicatedIpOutputResponse: Swift.Equatable {
    /// An object that contains information about a dedicated IP address.
    public let dedicatedIp: PinpointEmailClientTypes.DedicatedIp?

    public init (
        dedicatedIp: PinpointEmailClientTypes.DedicatedIp? = nil
    )
    {
        self.dedicatedIp = dedicatedIp
    }
}

struct GetDedicatedIpOutputResponseBody: Swift.Equatable {
    public let dedicatedIp: PinpointEmailClientTypes.DedicatedIp?
}

extension GetDedicatedIpOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedIp = "DedicatedIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DedicatedIp.self, forKey: .dedicatedIp)
        dedicatedIp = dedicatedIpDecoded
    }
}

extension GetDedicatedIpsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDedicatedIpsInput(nextToken: \(Swift.String(describing: nextToken)), pageSize: \(Swift.String(describing: pageSize)), poolName: \(Swift.String(describing: poolName)))"}
}

extension GetDedicatedIpsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDedicatedIpsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDedicatedIpsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDedicatedIpsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDedicatedIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDedicatedIpsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDedicatedIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDedicatedIpsOutputError>
}

public struct GetDedicatedIpsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDedicatedIpsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDedicatedIpsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDedicatedIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let poolName = input.operationInput.poolName {
            let poolNameQueryItem = ClientRuntime.URLQueryItem(name: "PoolName".urlPercentEncoding(), value: Swift.String(poolName).urlPercentEncoding())
            input.builder.withQueryItem(poolNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDedicatedIpsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDedicatedIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDedicatedIpsOutputError>
}

/// A request to obtain more information about dedicated IP pools.
public struct GetDedicatedIpsInput: Swift.Equatable {
    /// A token returned from a previous call to GetDedicatedIps to indicate the
    ///             position of the dedicated IP pool in the list of IP pools.
    public let nextToken: Swift.String?
    /// The number of results to show in a single call to GetDedicatedIpsRequest.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a NextToken element, which you can use to obtain
    ///             additional results.
    public let pageSize: Swift.Int?
    /// The name of the IP pool that the dedicated IP address is associated with.
    public let poolName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        poolName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.poolName = poolName
    }
}

struct GetDedicatedIpsInputBody: Swift.Equatable {
}

extension GetDedicatedIpsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDedicatedIpsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDedicatedIpsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDedicatedIpsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDedicatedIpsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDedicatedIpsOutputResponse(dedicatedIps: \(Swift.String(describing: dedicatedIps)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDedicatedIpsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDedicatedIpsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dedicatedIps = output.dedicatedIps
            self.nextToken = output.nextToken
        } else {
            self.dedicatedIps = nil
            self.nextToken = nil
        }
    }
}

/// Information about the dedicated IP addresses that are associated with your Amazon Pinpoint
///             account.
public struct GetDedicatedIpsOutputResponse: Swift.Equatable {
    /// A list of dedicated IP addresses that are reserved for use by your Amazon Pinpoint
    ///             account.
    public let dedicatedIps: [PinpointEmailClientTypes.DedicatedIp]?
    /// A token that indicates that there are additional dedicated IP addresses to list. To
    ///             view additional addresses, issue another request to GetDedicatedIps,
    ///             passing this token in the NextToken parameter.
    public let nextToken: Swift.String?

    public init (
        dedicatedIps: [PinpointEmailClientTypes.DedicatedIp]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dedicatedIps = dedicatedIps
        self.nextToken = nextToken
    }
}

struct GetDedicatedIpsOutputResponseBody: Swift.Equatable {
    public let dedicatedIps: [PinpointEmailClientTypes.DedicatedIp]?
    public let nextToken: Swift.String?
}

extension GetDedicatedIpsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedIps = "DedicatedIps"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DedicatedIp?].self, forKey: .dedicatedIps)
        var dedicatedIpsDecoded0:[PinpointEmailClientTypes.DedicatedIp]? = nil
        if let dedicatedIpsContainer = dedicatedIpsContainer {
            dedicatedIpsDecoded0 = [PinpointEmailClientTypes.DedicatedIp]()
            for structure0 in dedicatedIpsContainer {
                if let structure0 = structure0 {
                    dedicatedIpsDecoded0?.append(structure0)
                }
            }
        }
        dedicatedIps = dedicatedIpsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDeliverabilityDashboardOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeliverabilityDashboardOptionsInput()"}
}

extension GetDeliverabilityDashboardOptionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDeliverabilityDashboardOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeliverabilityDashboardOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeliverabilityDashboardOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeliverabilityDashboardOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeliverabilityDashboardOptionsOutputError>
}

public struct GetDeliverabilityDashboardOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeliverabilityDashboardOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeliverabilityDashboardOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeliverabilityDashboardOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeliverabilityDashboardOptionsOutputError>
}

/// Retrieve information about the status of the Deliverability dashboard for your Amazon Pinpoint account.
///             When the Deliverability dashboard is enabled, you gain access to reputation, deliverability, and
///             other metrics for the domains that you use to send email using Amazon Pinpoint. You also gain the
///             ability to perform predictive inbox placement tests.
///         When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
///             to any other fees that you accrue by using Amazon Pinpoint. For more information about the
///             features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/pinpoint/pricing/">Amazon Pinpoint Pricing.
public struct GetDeliverabilityDashboardOptionsInput: Swift.Equatable {

    public init() {}
}

struct GetDeliverabilityDashboardOptionsInputBody: Swift.Equatable {
}

extension GetDeliverabilityDashboardOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeliverabilityDashboardOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeliverabilityDashboardOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeliverabilityDashboardOptionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeliverabilityDashboardOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeliverabilityDashboardOptionsOutputResponse(accountStatus: \(Swift.String(describing: accountStatus)), activeSubscribedDomains: \(Swift.String(describing: activeSubscribedDomains)), dashboardEnabled: \(Swift.String(describing: dashboardEnabled)), pendingExpirationSubscribedDomains: \(Swift.String(describing: pendingExpirationSubscribedDomains)), subscriptionExpiryDate: \(Swift.String(describing: subscriptionExpiryDate)))"}
}

extension GetDeliverabilityDashboardOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeliverabilityDashboardOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountStatus = output.accountStatus
            self.activeSubscribedDomains = output.activeSubscribedDomains
            self.dashboardEnabled = output.dashboardEnabled
            self.pendingExpirationSubscribedDomains = output.pendingExpirationSubscribedDomains
            self.subscriptionExpiryDate = output.subscriptionExpiryDate
        } else {
            self.accountStatus = nil
            self.activeSubscribedDomains = nil
            self.dashboardEnabled = false
            self.pendingExpirationSubscribedDomains = nil
            self.subscriptionExpiryDate = nil
        }
    }
}

/// An object that shows the status of the Deliverability dashboard for your Amazon Pinpoint account.
public struct GetDeliverabilityDashboardOptionsOutputResponse: Swift.Equatable {
    /// The current status of your Deliverability dashboard subscription. If this value is
    ///                 PENDING_EXPIRATION, your subscription is scheduled to expire at the end
    ///             of the current calendar month.
    public let accountStatus: PinpointEmailClientTypes.DeliverabilityDashboardAccountStatus?
    /// An array of objects, one for each verified domain that you use to send email and
    ///             currently has an active Deliverability dashboard subscription that isnt scheduled to expire at
    ///             the end of the current calendar month.
    public let activeSubscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]?
    /// Specifies whether the Deliverability dashboard is enabled for your Amazon Pinpoint account. If this value
    ///             is true, the dashboard is enabled.
    /// This member is required.
    public let dashboardEnabled: Swift.Bool
    /// An array of objects, one for each verified domain that you use to send email and
    ///             currently has an active Deliverability dashboard subscription that's scheduled to expire at the
    ///             end of the current calendar month.
    public let pendingExpirationSubscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]?
    /// The date, in Unix time format, when your current subscription to the Deliverability dashboard
    ///             is scheduled to expire, if your subscription is scheduled to expire at the end of the
    ///             current calendar month. This value is null if you have an active subscription that isnt
    ///             due to expire at the end of the month.
    public let subscriptionExpiryDate: ClientRuntime.Date?

    public init (
        accountStatus: PinpointEmailClientTypes.DeliverabilityDashboardAccountStatus? = nil,
        activeSubscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]? = nil,
        dashboardEnabled: Swift.Bool = false,
        pendingExpirationSubscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]? = nil,
        subscriptionExpiryDate: ClientRuntime.Date? = nil
    )
    {
        self.accountStatus = accountStatus
        self.activeSubscribedDomains = activeSubscribedDomains
        self.dashboardEnabled = dashboardEnabled
        self.pendingExpirationSubscribedDomains = pendingExpirationSubscribedDomains
        self.subscriptionExpiryDate = subscriptionExpiryDate
    }
}

struct GetDeliverabilityDashboardOptionsOutputResponseBody: Swift.Equatable {
    public let dashboardEnabled: Swift.Bool
    public let subscriptionExpiryDate: ClientRuntime.Date?
    public let accountStatus: PinpointEmailClientTypes.DeliverabilityDashboardAccountStatus?
    public let activeSubscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]?
    public let pendingExpirationSubscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]?
}

extension GetDeliverabilityDashboardOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountStatus = "AccountStatus"
        case activeSubscribedDomains = "ActiveSubscribedDomains"
        case dashboardEnabled = "DashboardEnabled"
        case pendingExpirationSubscribedDomains = "PendingExpirationSubscribedDomains"
        case subscriptionExpiryDate = "SubscriptionExpiryDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dashboardEnabled)
        dashboardEnabled = dashboardEnabledDecoded
        let subscriptionExpiryDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .subscriptionExpiryDate)
        subscriptionExpiryDate = subscriptionExpiryDateDecoded
        let accountStatusDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DeliverabilityDashboardAccountStatus.self, forKey: .accountStatus)
        accountStatus = accountStatusDecoded
        let activeSubscribedDomainsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DomainDeliverabilityTrackingOption?].self, forKey: .activeSubscribedDomains)
        var activeSubscribedDomainsDecoded0:[PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]? = nil
        if let activeSubscribedDomainsContainer = activeSubscribedDomainsContainer {
            activeSubscribedDomainsDecoded0 = [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]()
            for structure0 in activeSubscribedDomainsContainer {
                if let structure0 = structure0 {
                    activeSubscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        activeSubscribedDomains = activeSubscribedDomainsDecoded0
        let pendingExpirationSubscribedDomainsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DomainDeliverabilityTrackingOption?].self, forKey: .pendingExpirationSubscribedDomains)
        var pendingExpirationSubscribedDomainsDecoded0:[PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]? = nil
        if let pendingExpirationSubscribedDomainsContainer = pendingExpirationSubscribedDomainsContainer {
            pendingExpirationSubscribedDomainsDecoded0 = [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]()
            for structure0 in pendingExpirationSubscribedDomainsContainer {
                if let structure0 = structure0 {
                    pendingExpirationSubscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        pendingExpirationSubscribedDomains = pendingExpirationSubscribedDomainsDecoded0
    }
}

extension GetDeliverabilityTestReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeliverabilityTestReportInput(reportId: \(Swift.String(describing: reportId)))"}
}

extension GetDeliverabilityTestReportInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDeliverabilityTestReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeliverabilityTestReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeliverabilityTestReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeliverabilityTestReportOutputError>
}

public struct GetDeliverabilityTestReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeliverabilityTestReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeliverabilityTestReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeliverabilityTestReportOutputError>
}

/// A request to retrieve the results of a predictive inbox placement test.
public struct GetDeliverabilityTestReportInput: Swift.Equatable {
    /// A unique string that identifies the predictive inbox placement test.
    /// This member is required.
    public let reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetDeliverabilityTestReportInputBody: Swift.Equatable {
}

extension GetDeliverabilityTestReportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeliverabilityTestReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeliverabilityTestReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeliverabilityTestReportOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeliverabilityTestReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeliverabilityTestReportOutputResponse(deliverabilityTestReport: \(Swift.String(describing: deliverabilityTestReport)), ispPlacements: \(Swift.String(describing: ispPlacements)), message: \(Swift.String(describing: message)), overallPlacement: \(Swift.String(describing: overallPlacement)), tags: \(Swift.String(describing: tags)))"}
}

extension GetDeliverabilityTestReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeliverabilityTestReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deliverabilityTestReport = output.deliverabilityTestReport
            self.ispPlacements = output.ispPlacements
            self.message = output.message
            self.overallPlacement = output.overallPlacement
            self.tags = output.tags
        } else {
            self.deliverabilityTestReport = nil
            self.ispPlacements = nil
            self.message = nil
            self.overallPlacement = nil
            self.tags = nil
        }
    }
}

/// The results of the predictive inbox placement test.
public struct GetDeliverabilityTestReportOutputResponse: Swift.Equatable {
    /// An object that contains the results of the predictive inbox placement test.
    /// This member is required.
    public let deliverabilityTestReport: PinpointEmailClientTypes.DeliverabilityTestReport?
    /// An object that describes how the test email was handled by several email providers,
    ///             including Gmail, Hotmail, Yahoo, AOL, and others.
    /// This member is required.
    public let ispPlacements: [PinpointEmailClientTypes.IspPlacement]?
    /// An object that contains the message that you sent when you performed this
    ///             predictive inbox placement test.
    public let message: Swift.String?
    /// An object that specifies how many test messages that were sent during the predictive inbox placement test were
    ///             delivered to recipients' inboxes, how many were sent to recipients' spam folders, and
    ///             how many weren't delivered.
    /// This member is required.
    public let overallPlacement: PinpointEmailClientTypes.PlacementStatistics?
    /// An array of objects that define the tags (keys and values) that are associated with
    ///             the predictive inbox placement test.
    public let tags: [PinpointEmailClientTypes.Tag]?

    public init (
        deliverabilityTestReport: PinpointEmailClientTypes.DeliverabilityTestReport? = nil,
        ispPlacements: [PinpointEmailClientTypes.IspPlacement]? = nil,
        message: Swift.String? = nil,
        overallPlacement: PinpointEmailClientTypes.PlacementStatistics? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil
    )
    {
        self.deliverabilityTestReport = deliverabilityTestReport
        self.ispPlacements = ispPlacements
        self.message = message
        self.overallPlacement = overallPlacement
        self.tags = tags
    }
}

struct GetDeliverabilityTestReportOutputResponseBody: Swift.Equatable {
    public let deliverabilityTestReport: PinpointEmailClientTypes.DeliverabilityTestReport?
    public let overallPlacement: PinpointEmailClientTypes.PlacementStatistics?
    public let ispPlacements: [PinpointEmailClientTypes.IspPlacement]?
    public let message: Swift.String?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension GetDeliverabilityTestReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliverabilityTestReport = "DeliverabilityTestReport"
        case ispPlacements = "IspPlacements"
        case message = "Message"
        case overallPlacement = "OverallPlacement"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliverabilityTestReportDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DeliverabilityTestReport.self, forKey: .deliverabilityTestReport)
        deliverabilityTestReport = deliverabilityTestReportDecoded
        let overallPlacementDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.PlacementStatistics.self, forKey: .overallPlacement)
        overallPlacement = overallPlacementDecoded
        let ispPlacementsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.IspPlacement?].self, forKey: .ispPlacements)
        var ispPlacementsDecoded0:[PinpointEmailClientTypes.IspPlacement]? = nil
        if let ispPlacementsContainer = ispPlacementsContainer {
            ispPlacementsDecoded0 = [PinpointEmailClientTypes.IspPlacement]()
            for structure0 in ispPlacementsContainer {
                if let structure0 = structure0 {
                    ispPlacementsDecoded0?.append(structure0)
                }
            }
        }
        ispPlacements = ispPlacementsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDomainDeliverabilityCampaignInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainDeliverabilityCampaignInput(campaignId: \(Swift.String(describing: campaignId)))"}
}

extension GetDomainDeliverabilityCampaignInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDomainDeliverabilityCampaignInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDomainDeliverabilityCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDomainDeliverabilityCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDomainDeliverabilityCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDomainDeliverabilityCampaignOutputError>
}

public struct GetDomainDeliverabilityCampaignInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDomainDeliverabilityCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDomainDeliverabilityCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDomainDeliverabilityCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDomainDeliverabilityCampaignOutputError>
}

/// Retrieve all the deliverability data for a specific campaign. This data is available
///             for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for (PutDeliverabilityDashboardOption
///             operation).
public struct GetDomainDeliverabilityCampaignInput: Swift.Equatable {
    /// The unique identifier for the campaign. Amazon Pinpoint automatically generates and assigns this
    ///             identifier to a campaign. This value is not the same as the campaign identifier that
    ///             Amazon Pinpoint assigns to campaigns that you create and manage by using the Amazon Pinpoint API or the
    ///             Amazon Pinpoint console.
    /// This member is required.
    public let campaignId: Swift.String?

    public init (
        campaignId: Swift.String? = nil
    )
    {
        self.campaignId = campaignId
    }
}

struct GetDomainDeliverabilityCampaignInputBody: Swift.Equatable {
}

extension GetDomainDeliverabilityCampaignInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainDeliverabilityCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainDeliverabilityCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainDeliverabilityCampaignOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainDeliverabilityCampaignOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainDeliverabilityCampaignOutputResponse(domainDeliverabilityCampaign: \(Swift.String(describing: domainDeliverabilityCampaign)))"}
}

extension GetDomainDeliverabilityCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainDeliverabilityCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainDeliverabilityCampaign = output.domainDeliverabilityCampaign
        } else {
            self.domainDeliverabilityCampaign = nil
        }
    }
}

/// An object that contains all the deliverability data for a specific campaign. This data
///             is available for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for (PutDeliverabilityDashboardOption
///             operation).
public struct GetDomainDeliverabilityCampaignOutputResponse: Swift.Equatable {
    /// An object that contains the deliverability data for the campaign.
    /// This member is required.
    public let domainDeliverabilityCampaign: PinpointEmailClientTypes.DomainDeliverabilityCampaign?

    public init (
        domainDeliverabilityCampaign: PinpointEmailClientTypes.DomainDeliverabilityCampaign? = nil
    )
    {
        self.domainDeliverabilityCampaign = domainDeliverabilityCampaign
    }
}

struct GetDomainDeliverabilityCampaignOutputResponseBody: Swift.Equatable {
    public let domainDeliverabilityCampaign: PinpointEmailClientTypes.DomainDeliverabilityCampaign?
}

extension GetDomainDeliverabilityCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainDeliverabilityCampaign = "DomainDeliverabilityCampaign"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDeliverabilityCampaignDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DomainDeliverabilityCampaign.self, forKey: .domainDeliverabilityCampaign)
        domainDeliverabilityCampaign = domainDeliverabilityCampaignDecoded
    }
}

extension GetDomainStatisticsReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainStatisticsReportInput(domain: \(Swift.String(describing: domain)), endDate: \(Swift.String(describing: endDate)), startDate: \(Swift.String(describing: startDate)))"}
}

extension GetDomainStatisticsReportInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDomainStatisticsReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDomainStatisticsReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDomainStatisticsReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDomainStatisticsReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDomainStatisticsReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDomainStatisticsReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDomainStatisticsReportOutputError>
}

public struct GetDomainStatisticsReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDomainStatisticsReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDomainStatisticsReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDomainStatisticsReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "StartDate".urlPercentEncoding(), value: Swift.String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "EndDate".urlPercentEncoding(), value: Swift.String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDomainStatisticsReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDomainStatisticsReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDomainStatisticsReportOutputError>
}

/// A request to obtain deliverability metrics for a domain.
public struct GetDomainStatisticsReportInput: Swift.Equatable {
    /// The domain that you want to obtain deliverability metrics for.
    /// This member is required.
    public let domain: Swift.String?
    /// The last day (in Unix time) that you want to obtain domain deliverability metrics for.
    ///             The EndDate that you specify has to be less than or equal to 30 days after
    ///             the StartDate.
    /// This member is required.
    public let endDate: ClientRuntime.Date?
    /// The first day (in Unix time) that you want to obtain domain deliverability metrics
    ///             for.
    /// This member is required.
    public let startDate: ClientRuntime.Date?

    public init (
        domain: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        startDate: ClientRuntime.Date? = nil
    )
    {
        self.domain = domain
        self.endDate = endDate
        self.startDate = startDate
    }
}

struct GetDomainStatisticsReportInputBody: Swift.Equatable {
}

extension GetDomainStatisticsReportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainStatisticsReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainStatisticsReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainStatisticsReportOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainStatisticsReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainStatisticsReportOutputResponse(dailyVolumes: \(Swift.String(describing: dailyVolumes)), overallVolume: \(Swift.String(describing: overallVolume)))"}
}

extension GetDomainStatisticsReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainStatisticsReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dailyVolumes = output.dailyVolumes
            self.overallVolume = output.overallVolume
        } else {
            self.dailyVolumes = nil
            self.overallVolume = nil
        }
    }
}

/// An object that includes statistics that are related to the domain that you
///             specified.
public struct GetDomainStatisticsReportOutputResponse: Swift.Equatable {
    /// An object that contains deliverability metrics for the domain that you specified. This
    ///             object contains data for each day, starting on the StartDate and ending on
    ///             the EndDate.
    /// This member is required.
    public let dailyVolumes: [PinpointEmailClientTypes.DailyVolume]?
    /// An object that contains deliverability metrics for the domain that you specified. The
    ///             data in this object is a summary of all of the data that was collected from the
    ///                 StartDate to the EndDate.
    /// This member is required.
    public let overallVolume: PinpointEmailClientTypes.OverallVolume?

    public init (
        dailyVolumes: [PinpointEmailClientTypes.DailyVolume]? = nil,
        overallVolume: PinpointEmailClientTypes.OverallVolume? = nil
    )
    {
        self.dailyVolumes = dailyVolumes
        self.overallVolume = overallVolume
    }
}

struct GetDomainStatisticsReportOutputResponseBody: Swift.Equatable {
    public let overallVolume: PinpointEmailClientTypes.OverallVolume?
    public let dailyVolumes: [PinpointEmailClientTypes.DailyVolume]?
}

extension GetDomainStatisticsReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dailyVolumes = "DailyVolumes"
        case overallVolume = "OverallVolume"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overallVolumeDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.OverallVolume.self, forKey: .overallVolume)
        overallVolume = overallVolumeDecoded
        let dailyVolumesContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DailyVolume?].self, forKey: .dailyVolumes)
        var dailyVolumesDecoded0:[PinpointEmailClientTypes.DailyVolume]? = nil
        if let dailyVolumesContainer = dailyVolumesContainer {
            dailyVolumesDecoded0 = [PinpointEmailClientTypes.DailyVolume]()
            for structure0 in dailyVolumesContainer {
                if let structure0 = structure0 {
                    dailyVolumesDecoded0?.append(structure0)
                }
            }
        }
        dailyVolumes = dailyVolumesDecoded0
    }
}

extension GetEmailIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEmailIdentityInput(emailIdentity: \(Swift.String(describing: emailIdentity)))"}
}

extension GetEmailIdentityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEmailIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEmailIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEmailIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEmailIdentityOutputError>
}

public struct GetEmailIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEmailIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEmailIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEmailIdentityOutputError>
}

/// A request to return details about an email identity.
public struct GetEmailIdentityInput: Swift.Equatable {
    /// The email identity that you want to retrieve details for.
    /// This member is required.
    public let emailIdentity: Swift.String?

    public init (
        emailIdentity: Swift.String? = nil
    )
    {
        self.emailIdentity = emailIdentity
    }
}

struct GetEmailIdentityInputBody: Swift.Equatable {
}

extension GetEmailIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEmailIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEmailIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEmailIdentityOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEmailIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEmailIdentityOutputResponse(dkimAttributes: \(Swift.String(describing: dkimAttributes)), feedbackForwardingStatus: \(Swift.String(describing: feedbackForwardingStatus)), identityType: \(Swift.String(describing: identityType)), mailFromAttributes: \(Swift.String(describing: mailFromAttributes)), tags: \(Swift.String(describing: tags)), verifiedForSendingStatus: \(Swift.String(describing: verifiedForSendingStatus)))"}
}

extension GetEmailIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEmailIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dkimAttributes = output.dkimAttributes
            self.feedbackForwardingStatus = output.feedbackForwardingStatus
            self.identityType = output.identityType
            self.mailFromAttributes = output.mailFromAttributes
            self.tags = output.tags
            self.verifiedForSendingStatus = output.verifiedForSendingStatus
        } else {
            self.dkimAttributes = nil
            self.feedbackForwardingStatus = false
            self.identityType = nil
            self.mailFromAttributes = nil
            self.tags = nil
            self.verifiedForSendingStatus = false
        }
    }
}

/// Details about an email identity.
public struct GetEmailIdentityOutputResponse: Swift.Equatable {
    /// An object that contains information about the DKIM attributes for the identity. This
    ///             object includes the tokens that you use to create the CNAME records that are required to
    ///             complete the DKIM verification process.
    public let dkimAttributes: PinpointEmailClientTypes.DkimAttributes?
    /// The feedback forwarding configuration for the identity.
    ///         If the value is true, Amazon Pinpoint sends you email notifications when bounce or
    ///             complaint events occur. Amazon Pinpoint sends this notification to the address that you specified
    ///             in the Return-Path header of the original email.
    ///         When you set this value to false, Amazon Pinpoint sends notifications through other
    ///             mechanisms, such as by notifying an Amazon SNS topic or another event destination. You're
    ///             required to have a method of tracking bounces and complaints. If you haven't set up
    ///             another mechanism for receiving bounce or complaint notifications, Amazon Pinpoint sends an email
    ///             notification when these events occur (even if this setting is disabled).
    public let feedbackForwardingStatus: Swift.Bool
    /// The email identity type.
    public let identityType: PinpointEmailClientTypes.IdentityType?
    /// An object that contains information about the Mail-From attributes for the email
    ///             identity.
    public let mailFromAttributes: PinpointEmailClientTypes.MailFromAttributes?
    /// An array of objects that define the tags (keys and values) that are associated with
    ///             the email identity.
    public let tags: [PinpointEmailClientTypes.Tag]?
    /// Specifies whether or not the identity is verified. In Amazon Pinpoint, you can only send email
    ///             from verified email addresses or domains. For more information about verifying
    ///             identities, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide.
    public let verifiedForSendingStatus: Swift.Bool

    public init (
        dkimAttributes: PinpointEmailClientTypes.DkimAttributes? = nil,
        feedbackForwardingStatus: Swift.Bool = false,
        identityType: PinpointEmailClientTypes.IdentityType? = nil,
        mailFromAttributes: PinpointEmailClientTypes.MailFromAttributes? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil,
        verifiedForSendingStatus: Swift.Bool = false
    )
    {
        self.dkimAttributes = dkimAttributes
        self.feedbackForwardingStatus = feedbackForwardingStatus
        self.identityType = identityType
        self.mailFromAttributes = mailFromAttributes
        self.tags = tags
        self.verifiedForSendingStatus = verifiedForSendingStatus
    }
}

struct GetEmailIdentityOutputResponseBody: Swift.Equatable {
    public let identityType: PinpointEmailClientTypes.IdentityType?
    public let feedbackForwardingStatus: Swift.Bool
    public let verifiedForSendingStatus: Swift.Bool
    public let dkimAttributes: PinpointEmailClientTypes.DkimAttributes?
    public let mailFromAttributes: PinpointEmailClientTypes.MailFromAttributes?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension GetEmailIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dkimAttributes = "DkimAttributes"
        case feedbackForwardingStatus = "FeedbackForwardingStatus"
        case identityType = "IdentityType"
        case mailFromAttributes = "MailFromAttributes"
        case tags = "Tags"
        case verifiedForSendingStatus = "VerifiedForSendingStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let feedbackForwardingStatusDecoded = try containerValues.decode(Swift.Bool.self, forKey: .feedbackForwardingStatus)
        feedbackForwardingStatus = feedbackForwardingStatusDecoded
        let verifiedForSendingStatusDecoded = try containerValues.decode(Swift.Bool.self, forKey: .verifiedForSendingStatus)
        verifiedForSendingStatus = verifiedForSendingStatusDecoded
        let dkimAttributesDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.DkimAttributes.self, forKey: .dkimAttributes)
        dkimAttributes = dkimAttributesDecoded
        let mailFromAttributesDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.MailFromAttributes.self, forKey: .mailFromAttributes)
        mailFromAttributes = mailFromAttributesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PinpointEmailClientTypes.IdentityInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityName = "IdentityName"
        case identityType = "IdentityType"
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityName = identityName {
            try encodeContainer.encode(identityName, forKey: .identityName)
        }
        if let identityType = identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let identityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityName)
        identityName = identityNameDecoded
        let sendingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PinpointEmailClientTypes.IdentityInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityInfo(identityName: \(Swift.String(describing: identityName)), identityType: \(Swift.String(describing: identityType)), sendingEnabled: \(Swift.String(describing: sendingEnabled)))"}
}

extension PinpointEmailClientTypes {
    /// Information about an email identity.
    public struct IdentityInfo: Swift.Equatable {
        /// The address or domain of the identity.
        public let identityName: Swift.String?
        /// The email identity type. The identity type can be one of the following:
        ///
        ///
        ///
        ///                   EMAIL_ADDRESS  The identity is an email address.
        ///
        ///
        ///
        ///                   DOMAIN  The identity is a domain.
        ///
        ///
        ///
        ///                   MANAGED_DOMAIN  The identity is a domain that is managed
        ///                     by AWS.
        ///
        ///
        public let identityType: PinpointEmailClientTypes.IdentityType?
        /// Indicates whether or not you can send email from the identity.
        ///         In Amazon Pinpoint, an identity is an email address or domain that you send email from. Before
        ///             you can send email from an identity, you have to demostrate that you own the identity,
        ///             and that you authorize Amazon Pinpoint to send email from that identity.
        public let sendingEnabled: Swift.Bool

        public init (
            identityName: Swift.String? = nil,
            identityType: PinpointEmailClientTypes.IdentityType? = nil,
            sendingEnabled: Swift.Bool = false
        )
        {
            self.identityName = identityName
            self.identityType = identityType
            self.sendingEnabled = sendingEnabled
        }
    }

}

extension PinpointEmailClientTypes {
    /// The email identity type. The identity type can be one of the following:
    ///
    ///
    ///
    ///                   EMAIL_ADDRESS  The identity is an email address.
    ///
    ///
    ///
    ///                   DOMAIN  The identity is a domain.
    ///
    ///
    public enum IdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domain
        case emailAddress
        case managedDomain
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .domain,
                .emailAddress,
                .managedDomain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domain: return "DOMAIN"
            case .emailAddress: return "EMAIL_ADDRESS"
            case .managedDomain: return "MANAGED_DOMAIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
        }
    }
}

extension PinpointEmailClientTypes.InboxPlacementTrackingOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case global = "Global"
        case trackedIsps = "TrackedIsps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if global != false {
            try encodeContainer.encode(global, forKey: .global)
        }
        if let trackedIsps = trackedIsps {
            var trackedIspsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trackedIsps)
            for ispnamelist0 in trackedIsps {
                try trackedIspsContainer.encode(ispnamelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .global)
        global = globalDecoded
        let trackedIspsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trackedIsps)
        var trackedIspsDecoded0:[Swift.String]? = nil
        if let trackedIspsContainer = trackedIspsContainer {
            trackedIspsDecoded0 = [Swift.String]()
            for string0 in trackedIspsContainer {
                if let string0 = string0 {
                    trackedIspsDecoded0?.append(string0)
                }
            }
        }
        trackedIsps = trackedIspsDecoded0
    }
}

extension PinpointEmailClientTypes.InboxPlacementTrackingOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InboxPlacementTrackingOption(global: \(Swift.String(describing: global)), trackedIsps: \(Swift.String(describing: trackedIsps)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about the inbox placement data settings for a
    ///             verified domain thats associated with your AWS account. This data is available only
    ///             if you enabled the Deliverability dashboard for the domain
    ///                 (PutDeliverabilityDashboardOption operation).
    public struct InboxPlacementTrackingOption: Swift.Equatable {
        /// Specifies whether inbox placement data is being tracked for the domain.
        public let global: Swift.Bool
        /// An array of strings, one for each major email provider that the inbox placement data
        ///             applies to.
        public let trackedIsps: [Swift.String]?

        public init (
            global: Swift.Bool = false,
            trackedIsps: [Swift.String]? = nil
        )
        {
            self.global = global
            self.trackedIsps = trackedIsps
        }
    }

}

extension PinpointEmailClientTypes.IspPlacement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ispName = "IspName"
        case placementStatistics = "PlacementStatistics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ispName = ispName {
            try encodeContainer.encode(ispName, forKey: .ispName)
        }
        if let placementStatistics = placementStatistics {
            try encodeContainer.encode(placementStatistics, forKey: .placementStatistics)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ispNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ispName)
        ispName = ispNameDecoded
        let placementStatisticsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.PlacementStatistics.self, forKey: .placementStatistics)
        placementStatistics = placementStatisticsDecoded
    }
}

extension PinpointEmailClientTypes.IspPlacement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IspPlacement(ispName: \(Swift.String(describing: ispName)), placementStatistics: \(Swift.String(describing: placementStatistics)))"}
}

extension PinpointEmailClientTypes {
    /// An object that describes how email sent during the predictive inbox placement test was handled by a certain
    ///             email provider.
    public struct IspPlacement: Swift.Equatable {
        /// The name of the email provider that the inbox placement data applies to.
        public let ispName: Swift.String?
        /// An object that contains inbox placement metrics for a specific email provider.
        public let placementStatistics: PinpointEmailClientTypes.PlacementStatistics?

        public init (
            ispName: Swift.String? = nil,
            placementStatistics: PinpointEmailClientTypes.PlacementStatistics? = nil
        )
        {
            self.ispName = ispName
            self.placementStatistics = placementStatistics
        }
    }

}

extension PinpointEmailClientTypes.KinesisFirehoseDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
    }
}

extension PinpointEmailClientTypes.KinesisFirehoseDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisFirehoseDestination(deliveryStreamArn: \(Swift.String(describing: deliveryStreamArn)), iamRoleArn: \(Swift.String(describing: iamRoleArn)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
    ///             stream data to other services, such as Amazon S3 and Amazon Redshift.
    public struct KinesisFirehoseDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that Amazon Pinpoint sends email events
        ///             to.
        /// This member is required.
        public let deliveryStreamArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that Amazon Pinpoint uses when sending email
        ///             events to the Amazon Kinesis Data Firehose stream.
        /// This member is required.
        public let iamRoleArn: Swift.String?

        public init (
            deliveryStreamArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are too many instances of the specified resource type.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationSetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationSetsInput(nextToken: \(Swift.String(describing: nextToken)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension ListConfigurationSetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConfigurationSetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationSetsOutputError>
}

public struct ListConfigurationSetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationSetsOutputError>
}

/// A request to obtain a list of configuration sets for your Amazon Pinpoint account in the current
///             AWS Region.
public struct ListConfigurationSetsInput: Swift.Equatable {
    /// A token returned from a previous call to ListConfigurationSets to
    ///             indicate the position in the list of configuration sets.
    public let nextToken: Swift.String?
    /// The number of results to show in a single call to ListConfigurationSets.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a NextToken element, which you can use to obtain
    ///             additional results.
    public let pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListConfigurationSetsInputBody: Swift.Equatable {
}

extension ListConfigurationSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationSetsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationSetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationSetsOutputResponse(configurationSets: \(Swift.String(describing: configurationSets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

/// A list of configuration sets in your Amazon Pinpoint account in the current AWS Region.
public struct ListConfigurationSetsOutputResponse: Swift.Equatable {
    /// An array that contains all of the configuration sets in your Amazon Pinpoint account in the
    ///             current AWS Region.
    public let configurationSets: [Swift.String]?
    /// A token that indicates that there are additional configuration sets to list. To view
    ///             additional configuration sets, issue another request to
    ///                 ListConfigurationSets, and pass this token in the
    ///                 NextToken parameter.
    public let nextToken: Swift.String?

    public init (
        configurationSets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct ListConfigurationSetsOutputResponseBody: Swift.Equatable {
    public let configurationSets: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListConfigurationSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[Swift.String]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [Swift.String]()
            for string0 in configurationSetsContainer {
                if let string0 = string0 {
                    configurationSetsDecoded0?.append(string0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDedicatedIpPoolsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDedicatedIpPoolsInput(nextToken: \(Swift.String(describing: nextToken)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension ListDedicatedIpPoolsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDedicatedIpPoolsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDedicatedIpPoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDedicatedIpPoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDedicatedIpPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDedicatedIpPoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDedicatedIpPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDedicatedIpPoolsOutputError>
}

public struct ListDedicatedIpPoolsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDedicatedIpPoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDedicatedIpPoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDedicatedIpPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDedicatedIpPoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDedicatedIpPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDedicatedIpPoolsOutputError>
}

/// A request to obtain a list of dedicated IP pools.
public struct ListDedicatedIpPoolsInput: Swift.Equatable {
    /// A token returned from a previous call to ListDedicatedIpPools to indicate
    ///             the position in the list of dedicated IP pools.
    public let nextToken: Swift.String?
    /// The number of results to show in a single call to ListDedicatedIpPools.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a NextToken element, which you can use to obtain
    ///             additional results.
    public let pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListDedicatedIpPoolsInputBody: Swift.Equatable {
}

extension ListDedicatedIpPoolsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDedicatedIpPoolsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDedicatedIpPoolsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDedicatedIpPoolsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDedicatedIpPoolsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDedicatedIpPoolsOutputResponse(dedicatedIpPools: \(Swift.String(describing: dedicatedIpPools)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDedicatedIpPoolsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDedicatedIpPoolsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dedicatedIpPools = output.dedicatedIpPools
            self.nextToken = output.nextToken
        } else {
            self.dedicatedIpPools = nil
            self.nextToken = nil
        }
    }
}

/// A list of dedicated IP pools.
public struct ListDedicatedIpPoolsOutputResponse: Swift.Equatable {
    /// A list of all of the dedicated IP pools that are associated with your Amazon Pinpoint
    ///             account.
    public let dedicatedIpPools: [Swift.String]?
    /// A token that indicates that there are additional IP pools to list. To view additional
    ///             IP pools, issue another request to ListDedicatedIpPools, passing this token
    ///             in the NextToken parameter.
    public let nextToken: Swift.String?

    public init (
        dedicatedIpPools: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dedicatedIpPools = dedicatedIpPools
        self.nextToken = nextToken
    }
}

struct ListDedicatedIpPoolsOutputResponseBody: Swift.Equatable {
    public let dedicatedIpPools: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListDedicatedIpPoolsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedIpPools = "DedicatedIpPools"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpPoolsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dedicatedIpPools)
        var dedicatedIpPoolsDecoded0:[Swift.String]? = nil
        if let dedicatedIpPoolsContainer = dedicatedIpPoolsContainer {
            dedicatedIpPoolsDecoded0 = [Swift.String]()
            for string0 in dedicatedIpPoolsContainer {
                if let string0 = string0 {
                    dedicatedIpPoolsDecoded0?.append(string0)
                }
            }
        }
        dedicatedIpPools = dedicatedIpPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeliverabilityTestReportsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeliverabilityTestReportsInput(nextToken: \(Swift.String(describing: nextToken)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension ListDeliverabilityTestReportsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDeliverabilityTestReportsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeliverabilityTestReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeliverabilityTestReportsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeliverabilityTestReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeliverabilityTestReportsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeliverabilityTestReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeliverabilityTestReportsOutputError>
}

public struct ListDeliverabilityTestReportsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeliverabilityTestReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeliverabilityTestReportsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeliverabilityTestReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeliverabilityTestReportsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeliverabilityTestReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeliverabilityTestReportsOutputError>
}

/// A request to list all of the predictive inbox placement tests that you've performed.
public struct ListDeliverabilityTestReportsInput: Swift.Equatable {
    /// A token returned from a previous call to ListDeliverabilityTestReports to
    ///             indicate the position in the list of predictive inbox placement tests.
    public let nextToken: Swift.String?
    /// The number of results to show in a single call to
    ///                 ListDeliverabilityTestReports. If the number of results is larger than
    ///             the number you specified in this parameter, then the response includes a
    ///                 NextToken element, which you can use to obtain additional
    ///             results.
    ///         The value you specify has to be at least 0, and can be no more than 1000.
    public let pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListDeliverabilityTestReportsInputBody: Swift.Equatable {
}

extension ListDeliverabilityTestReportsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeliverabilityTestReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeliverabilityTestReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeliverabilityTestReportsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeliverabilityTestReportsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeliverabilityTestReportsOutputResponse(deliverabilityTestReports: \(Swift.String(describing: deliverabilityTestReports)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeliverabilityTestReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeliverabilityTestReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deliverabilityTestReports = output.deliverabilityTestReports
            self.nextToken = output.nextToken
        } else {
            self.deliverabilityTestReports = nil
            self.nextToken = nil
        }
    }
}

/// A list of the predictive inbox placement test reports that are available for your account, regardless of
///             whether or not those tests are complete.
public struct ListDeliverabilityTestReportsOutputResponse: Swift.Equatable {
    /// An object that contains a lists of predictive inbox placement tests that you've performed.
    /// This member is required.
    public let deliverabilityTestReports: [PinpointEmailClientTypes.DeliverabilityTestReport]?
    /// A token that indicates that there are additional predictive inbox placement tests to list. To view additional
    ///             predictive inbox placement tests, issue another request to ListDeliverabilityTestReports, and pass
    ///             this token in the NextToken parameter.
    public let nextToken: Swift.String?

    public init (
        deliverabilityTestReports: [PinpointEmailClientTypes.DeliverabilityTestReport]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deliverabilityTestReports = deliverabilityTestReports
        self.nextToken = nextToken
    }
}

struct ListDeliverabilityTestReportsOutputResponseBody: Swift.Equatable {
    public let deliverabilityTestReports: [PinpointEmailClientTypes.DeliverabilityTestReport]?
    public let nextToken: Swift.String?
}

extension ListDeliverabilityTestReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliverabilityTestReports = "DeliverabilityTestReports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliverabilityTestReportsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DeliverabilityTestReport?].self, forKey: .deliverabilityTestReports)
        var deliverabilityTestReportsDecoded0:[PinpointEmailClientTypes.DeliverabilityTestReport]? = nil
        if let deliverabilityTestReportsContainer = deliverabilityTestReportsContainer {
            deliverabilityTestReportsDecoded0 = [PinpointEmailClientTypes.DeliverabilityTestReport]()
            for structure0 in deliverabilityTestReportsContainer {
                if let structure0 = structure0 {
                    deliverabilityTestReportsDecoded0?.append(structure0)
                }
            }
        }
        deliverabilityTestReports = deliverabilityTestReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainDeliverabilityCampaignsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainDeliverabilityCampaignsInput(endDate: \(Swift.String(describing: endDate)), nextToken: \(Swift.String(describing: nextToken)), pageSize: \(Swift.String(describing: pageSize)), startDate: \(Swift.String(describing: startDate)), subscribedDomain: \(Swift.String(describing: subscribedDomain)))"}
}

extension ListDomainDeliverabilityCampaignsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDomainDeliverabilityCampaignsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainDeliverabilityCampaignsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainDeliverabilityCampaignsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainDeliverabilityCampaignsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainDeliverabilityCampaignsOutputError>
}

public struct ListDomainDeliverabilityCampaignsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainDeliverabilityCampaignsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainDeliverabilityCampaignsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "StartDate".urlPercentEncoding(), value: Swift.String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "EndDate".urlPercentEncoding(), value: Swift.String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainDeliverabilityCampaignsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainDeliverabilityCampaignsOutputError>
}

/// Retrieve deliverability data for all the campaigns that used a specific domain to send
///             email during a specified time range. This data is available for a domain only if you
///             enabled the Deliverability dashboard (PutDeliverabilityDashboardOption operation)
///             for the domain.
public struct ListDomainDeliverabilityCampaignsInput: Swift.Equatable {
    /// The last day, in Unix time format, that you want to obtain deliverability data for.
    ///             This value has to be less than or equal to 30 days after the value of the
    ///                 StartDate parameter.
    /// This member is required.
    public let endDate: ClientRuntime.Date?
    /// A token thats returned from a previous call to the
    ///                 ListDomainDeliverabilityCampaigns operation. This token indicates the
    ///             position of a campaign in the list of campaigns.
    public let nextToken: Swift.String?
    /// The maximum number of results to include in response to a single call to the
    ///                 ListDomainDeliverabilityCampaigns operation. If the number of results
    ///             is larger than the number that you specify in this parameter, the response includes a
    ///                 NextToken element, which you can use to obtain additional
    ///             results.
    public let pageSize: Swift.Int?
    /// The first day, in Unix time format, that you want to obtain deliverability data
    ///             for.
    /// This member is required.
    public let startDate: ClientRuntime.Date?
    /// The domain to obtain deliverability data for.
    /// This member is required.
    public let subscribedDomain: Swift.String?

    public init (
        endDate: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        startDate: ClientRuntime.Date? = nil,
        subscribedDomain: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startDate = startDate
        self.subscribedDomain = subscribedDomain
    }
}

struct ListDomainDeliverabilityCampaignsInputBody: Swift.Equatable {
}

extension ListDomainDeliverabilityCampaignsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainDeliverabilityCampaignsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainDeliverabilityCampaignsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainDeliverabilityCampaignsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainDeliverabilityCampaignsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainDeliverabilityCampaignsOutputResponse(domainDeliverabilityCampaigns: \(Swift.String(describing: domainDeliverabilityCampaigns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDomainDeliverabilityCampaignsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainDeliverabilityCampaignsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainDeliverabilityCampaigns = output.domainDeliverabilityCampaigns
            self.nextToken = output.nextToken
        } else {
            self.domainDeliverabilityCampaigns = nil
            self.nextToken = nil
        }
    }
}

/// An array of objects that provide deliverability data for all the campaigns that used a
///             specific domain to send email during a specified time range. This data is available for
///             a domain only if you enabled the Deliverability dashboard
///                 (PutDeliverabilityDashboardOption operation) for the domain.
public struct ListDomainDeliverabilityCampaignsOutputResponse: Swift.Equatable {
    /// An array of responses, one for each campaign that used the domain to send email during
    ///             the specified time range.
    /// This member is required.
    public let domainDeliverabilityCampaigns: [PinpointEmailClientTypes.DomainDeliverabilityCampaign]?
    /// A token thats returned from a previous call to the
    ///                 ListDomainDeliverabilityCampaigns operation. This token indicates the
    ///             position of the campaign in the list of campaigns.
    public let nextToken: Swift.String?

    public init (
        domainDeliverabilityCampaigns: [PinpointEmailClientTypes.DomainDeliverabilityCampaign]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainDeliverabilityCampaigns = domainDeliverabilityCampaigns
        self.nextToken = nextToken
    }
}

struct ListDomainDeliverabilityCampaignsOutputResponseBody: Swift.Equatable {
    public let domainDeliverabilityCampaigns: [PinpointEmailClientTypes.DomainDeliverabilityCampaign]?
    public let nextToken: Swift.String?
}

extension ListDomainDeliverabilityCampaignsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainDeliverabilityCampaigns = "DomainDeliverabilityCampaigns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDeliverabilityCampaignsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DomainDeliverabilityCampaign?].self, forKey: .domainDeliverabilityCampaigns)
        var domainDeliverabilityCampaignsDecoded0:[PinpointEmailClientTypes.DomainDeliverabilityCampaign]? = nil
        if let domainDeliverabilityCampaignsContainer = domainDeliverabilityCampaignsContainer {
            domainDeliverabilityCampaignsDecoded0 = [PinpointEmailClientTypes.DomainDeliverabilityCampaign]()
            for structure0 in domainDeliverabilityCampaignsContainer {
                if let structure0 = structure0 {
                    domainDeliverabilityCampaignsDecoded0?.append(structure0)
                }
            }
        }
        domainDeliverabilityCampaigns = domainDeliverabilityCampaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEmailIdentitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEmailIdentitiesInput(nextToken: \(Swift.String(describing: nextToken)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension ListEmailIdentitiesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEmailIdentitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEmailIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEmailIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEmailIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEmailIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEmailIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEmailIdentitiesOutputError>
}

public struct ListEmailIdentitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEmailIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEmailIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEmailIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEmailIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEmailIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEmailIdentitiesOutputError>
}

/// A request to list all of the email identities associated with your Amazon Pinpoint account. This
///             list includes identities that you've already verified, identities that are unverified,
///             and identities that were verified in the past, but are no longer verified.
public struct ListEmailIdentitiesInput: Swift.Equatable {
    /// A token returned from a previous call to ListEmailIdentities to indicate
    ///             the position in the list of identities.
    public let nextToken: Swift.String?
    /// The number of results to show in a single call to ListEmailIdentities. If
    ///             the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a NextToken element, which you can use to obtain
    ///             additional results.
    ///         The value you specify has to be at least 0, and can be no more than 1000.
    public let pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListEmailIdentitiesInputBody: Swift.Equatable {
}

extension ListEmailIdentitiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEmailIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEmailIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEmailIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEmailIdentitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEmailIdentitiesOutputResponse(emailIdentities: \(Swift.String(describing: emailIdentities)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEmailIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEmailIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emailIdentities = output.emailIdentities
            self.nextToken = output.nextToken
        } else {
            self.emailIdentities = nil
            self.nextToken = nil
        }
    }
}

/// A list of all of the identities that you've attempted to verify for use with Amazon Pinpoint,
///             regardless of whether or not those identities were successfully verified.
public struct ListEmailIdentitiesOutputResponse: Swift.Equatable {
    /// An array that includes all of the identities associated with your Amazon Pinpoint
    ///             account.
    public let emailIdentities: [PinpointEmailClientTypes.IdentityInfo]?
    /// A token that indicates that there are additional configuration sets to list. To view
    ///             additional configuration sets, issue another request to
    ///             ListEmailIdentities, and pass this token in the NextToken
    ///             parameter.
    public let nextToken: Swift.String?

    public init (
        emailIdentities: [PinpointEmailClientTypes.IdentityInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.emailIdentities = emailIdentities
        self.nextToken = nextToken
    }
}

struct ListEmailIdentitiesOutputResponseBody: Swift.Equatable {
    public let emailIdentities: [PinpointEmailClientTypes.IdentityInfo]?
    public let nextToken: Swift.String?
}

extension ListEmailIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailIdentities = "EmailIdentities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailIdentitiesContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.IdentityInfo?].self, forKey: .emailIdentities)
        var emailIdentitiesDecoded0:[PinpointEmailClientTypes.IdentityInfo]? = nil
        if let emailIdentitiesContainer = emailIdentitiesContainer {
            emailIdentitiesDecoded0 = [PinpointEmailClientTypes.IdentityInfo]()
            for structure0 in emailIdentitiesContainer {
                if let structure0 = structure0 {
                    emailIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        emailIdentities = emailIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "ResourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tag
    ///             information for.
    /// This member is required.
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// An array that lists all the tags that are associated with the resource. Each tag
    ///             consists of a required tag key (Key) and an associated tag value
    ///                 (Value)
    /// This member is required.
    public let tags: [PinpointEmailClientTypes.Tag]?

    public init (
        tags: [PinpointEmailClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PinpointEmailClientTypes.MailFromAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
        case mailFromDomainStatus = "MailFromDomainStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorOnMxFailure = behaviorOnMxFailure {
            try encodeContainer.encode(behaviorOnMxFailure.rawValue, forKey: .behaviorOnMxFailure)
        }
        if let mailFromDomain = mailFromDomain {
            try encodeContainer.encode(mailFromDomain, forKey: .mailFromDomain)
        }
        if let mailFromDomainStatus = mailFromDomainStatus {
            try encodeContainer.encode(mailFromDomainStatus.rawValue, forKey: .mailFromDomainStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailFromDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mailFromDomain)
        mailFromDomain = mailFromDomainDecoded
        let mailFromDomainStatusDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.MailFromDomainStatus.self, forKey: .mailFromDomainStatus)
        mailFromDomainStatus = mailFromDomainStatusDecoded
        let behaviorOnMxFailureDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.BehaviorOnMxFailure.self, forKey: .behaviorOnMxFailure)
        behaviorOnMxFailure = behaviorOnMxFailureDecoded
    }
}

extension PinpointEmailClientTypes.MailFromAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MailFromAttributes(behaviorOnMxFailure: \(Swift.String(describing: behaviorOnMxFailure)), mailFromDomain: \(Swift.String(describing: mailFromDomain)), mailFromDomainStatus: \(Swift.String(describing: mailFromDomainStatus)))"}
}

extension PinpointEmailClientTypes {
    /// A list of attributes that are associated with a MAIL FROM domain.
    public struct MailFromAttributes: Swift.Equatable {
        /// The action that Amazon Pinpoint to takes if it can't read the required MX record for a custom
        ///             MAIL FROM domain. When you set this value to UseDefaultValue, Amazon Pinpoint uses
        ///                 amazonses.com as the MAIL FROM domain. When you set this value
        ///             to RejectMessage, Amazon Pinpoint returns a MailFromDomainNotVerified
        ///             error, and doesn't attempt to deliver the email.
        ///         These behaviors are taken when the custom MAIL FROM domain configuration is in the
        ///                 Pending, Failed, and TemporaryFailure
        ///             states.
        /// This member is required.
        public let behaviorOnMxFailure: PinpointEmailClientTypes.BehaviorOnMxFailure?
        /// The name of a domain that an email identity uses as a custom MAIL FROM domain.
        /// This member is required.
        public let mailFromDomain: Swift.String?
        /// The status of the MAIL FROM domain. This status can have the following values:
        ///
        ///
        ///
        ///                   PENDING  Amazon Pinpoint hasn't started searching for the MX record
        ///                     yet.
        ///
        ///
        ///
        ///                   SUCCESS  Amazon Pinpoint detected the required MX record for the
        ///                     MAIL FROM domain.
        ///
        ///
        ///
        ///                   FAILED  Amazon Pinpoint can't find the required MX record, or the
        ///                     record no longer exists.
        ///
        ///
        ///
        ///                   TEMPORARY_FAILURE  A temporary issue occurred, which
        ///                     prevented Amazon Pinpoint from determining the status of the MAIL FROM domain.
        ///
        ///
        /// This member is required.
        public let mailFromDomainStatus: PinpointEmailClientTypes.MailFromDomainStatus?

        public init (
            behaviorOnMxFailure: PinpointEmailClientTypes.BehaviorOnMxFailure? = nil,
            mailFromDomain: Swift.String? = nil,
            mailFromDomainStatus: PinpointEmailClientTypes.MailFromDomainStatus? = nil
        )
        {
            self.behaviorOnMxFailure = behaviorOnMxFailure
            self.mailFromDomain = mailFromDomain
            self.mailFromDomainStatus = mailFromDomainStatus
        }
    }

}

extension MailFromDomainNotVerifiedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MailFromDomainNotVerifiedException(message: \(Swift.String(describing: message)))"}
}

extension MailFromDomainNotVerifiedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MailFromDomainNotVerifiedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The message can't be sent because the sending domain isn't verified.
public struct MailFromDomainNotVerifiedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MailFromDomainNotVerifiedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MailFromDomainNotVerifiedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointEmailClientTypes {
    /// The status of the MAIL FROM domain. This status can have the following values:
    ///
    ///
    ///
    ///                   PENDING  Amazon Pinpoint hasn't started searching for the MX record
    ///                     yet.
    ///
    ///
    ///
    ///                   SUCCESS  Amazon Pinpoint detected the required MX record for the
    ///                     MAIL FROM domain.
    ///
    ///
    ///
    ///                   FAILED  Amazon Pinpoint can't find the required MX record, or the
    ///                     record no longer exists.
    ///
    ///
    ///
    ///                   TEMPORARY_FAILURE  A temporary issue occurred, which
    ///                     prevented Amazon Pinpoint from determining the status of the MAIL FROM domain.
    ///
    ///
    public enum MailFromDomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case success
        case temporaryFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [MailFromDomainStatus] {
            return [
                .failed,
                .pending,
                .success,
                .temporaryFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case .temporaryFailure: return "TEMPORARY_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MailFromDomainStatus(rawValue: rawValue) ?? MailFromDomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointEmailClientTypes.Message: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.Content.self, forKey: .subject)
        subject = subjectDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.Body.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PinpointEmailClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(body: \(Swift.String(describing: body)), subject: \(Swift.String(describing: subject)))"}
}

extension PinpointEmailClientTypes {
    /// Represents the email message that you're sending. The Message object
    ///             consists of a subject line and a message body.
    public struct Message: Swift.Equatable {
        /// The body of the message. You can specify an HTML version of the message, a text-only
        ///             version of the message, or both.
        /// This member is required.
        public let body: PinpointEmailClientTypes.Body?
        /// The subject line of the email. The subject line can only contain 7-bit ASCII
        ///             characters. However, you can specify non-ASCII characters in the subject line by using
        ///             encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047.
        /// This member is required.
        public let subject: PinpointEmailClientTypes.Content?

        public init (
            body: PinpointEmailClientTypes.Body? = nil,
            subject: PinpointEmailClientTypes.Content? = nil
        )
        {
            self.body = body
            self.subject = subject
        }
    }

}

extension MessageRejected: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageRejected(message: \(Swift.String(describing: message)))"}
}

extension MessageRejected {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MessageRejectedBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The message can't be sent because it contains invalid content.
public struct MessageRejected: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MessageRejectedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MessageRejectedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointEmailClientTypes.MessageTag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PinpointEmailClientTypes.MessageTag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageTag(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension PinpointEmailClientTypes {
    /// Contains the name and value of a tag that you apply to an email. You can use message
    ///             tags when you publish email sending events.
    ///
    public struct MessageTag: Swift.Equatable {
        /// The name of the message tag. The message tag name has to meet the following
        ///             criteria:
        ///
        ///
        ///                 It can only contain ASCII letters (az, AZ), numbers (09),
        ///                     underscores (_), or dashes (-).
        ///
        ///
        ///                 It can contain no more than 256 characters.
        ///
        ///
        /// This member is required.
        public let name: Swift.String?
        /// The value of the message tag. The message tag value has to meet the following
        ///             criteria:
        ///
        ///
        ///                 It can only contain ASCII letters (az, AZ), numbers (09),
        ///                     underscores (_), or dashes (-).
        ///
        ///
        ///                 It can contain no more than 256 characters.
        ///
        ///
        /// This member is required.
        public let value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource you attempted to access doesn't exist.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointEmailClientTypes.OverallVolume: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainIspPlacements = "DomainIspPlacements"
        case readRatePercent = "ReadRatePercent"
        case volumeStatistics = "VolumeStatistics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainIspPlacements = domainIspPlacements {
            var domainIspPlacementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainIspPlacements)
            for domainispplacements0 in domainIspPlacements {
                try domainIspPlacementsContainer.encode(domainispplacements0)
            }
        }
        if let readRatePercent = readRatePercent {
            try encodeContainer.encode(readRatePercent, forKey: .readRatePercent)
        }
        if let volumeStatistics = volumeStatistics {
            try encodeContainer.encode(volumeStatistics, forKey: .volumeStatistics)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeStatisticsDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.VolumeStatistics.self, forKey: .volumeStatistics)
        volumeStatistics = volumeStatisticsDecoded
        let readRatePercentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .readRatePercent)
        readRatePercent = readRatePercentDecoded
        let domainIspPlacementsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DomainIspPlacement?].self, forKey: .domainIspPlacements)
        var domainIspPlacementsDecoded0:[PinpointEmailClientTypes.DomainIspPlacement]? = nil
        if let domainIspPlacementsContainer = domainIspPlacementsContainer {
            domainIspPlacementsDecoded0 = [PinpointEmailClientTypes.DomainIspPlacement]()
            for structure0 in domainIspPlacementsContainer {
                if let structure0 = structure0 {
                    domainIspPlacementsDecoded0?.append(structure0)
                }
            }
        }
        domainIspPlacements = domainIspPlacementsDecoded0
    }
}

extension PinpointEmailClientTypes.OverallVolume: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OverallVolume(domainIspPlacements: \(Swift.String(describing: domainIspPlacements)), readRatePercent: \(Swift.String(describing: readRatePercent)), volumeStatistics: \(Swift.String(describing: volumeStatistics)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about email that was sent from the selected
    ///             domain.
    public struct OverallVolume: Swift.Equatable {
        /// An object that contains inbox and junk mail placement metrics for individual email
        ///             providers.
        public let domainIspPlacements: [PinpointEmailClientTypes.DomainIspPlacement]?
        /// The percentage of emails that were sent from the domain that were read by their
        ///             recipients.
        public let readRatePercent: Swift.Double?
        /// An object that contains information about the numbers of messages that arrived in
        ///             recipients' inboxes and junk mail folders.
        public let volumeStatistics: PinpointEmailClientTypes.VolumeStatistics?

        public init (
            domainIspPlacements: [PinpointEmailClientTypes.DomainIspPlacement]? = nil,
            readRatePercent: Swift.Double? = nil,
            volumeStatistics: PinpointEmailClientTypes.VolumeStatistics? = nil
        )
        {
            self.domainIspPlacements = domainIspPlacements
            self.readRatePercent = readRatePercent
            self.volumeStatistics = volumeStatistics
        }
    }

}

extension PinpointEmailClientTypes.PinpointDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension PinpointEmailClientTypes.PinpointDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PinpointDestination(applicationArn: \(Swift.String(describing: applicationArn)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
    ///             to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
    ///             for your campaigns.
    public struct PinpointDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Pinpoint project that you want to send email
        ///             events to.
        public let applicationArn: Swift.String?

        public init (
            applicationArn: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
        }
    }

}

extension PinpointEmailClientTypes.PlacementStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dkimPercentage = "DkimPercentage"
        case inboxPercentage = "InboxPercentage"
        case missingPercentage = "MissingPercentage"
        case spamPercentage = "SpamPercentage"
        case spfPercentage = "SpfPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dkimPercentage = dkimPercentage {
            try encodeContainer.encode(dkimPercentage, forKey: .dkimPercentage)
        }
        if let inboxPercentage = inboxPercentage {
            try encodeContainer.encode(inboxPercentage, forKey: .inboxPercentage)
        }
        if let missingPercentage = missingPercentage {
            try encodeContainer.encode(missingPercentage, forKey: .missingPercentage)
        }
        if let spamPercentage = spamPercentage {
            try encodeContainer.encode(spamPercentage, forKey: .spamPercentage)
        }
        if let spfPercentage = spfPercentage {
            try encodeContainer.encode(spfPercentage, forKey: .spfPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboxPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .inboxPercentage)
        inboxPercentage = inboxPercentageDecoded
        let spamPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .spamPercentage)
        spamPercentage = spamPercentageDecoded
        let missingPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .missingPercentage)
        missingPercentage = missingPercentageDecoded
        let spfPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .spfPercentage)
        spfPercentage = spfPercentageDecoded
        let dkimPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dkimPercentage)
        dkimPercentage = dkimPercentageDecoded
    }
}

extension PinpointEmailClientTypes.PlacementStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlacementStatistics(dkimPercentage: \(Swift.String(describing: dkimPercentage)), inboxPercentage: \(Swift.String(describing: inboxPercentage)), missingPercentage: \(Swift.String(describing: missingPercentage)), spamPercentage: \(Swift.String(describing: spamPercentage)), spfPercentage: \(Swift.String(describing: spfPercentage)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains inbox placement data for an email provider.
    public struct PlacementStatistics: Swift.Equatable {
        /// The percentage of emails that were authenticated by using DomainKeys Identified Mail
        ///             (DKIM) during the predictive inbox placement test.
        public let dkimPercentage: Swift.Double?
        /// The percentage of emails that arrived in recipients' inboxes during the predictive inbox placement test.
        public let inboxPercentage: Swift.Double?
        /// The percentage of emails that didn't arrive in recipients' inboxes at all during the
        ///             predictive inbox placement test.
        public let missingPercentage: Swift.Double?
        /// The percentage of emails that arrived in recipients' spam or junk mail folders during
        ///             the predictive inbox placement test.
        public let spamPercentage: Swift.Double?
        /// The percentage of emails that were authenticated by using Sender Policy Framework
        ///             (SPF) during the predictive inbox placement test.
        public let spfPercentage: Swift.Double?

        public init (
            dkimPercentage: Swift.Double? = nil,
            inboxPercentage: Swift.Double? = nil,
            missingPercentage: Swift.Double? = nil,
            spamPercentage: Swift.Double? = nil,
            spfPercentage: Swift.Double? = nil
        )
        {
            self.dkimPercentage = dkimPercentage
            self.inboxPercentage = inboxPercentage
            self.missingPercentage = missingPercentage
            self.spamPercentage = spamPercentage
            self.spfPercentage = spfPercentage
        }
    }

}

public struct PutAccountDedicatedIpWarmupAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountDedicatedIpWarmupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

extension PutAccountDedicatedIpWarmupAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccountDedicatedIpWarmupAttributesInput(autoWarmupEnabled: \(Swift.String(describing: autoWarmupEnabled)))"}
}

extension PutAccountDedicatedIpWarmupAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoWarmupEnabled = "AutoWarmupEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoWarmupEnabled != false {
            try encodeContainer.encode(autoWarmupEnabled, forKey: .autoWarmupEnabled)
        }
    }
}

public struct PutAccountDedicatedIpWarmupAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountDedicatedIpWarmupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

public struct PutAccountDedicatedIpWarmupAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountDedicatedIpWarmupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

/// A request to enable or disable the automatic IP address warm-up feature.
public struct PutAccountDedicatedIpWarmupAttributesInput: Swift.Equatable {
    /// Enables or disables the automatic warm-up feature for dedicated IP addresses that are
    ///             associated with your Amazon Pinpoint account in the current AWS Region. Set to true
    ///             to enable the automatic warm-up feature, or set to false to disable
    ///             it.
    public let autoWarmupEnabled: Swift.Bool

    public init (
        autoWarmupEnabled: Swift.Bool = false
    )
    {
        self.autoWarmupEnabled = autoWarmupEnabled
    }
}

struct PutAccountDedicatedIpWarmupAttributesInputBody: Swift.Equatable {
    public let autoWarmupEnabled: Swift.Bool
}

extension PutAccountDedicatedIpWarmupAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoWarmupEnabled = "AutoWarmupEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoWarmupEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoWarmupEnabled)
        autoWarmupEnabled = autoWarmupEnabledDecoded
    }
}

extension PutAccountDedicatedIpWarmupAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountDedicatedIpWarmupAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountDedicatedIpWarmupAttributesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccountDedicatedIpWarmupAttributesOutputResponse()"}
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutAccountDedicatedIpWarmupAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutAccountDedicatedIpWarmupAttributesOutputResponseBody: Swift.Equatable {
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutAccountSendingAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountSendingAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountSendingAttributesOutputError>
}

extension PutAccountSendingAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccountSendingAttributesInput(sendingEnabled: \(Swift.String(describing: sendingEnabled)))"}
}

extension PutAccountSendingAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }
}

public struct PutAccountSendingAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountSendingAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountSendingAttributesOutputError>
}

public struct PutAccountSendingAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountSendingAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountSendingAttributesOutputError>
}

/// A request to change the ability of your account to send email.
public struct PutAccountSendingAttributesInput: Swift.Equatable {
    /// Enables or disables your account's ability to send email. Set to true to
    ///             enable email sending, or set to false to disable email sending.
    ///
    ///             If AWS paused your account's ability to send email, you can't use this operation
    ///                 to resume your account's ability to send email.
    ///
    public let sendingEnabled: Swift.Bool

    public init (
        sendingEnabled: Swift.Bool = false
    )
    {
        self.sendingEnabled = sendingEnabled
    }
}

struct PutAccountSendingAttributesInputBody: Swift.Equatable {
    public let sendingEnabled: Swift.Bool
}

extension PutAccountSendingAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PutAccountSendingAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountSendingAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountSendingAttributesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountSendingAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccountSendingAttributesOutputResponse()"}
}

extension PutAccountSendingAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutAccountSendingAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutAccountSendingAttributesOutputResponseBody: Swift.Equatable {
}

extension PutAccountSendingAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutConfigurationSetDeliveryOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetDeliveryOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

extension PutConfigurationSetDeliveryOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetDeliveryOptionsInput(configurationSetName: \(Swift.String(describing: configurationSetName)), sendingPoolName: \(Swift.String(describing: sendingPoolName)), tlsPolicy: \(Swift.String(describing: tlsPolicy)))"}
}

extension PutConfigurationSetDeliveryOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sendingPoolName = sendingPoolName {
            try encodeContainer.encode(sendingPoolName, forKey: .sendingPoolName)
        }
        if let tlsPolicy = tlsPolicy {
            try encodeContainer.encode(tlsPolicy.rawValue, forKey: .tlsPolicy)
        }
    }
}

public struct PutConfigurationSetDeliveryOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetDeliveryOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

public struct PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

/// A request to associate a configuration set with a dedicated IP pool.
public struct PutConfigurationSetDeliveryOptionsInput: Swift.Equatable {
    /// The name of the configuration set that you want to associate with a dedicated IP
    ///             pool.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// The name of the dedicated IP pool that you want to associate with the configuration
    ///             set.
    public let sendingPoolName: Swift.String?
    /// Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS). If the value is Require, messages are only
    ///             delivered if a TLS connection can be established. If the value is Optional,
    ///             messages can be delivered in plain text if a TLS connection can't be established.
    public let tlsPolicy: PinpointEmailClientTypes.TlsPolicy?

    public init (
        configurationSetName: Swift.String? = nil,
        sendingPoolName: Swift.String? = nil,
        tlsPolicy: PinpointEmailClientTypes.TlsPolicy? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.sendingPoolName = sendingPoolName
        self.tlsPolicy = tlsPolicy
    }
}

struct PutConfigurationSetDeliveryOptionsInputBody: Swift.Equatable {
    public let tlsPolicy: PinpointEmailClientTypes.TlsPolicy?
    public let sendingPoolName: Swift.String?
}

extension PutConfigurationSetDeliveryOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
        let sendingPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sendingPoolName)
        sendingPoolName = sendingPoolNameDecoded
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetDeliveryOptionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetDeliveryOptionsOutputResponse()"}
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutConfigurationSetDeliveryOptionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutConfigurationSetDeliveryOptionsOutputResponseBody: Swift.Equatable {
}

extension PutConfigurationSetDeliveryOptionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutConfigurationSetReputationOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetReputationOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetReputationOptionsOutputError>
}

extension PutConfigurationSetReputationOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetReputationOptionsInput(configurationSetName: \(Swift.String(describing: configurationSetName)), reputationMetricsEnabled: \(Swift.String(describing: reputationMetricsEnabled)))"}
}

extension PutConfigurationSetReputationOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if reputationMetricsEnabled != false {
            try encodeContainer.encode(reputationMetricsEnabled, forKey: .reputationMetricsEnabled)
        }
    }
}

public struct PutConfigurationSetReputationOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetReputationOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetReputationOptionsOutputError>
}

public struct PutConfigurationSetReputationOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetReputationOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetReputationOptionsOutputError>
}

/// A request to enable or disable tracking of reputation metrics for a configuration
///             set.
public struct PutConfigurationSetReputationOptionsInput: Swift.Equatable {
    /// The name of the configuration set that you want to enable or disable reputation metric
    ///             tracking for.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// If true, tracking of reputation metrics is enabled for the configuration
    ///             set. If false, tracking of reputation metrics is disabled for the
    ///             configuration set.
    public let reputationMetricsEnabled: Swift.Bool

    public init (
        configurationSetName: Swift.String? = nil,
        reputationMetricsEnabled: Swift.Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.reputationMetricsEnabled = reputationMetricsEnabled
    }
}

struct PutConfigurationSetReputationOptionsInputBody: Swift.Equatable {
    public let reputationMetricsEnabled: Swift.Bool
}

extension PutConfigurationSetReputationOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reputationMetricsEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reputationMetricsEnabled)
        reputationMetricsEnabled = reputationMetricsEnabledDecoded
    }
}

extension PutConfigurationSetReputationOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetReputationOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetReputationOptionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetReputationOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetReputationOptionsOutputResponse()"}
}

extension PutConfigurationSetReputationOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutConfigurationSetReputationOptionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutConfigurationSetReputationOptionsOutputResponseBody: Swift.Equatable {
}

extension PutConfigurationSetReputationOptionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutConfigurationSetSendingOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetSendingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetSendingOptionsOutputError>
}

extension PutConfigurationSetSendingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetSendingOptionsInput(configurationSetName: \(Swift.String(describing: configurationSetName)), sendingEnabled: \(Swift.String(describing: sendingEnabled)))"}
}

extension PutConfigurationSetSendingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }
}

public struct PutConfigurationSetSendingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetSendingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetSendingOptionsOutputError>
}

public struct PutConfigurationSetSendingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetSendingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetSendingOptionsOutputError>
}

/// A request to enable or disable the ability of Amazon Pinpoint to send emails that use a specific
///             configuration set.
public struct PutConfigurationSetSendingOptionsInput: Swift.Equatable {
    /// The name of the configuration set that you want to enable or disable email sending
    ///             for.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// If true, email sending is enabled for the configuration set. If
    ///                 false, email sending is disabled for the configuration set.
    public let sendingEnabled: Swift.Bool

    public init (
        configurationSetName: Swift.String? = nil,
        sendingEnabled: Swift.Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.sendingEnabled = sendingEnabled
    }
}

struct PutConfigurationSetSendingOptionsInputBody: Swift.Equatable {
    public let sendingEnabled: Swift.Bool
}

extension PutConfigurationSetSendingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PutConfigurationSetSendingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetSendingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetSendingOptionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetSendingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetSendingOptionsOutputResponse()"}
}

extension PutConfigurationSetSendingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutConfigurationSetSendingOptionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutConfigurationSetSendingOptionsOutputResponseBody: Swift.Equatable {
}

extension PutConfigurationSetSendingOptionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutConfigurationSetTrackingOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetTrackingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

extension PutConfigurationSetTrackingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetTrackingOptionsInput(configurationSetName: \(Swift.String(describing: configurationSetName)), customRedirectDomain: \(Swift.String(describing: customRedirectDomain)))"}
}

extension PutConfigurationSetTrackingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRedirectDomain = customRedirectDomain {
            try encodeContainer.encode(customRedirectDomain, forKey: .customRedirectDomain)
        }
    }
}

public struct PutConfigurationSetTrackingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetTrackingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

public struct PutConfigurationSetTrackingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutConfigurationSetTrackingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

/// A request to add a custom domain for tracking open and click events to a configuration
///             set.
public struct PutConfigurationSetTrackingOptionsInput: Swift.Equatable {
    /// The name of the configuration set that you want to add a custom tracking domain
    ///             to.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// The domain that you want to use to track open and click events.
    public let customRedirectDomain: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil,
        customRedirectDomain: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.customRedirectDomain = customRedirectDomain
    }
}

struct PutConfigurationSetTrackingOptionsInputBody: Swift.Equatable {
    public let customRedirectDomain: Swift.String?
}

extension PutConfigurationSetTrackingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRedirectDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customRedirectDomain)
        customRedirectDomain = customRedirectDomainDecoded
    }
}

extension PutConfigurationSetTrackingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetTrackingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetTrackingOptionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetTrackingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutConfigurationSetTrackingOptionsOutputResponse()"}
}

extension PutConfigurationSetTrackingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutConfigurationSetTrackingOptionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutConfigurationSetTrackingOptionsOutputResponseBody: Swift.Equatable {
}

extension PutConfigurationSetTrackingOptionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutDedicatedIpInPoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDedicatedIpInPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDedicatedIpInPoolOutputError>
}

extension PutDedicatedIpInPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDedicatedIpInPoolInput(destinationPoolName: \(Swift.String(describing: destinationPoolName)), ip: \(Swift.String(describing: ip)))"}
}

extension PutDedicatedIpInPoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPoolName = "DestinationPoolName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPoolName = destinationPoolName {
            try encodeContainer.encode(destinationPoolName, forKey: .destinationPoolName)
        }
    }
}

public struct PutDedicatedIpInPoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDedicatedIpInPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDedicatedIpInPoolOutputError>
}

public struct PutDedicatedIpInPoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDedicatedIpInPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDedicatedIpInPoolOutputError>
}

/// A request to move a dedicated IP address to a dedicated IP pool.
public struct PutDedicatedIpInPoolInput: Swift.Equatable {
    /// The name of the IP pool that you want to add the dedicated IP address to. You have to
    ///             specify an IP pool that already exists.
    /// This member is required.
    public let destinationPoolName: Swift.String?
    /// The IP address that you want to move to the dedicated IP pool. The value you specify
    ///             has to be a dedicated IP address that's associated with your Amazon Pinpoint account.
    /// This member is required.
    public let ip: Swift.String?

    public init (
        destinationPoolName: Swift.String? = nil,
        ip: Swift.String? = nil
    )
    {
        self.destinationPoolName = destinationPoolName
        self.ip = ip
    }
}

struct PutDedicatedIpInPoolInputBody: Swift.Equatable {
    public let destinationPoolName: Swift.String?
}

extension PutDedicatedIpInPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPoolName = "DestinationPoolName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPoolName)
        destinationPoolName = destinationPoolNameDecoded
    }
}

extension PutDedicatedIpInPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDedicatedIpInPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDedicatedIpInPoolOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDedicatedIpInPoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDedicatedIpInPoolOutputResponse()"}
}

extension PutDedicatedIpInPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutDedicatedIpInPoolOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutDedicatedIpInPoolOutputResponseBody: Swift.Equatable {
}

extension PutDedicatedIpInPoolOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutDedicatedIpWarmupAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDedicatedIpWarmupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

extension PutDedicatedIpWarmupAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDedicatedIpWarmupAttributesInput(ip: \(Swift.String(describing: ip)), warmupPercentage: \(Swift.String(describing: warmupPercentage)))"}
}

extension PutDedicatedIpWarmupAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case warmupPercentage = "WarmupPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let warmupPercentage = warmupPercentage {
            try encodeContainer.encode(warmupPercentage, forKey: .warmupPercentage)
        }
    }
}

public struct PutDedicatedIpWarmupAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDedicatedIpWarmupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

public struct PutDedicatedIpWarmupAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDedicatedIpWarmupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

/// A request to change the warm-up attributes for a dedicated IP address. This operation
///             is useful when you want to resume the warm-up process for an existing IP address.
public struct PutDedicatedIpWarmupAttributesInput: Swift.Equatable {
    /// The dedicated IP address that you want to update the warm-up attributes for.
    /// This member is required.
    public let ip: Swift.String?
    /// The warm-up percentage that you want to associate with the dedicated IP
    ///             address.
    /// This member is required.
    public let warmupPercentage: Swift.Int?

    public init (
        ip: Swift.String? = nil,
        warmupPercentage: Swift.Int? = nil
    )
    {
        self.ip = ip
        self.warmupPercentage = warmupPercentage
    }
}

struct PutDedicatedIpWarmupAttributesInputBody: Swift.Equatable {
    public let warmupPercentage: Swift.Int?
}

extension PutDedicatedIpWarmupAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case warmupPercentage = "WarmupPercentage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warmupPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .warmupPercentage)
        warmupPercentage = warmupPercentageDecoded
    }
}

extension PutDedicatedIpWarmupAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDedicatedIpWarmupAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDedicatedIpWarmupAttributesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDedicatedIpWarmupAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDedicatedIpWarmupAttributesOutputResponse()"}
}

extension PutDedicatedIpWarmupAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutDedicatedIpWarmupAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutDedicatedIpWarmupAttributesOutputResponseBody: Swift.Equatable {
}

extension PutDedicatedIpWarmupAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutDeliverabilityDashboardOptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDeliverabilityDashboardOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDeliverabilityDashboardOptionOutputError>
}

extension PutDeliverabilityDashboardOptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDeliverabilityDashboardOptionInput(dashboardEnabled: \(Swift.String(describing: dashboardEnabled)), subscribedDomains: \(Swift.String(describing: subscribedDomains)))"}
}

extension PutDeliverabilityDashboardOptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardEnabled = "DashboardEnabled"
        case subscribedDomains = "SubscribedDomains"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dashboardEnabled != false {
            try encodeContainer.encode(dashboardEnabled, forKey: .dashboardEnabled)
        }
        if let subscribedDomains = subscribedDomains {
            var subscribedDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribedDomains)
            for domaindeliverabilitytrackingoptions0 in subscribedDomains {
                try subscribedDomainsContainer.encode(domaindeliverabilitytrackingoptions0)
            }
        }
    }
}

public struct PutDeliverabilityDashboardOptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDeliverabilityDashboardOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDeliverabilityDashboardOptionOutputError>
}

public struct PutDeliverabilityDashboardOptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDeliverabilityDashboardOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDeliverabilityDashboardOptionOutputError>
}

/// Enable or disable the Deliverability dashboard for your Amazon Pinpoint account. When you enable the
///             Deliverability dashboard, you gain access to reputation, deliverability, and other metrics for
///             the domains that you use to send email using Amazon Pinpoint. You also gain the ability to perform
///             predictive inbox placement tests.
///         When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
///             to any other fees that you accrue by using Amazon Pinpoint. For more information about the
///             features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/pinpoint/pricing/">Amazon Pinpoint Pricing.
public struct PutDeliverabilityDashboardOptionInput: Swift.Equatable {
    /// Specifies whether to enable the Deliverability dashboard for your Amazon Pinpoint account. To enable the
    ///             dashboard, set this value to true.
    /// This member is required.
    public let dashboardEnabled: Swift.Bool
    /// An array of objects, one for each verified domain that you use to send email and
    ///             enabled the Deliverability dashboard for.
    public let subscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]?

    public init (
        dashboardEnabled: Swift.Bool = false,
        subscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]? = nil
    )
    {
        self.dashboardEnabled = dashboardEnabled
        self.subscribedDomains = subscribedDomains
    }
}

struct PutDeliverabilityDashboardOptionInputBody: Swift.Equatable {
    public let dashboardEnabled: Swift.Bool
    public let subscribedDomains: [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]?
}

extension PutDeliverabilityDashboardOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardEnabled = "DashboardEnabled"
        case subscribedDomains = "SubscribedDomains"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dashboardEnabled)
        dashboardEnabled = dashboardEnabledDecoded
        let subscribedDomainsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.DomainDeliverabilityTrackingOption?].self, forKey: .subscribedDomains)
        var subscribedDomainsDecoded0:[PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]? = nil
        if let subscribedDomainsContainer = subscribedDomainsContainer {
            subscribedDomainsDecoded0 = [PinpointEmailClientTypes.DomainDeliverabilityTrackingOption]()
            for structure0 in subscribedDomainsContainer {
                if let structure0 = structure0 {
                    subscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        subscribedDomains = subscribedDomainsDecoded0
    }
}

extension PutDeliverabilityDashboardOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDeliverabilityDashboardOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDeliverabilityDashboardOptionOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDeliverabilityDashboardOptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDeliverabilityDashboardOptionOutputResponse()"}
}

extension PutDeliverabilityDashboardOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// A response that indicates whether the Deliverability dashboard is enabled for your Amazon Pinpoint
///             account.
public struct PutDeliverabilityDashboardOptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutDeliverabilityDashboardOptionOutputResponseBody: Swift.Equatable {
}

extension PutDeliverabilityDashboardOptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutEmailIdentityDkimAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityDkimAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityDkimAttributesOutputError>
}

extension PutEmailIdentityDkimAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEmailIdentityDkimAttributesInput(emailIdentity: \(Swift.String(describing: emailIdentity)), signingEnabled: \(Swift.String(describing: signingEnabled)))"}
}

extension PutEmailIdentityDkimAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingEnabled = "SigningEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if signingEnabled != false {
            try encodeContainer.encode(signingEnabled, forKey: .signingEnabled)
        }
    }
}

public struct PutEmailIdentityDkimAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityDkimAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityDkimAttributesOutputError>
}

public struct PutEmailIdentityDkimAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityDkimAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityDkimAttributesOutputError>
}

/// A request to enable or disable DKIM signing of email that you send from an email
///             identity.
public struct PutEmailIdentityDkimAttributesInput: Swift.Equatable {
    /// The email identity that you want to change the DKIM settings for.
    /// This member is required.
    public let emailIdentity: Swift.String?
    /// Sets the DKIM signing configuration for the identity.
    ///         When you set this value true, then the messages that Amazon Pinpoint sends from the
    ///             identity are DKIM-signed. When you set this value to false, then the
    ///             messages that Amazon Pinpoint sends from the identity aren't DKIM-signed.
    public let signingEnabled: Swift.Bool

    public init (
        emailIdentity: Swift.String? = nil,
        signingEnabled: Swift.Bool = false
    )
    {
        self.emailIdentity = emailIdentity
        self.signingEnabled = signingEnabled
    }
}

struct PutEmailIdentityDkimAttributesInputBody: Swift.Equatable {
    public let signingEnabled: Swift.Bool
}

extension PutEmailIdentityDkimAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingEnabled = "SigningEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .signingEnabled)
        signingEnabled = signingEnabledDecoded
    }
}

extension PutEmailIdentityDkimAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityDkimAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityDkimAttributesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityDkimAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEmailIdentityDkimAttributesOutputResponse()"}
}

extension PutEmailIdentityDkimAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutEmailIdentityDkimAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutEmailIdentityDkimAttributesOutputResponseBody: Swift.Equatable {
}

extension PutEmailIdentityDkimAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutEmailIdentityFeedbackAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityFeedbackAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

extension PutEmailIdentityFeedbackAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEmailIdentityFeedbackAttributesInput(emailForwardingEnabled: \(Swift.String(describing: emailForwardingEnabled)), emailIdentity: \(Swift.String(describing: emailIdentity)))"}
}

extension PutEmailIdentityFeedbackAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailForwardingEnabled = "EmailForwardingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if emailForwardingEnabled != false {
            try encodeContainer.encode(emailForwardingEnabled, forKey: .emailForwardingEnabled)
        }
    }
}

public struct PutEmailIdentityFeedbackAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityFeedbackAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

public struct PutEmailIdentityFeedbackAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityFeedbackAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

/// A request to set the attributes that control how bounce and complaint events are
///             processed.
public struct PutEmailIdentityFeedbackAttributesInput: Swift.Equatable {
    /// Sets the feedback forwarding configuration for the identity.
    ///         If the value is true, Amazon Pinpoint sends you email notifications when bounce or
    ///             complaint events occur. Amazon Pinpoint sends this notification to the address that you specified
    ///             in the Return-Path header of the original email.
    ///         When you set this value to false, Amazon Pinpoint sends notifications through other
    ///             mechanisms, such as by notifying an Amazon SNS topic or another event destination. You're
    ///             required to have a method of tracking bounces and complaints. If you haven't set up
    ///             another mechanism for receiving bounce or complaint notifications, Amazon Pinpoint sends an email
    ///             notification when these events occur (even if this setting is disabled).
    public let emailForwardingEnabled: Swift.Bool
    /// The email identity that you want to configure bounce and complaint feedback forwarding
    ///             for.
    /// This member is required.
    public let emailIdentity: Swift.String?

    public init (
        emailForwardingEnabled: Swift.Bool = false,
        emailIdentity: Swift.String? = nil
    )
    {
        self.emailForwardingEnabled = emailForwardingEnabled
        self.emailIdentity = emailIdentity
    }
}

struct PutEmailIdentityFeedbackAttributesInputBody: Swift.Equatable {
    public let emailForwardingEnabled: Swift.Bool
}

extension PutEmailIdentityFeedbackAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailForwardingEnabled = "EmailForwardingEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailForwardingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .emailForwardingEnabled)
        emailForwardingEnabled = emailForwardingEnabledDecoded
    }
}

extension PutEmailIdentityFeedbackAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityFeedbackAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityFeedbackAttributesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityFeedbackAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEmailIdentityFeedbackAttributesOutputResponse()"}
}

extension PutEmailIdentityFeedbackAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutEmailIdentityFeedbackAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutEmailIdentityFeedbackAttributesOutputResponseBody: Swift.Equatable {
}

extension PutEmailIdentityFeedbackAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutEmailIdentityMailFromAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityMailFromAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

extension PutEmailIdentityMailFromAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEmailIdentityMailFromAttributesInput(behaviorOnMxFailure: \(Swift.String(describing: behaviorOnMxFailure)), emailIdentity: \(Swift.String(describing: emailIdentity)), mailFromDomain: \(Swift.String(describing: mailFromDomain)))"}
}

extension PutEmailIdentityMailFromAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorOnMxFailure = behaviorOnMxFailure {
            try encodeContainer.encode(behaviorOnMxFailure.rawValue, forKey: .behaviorOnMxFailure)
        }
        if let mailFromDomain = mailFromDomain {
            try encodeContainer.encode(mailFromDomain, forKey: .mailFromDomain)
        }
    }
}

public struct PutEmailIdentityMailFromAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityMailFromAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

public struct PutEmailIdentityMailFromAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEmailIdentityMailFromAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

/// A request to configure the custom MAIL FROM domain for a verified identity.
public struct PutEmailIdentityMailFromAttributesInput: Swift.Equatable {
    /// The action that you want Amazon Pinpoint to take if it can't read the required MX record when
    ///             you send an email. When you set this value to UseDefaultValue, Amazon Pinpoint uses
    ///                 amazonses.com as the MAIL FROM domain. When you set this value
    ///             to RejectMessage, Amazon Pinpoint returns a MailFromDomainNotVerified
    ///             error, and doesn't attempt to deliver the email.
    ///         These behaviors are taken when the custom MAIL FROM domain configuration is in the
    ///                 Pending, Failed, and TemporaryFailure
    ///             states.
    public let behaviorOnMxFailure: PinpointEmailClientTypes.BehaviorOnMxFailure?
    /// The verified email identity that you want to set up the custom MAIL FROM domain
    ///             for.
    /// This member is required.
    public let emailIdentity: Swift.String?
    ///  The custom MAIL FROM domain that you want the verified identity to use. The MAIL FROM
    ///             domain must meet the following criteria:
    ///
    ///
    ///                 It has to be a subdomain of the verified identity.
    ///
    ///
    ///                 It can't be used to receive email.
    ///
    ///
    ///                 It can't be used in a "From" address if the MAIL FROM domain is a destination
    ///                     for feedback forwarding emails.
    ///
    ///
    public let mailFromDomain: Swift.String?

    public init (
        behaviorOnMxFailure: PinpointEmailClientTypes.BehaviorOnMxFailure? = nil,
        emailIdentity: Swift.String? = nil,
        mailFromDomain: Swift.String? = nil
    )
    {
        self.behaviorOnMxFailure = behaviorOnMxFailure
        self.emailIdentity = emailIdentity
        self.mailFromDomain = mailFromDomain
    }
}

struct PutEmailIdentityMailFromAttributesInputBody: Swift.Equatable {
    public let mailFromDomain: Swift.String?
    public let behaviorOnMxFailure: PinpointEmailClientTypes.BehaviorOnMxFailure?
}

extension PutEmailIdentityMailFromAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailFromDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mailFromDomain)
        mailFromDomain = mailFromDomainDecoded
        let behaviorOnMxFailureDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.BehaviorOnMxFailure.self, forKey: .behaviorOnMxFailure)
        behaviorOnMxFailure = behaviorOnMxFailureDecoded
    }
}

extension PutEmailIdentityMailFromAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityMailFromAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityMailFromAttributesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityMailFromAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEmailIdentityMailFromAttributesOutputResponse()"}
}

extension PutEmailIdentityMailFromAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct PutEmailIdentityMailFromAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutEmailIdentityMailFromAttributesOutputResponseBody: Swift.Equatable {
}

extension PutEmailIdentityMailFromAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PinpointEmailClientTypes.RawMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension PinpointEmailClientTypes.RawMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RawMessage(data: \(Swift.String(describing: data)))"}
}

extension PinpointEmailClientTypes {
    /// The raw email message.
    public struct RawMessage: Swift.Equatable {
        /// The raw email message. The message has to meet the following criteria:
        ///
        ///
        ///                 The message has to contain a header and a body, separated by one blank
        ///                     line.
        ///
        ///
        ///                 All of the required header fields must be present in the message.
        ///
        ///
        ///                 Each part of a multipart MIME message must be formatted properly.
        ///
        ///
        ///                 Attachments must be in a file format that Amazon Pinpoint supports.
        ///
        ///
        ///
        ///                 The entire message must be Base64 encoded.
        ///
        ///
        ///                 If any of the MIME parts in your message contain content that is outside of
        ///                     the 7-bit ASCII character range, you should encode that content to ensure that
        ///                     recipients' email clients render the message properly.
        ///
        ///
        ///                 The length of any single line of text in the message can't exceed 1,000
        ///                     characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321.
        ///
        ///
        /// This member is required.
        public let data: ClientRuntime.Data?

        public init (
            data: ClientRuntime.Data? = nil
        )
        {
            self.data = data
        }
    }

}

extension PinpointEmailClientTypes.ReputationOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastFreshStart = "LastFreshStart"
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastFreshStart = lastFreshStart {
            try encodeContainer.encode(lastFreshStart.timeIntervalSince1970, forKey: .lastFreshStart)
        }
        if reputationMetricsEnabled != false {
            try encodeContainer.encode(reputationMetricsEnabled, forKey: .reputationMetricsEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reputationMetricsEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reputationMetricsEnabled)
        reputationMetricsEnabled = reputationMetricsEnabledDecoded
        let lastFreshStartDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastFreshStart)
        lastFreshStart = lastFreshStartDecoded
    }
}

extension PinpointEmailClientTypes.ReputationOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReputationOptions(lastFreshStart: \(Swift.String(describing: lastFreshStart)), reputationMetricsEnabled: \(Swift.String(describing: reputationMetricsEnabled)))"}
}

extension PinpointEmailClientTypes {
    /// Enable or disable collection of reputation metrics for emails that you send using this
    ///             configuration set in the current AWS Region.
    public struct ReputationOptions: Swift.Equatable {
        /// The date and time (in Unix time) when the reputation metrics were last given a fresh
        ///             start. When your account is given a fresh start, your reputation metrics are calculated
        ///             starting from the date of the fresh start.
        public let lastFreshStart: ClientRuntime.Date?
        /// If true, tracking of reputation metrics is enabled for the configuration
        ///             set. If false, tracking of reputation metrics is disabled for the
        ///             configuration set.
        public let reputationMetricsEnabled: Swift.Bool

        public init (
            lastFreshStart: ClientRuntime.Date? = nil,
            reputationMetricsEnabled: Swift.Bool = false
        )
        {
            self.lastFreshStart = lastFreshStart
            self.reputationMetricsEnabled = reputationMetricsEnabled
        }
    }

}

public struct SendEmailInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendEmailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEmailOutputError>
}

extension SendEmailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendEmailInput(configurationSetName: \(Swift.String(describing: configurationSetName)), content: \(Swift.String(describing: content)), destination: \(Swift.String(describing: destination)), emailTags: \(Swift.String(describing: emailTags)), feedbackForwardingEmailAddress: \(Swift.String(describing: feedbackForwardingEmailAddress)), fromEmailAddress: \(Swift.String(describing: fromEmailAddress)), replyToAddresses: \(Swift.String(describing: replyToAddresses)))"}
}

extension SendEmailInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destination = "Destination"
        case emailTags = "EmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case fromEmailAddress = "FromEmailAddress"
        case replyToAddresses = "ReplyToAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let emailTags = emailTags {
            var emailTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emailTags)
            for messagetaglist0 in emailTags {
                try emailTagsContainer.encode(messagetaglist0)
            }
        }
        if let feedbackForwardingEmailAddress = feedbackForwardingEmailAddress {
            try encodeContainer.encode(feedbackForwardingEmailAddress, forKey: .feedbackForwardingEmailAddress)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replyToAddresses)
            for emailaddresslist0 in replyToAddresses {
                try replyToAddressesContainer.encode(emailaddresslist0)
            }
        }
    }
}

public struct SendEmailInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendEmailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEmailOutputError>
}

public struct SendEmailInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendEmailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEmailOutputError>
}

/// A request to send an email message.
public struct SendEmailInput: Swift.Equatable {
    /// The name of the configuration set that you want to use when sending the email.
    public let configurationSetName: Swift.String?
    /// An object that contains the body of the message. You can send either a Simple message
    ///             or a Raw message.
    /// This member is required.
    public let content: PinpointEmailClientTypes.EmailContent?
    /// An object that contains the recipients of the email message.
    /// This member is required.
    public let destination: PinpointEmailClientTypes.Destination?
    /// A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using the SendEmail operation. Tags correspond to characteristics of the
    ///             email that you define, so that you can publish email sending events.
    public let emailTags: [PinpointEmailClientTypes.MessageTag]?
    /// The address that Amazon Pinpoint should send bounce and complaint notifications to.
    public let feedbackForwardingEmailAddress: Swift.String?
    /// The email address that you want to use as the "From" address for the email. The
    ///             address that you specify has to be verified.
    ///
    public let fromEmailAddress: Swift.String?
    /// The "Reply-to" email addresses for the message. When the recipient replies to the
    ///             message, each Reply-to address receives the reply.
    public let replyToAddresses: [Swift.String]?

    public init (
        configurationSetName: Swift.String? = nil,
        content: PinpointEmailClientTypes.EmailContent? = nil,
        destination: PinpointEmailClientTypes.Destination? = nil,
        emailTags: [PinpointEmailClientTypes.MessageTag]? = nil,
        feedbackForwardingEmailAddress: Swift.String? = nil,
        fromEmailAddress: Swift.String? = nil,
        replyToAddresses: [Swift.String]? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.content = content
        self.destination = destination
        self.emailTags = emailTags
        self.feedbackForwardingEmailAddress = feedbackForwardingEmailAddress
        self.fromEmailAddress = fromEmailAddress
        self.replyToAddresses = replyToAddresses
    }
}

struct SendEmailInputBody: Swift.Equatable {
    public let fromEmailAddress: Swift.String?
    public let destination: PinpointEmailClientTypes.Destination?
    public let replyToAddresses: [Swift.String]?
    public let feedbackForwardingEmailAddress: Swift.String?
    public let content: PinpointEmailClientTypes.EmailContent?
    public let emailTags: [PinpointEmailClientTypes.MessageTag]?
    public let configurationSetName: Swift.String?
}

extension SendEmailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destination = "Destination"
        case emailTags = "EmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case fromEmailAddress = "FromEmailAddress"
        case replyToAddresses = "ReplyToAddresses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let replyToAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replyToAddresses)
        var replyToAddressesDecoded0:[Swift.String]? = nil
        if let replyToAddressesContainer = replyToAddressesContainer {
            replyToAddressesDecoded0 = [Swift.String]()
            for string0 in replyToAddressesContainer {
                if let string0 = string0 {
                    replyToAddressesDecoded0?.append(string0)
                }
            }
        }
        replyToAddresses = replyToAddressesDecoded0
        let feedbackForwardingEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackForwardingEmailAddress)
        feedbackForwardingEmailAddress = feedbackForwardingEmailAddressDecoded
        let contentDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.EmailContent.self, forKey: .content)
        content = contentDecoded
        let emailTagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.MessageTag?].self, forKey: .emailTags)
        var emailTagsDecoded0:[PinpointEmailClientTypes.MessageTag]? = nil
        if let emailTagsContainer = emailTagsContainer {
            emailTagsDecoded0 = [PinpointEmailClientTypes.MessageTag]()
            for structure0 in emailTagsContainer {
                if let structure0 = structure0 {
                    emailTagsDecoded0?.append(structure0)
                }
            }
        }
        emailTags = emailTagsDecoded0
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension SendEmailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEmailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountSuspendedException" : self = .accountSuspendedException(try AccountSuspendedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendEmailOutputError: Swift.Error, Swift.Equatable {
    case accountSuspendedException(AccountSuspendedException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEmailOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendEmailOutputResponse(messageId: \(Swift.String(describing: messageId)))"}
}

extension SendEmailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendEmailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// A unique message ID that you receive when Amazon Pinpoint accepts an email for sending.
public struct SendEmailOutputResponse: Swift.Equatable {
    /// A unique identifier for the message that is generated when Amazon Pinpoint accepts the
    ///             message.
    ///
    ///             It is possible for Amazon Pinpoint to accept a message without sending it. This can happen
    ///                 when the message you're trying to send has an attachment doesn't pass a virus check,
    ///                 or when you send a templated email that contains invalid personalization content,
    ///                 for example.
    ///
    public let messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendEmailOutputResponseBody: Swift.Equatable {
    public let messageId: Swift.String?
}

extension SendEmailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension PinpointEmailClientTypes.SendQuota: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max24HourSend = "Max24HourSend"
        case maxSendRate = "MaxSendRate"
        case sentLast24Hours = "SentLast24Hours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max24HourSend != 0.0 {
            try encodeContainer.encode(max24HourSend, forKey: .max24HourSend)
        }
        if maxSendRate != 0.0 {
            try encodeContainer.encode(maxSendRate, forKey: .maxSendRate)
        }
        if sentLast24Hours != 0.0 {
            try encodeContainer.encode(sentLast24Hours, forKey: .sentLast24Hours)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let max24HourSendDecoded = try containerValues.decode(Swift.Double.self, forKey: .max24HourSend)
        max24HourSend = max24HourSendDecoded
        let maxSendRateDecoded = try containerValues.decode(Swift.Double.self, forKey: .maxSendRate)
        maxSendRate = maxSendRateDecoded
        let sentLast24HoursDecoded = try containerValues.decode(Swift.Double.self, forKey: .sentLast24Hours)
        sentLast24Hours = sentLast24HoursDecoded
    }
}

extension PinpointEmailClientTypes.SendQuota: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendQuota(max24HourSend: \(Swift.String(describing: max24HourSend)), maxSendRate: \(Swift.String(describing: maxSendRate)), sentLast24Hours: \(Swift.String(describing: sentLast24Hours)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about the per-day and per-second sending limits
    ///             for your Amazon Pinpoint account in the current AWS Region.
    public struct SendQuota: Swift.Equatable {
        /// The maximum number of emails that you can send in the current AWS Region over a
        ///             24-hour period. This value is also called your sending
        ///             quota.
        public let max24HourSend: Swift.Double
        /// The maximum number of emails that you can send per second in the current AWS Region.
        ///             This value is also called your maximum sending rate or your
        ///                 maximum TPS (transactions per second) rate.
        public let maxSendRate: Swift.Double
        /// The number of emails sent from your Amazon Pinpoint account in the current AWS Region over the
        ///             past 24 hours.
        public let sentLast24Hours: Swift.Double

        public init (
            max24HourSend: Swift.Double = 0.0,
            maxSendRate: Swift.Double = 0.0,
            sentLast24Hours: Swift.Double = 0.0
        )
        {
            self.max24HourSend = max24HourSend
            self.maxSendRate = maxSendRate
            self.sentLast24Hours = sentLast24Hours
        }
    }

}

extension PinpointEmailClientTypes.SendingOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PinpointEmailClientTypes.SendingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendingOptions(sendingEnabled: \(Swift.String(describing: sendingEnabled)))"}
}

extension PinpointEmailClientTypes {
    /// Used to enable or disable email sending for messages that use this configuration set
    ///             in the current AWS Region.
    public struct SendingOptions: Swift.Equatable {
        /// If true, email sending is enabled for the configuration set. If
        ///                 false, email sending is disabled for the configuration set.
        public let sendingEnabled: Swift.Bool

        public init (
            sendingEnabled: Swift.Bool = false
        )
        {
            self.sendingEnabled = sendingEnabled
        }
    }

}

extension SendingPausedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendingPausedException(message: \(Swift.String(describing: message)))"}
}

extension SendingPausedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendingPausedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The message can't be sent because the account's ability to send email is currently
///             paused.
public struct SendingPausedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SendingPausedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SendingPausedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointEmailClientTypes.SnsDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension PinpointEmailClientTypes.SnsDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnsDestination(topicArn: \(Swift.String(describing: topicArn)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
    ///             send notification when certain email events occur.
    public struct SnsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish email
        ///             events to. For more information about Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer
        ///                 Guide.
        /// This member is required.
        public let topicArn: Swift.String?

        public init (
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension PinpointEmailClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PinpointEmailClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines the tags that are associated with a resource.
    ///                 Atagis a label that you optionally define and associate with
    ///             a resource in Amazon Pinpoint. Tags can help you categorize and manage resources in different
    ///             ways, such as by purpose, owner, environment, or other criteria. A resource can have as
    ///             many as 50 tags.
    ///         Each tag consists of a requiredtag keyand an
    ///                 associatedtag value, both of which you define. A tag key is a
    ///             general label that acts as a category for a more specific tag value. A tag value acts as
    ///             a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag
    ///             value can contain as many as 256 characters. The characters can be Unicode letters,
    ///             digits, white space, or one of the following symbols: _ . : / = + -. The following
    ///             additional restrictions apply to tags:
    ///
    ///
    ///                 Tag keys and values are case sensitive.
    ///
    ///
    ///                 For each associated resource, each tag key must be unique and it can have only
    ///                     one value.
    ///
    ///
    ///                 Theaws:prefix is reserved for use by AWS; you cant use it in
    ///                     any tag keys or values that you define. In addition, you can't edit or remove
    ///                     tag keys or values that use this prefix. Tags that use this prefix dont count
    ///                     against the limit of 50 tags per resource.
    ///
    ///
    ///                 You can associate tags with public or shared resources, but the tags are
    ///                     available only for your AWS account, not any other accounts that share the
    ///                     resource. In addition, the tags are available only for resources that are
    ///                     located in the specified AWS Region for your AWS account.
    ///
    ///
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that defines a tag. The maximum length of a tag key is
        ///             128 characters. The minimum length is 1 character.
        /// This member is required.
        public let key: Swift.String?
        /// The optional part of a key-value pair that defines a tag. The maximum length of a tag
        ///             value is 256 characters. The minimum length is 0 characters. If you dont want a
        ///             resource to have a specific tag value, dont specify a value for thisparameter. Amazon Pinpoint
        ///             will set the value to an empty string.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add one or more tags
    ///             to.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// A list of the tags that you want to add to the resource. A tag consists of a required
    ///             tag key (Key) and an associated tag value (Value). The maximum
    ///             length of a tag key is 128 characters. The maximum length of a tag value is 256
    ///             characters.
    /// This member is required.
    public let tags: [PinpointEmailClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [PinpointEmailClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [PinpointEmailClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointEmailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointEmailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointEmailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PinpointEmailClientTypes.Template: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateArn = "TemplateArn"
        case templateData = "TemplateData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateArn = templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateData = templateData {
            try encodeContainer.encode(templateData, forKey: .templateData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateData)
        templateData = templateDataDecoded
    }
}

extension PinpointEmailClientTypes.Template: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Template(templateArn: \(Swift.String(describing: templateArn)), templateData: \(Swift.String(describing: templateData)))"}
}

extension PinpointEmailClientTypes {
    public struct Template: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: Swift.String?
        /// An object that defines the values to use for message variables in the template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the value to use for that variable.
        public let templateData: Swift.String?

        public init (
            templateArn: Swift.String? = nil,
            templateData: Swift.String? = nil
        )
        {
            self.templateArn = templateArn
            self.templateData = templateData
        }
    }

}

extension PinpointEmailClientTypes {
    /// Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS). If the value is Require, messages are only
    ///             delivered if a TLS connection can be established. If the value is Optional,
    ///             messages can be delivered in plain text if a TLS connection can't be established.
    public enum TlsPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `optional`
        case require
        case sdkUnknown(Swift.String)

        public static var allCases: [TlsPolicy] {
            return [
                .optional,
                .require,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .optional: return "OPTIONAL"
            case .require: return "REQUIRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TlsPolicy(rawValue: rawValue) ?? TlsPolicy.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Too many requests have been made to the operation.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointEmailClientTypes.TrackingOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRedirectDomain = customRedirectDomain {
            try encodeContainer.encode(customRedirectDomain, forKey: .customRedirectDomain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRedirectDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customRedirectDomain)
        customRedirectDomain = customRedirectDomainDecoded
    }
}

extension PinpointEmailClientTypes.TrackingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrackingOptions(customRedirectDomain: \(Swift.String(describing: customRedirectDomain)))"}
}

extension PinpointEmailClientTypes {
    /// An object that defines the tracking options for a configuration set. When you use
    ///             Amazon Pinpoint to send an email, it contains an invisible image that's used to track when
    ///             recipients open your email. If your email contains links, those links are changed
    ///             slightly in order to track when recipients click them.
    ///         These images and links include references to a domain operated by AWS. You can
    ///             optionally configure Amazon Pinpoint to use a domain that you operate for these images and
    ///             links.
    public struct TrackingOptions: Swift.Equatable {
        /// The domain that you want to use for tracking open and click events.
        /// This member is required.
        public let customRedirectDomain: Swift.String?

        public init (
            customRedirectDomain: Swift.String? = nil
        )
        {
            self.customRedirectDomain = customRedirectDomain
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "ResourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "TagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove one or more
    ///             tags from.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// The tags (tag keys) that you want to remove from the resource. When you specify a tag
    ///             key, the action removes both that key and its associated tag value.
    ///         To remove more than one tag from the resource, append the TagKeys
    ///             parameter and argument for each additional tag to remove, separated by an ampersand. For
    ///             example:
    ///                 /v1/email/tags?ResourceArn=ResourceArn&TagKeys=Key1&TagKeys=Key2
    ///
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateConfigurationSetEventDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

extension UpdateConfigurationSetEventDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationSetEventDestinationInput(configurationSetName: \(Swift.String(describing: configurationSetName)), eventDestination: \(Swift.String(describing: eventDestination)), eventDestinationName: \(Swift.String(describing: eventDestinationName)))"}
}

extension UpdateConfigurationSetEventDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
    }
}

public struct UpdateConfigurationSetEventDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

public struct UpdateConfigurationSetEventDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

/// A request to change the settings for an event destination for a configuration
///             set.
public struct UpdateConfigurationSetEventDestinationInput: Swift.Equatable {
    /// The name of the configuration set that contains the event destination that you want to
    ///             modify.
    /// This member is required.
    public let configurationSetName: Swift.String?
    /// An object that defines the event destination.
    /// This member is required.
    public let eventDestination: PinpointEmailClientTypes.EventDestinationDefinition?
    /// The name of the event destination that you want to modify.
    /// This member is required.
    public let eventDestinationName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointEmailClientTypes.EventDestinationDefinition? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct UpdateConfigurationSetEventDestinationInputBody: Swift.Equatable {
    public let eventDestination: PinpointEmailClientTypes.EventDestinationDefinition?
}

extension UpdateConfigurationSetEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointEmailClientTypes.EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension UpdateConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationSetEventDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetEventDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetEventDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationSetEventDestinationOutputResponse()"}
}

extension UpdateConfigurationSetEventDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.
public struct UpdateConfigurationSetEventDestinationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateConfigurationSetEventDestinationOutputResponseBody: Swift.Equatable {
}

extension UpdateConfigurationSetEventDestinationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PinpointEmailClientTypes.VolumeStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboxRawCount = "InboxRawCount"
        case projectedInbox = "ProjectedInbox"
        case projectedSpam = "ProjectedSpam"
        case spamRawCount = "SpamRawCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboxRawCount = inboxRawCount {
            try encodeContainer.encode(inboxRawCount, forKey: .inboxRawCount)
        }
        if let projectedInbox = projectedInbox {
            try encodeContainer.encode(projectedInbox, forKey: .projectedInbox)
        }
        if let projectedSpam = projectedSpam {
            try encodeContainer.encode(projectedSpam, forKey: .projectedSpam)
        }
        if let spamRawCount = spamRawCount {
            try encodeContainer.encode(spamRawCount, forKey: .spamRawCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboxRawCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inboxRawCount)
        inboxRawCount = inboxRawCountDecoded
        let spamRawCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spamRawCount)
        spamRawCount = spamRawCountDecoded
        let projectedInboxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .projectedInbox)
        projectedInbox = projectedInboxDecoded
        let projectedSpamDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .projectedSpam)
        projectedSpam = projectedSpamDecoded
    }
}

extension PinpointEmailClientTypes.VolumeStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VolumeStatistics(inboxRawCount: \(Swift.String(describing: inboxRawCount)), projectedInbox: \(Swift.String(describing: projectedInbox)), projectedSpam: \(Swift.String(describing: projectedSpam)), spamRawCount: \(Swift.String(describing: spamRawCount)))"}
}

extension PinpointEmailClientTypes {
    /// An object that contains information about the amount of email that was delivered to
    ///             recipients.
    public struct VolumeStatistics: Swift.Equatable {
        /// The total number of emails that arrived in recipients' inboxes.
        public let inboxRawCount: Swift.Int?
        /// An estimate of the percentage of emails sent from the current domain that will arrive
        ///             in recipients' inboxes.
        public let projectedInbox: Swift.Int?
        /// An estimate of the percentage of emails sent from the current domain that will arrive
        ///             in recipients' spam or junk mail folders.
        public let projectedSpam: Swift.Int?
        /// The total number of emails that arrived in recipients' spam or junk mail
        ///             folders.
        public let spamRawCount: Swift.Int?

        public init (
            inboxRawCount: Swift.Int? = nil,
            projectedInbox: Swift.Int? = nil,
            projectedSpam: Swift.Int? = nil,
            spamRawCount: Swift.Int? = nil
        )
        {
            self.inboxRawCount = inboxRawCount
            self.projectedInbox = projectedInbox
            self.projectedSpam = projectedSpam
            self.spamRawCount = spamRawCount
        }
    }

}

extension PinpointEmailClientTypes {
    /// The warmup status of a dedicated IP.
    public enum WarmupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case done
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [WarmupStatus] {
            return [
                .done,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .done: return "DONE"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WarmupStatus(rawValue: rawValue) ?? WarmupStatus.sdkUnknown(rawValue)
        }
    }
}
