// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAccountPermissionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAccountPermissionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAccountPermissionsOutputResponse`
extension Inspector2Client {
    public func listAccountPermissionsPaginated(input: ListAccountPermissionsInput) -> ClientRuntime.PaginatorSequence<ListAccountPermissionsInput, ListAccountPermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAccountPermissionsInput, ListAccountPermissionsOutputResponse>(input: input, inputKey: \ListAccountPermissionsInput.nextToken, outputKey: \ListAccountPermissionsOutputResponse.nextToken, paginationFunction: self.listAccountPermissions(input:))
    }
}

extension ListAccountPermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountPermissionsInput {
        return ListAccountPermissionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            service: self.service
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAccountPermissionsPaginated`
/// to access the nested member `[Inspector2ClientTypes.Permission]`
/// - Returns: `[Inspector2ClientTypes.Permission]`
extension PaginatorSequence where Input == ListAccountPermissionsInput, Output == ListAccountPermissionsOutputResponse {
    func permissions() async throws -> [Inspector2ClientTypes.Permission] {
        return try await self.asyncCompactMap { item in item.permissions }
    }
}

/// Paginate over `[ListCoverageOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCoverageInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCoverageOutputResponse`
extension Inspector2Client {
    public func listCoveragePaginated(input: ListCoverageInput) -> ClientRuntime.PaginatorSequence<ListCoverageInput, ListCoverageOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCoverageInput, ListCoverageOutputResponse>(input: input, inputKey: \ListCoverageInput.nextToken, outputKey: \ListCoverageOutputResponse.nextToken, paginationFunction: self.listCoverage(input:))
    }
}

extension ListCoverageInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCoverageInput {
        return ListCoverageInput(
            filterCriteria: self.filterCriteria,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCoveragePaginated`
/// to access the nested member `[Inspector2ClientTypes.CoveredResource]`
/// - Returns: `[Inspector2ClientTypes.CoveredResource]`
extension PaginatorSequence where Input == ListCoverageInput, Output == ListCoverageOutputResponse {
    func coveredResources() async throws -> [Inspector2ClientTypes.CoveredResource] {
        return try await self.asyncCompactMap { item in item.coveredResources }
    }
}

/// Paginate over `[ListCoverageStatisticsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCoverageStatisticsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCoverageStatisticsOutputResponse`
extension Inspector2Client {
    public func listCoverageStatisticsPaginated(input: ListCoverageStatisticsInput) -> ClientRuntime.PaginatorSequence<ListCoverageStatisticsInput, ListCoverageStatisticsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCoverageStatisticsInput, ListCoverageStatisticsOutputResponse>(input: input, inputKey: \ListCoverageStatisticsInput.nextToken, outputKey: \ListCoverageStatisticsOutputResponse.nextToken, paginationFunction: self.listCoverageStatistics(input:))
    }
}

extension ListCoverageStatisticsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCoverageStatisticsInput {
        return ListCoverageStatisticsInput(
            filterCriteria: self.filterCriteria,
            groupBy: self.groupBy,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCoverageStatisticsPaginated`
/// to access the nested member `[Inspector2ClientTypes.Counts]`
/// - Returns: `[Inspector2ClientTypes.Counts]`
extension PaginatorSequence where Input == ListCoverageStatisticsInput, Output == ListCoverageStatisticsOutputResponse {
    func countsByGroup() async throws -> [Inspector2ClientTypes.Counts] {
        return try await self.asyncCompactMap { item in item.countsByGroup }
    }
}

/// Paginate over `[ListDelegatedAdminAccountsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDelegatedAdminAccountsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDelegatedAdminAccountsOutputResponse`
extension Inspector2Client {
    public func listDelegatedAdminAccountsPaginated(input: ListDelegatedAdminAccountsInput) -> ClientRuntime.PaginatorSequence<ListDelegatedAdminAccountsInput, ListDelegatedAdminAccountsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDelegatedAdminAccountsInput, ListDelegatedAdminAccountsOutputResponse>(input: input, inputKey: \ListDelegatedAdminAccountsInput.nextToken, outputKey: \ListDelegatedAdminAccountsOutputResponse.nextToken, paginationFunction: self.listDelegatedAdminAccounts(input:))
    }
}

extension ListDelegatedAdminAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDelegatedAdminAccountsInput {
        return ListDelegatedAdminAccountsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDelegatedAdminAccountsPaginated`
/// to access the nested member `[Inspector2ClientTypes.DelegatedAdminAccount]`
/// - Returns: `[Inspector2ClientTypes.DelegatedAdminAccount]`
extension PaginatorSequence where Input == ListDelegatedAdminAccountsInput, Output == ListDelegatedAdminAccountsOutputResponse {
    func delegatedAdminAccounts() async throws -> [Inspector2ClientTypes.DelegatedAdminAccount] {
        return try await self.asyncCompactMap { item in item.delegatedAdminAccounts }
    }
}

/// Paginate over `[ListFiltersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFiltersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFiltersOutputResponse`
extension Inspector2Client {
    public func listFiltersPaginated(input: ListFiltersInput) -> ClientRuntime.PaginatorSequence<ListFiltersInput, ListFiltersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFiltersInput, ListFiltersOutputResponse>(input: input, inputKey: \ListFiltersInput.nextToken, outputKey: \ListFiltersOutputResponse.nextToken, paginationFunction: self.listFilters(input:))
    }
}

extension ListFiltersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFiltersInput {
        return ListFiltersInput(
            action: self.action,
            arns: self.arns,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFiltersPaginated`
/// to access the nested member `[Inspector2ClientTypes.Filter]`
/// - Returns: `[Inspector2ClientTypes.Filter]`
extension PaginatorSequence where Input == ListFiltersInput, Output == ListFiltersOutputResponse {
    func filters() async throws -> [Inspector2ClientTypes.Filter] {
        return try await self.asyncCompactMap { item in item.filters }
    }
}

/// Paginate over `[ListFindingAggregationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFindingAggregationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFindingAggregationsOutputResponse`
extension Inspector2Client {
    public func listFindingAggregationsPaginated(input: ListFindingAggregationsInput) -> ClientRuntime.PaginatorSequence<ListFindingAggregationsInput, ListFindingAggregationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFindingAggregationsInput, ListFindingAggregationsOutputResponse>(input: input, inputKey: \ListFindingAggregationsInput.nextToken, outputKey: \ListFindingAggregationsOutputResponse.nextToken, paginationFunction: self.listFindingAggregations(input:))
    }
}

extension ListFindingAggregationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingAggregationsInput {
        return ListFindingAggregationsInput(
            accountIds: self.accountIds,
            aggregationRequest: self.aggregationRequest,
            aggregationType: self.aggregationType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFindingAggregationsPaginated`
/// to access the nested member `[Inspector2ClientTypes.AggregationResponse]`
/// - Returns: `[Inspector2ClientTypes.AggregationResponse]`
extension PaginatorSequence where Input == ListFindingAggregationsInput, Output == ListFindingAggregationsOutputResponse {
    func responses() async throws -> [Inspector2ClientTypes.AggregationResponse] {
        return try await self.asyncCompactMap { item in item.responses }
    }
}

/// Paginate over `[ListFindingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFindingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFindingsOutputResponse`
extension Inspector2Client {
    public func listFindingsPaginated(input: ListFindingsInput) -> ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutputResponse>(input: input, inputKey: \ListFindingsInput.nextToken, outputKey: \ListFindingsOutputResponse.nextToken, paginationFunction: self.listFindings(input:))
    }
}

extension ListFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingsInput {
        return ListFindingsInput(
            filterCriteria: self.filterCriteria,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFindingsPaginated`
/// to access the nested member `[Inspector2ClientTypes.Finding]`
/// - Returns: `[Inspector2ClientTypes.Finding]`
extension PaginatorSequence where Input == ListFindingsInput, Output == ListFindingsOutputResponse {
    func findings() async throws -> [Inspector2ClientTypes.Finding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}

/// Paginate over `[ListMembersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMembersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMembersOutputResponse`
extension Inspector2Client {
    public func listMembersPaginated(input: ListMembersInput) -> ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutputResponse>(input: input, inputKey: \ListMembersInput.nextToken, outputKey: \ListMembersOutputResponse.nextToken, paginationFunction: self.listMembers(input:))
    }
}

extension ListMembersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMembersInput {
        return ListMembersInput(
            maxResults: self.maxResults,
            nextToken: token,
            onlyAssociated: self.onlyAssociated
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMembersPaginated`
/// to access the nested member `[Inspector2ClientTypes.Member]`
/// - Returns: `[Inspector2ClientTypes.Member]`
extension PaginatorSequence where Input == ListMembersInput, Output == ListMembersOutputResponse {
    func members() async throws -> [Inspector2ClientTypes.Member] {
        return try await self.asyncCompactMap { item in item.members }
    }
}

/// Paginate over `[ListUsageTotalsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUsageTotalsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUsageTotalsOutputResponse`
extension Inspector2Client {
    public func listUsageTotalsPaginated(input: ListUsageTotalsInput) -> ClientRuntime.PaginatorSequence<ListUsageTotalsInput, ListUsageTotalsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUsageTotalsInput, ListUsageTotalsOutputResponse>(input: input, inputKey: \ListUsageTotalsInput.nextToken, outputKey: \ListUsageTotalsOutputResponse.nextToken, paginationFunction: self.listUsageTotals(input:))
    }
}

extension ListUsageTotalsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsageTotalsInput {
        return ListUsageTotalsInput(
            accountIds: self.accountIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUsageTotalsPaginated`
/// to access the nested member `[Inspector2ClientTypes.UsageTotal]`
/// - Returns: `[Inspector2ClientTypes.UsageTotal]`
extension PaginatorSequence where Input == ListUsageTotalsInput, Output == ListUsageTotalsOutputResponse {
    func totals() async throws -> [Inspector2ClientTypes.UsageTotal] {
        return try await self.asyncCompactMap { item in item.totals }
    }
}
